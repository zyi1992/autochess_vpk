--          啊 如此良辰美景 赋词一首
--          
--          古古咕古古古咕                                                                ........ . .......               
--          故咕咕                                                                       ....:?++?+??+.....               
--          古古咕                                                                   .  ...++++++???+??7.....             
--          古古古古                                                                 ....++?++???=:=IIII7Z.               
--          古故故咕咕                                                               ...???????I=7$D+7II77Z . .           
--          古故古咕古故故                                                          ...I+++??I7+~ZZ$+$77777Z...           
--          古古故                                                                 ..+?+????IIII+I7777I?,:,~+..          
--          故咕咕                                                                . .?????IIIII777777777III$$++.          
--          古古咕古古古咕                                                      ....I???III7I7$$$$$$$$$$ZZ?I$?7I....      
--          故咕咕                                                             ...IIIIIII777$7$$$$ZZ+.........?=...      
--          古古咕                                                             ..?I7$I777777ZZ$$ZOZ........ .......      
--          古古古古                                                           .,7$7II7777I$7$$ZO8.                      
--          古故故咕咕                                                           .$7$7I777$77$$ZZZ8O .                     
--          古故古咕古故故                                                      $7$777I77II$77$OO8...                     
--          古古故                                                         ...,777$77I777$7$$$Z88 .                      
--          估孤 故咕咕                                                     . =$7$$7$777Z$7ZZZZ888                        
--                                                                        ...7ZOZ$7777$77Z$O$ZOO$                        
--                                                                         .7$$7$7$7III$IZOOOZO87                        
--                                                                      . .$Z$$$$7$II$I$Z$ZZOO88D                        
--                                                                    . ..ZZ77I$IZ?$7ZI7$$ZOOOO8D                        
--                                                                    ...7II777$7I7I$$77$ZZOZOO8D                        
--                                                                    ..?II7III77I7II$77Z$ZZO888D                        
--                                                                .   .=?77?I??II?II777$ZZZOOO88D                        
--                                                                ....?=?==+??I7I7I77$ZZ$ZZOOO888                        
--                                                                ...====~~==+??III77$$Z$ZOOOOOO8                        
--                                                           .. ...=~~~~~~~~~~=++III$$$ZZOOOOOO88                        
--                                                           ....,~::::::~~~~~~~~:~+I7$Z$ZZOOOO88                        
--                                                           ..::::,::::::::::::~~:~~=7$ZZZZOOOO8 .                      
--                                                  .  ... .,:::::::::::::::::~~~~~====~+ZOZZOOOO..                      
--                                                       ..:,::::,:::::::::~~~~~~~~=======??ZOOOO:.                      
--                                                  .. .,::,:::::::::::::~~~~~~~=========+=+?$ZZO$.                      
--                                                 ...,,,::::::::::::::::~~~~~~~=========+=??7OZZO....                   
--                                               ...,:,,::::::::::::::::~~~~~~~~==+=======+?I7ZZZZ....                   
--                                             ...:.,,:::::::::,::::::~~~~~~===~==~~=====++?I7ZZZZ....                   
--                                         ..  .=..::,:::::,,,:::::::~~~~~~=~~====~=====++?II7OZZZ...                    
--                                       . ....:+:??,:=++:,,,::::::~~~~~~~~~~=~==~====++??II7$OZZO..                     
--                                ..   ......77IIII$,:==~?,:::::::~~~~~~~~~~~~~~====++++?I77$8ZZZZ..                     
--                                ......:=.,III~7777~~::=+,:::::::::~~~~~~~~=~~~=+=+++??II77OZ$$O~                       
--                               ....$++=,I7777:,$7777:::::::::::~~~::~:~~~~~~==+=+++??II7$OO$ZZI                        
--                      .      ..7Z7I++=~:7777?:~:77777$=:::::~:::::~~~~~~~========++??I7$ZZZ$ZO.                        
--                   .......$ZZZZ7I?++=$7II777:,,,:=$7$$$I~::::::~~~~~~=~~===++++++???I7OZ$$$ZZ..                        
--                   ..$88ZZZZ$$++?II?,,,,77$$$+::::::7Z$$$7=~~~::~~~~~~~====+=++???IIOZ$$$$$7 ..                        
--           ......O8888OZI7II7II7$I7~:::::I$Z$ZZ~:::::::7Z$Z$?~~~~~~=~====+==+?+??IZZ$$$7$$~                            
--            .O88888ZI77II7I7I777$77$~:::::7ZOZZZ=~::~~~:~$ZZ$$ZZ+======++++??IIIZZ$7$$$$$..                            
--            8OOZ7I7$777I7I77$77?I77$I=:::::ZZO$OZ~=~~~~~~~+ZZZZZOOZZI++??7II77Z$7$$7$$Z....                            
--     .......?777I$7II7III7I7I77$$IIIII7$I+===?I7$7I?=~~~~~~~==ZOOZZOI???I$$$77777$$$Z.                                 
--     ....$$$$$$77$77777I777III777777$777777777$ZZZ$$7+======+=++??I77??II?III7$$Z$?..,                                 
--     .,7$$Z$7$$$$7$7$77777I??I?7I7I777IIIII7IIIII??+??I??+++?II++?++????III77$$Z ..                                    
--  ..II7ZZZZZ$7??+?I7+~==I77$$$$7$ZZ77IZ7$Z7777$$$77II???++==~~=+==++???II77ZO.                                         
-- ...?ZZZ$ZZ$$Z=............................7$7IIII??++=+====~~==++++??I7$O:  .                                         
--  ......... ....................   .        . $I??+++?========+++???I7Z. ..                                            
--                                                . :II?+~=+=++++?+?7Z .                                                 
--                                                  .....+===++++II?..                                                   
--                                                  .....:~~~==+I$.. .                                                   
--                                                    . .~~~==+I$$O.. .....                                              
--                                                      ..~~==+7$ZO8...   ..                                             
--                                                      ...:~~=$$$$OOZ7ZOD8~  . .                                        
--                                                      ....~~=~7I77OZ$Z8~..........                                     
--                                                      ..$,~+?+?Z$ZII$DZ8Z7II+?$Z..                                     
--                                                       ...+==I+$=.7II??7..........                                     
--                                                       ....=+++ZI......I=      ...                                     
--                                                      ..?~=~~+:=~$,..?II~                                              
--                                                        . ...I=~=??+$$O~..........                                     
--                                                           ....+~+?I?+,:++:==.....                                     
--                                                           ......+:~=~.~+IIII+....                                     
--                                                                   .=:+..                                              
--                                                                  ..+~...                                              

--刀塔自走棋
if DAC == nil then
	DAC = class({})
end

--报错追踪
if GetDedicatedServerKeyV2('hehe') ~= 'Invalid_NotOnDedicatedServer' then
	--官服游戏（有DedicatedServerKey），报错打印在屏幕上
	debug.traceback = function(e)
		if e ~= nil and GameRules:GetGameModeEntity().myself == true then
			prt(tostring(e))
		end
	end
end

require('libs/amhc_library/amhc')
require('libs/Timers')
require('libs/Physics')
require('libs/util')
require('libs/barebones')
require('pathfinder/core/heuristics')
require('pathfinder/core/node')
require('pathfinder/core/path')
require('pathfinder/grid')
require('pathfinder/pathfinder')
require('pathfinder/core/bheap')
require('pathfinder/search/astar')
require('pathfinder/search/bfs')
require('pathfinder/search/dfs')
require('pathfinder/search/dijkstra')
require('pathfinder/search/jps')
require("libs/animations")
require('libs/aeslua')
local base64 = require('libs/base64')
local sha2 = require('libs/sha2')
local LibDeflate = require("libs/LibDeflate")
require("libraries/animations")

LinkLuaModifier("modifier_jump", "lua_modifier/jump.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_run", "lua_modifier/run.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_elfrun", "lua_modifier/elfrun.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_windwalk", "lua_modifier/windwalk.lua", LUA_MODIFIER_MOTION_HORIZONTAL)
LinkLuaModifier("modifier_walk", "lua_modifier/walk.lua", LUA_MODIFIER_MOTION_HORIZONTAL)
LinkLuaModifier("modifier_tuitui", "lua_modifier/tuitui.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_toss", "lua_modifier/toss.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_fall", "lua_modifier/fall.lua", LUA_MODIFIER_MOTION_VERTICAL)
LinkLuaModifier("modifier_breaksoil", "lua_modifier/breaksoil.lua", LUA_MODIFIER_MOTION_VERTICAL)
LinkLuaModifier("modifier_teleport", "lua_modifier/teleport.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_spawn", "lua_modifier/spawn.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_ready", "lua_modifier/ready.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_torrent", "lua_modifier/torrent.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_gungun", "lua_modifier/gungun.lua", LUA_MODIFIER_MOTION_HORIZONTAL)

function Precache( context )
    print("Precache...")
    local precache_list = require("precache")
	for _, precache_item in pairs(precache_list) do
		--预载precache.lua里的资源
		if string.find(precache_item, ".vpcf") then
			-- print('[precache]'..precache_item)
			PrecacheResource( "particle",  precache_item, context)
		end
		if string.find(precache_item, ".vmdl") then 	
			-- print('[precache]'..precache_item)
			PrecacheResource( "model",  precache_item, context)
		end
		if string.find(precache_item, ".vsndevts") then
			-- print('[precache]'..precache_item)
			PrecacheResource( "soundfile",  precache_item, context)
		end
		if string.find(precache_item, ".v") == false then
			-- print('[precache]'..precache_item)
			PrecacheResource( "particle_folder",  precache_item, context)
		end
    end
    --预载入
    local chess_mana_1 = {'chess_luna','chess_cm','chess_tusk','chess_axe','chess_eh','chess_clock','chess_ss','chess_bh','chess_dr','chess_tk','chess_am','chess_tiny','chess_mars','chess_ww','chess_wd','chess_sb','chess_ember','chess_storm','chess_earth','chess_io','chess_pangolier','chess_oracle'}
    for k,v in pairs(chess_mana_1) do
    	if v ~= nil then
    		PrecacheUnitByNameSync(v, context)
    	end
    end

	--预载入物品
	-- local items_kv = LoadKeyValues("scripts/npc/npc_items_custom.txt")
	-- for k, v in pairs(items_kv) do
	-- 	if k ~= "Version" then
	-- 		PrecacheItemByNameSync(k, context)
	-- 	end
	-- end
	--预载入技能里的precache
	-- local abilities_kv = LoadKeyValues("scripts/npc/npc_abilities_custom.txt")
	-- for k, v in pairs(KeyValues.AbilitiesKv) do
	-- 	if k ~= "Version" then
	-- 		if v.precache then
	-- 			for sPrecacheMode, sResource in pairs(v.precache) do
	-- 				PrecacheResource(sPrecacheMode, sResource, context)
	-- 			end
	-- 		end
	-- 	end
	-- end

    print("Precache OK")
end

function Activate()
	GameRules:GetGameModeEntity().AddonTemplate = DAC()
	GameRules:GetGameModeEntity().AddonTemplate:InitGameMode()
end
--1、初始化变量和监听
function DAC:InitGameMode()
	AMHCInit()
	GameRules:GetGameModeEntity().dotamind_ticket = ''
	GameRules:GetGameModeEntity().playing_player_count = 0
	GameRules:GetGameModeEntity().obing_player_count = 0

	GameRules:GetGameModeEntity().bans = ''
	LimitPathingSearchDepth(1)

	Convars:RegisterCommand( "drop_money", function(...) return self._GoldDropConsoleCommand( ... ) end, "Spawn a gold bag.", FCVAR_CHEAT )
	
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_GOODGUYS, 0 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_BADGUYS, 0 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_1, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_2, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_3, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_4, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_5, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_6, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_7, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_8, 1 )

	GameRules:GetGameModeEntity():SetCustomBackpackSwapCooldown(0)


	if GetMapName() == 'casual_1x8_ob' or GetMapName() == 'casual_2x4_ob' then
		GameRules:SetCustomGameTeamMaxPlayers( 1, 5) --OB位
	-- else
		-- GameRules:SetCustomGameTeamMaxPlayers( 1, 0)
	end
	InitDeathTable()
	GameRules:GetGameModeEntity().restore_check = false
	GameRules:GetGameModeEntity().p2_win_sent = false
	GameRules:GetGameModeEntity().p2_win_settle = false
	GameRules:GetGameModeEntity().p2_death_table = {}
	GameRules:GetGameModeEntity().p2_mode = false
	GameRules:GetGameModeEntity().user_md5_table = {}
	GameRules:GetGameModeEntity().lastrandomn_team = nil
	GameRules:GetGameModeEntity().lastalive_team = nil
	GameRules:GetGameModeEntity().custom_round_time = nil

	GameRules:SetTreeRegrowTime(60)

	GameRules:GetGameModeEntity().quest_init = {
		q001 = false,--rank_1x8
		q002 = false,--rank_2x4
		q003 = false,--$5 level2
		q004 = false,--$4 level3
		q005 = false,--rampage
		q006 = false,--round 35
		q007 = false,--100 gold
		q008 = true,--<=20 gold
		q009 = false,--win >=10 chess
		q010 = true,--hp 100 15 round
		q011 = false,--$1 level3 x4
		q012 = false,--win streak 10
		q013 = false,--10 pieces
		q014 = false,--a >=6 synergy
		q015 = false,-->=3 synergies
		q016 = false,--d>10000
		q017 = true,--defeat neutrals
		q018 = false,--transfer >=5 pieces
		q019 = false,--love effect
		q020 = false,--150 damage
		q021 = false,--terminate 10x strike
		q022 = false,--t5 items
		q023 = false,--400 gold
		q024 = false,--h1xx
		q025 = false,--h2xx
		q026 = false,--h3xx
		q027 = false,--h4xx
		q028 = false,--ban >=15 gold
		q029 = false,--3x$5
		q030 = false,--apple
		q031 = false,--$5 interest
		q032 = false,--t4 items
	}
	GameRules:GetGameModeEntity().player_id_table = {}
	GameRules:GetGameModeEntity().level3pieces = {
		[6] = 0,
		[7] = 0,
		[8] = 0,
		[9] = 0,
		[10] = 0,
		[11] = 0,
		[12] = 0,
		[13] = 0,
	}
	GameRules:GetGameModeEntity().quest_status = {
		[6] = -1,
		[7] = -1,
		[8] = -1,
		[9] = -1,
		[10] = -1,
		[11] = -1,
		[12] = -1,
		[13] = -1,
	}
	GameRules:GetGameModeEntity().quest_14_buff_list = {
		is_troll = 6,
		is_elf = 9,
		is_human = 6,
		is_undead = 6,
		is_goblin = 6,
		is_warrior = 9,
		is_mage = 9,
		is_warlock = 6,
		is_mech = 6,
		is_assassin = 9,
		is_hunter = 9,
		is_knight = 6,
		is_beast = 6,
		is_orc = 6,
	}
	GameRules:GetGameModeEntity().p2_match = {
		[2] = {
			{1,-1},
		},
		[3] = {
			{1,1,-2},
			{2,-1,-1},
		},
		[4] = {
			{1,-1,1,-1},
			{1,1,1,-3},
			{1,2,-2,-1},
			{2,-1,1,-2},
			{2,2,-2,-2},
			{2,2,-1,-3},
			{3,-1,-1,-1},
			{3,1,-2,-2},
			{3,1,-1,-3},
		},
	}
	GameRules:GetGameModeEntity().p2_battle = {
		[1] = -1,
		[2] = -1,
		[3] = -1,
		[4] = -1,
	}
	GameRules:GetGameModeEntity().p2_player = {
		[1] = {},
		[2] = {},
		[3] = {},
		[4] = {},
	}
	GameRules:GetGameModeEntity().team_color = {
		[4] = {r=255,g=0,b=0},
		[6] = {r=0,g=46,b=197},
		[7] = {r=128,g=128,b=128},
		[8] = {r=255,g=255,b=192},
		[9] = {r=255,g=192,b=64},
		[10] = {r=17,g=232,b=234},
		[11] = {r=255,g=100,b=200},
		[12] = {r=255,g=156,b=156},
		[13] = {r=255,g=0,b=255},
	}
	GameRules:GetGameModeEntity().setwin = nil
	GameRules:GetGameModeEntity().big_damage = 1
	-- PlayerResource:SetCustomPlayerColor(0, 0,0,255)
	-- PlayerResource:SetCustomPlayerColor(1, 0,0,255)

	GameRules:GetGameModeEntity().alive_player_table = {}
	GameRules:GetGameModeEntity().current_round = {}
	GameRules:GetGameModeEntity().last_round = {}
	GameRules:GetGameModeEntity().last_2nd_round = {}
	GameRules:GetGameModeEntity().last_3rd_round = {}

	
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_1, 0,192,0)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_2, 128,128,128)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_3, 255,255,192)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_4, 255,192,64)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_5, 17,232,234)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_6, 255,100,200)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_7, 255,156,156)
	-- SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_8, 255,0,255)
	
	SetTeamCustomHealthbarColor(DOTA_TEAM_NEUTRALS, 255,0,0)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_1, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_2, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_3, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_4, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_5, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_6, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_7, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_8, 128,255,128)

    ListenToGameEvent("player_connect_full", Dynamic_Wrap(DAC,"OnPlayerConnectFull" ),self)
    ListenToGameEvent("player_disconnect", Dynamic_Wrap(DAC, "OnPlayerDisconnect"), self)
    ListenToGameEvent("player_chat",Dynamic_Wrap(DAC,"OnPlayerChat"),self)
    ListenToGameEvent("dota_player_pick_hero",Dynamic_Wrap(DAC,"OnPlayerPickHero"),self)
    ListenToGameEvent("entity_killed", Dynamic_Wrap(DAC, "OnEntityKilled"), self)
    ListenToGameEvent("dota_player_gained_level", Dynamic_Wrap(DAC,"OnPlayerGainedLevel"), self)

    CustomGameEventManager:RegisterListener("request_buy_chess", Dynamic_Wrap(DAC, "OnRequestBuyChess") )
    CustomGameEventManager:RegisterListener("pick_chess_position", Dynamic_Wrap(DAC, "OnPickChessPosition") )
    CustomGameEventManager:RegisterListener("cancel_pick_chess_position", Dynamic_Wrap(DAC, "OnCancelPickChessPosition") )
    CustomGameEventManager:RegisterListener("dac_refresh_chess", Dynamic_Wrap(DAC, "OnRefreshChess") )
    CustomGameEventManager:RegisterListener("dac_report", Dynamic_Wrap(DAC, "OnReport") )
    CustomGameEventManager:RegisterListener("catch_crab", Dynamic_Wrap(DAC, "OnCatchCrab") )
    CustomGameEventManager:RegisterListener("unlock_chess", Dynamic_Wrap(DAC, "OnUnlockChess") )
    CustomGameEventManager:RegisterListener("lock_chess", Dynamic_Wrap(DAC, "OnLockChess") )
    CustomGameEventManager:RegisterListener("change_onduty_hero", Dynamic_Wrap(DAC, "OnChangeOndutyHero") )
    CustomGameEventManager:RegisterListener("preview_effect", Dynamic_Wrap(DAC, "OnPreviewEffect") )
    CustomGameEventManager:RegisterListener("preview_projectile", Dynamic_Wrap(DAC, "OnPreviewProjectile") )
    CustomGameEventManager:RegisterListener("suggest_liuju", Dynamic_Wrap(DAC, "OnSuggestLiuju") )
    CustomGameEventManager:RegisterListener("set_auto_combine", Dynamic_Wrap(DAC, "OnSetAutoCombine") )
    CustomGameEventManager:RegisterListener("select_difficulty", Dynamic_Wrap(DAC, "OnSelectDifficulty") )
    CustomGameEventManager:RegisterListener("request_pause_game", Dynamic_Wrap(DAC, "OnPauseGame") )
    CustomGameEventManager:RegisterListener("request_select_chess", Dynamic_Wrap(DAC, "OnRequestSelectChess") )
    CustomGameEventManager:RegisterListener("user_settings_update", Dynamic_Wrap(DAC, "OnUpdateUserSettings") )
    CustomGameEventManager:RegisterListener("request_choose_loot", Dynamic_Wrap(DAC, "OnRequestChooseLoot") )
    CustomGameEventManager:RegisterListener("choose_badge", Dynamic_Wrap(DAC, "OnChooseBadge") )
    CustomGameEventManager:RegisterListener("show_game_notice", Dynamic_Wrap(DAC, "OnShowGameNotice") )
    CustomGameEventManager:RegisterListener("player_language", Dynamic_Wrap(DAC, "OnPlayerLanguage") )
    CustomGameEventManager:RegisterListener("request_ban_chess", Dynamic_Wrap(DAC, "OnBanChess") )
    CustomGameEventManager:RegisterListener("request_unban_chess", Dynamic_Wrap(DAC, "OnUnBanSynergy") )
    CustomGameEventManager:RegisterListener("reset_fow", Dynamic_Wrap(DAC, "ResetFOW") )
    CustomGameEventManager:RegisterListener("request_show_emotion_bubble", Dynamic_Wrap(DAC, "RequestShowEmotionBubble") )
    CustomGameEventManager:RegisterListener("set_courier_table", Dynamic_Wrap(DAC, "SetCourierTable") )
    CustomGameEventManager:RegisterListener("set_player_show_buff_list", Dynamic_Wrap(DAC, "SetPlayerShowBuffList") )

	GameRules:GetGameModeEntity():SetDamageFilter(Dynamic_Wrap(DAC, "DamageFilter"), DAC)
	GameRules:GetGameModeEntity():SetHealingFilter(Dynamic_Wrap(DAC, "HealingFilter"), DAC)
	GameRules:GetGameModeEntity():SetExecuteOrderFilter(Dynamic_Wrap(DAC, 'ExecuteOrderFilter'), DAC )
	GameRules:GetGameModeEntity():SetItemAddedToInventoryFilter( Dynamic_Wrap( DAC, "ItemAddedToInventoryFilter" ), DAC )--设置一个过滤器，用来控制物品被放入物品栏时的行为。
	GameRules:GetGameModeEntity():SetModifierGainedFilter( Dynamic_Wrap( DAC, "ModifierGainedFilter" ), DAC )

    GameRules:GetGameModeEntity().battle_round = 1
    GameRules:GetGameModeEntity().pilao_round = 50
    GameRules:GetGameModeEntity().difficulty = 2
    GameRules:GetGameModeEntity().steamidlist = ''
    GameRules:GetGameModeEntity().steamidlist_heroindex = ''
    GameRules:GetGameModeEntity().steamid2playerid = {}
    GameRules:GetGameModeEntity().playerid2steamid = {}
    GameRules:GetGameModeEntity().steamid2name = {}
    GameRules:GetGameModeEntity().stat_info = {}
    GameRules:GetGameModeEntity().send_info = {}
    GameRules:GetGameModeEntity().send_status = {}
    GameRules:GetGameModeEntity().show_damage = false
    GameRules:GetGameModeEntity().upload_lineup = {}
    GameRules:GetGameModeEntity().upload_detail_stat = {}
    GameRules:GetGameModeEntity().connect_state = {
	    [0] = false,
	    [1] = false,
	    [2] = false,
	    [3] = false,
	    [4] = false,
	    [5] = false,
	    [6] = false,
	    [7] = false,
	}
    GameRules:GetGameModeEntity().battle_boss = {
  --   	[1] = {  --夜魇卫士
	 --    	[1] = {x=4,y=8,enemy='pve_melee_bad_diretide'},
	 --    	[2] = {x=5,y=8,enemy='pve_melee_bad_diretide'},
		-- },
		-- [2] = {  --夜魇中军
	 --    	[1] = {x=4,y=6,enemy='pve_melee_bad_mega_diretide'},
	 --    	[2] = {x=5,y=8,enemy='pve_ranged_bad_diretide'},
	 --    	[3] = {x=3,y=8,enemy='pve_ranged_bad_diretide'},
		-- },
		-- [3] = {  --夜魇统帅
	 --    	[1] = {x=4,y=6,enemy='pve_melee_bad_mega_diretide'},
	 --    	[2] = {x=5,y=6,enemy='pve_melee_bad_mega_diretide'},
	 --    	[3] = {x=4,y=8,enemy='pve_ranged_bad_diretide'},
	 --    	[4] = {x=5,y=8,enemy='pve_ranged_bad_diretide'},
	 --    	[5] = {x=3,y=7,enemy='pve_melee_bad_diretide'},
	 --    	[6] = {x=6,y=7,enemy='pve_melee_bad_diretide'},
		-- },
	    [1] = {  --天辉卫士
	    	[1] = {x=4,y=8,enemy='pve_melee_good'},
	    	[2] = {x=5,y=8,enemy='pve_melee_good'},
		},
		[2] = {  --天辉中军
	    	[1] = {x=4,y=6,enemy='pve_melee_good_mega'},
	    	[2] = {x=5,y=8,enemy='pve_ranged_good'},
	    	[3] = {x=3,y=8,enemy='pve_ranged_good'},
		},
		[3] = {  --天辉统帅
	    	[1] = {x=4,y=6,enemy='pve_melee_good_mega'},
	    	[2] = {x=5,y=6,enemy='pve_melee_good_mega'},
	    	[3] = {x=4,y=8,enemy='pve_ranged_good'},
	    	[4] = {x=5,y=8,enemy='pve_ranged_good'},
	    	[5] = {x=3,y=7,enemy='pve_melee_good'},
	    	[6] = {x=6,y=7,enemy='pve_melee_good'},
		},
		[10] = {  --岩石傀儡
			[1] = {x=4,y=6,enemy='pve_stone_a'},
	    	[2] = {x=2,y=7,enemy='pve_stone_b'},
	    	[3] = {x=6,y=7,enemy='pve_stone_b'},
		},
		[15] = {  --群狼
			[1] = {x=4,y=6,enemy='pve_wolf_big'},
			[2] = {x=5,y=8,enemy='pve_wolf_small_a'},
	    	[3] = {x=3,y=8,enemy='pve_wolf_small_a'},
	    	[4] = {x=2,y=7,enemy='pve_wolf_small_b'},
	    	[5] = {x=6,y=7,enemy='pve_wolf_small_b'},
		},
		[20] = {  --夺命双熊
			[1] = {x=4,y=6,enemy='pve_bear_a'},
	    	[2] = {x=2,y=7,enemy='pve_bear_b'},
		},
		[25] = {  --愤怒的枭兽
			[1] = {x=2,y=7,enemy='pve_vulture_a'},
			[2] = {x=7,y=7,enemy='pve_vulture_b'},
		},
		[30] = {  --雷隐兽
			[1] = {x=4,y=6,enemy='pve_leishou_a'},
			[2] = {x=3,y=7,enemy='pve_leishou_b'},
			[3] = {x=5,y=7,enemy='pve_leishou_b'},
		},
		[35] = {  --黑龙王
			[1] = {x=4,y=5,enemy='pve_black_dragon'},
		},
		-- [35] = {  --千娇魔女
		-- 	[1] = {x=4,y=5,enemy='pve_qianjiaomonv'},
		-- },
		[40] = {  --巨魔部落
			[1] = {x=3,y=6,enemy='pve_troll_dark_a'},
			[2] = {x=4,y=6,enemy='pve_troll_dark_a'},
			[3] = {x=5,y=6,enemy='pve_troll_dark_a'},
			[4] = {x=6,y=6,enemy='pve_troll_dark_a'},
			[5] = {x=3,y=8,enemy='pve_troll_dark_b'},
			[6] = {x=6,y=8,enemy='pve_troll_dark_c'},
		},
		[45] = {  --年兽
			[1] = {x=4,y=7,enemy='pve_nian'},
		},
		-- [50] = {  --肉山大魔王
		-- 	[1] = {x=4,y=7,enemy='pve_tangyimaowang'},
		-- },
		[50] = {  --肉山大魔王
			[1] = {x=4,y=7,enemy='pve_roshan'},
		},
		[554] = {  --for test
			[1] = {x=4,y=5,enemy='chess_tiny11'},
		},
		[555] = {  --for test
			[1] = {x=4,y=5,enemy='chess_ww1'},
			[2] = {x=4,y=6,enemy='chess_nec1'},
			[3] = {x=4,y=7,enemy='chess_dr1'},
			[4] = {x=4,y=8,enemy='chess_na1'},
			[5] = {x=5,y=5,enemy='chess_visage1'},
			[6] = {x=5,y=6,enemy='chess_abaddon1'},
		},
	}

	GameRules:GetGameModeEntity().DROP_ITEM_LIST = {
		[1] = {
			[1] = 'item_suozijia',
			[2] = 'item_yuandun',
			[3] = 'item_zhiliaozhihuan',
			[4] = 'item_gongjizhizhua',
			[5] = 'item_kuweishi',
			[6] = 'item_duangun',
			[7] = 'item_xixuemianju',
			[8] = 'item_huifuzhihuan',
			[9] = 'item_kangmodoupeng',
			[10] = 'item_xuwubaoshi',
			[11] = 'item_fashichangpao',
			[12] = 'item_wangguan',
			[13] = 'item_suduzhixue',
		},
		[2] = {	
			[1] = 'item_huoliqiu',
			[2] = 'item_kuojian',
			[3] = 'item_miyinchui',
			[4] = 'item_biaoqiang',
			[5] = 'item_molifazhang',
			[6] = 'item_xiaofu',
			[7] = 'item_nengliangqiu',
			[8] = 'item_tiaodao',
			[9] = 'item_huanxinzhiren',
			[10] = 'item_shanbihufu',
		},
		[3] = {
			[1] = 'item_banjia', 
			[2] = 'item_emodaofeng',
			[3] = 'item_zhenfenbaoshi',
			[4] = 'item_jixianfaqiu',
			[5] = 'item_shengzheyiwu',
			[6] = 'item_dafu',
			[7] = 'item_shenmifazhang',
			[8] = 'item_yingjiaogong',
		}
	}
	GameRules:GetGameModeEntity().ITEM_FOOD_LIST = {
		[1] = 'item_mangguo',
	}

	GameRules:GetGameModeEntity().COMBINED_ITEM_LIST = {
		[2] = {'item_qiongguidun','item_jianrenqiu','item_jingmixie','item_yuanlifazhang','item_dianjinshou','item_tiaodao'},
		[3] = {'item_banjia','item_zhenfenbaoshi','item_shuijingjian','item_emodaofeng','item_jixianfaqiu','item_shenmifazhang','item_yingjiaogong','item_fengkuangmianju','item_renjia','item_zhaohuanshenshi','item_aoshuxie','item_xianfengdun','item_tiaozhantoujin','item_huiguang','item_hongzhang_1','item_hongzhang_2','item_hongzhang_3','item_hongzhang_4','item_hongzhang_5','item_wangyuanjing'},
		[4] = {'item_shengzheyiwu','item_dafu','item_yinyuezhijing','item_xuanwo','item_anmie','item_kuangzhanfu','item_huiyao','item_bingyan','item_xiwa','item_bkb','item_dongchayandou','item_huanyingfu','item_qinglianbaozhu','item_linkenfaqiu','item_chihongjia'},
		[5] = {'item_shengjian','item_jingubang','item_dapao','item_dadianchui','item_longxin','item_sadan','item_qiangxi','item_shuaxinqiu','item_yangdao','item_hudie','item_shirenmozhimao','item_baojunwangpao'},
	}


	GameRules:GetGameModeEntity():SetPauseEnabled(false)
    GameRules:GetGameModeEntity():SetFogOfWarDisabled(false)
    GameRules:GetGameModeEntity():SetUnseenFogOfWarEnabled(false)
    

    GameRules:GetGameModeEntity():SetBuybackEnabled(false)
    GameRules:GetGameModeEntity().heroindex2steamid = {}
    GameRules:GetGameModeEntity().cloudlineup = nil
    GameRules:GetGameModeEntity().steamid2heroindex = {}

    GameRules:GetGameModeEntity().userid2player = {}
	GameRules:GetGameModeEntity().team2playerid = {}
	GameRules:GetGameModeEntity().playerid2team = {}

	GameRules:GetGameModeEntity().START_TIME = nil
    GameRules:GetGameModeEntity().player_levels = {}
    GameRules:GetGameModeEntity():SetUseCustomHeroLevels(true)
	GameRules:GetGameModeEntity():SetCustomHeroMaxLevel(16)
	GameRules:GetGameModeEntity().HeroExpTable = {
			[1] = 0,--+1
			[2] = 1,--+1
			[3] = 2,--+2-->+4(1)(0)(1)
			[4] = 6,--+4-->+8(1)(0)(1)
			[5] = 14,--+8-->+16(1)(1)(1)
			[6] = 30,--+16-->+32(2)(2)(2)
			[7] = 62,--+24-->+48(3)(3)(2)
			[8] = 110,--+32-->+56(4)(3)(3)
			[9] = 166,--+40-->+64(4)(4)(3)

			[10] = 230,--+48-->+64
			[11] = 294,--+56-->+64
			[12] = 358,--+64-->+64
			[13] = 422,--+72-->+64
			[14] = 486,--+80-->+64
			[15] = 550,--+88-->+64
			[16] = 614,
		}
    GameRules:GetGameModeEntity():SetCustomXPRequiredToReachNextLevel(GameRules:GetGameModeEntity().HeroExpTable)
	GameRules:GetGameModeEntity().client_key = {
		[1] = RandomInt(1,1000000),
	    [6] = RandomInt(1,1000000),
		[7] = RandomInt(1,1000000),
		[8] = RandomInt(1,1000000),
		[9] = RandomInt(1,1000000),
		[10] = RandomInt(1,1000000),
		[11] = RandomInt(1,1000000),
		[12] = RandomInt(1,1000000),
		[13] = RandomInt(1,1000000),
    }

    GameRules:GetGameModeEntity().history_win = {
    	[6] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[7] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[8] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[9] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[10] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[11] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[12] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[13] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
	}

	GameRules:GetGameModeEntity().history_lose = {
    	[6] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[7] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[8] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[9] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[10] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[11] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[12] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[13] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
	}

    GameRules:GetGameModeEntity().unit = {
	    [6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
    }
    GameRules:GetGameModeEntity().mychess = {
    	[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	GameRules:GetGameModeEntity().to_be_destory_list = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	GameRules:GetGameModeEntity().game_status = 0
	GameRules:GetGameModeEntity().prepare_timer = 35
	GameRules:GetGameModeEntity().battle_timer = 50
    GameRules:GetGameModeEntity().myself = false
	GameRules:GetGameModeEntity().is_stop = false
	GameRules:GetGameModeEntity().isConnected = {}
	GameRules:GetGameModeEntity().is_game_started =false
	GameRules:GetGameModeEntity().is_game_ended =false

	--默认卡池参数
	GameRules:GetGameModeEntity().CHESS_POOL_SIZE = 5
	GameRules:GetGameModeEntity().CHESS_INIT_COUNT = {
		[1] = 4,
		[2] = 4,
		[3] = 3,
		[4] = 3,
		[5] = 2,
	}
	GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE = {
		[1] = 1,
		[2] = 1,
		[3] = 1,
		[4] = 1,
		[5] = 1,
	}

    GameRules:GetGameModeEntity().hero = {}
    GameRules:GetGameModeEntity().battleid = nil
    GameRules:GetGameModeEntity().ended = false
    GameRules:GetGameModeEntity().playerid2hero = {}
	GameRules:GetGameModeEntity().teamid2hero = {}

	GameRules:GetGameModeEntity().reportinfo = {}
	

	GameRules:GetGameModeEntity().base_vector = {
		[6] = Vector(-2496,1728,128),
		[7] = Vector(-448,1728,128),
		[8] = Vector(1600,1728,128),
		[9] = Vector(1600,-320,128),
		[10] = Vector(1600,-2368,128),
		[11] = Vector(-448,-2368,128),
		[12] = Vector(-2496,-2368,128),
		[13] = Vector(-2496,-320,128),
	}
	GameRules:GetGameModeEntity().hand = {
		[6] = {0,0,0,0,0,0,0,0},
		[7] = {0,0,0,0,0,0,0,0},
		[8] = {0,0,0,0,0,0,0,0},
		[9] = {0,0,0,0,0,0,0,0},
		[10] = {0,0,0,0,0,0,0,0},
		[11] = {0,0,0,0,0,0,0,0},
		[12] = {0,0,0,0,0,0,0,0},
		[13] = {0,0,0,0,0,0,0,0},
	}
	GameRules:GetGameModeEntity().counterpart = {}
	GameRules:GetGameModeEntity().lastrandomn = 0
	GameRules:GetGameModeEntity().population = {
		[6] = 0,
		[7] = 0,
		[8] = 0,
		[9] = 0,
		[10] = 0,
		[11] = 0,
		[12] = 0,
		[13] = 0,
	}
	GameRules:GetGameModeEntity().population_max = {
		[6] = 1,
		[7] = 1,
		[8] = 1,
		[9] = 1,
		[10] = 1,
		[11] = 1,
		[12] = 1,
		[13] = 1,
	}
	--给第i个人提供第j个场地的视野
	GameRules:GetGameModeEntity().lights = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	GameRules:GetGameModeEntity().damage_stat = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	GameRules:GetGameModeEntity().effect_list = "e101,e102,e103,e104,e107,e108,e111,e112,e113,e114,e201,e202,e203,e205,e210,e213,e214,e215,e301,e302,e303,e304,e305,e306,e308,e309,e311,e312,e313,e315,e317,e319,e320,e321,e322,e323,e324,e325,e401,e402,e403,e404,e405,e406,e407,e408,e409,e410,e411,e412,e413,e414,e415,e451,e452,e453,e454,e455,e456,e457,e458,e459"

	--按费用抽卡的棋子列表（受本局橙卡池影响）
	GameRules:GetGameModeEntity().chess_list_by_mana = {
		[1] = {'chess_cm','chess_tusk','chess_axe','chess_eh','chess_clock','chess_ss','chess_bh','chess_dr','chess_tk','chess_am','chess_tiny','chess_mars','chess_ww','chess_wd','chess_sb','chess_luna','chess_oracle'}, --'chess_dw',
		[2] = {'chess_bm','chess_jugg','chess_shredder','chess_ck','chess_fur','chess_morph','chess_slark','chess_bat','chess_om','chess_pom','chess_sniper','chess_abaddon','chess_dazzle','chess_brew','chess_lion','chess_visage'}, --'chess_riki','chess_puck',,'chess_bs'
		[3] = {'chess_ok','chess_razor','chess_viper','chess_lyc','chess_lina','chess_tb','chess_tp','chess_veno','chess_sk','chess_rubick','chess_lc','chess_slardar','chess_sf','chess_meepo','chess_fv','chess_gs'}, --'chess_ember','chess_storm','chess_earth','chess_pudge','chess_pa'
		[4] = {'chess_doom','chess_nec','chess_medusa','chess_ga','chess_dk','chess_light','chess_ld','chess_na','chess_chen','chess_wr','chess_br','chess_kunkka','chess_es','chess_pangolier'}, --'chess_troll'
		[5] = {'chess_disruptor','chess_mk','chess_kael','chess_ta','chess_gyro','chess_huskar','chess_thd','chess_tech','chess_snap','chess_th','chess_enigma','chess_zeus','chess_et','chess_sven','chess_qop'}, --chess_lich','chess_dp'
	}
	--金色机械核心可以开出的橙卡棋子（不受本局橙卡池影响）
	GameRules:GetGameModeEntity().chess_list_by_mana_gold = {
		'chess_disruptor','chess_mk','chess_kael','chess_ta','chess_gyro','chess_huskar','chess_thd','chess_tech','chess_snap','chess_th','chess_enigma','chess_zeus','chess_et','chess_sven','chess_qop'
	}
	--德鲁伊棋子列表（不受本局橙卡池影响）
	GameRules:GetGameModeEntity().chess_list_by_druid = {
		'chess_eh','chess_fur','chess_tp','chess_ld','chess_et'
	}
	--按种族/职业索引的棋子列表（受本局橙卡池影响）
	GameRules:GetGameModeEntity().chess_list_by_synergy = {
		is_aqir = {'chess_veno','chess_sk','chess_na','chess_br'},
		is_beast = {'chess_tusk','chess_eh','chess_pangolier','chess_lyc','chess_veno','chess_ld','chess_mk'}, --
		is_demon = {'chess_ck','chess_lion','chess_tb','chess_sf','chess_doom','chess_gs','chess_sven','chess_qop'},
		is_dragon = {'chess_ww','chess_viper','chess_visage','chess_dk','chess_thd'},
		is_dwarf = {'chess_sniper','chess_gyro'},
		is_element = {'chess_tiny','chess_morph','chess_razor','chess_enigma',},
		is_elf = {'chess_am','chess_luna','chess_fur','chess_pom','chess_tp','chess_wr','chess_ta','chess_kael'},--,'chess_dw','chess_pa'
		is_goblin = {'chess_clock','chess_bh','chess_tk','chess_shredder','chess_ga','chess_tech','chess_snap'},
		is_god = {'chess_mars','chess_oracle','chess_rubick','chess_zeus','chess_et'},
		is_human = {'chess_cm','chess_ok','chess_lyc','chess_lina','chess_lc','chess_dk','chess_light','chess_kunkka'},
		is_naga = {'chess_slark','chess_slardar','chess_medusa','chess_th'},
		is_ogre = {'chess_om','chess_ga'},
		is_orc = {'chess_axe','chess_bm','chess_jugg','chess_chen','chess_disruptor'}, --,'chess_bs'
		is_pandaman = {'chess_brew'},
		is_troll = {'chess_ss','chess_wd','chess_bat','chess_dazzle','chess_huskar'},--'chess_troll',
		is_undead = {'chess_dr','chess_ww','chess_abaddon','chess_visage','chess_nec','chess_na'},--,'chess_pudge','chess_dp'
		is_tauren = {'chess_sb','chess_es','chess_et'},
		is_kobold = {'chess_meepo'},
		is_nraqi = {'chess_fv'},

		is_assassin = {'chess_bh','chess_sb','chess_morph','chess_slark','chess_pangolier','chess_viper','chess_sk','chess_na','chess_fv','chess_ta','chess_qop'}, --,'chess_pa'
		is_demonhunter = {'chess_am','chess_tb'},
		is_druid = {'chess_eh','chess_fur','chess_tp','chess_ld','chess_et'},
		is_hunter = {'chess_dr','chess_bm','chess_pom','chess_sniper','chess_visage','chess_medusa','chess_wr','chess_th','chess_br'},
		is_knight = {'chess_luna','chess_ck','chess_bat','chess_abaddon','chess_ok','chess_lc','chess_dk','chess_snap'},
		is_mage = {'chess_cm','chess_ww','chess_om','chess_razor','chess_lina','chess_light','chess_kael','chess_thd','chess_zeus'},
		is_mech = {'chess_clock','chess_tk','chess_shredder','chess_meepo','chess_gyro','chess_tech'},
		is_monk = {'chess_brew','chess_mk'},--
		is_priest = {'chess_oracle','chess_dazzle','chess_chen'},
		is_shaman = {'chess_ss','chess_es','chess_disruptor'}, --,'chess_bs'
		is_warlock = {'chess_wd','chess_veno','chess_sf','chess_nec','chess_ga','chess_enigma'},--,'chess_dp'
		is_warrior = {'chess_tusk','chess_axe','chess_tiny','chess_mars','chess_jugg','chess_lyc','chess_slardar','chess_doom','chess_kunkka','chess_huskar','chess_sven'},--'chess_pudge','chess_troll',
		is_wizard = {'chess_rubick','chess_gs','chess_lion'}, --'chess_dw',
	}
	GameRules:GetGameModeEntity().chess_list_ssr = {'chess_nec_ssr','chess_ck_ssr','chess_ss_ssr','chess_brew_ssr'} 
	GameRules:GetGameModeEntity().chess_2_mana = {
		chess_tusk = 1,
		chess_axe = 1,
		chess_eh = 1,
		chess_om = 2,
		chess_clock = 1,
		chess_ss = 1,
		chess_bh = 1,
		chess_bat = 2,
		chess_dr = 1,
		chess_tk = 1,
		chess_bm = 2,
		chess_jugg = 2,
		chess_shredder = 2,
		chess_puck = 2,
		chess_ck = 2,
		chess_slardar = 3,
		chess_luna = 1,
		chess_tp = 3,
		chess_qop = 5,
		chess_snap = 5,
		chess_huskar = 5,
		chess_bs = 2,
		chess_am = 1,
		chess_wd = 1,
		chess_cm = 1,
		chess_light = 4,
		chess_ok = 3,
		chess_razor = 3,
		chess_wr = 4,
		chess_sk = 3,
		chess_abaddon = 2,
		chess_slark = 2,
		chess_sniper = 2,
		chess_sf = 3,
		chess_viper = 3,
		chess_lyc = 3,
		chess_pa = 3,
		chess_kunkka = 4,
		chess_doom = 4,
		chess_lina = 3,
		chess_troll = 4,
		chess_veno = 3,
		chess_nec = 4,
		chess_ta = 5,
		chess_medusa = 4,
		chess_disruptor = 5,
		chess_ga = 4,
		chess_dk = 4,
		chess_gyro = 5,
		chess_lich = 5,
		chess_th = 5,
		chess_enigma = 5,
		chess_tech = 5,
		chess_fur = 2,
		chess_ld = 4,
		--
		chess_tiny = 1,
		chess_tb = 3,
		chess_morph = 2,
		chess_nec_ssr = 10,
		chess_ck_ssr = 15,
		chess_ss_ssr = 10,
		chess_enigma_ssr = 15,

		chess_kael = 5,
		chess_sven = 5,

		chess_riki = 3,
		chess_pom = 2,
		chess_dp = 5,
		chess_fv = 3,

		chess_zeus = 5,
		chess_mars = 1,
		chess_ss_ssr = 8,
		chess_lich_ssr = 6,
		chess_brew_ssr = 15,

		chess_dazzle = 2,
		chess_io = 5,
		chess_ww = 1,
		chess_rubick = 3,
		chess_gs = 3,

		chess_pudge = 3,
		chess_visage = 2,
		chess_lion = 2,
		chess_na = 4,
		chess_oracle = 1,
		chess_br = 4,
		chess_lc = 3,
		chess_chen = 4,
		chess_thd = 5,
		chess_dw = 1,

		chess_brew = 2,
		chess_ember = 3,
		chess_storm = 3,
		chess_earth = 3,
		chess_mk = 5,
		chess_es = 4,
		chess_sb = 1,
		chess_et = 5,
		chess_meepo = 3,
		chess_pangolier = 4,
	}
	GameRules:GetGameModeEntity().chess_list_by_level = {}
	GameRules:GetGameModeEntity().chess_pool = {
		[1] = {},
		[2] = {},
		[3] = {},
		[4] = {},
		[5] = {},
	}
	GameRules:GetGameModeEntity().chess_gailv = {
		[1] = { [101] = 2 },
		[2] = { [70] = 2 },
		[3] = { [60] = 2, [95] = 3 },
		[4] = { [50] = 2, [85] = 3 },
		[5] = { [40] = 2, [75] = 3, [98] = 4 },
		[6] = { [33] = 2, [63] = 3, [93] = 4 },
		[7] = { [30] = 2, [60] = 3, [90] = 4 },
		[8] = { [24] = 2, [54] = 3, [84] = 4, [99] = 5 },
		[9] = { [22] = 2, [52] = 3, [77] = 4, [97] = 5 },
		[10] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
		[11] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
		[12] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
		[13] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
		[14] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
		[15] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
		[16] = { [19] = 2, [44] = 3, [69] = 4, [94] = 5 },
	}
	GameRules:GetGameModeEntity().drop_item_gailv = {
		[1] = { [101] = 1},
		[2] = { [101] = 1},
		[3] = { [101] = 1},
		[4] = { [50] = 1},
		[5] = { [50] = 1, [80] = 2},
		[6] = { [50] = 1, [80] = 2},
		[7] = { [50] = 1, [80] = 2},
		[8] = { [50] = 1, [80] = 2},
		[9] = { [50] = 1, [80] = 2},
	}
	GameRules:GetGameModeEntity().drop_loot_gailv = {
		[1] = { [0] = 1},
		[2] = { [0] = 1, [66] = 2},
		[3] = { [0] = 1, [34] = 2},
		[4] = { [0] = 1, [25] = 2, [75] = 3},
		[5] = { [0] = 2, [50] = 3},
		[6] = { [0] = 2, [25] = 3},
	}
	GameRules:GetGameModeEntity().wave_2_lootbox = {
		[1] = 'item_lootbox_lv1',
		[2] = 'item_lootbox_lv1',
		[3] = 'item_lootbox_lv1',
		[10] = 'item_lootbox_lv2',
		[15] = 'item_lootbox_lv2',
		[20] = 'item_lootbox_lv3',
		[25] = 'item_lootbox_lv3',
		[30] = 'item_lootbox_lv4',
		[35] = 'item_lootbox_lv4',
		[40] = 'item_lootbox_lv5',
		[45] = 'item_lootbox_lv5',
		[50] = 'item_lootbox_lv6',
	}
	GameRules:GetGameModeEntity().chess_ability_list = {
		chess_cm = 'cm_mana_aura',
		chess_axe = 'axe_berserkers_call',
		chess_dr = 'dr_shooter_aura',
		chess_eh = 'enchantress_natures_attendants',
		chess_om = 'om_multi_cast',
		chess_tusk = 'tusk_walrus_punch',
		chess_bm = 'bm_beast',
		chess_jugg = 'juggernaut_blade_fury',
		chess_lyc = 'lyc_wolf',
		chess_shredder = 'shredder_whirling_death',
		chess_tk = 'a108',
		chess_light = 'keeper_of_the_light_illuminate',
		chess_ok = 'omniknight_purification',
		chess_razor = 'razor_plasma_field',
		chess_wr = 'windrunner_powershot',
		chess_doom = 'doom_bringer_doom',
		chess_kunkka = 'kunkka_ship',
		chess_lina = 'lina_laguna_blade',
		chess_troll = 'troll_warlord_fervor',
		chess_veno = 'veno_ward',
		chess_gyro = 'gyrocopter_call_down',
		chess_lich = 'lich_chain_frost',
		chess_qop = 'queenofpain_sonic_wave_datadriven',
		chess_snap = 'snapfire_lil_shredder',
		chess_th = 'tidehunter_ravage',
		chess_br = 'br_web',
		--
		chess_am = 'antimage_mana_break',
		chess_wd = 'witch_doctor_paralyzing_cask',
		chess_clock = 'rattletrap_battery_assault',
		chess_ss = 'shadow_shaman_shackles',
		chess_pa = 'phantom_assassin_coup_de_grace',
		chess_puck = 'puck_illusory_orb',
		chess_slardar = 'slardar_slithereen_crush',
		chess_ck = 'chaos_knight_chaos_bolt',
		chess_abaddon = 'abaddon_aphotic_shield',
		chess_sk = 'sandking_burrowstrike',
		chess_slark = 'slark_nengliangzhuanyi',
		chess_sniper = 'sniper_assassinate',
		chess_nec = 'necrolyte_death_pulse',
		chess_ta = 'templar_assassin_refraction',
		chess_enigma = 'midnight_pulse_datadriven',
		--
		chess_bat = 'batrider_firefly',
		-- chess_bat = 'batrider_sticky_napalm',
		chess_luna = 'luna_moon_glaive',
		chess_tp = 'tp_seed',
		chess_sf = 'shadow_fiend_requiem_of_souls_lua',
		chess_dk = 'dragon_knight_elder_dragon_form',
		chess_viper = 'viper_viper_strike',
		chess_medusa = 'medusa_stone_gaze',
		chess_disruptor = 'ability_disruptor_static_storm',
		chess_ga = 'alchemist_chemical_rage',
		chess_tech = 'chess_tech_bomb',
		--
		chess_fur = 'fur_tree',
		chess_ld = 'ld_bear',
		--
		chess_nec_ssr = 'nec_ssr_scythe',
		chess_morph = 'morphling_waveform',
		chess_tb = 'tb_mohua',
		chess_tiny = 'tiny_touzhi',
		--
		chess_riki = 'riki_smoke_screen',
		chess_pom = 'pom_arrow_far',
		chess_dp = 'death_prophet_exorcism',
		--
		chess_fv = 'fv_zhao',
		chess_kael = 'kael_???',
		--
		chess_zeus = 'zeus_thunder',
		chess_mars = 'mars_bulwark_attack',
		--
		chess_sven = 'sven_gods_strength',
		chess_ww = 'winter_wyvern_cold_embrace',
		chess_rubick = 'rubick_qiequ',
		chess_gs = 'gs_moji',

		chess_cm1 = 'cm_mana_aura',
		chess_axe1 = 'axe_berserkers_call',
		chess_dr1 = 'dr_shooter_aura',
		chess_eh1 = 'enchantress_natures_attendants',
		chess_om1 = 'om_multi_cast',
		chess_tusk1 = 'tusk_walrus_punch',
		chess_bm1 = 'bm_beast',
		chess_jugg1 = 'juggernaut_blade_fury',
		chess_lyc1 = 'lyc_wolf',
		chess_shredder1 = 'shredder_whirling_death',
		chess_tk1 = 'a108',
		chess_light1 = 'keeper_of_the_light_illuminate',
		chess_ok1 = 'omniknight_purification',
		chess_razor1 = 'razor_plasma_field',
		chess_wr1 = 'windrunner_powershot',
		chess_doom1 = 'doom_bringer_doom',
		chess_kunkka1 = 'kunkka_ship',
		chess_lina1 = 'lina_laguna_blade',
		chess_troll1 = 'troll_warlord_fervor',
		chess_veno1 = 'veno_ward',
		chess_gyro1 = 'gyrocopter_call_down',
		chess_lich1 = 'lich_chain_frost',
		chess_qop1 = 'queenofpain_sonic_wave_datadriven',
		chess_snap1 = 'snapfire_lil_shredder',
		chess_th1 = 'tidehunter_ravage',
		chess_br1 = 'br_web',
		--
		chess_am1 = 'antimage_mana_break',
		chess_wd1 = 'witch_doctor_paralyzing_cask',
		chess_clock1 = 'rattletrap_battery_assault',
		chess_ss1 = 'shadow_shaman_shackles',
		chess_pa1 = 'phantom_assassin_coup_de_grace',
		chess_puck1 = 'puck_illusory_orb',
		chess_slardar1 = 'slardar_slithereen_crush',
		chess_ck1 = 'chaos_knight_chaos_bolt',
		chess_abaddon1 = 'abaddon_aphotic_shield',
		chess_sk1 = 'sandking_burrowstrike',
		chess_slark1 = 'slark_nengliangzhuanyi',
		chess_sniper1 = 'sniper_assassinate',
		chess_nec1 = 'necrolyte_death_pulse',
		chess_ta1 = 'templar_assassin_refraction',
		chess_enigma1 = 'midnight_pulse_datadriven',
		--
		chess_bat1 = 'batrider_firefly',
		-- chess_bat1 = 'batrider_sticky_napalm',
		chess_luna1 = 'luna_moon_glaive',
		chess_tp1 = 'tp_seed',
		chess_sf1 = 'shadow_fiend_requiem_of_souls_lua',
		chess_dk1 = 'dragon_knight_elder_dragon_form',
		chess_viper1 = 'viper_viper_strike',
		chess_medusa1 = 'medusa_stone_gaze',
		chess_disruptor1 = 'ability_disruptor_static_storm',
		chess_ga1 = 'alchemist_chemical_rage',
		chess_tech1 = 'chess_tech_bomb',
		--
		chess_fur1 = 'fur_tree',
		chess_ld1 = 'ld_bear',
		--
		chess_morph1 = 'morphling_waveform',
		chess_tb1 = 'tb_mohua',
		chess_tiny1 = 'tiny_touzhi',
		--
		chess_riki1 = 'riki_smoke_screen',
		chess_pom1 = 'pom_arrow_far',
		chess_dp1 = 'death_prophet_exorcism',
		--
		chess_fv1 = 'fv_zhao',
		chess_kael1 = 'kael_???',
		--
		chess_zeus1 = 'zeus_thunder',
		chess_mars1 = 'mars_bulwark_attack',
		--
		chess_sven1 = 'sven_gods_strength',
		chess_ww1 = 'winter_wyvern_cold_embrace',
		chess_rubick1 = 'rubick_qiequ',
		chess_gs1 = 'gs_moji',


		chess_cm11 = 'cm_mana_aura',
		chess_axe11 = 'axe_berserkers_call',
		chess_dr11 = 'dr_shooter_aura',
		chess_eh11 = 'enchantress_natures_attendants',
		chess_om11 = 'om_multi_cast',
		chess_tusk11 = 'tusk_walrus_punch',
		chess_bm11 = 'bm_beast',
		chess_jugg11 = 'juggernaut_blade_fury',
		chess_lyc11 = 'lyc_wolf',
		chess_shredder11 = 'shredder_whirling_death',
		chess_tk11 = 'a108',
		chess_light11 = 'keeper_of_the_light_illuminate',
		chess_ok11 = 'omniknight_purification',
		chess_razor11 = 'razor_plasma_field',
		chess_wr11 = 'windrunner_powershot',
		chess_doom11 = 'doom_bringer_doom',
		chess_kunkka11 = 'kunkka_ship',
		chess_lina11 = 'lina_laguna_blade',
		chess_troll11 = 'troll_warlord_fervor',
		chess_veno11 = 'veno_ward',
		chess_gyro11 = 'gyrocopter_call_down',
		chess_lich11 = 'lich_chain_frost',
		chess_qop11 = 'queenofpain_sonic_wave_datadriven',
		chess_snap11 = 'snapfire_lil_shredder',
		chess_th11 = 'tidehunter_ravage',
		chess_br11 = 'br_web',
		--
		chess_am11 = 'antimage_mana_break',
		chess_wd11 = 'witch_doctor_paralyzing_cask',
		chess_clock11 = 'rattletrap_battery_assault',
		chess_ss11 = 'shadow_shaman_shackles',
		chess_pa11 = 'phantom_assassin_coup_de_grace',
		chess_puck11 = 'puck_illusory_orb',
		chess_slardar11 = 'slardar_slithereen_crush',
		chess_ck11 = 'chaos_knight_chaos_bolt',
		chess_abaddon11 = 'abaddon_aphotic_shield',
		chess_sk11 = 'sandking_burrowstrike',
		chess_slark11 = 'slark_nengliangzhuanyi',
		chess_sniper11 = 'sniper_assassinate',
		chess_nec11 = 'necrolyte_death_pulse',
		chess_ta11 = 'templar_assassin_refraction',
		chess_enigma11 = 'midnight_pulse_datadriven',
		--
		chess_bat11 = 'batrider_firefly',
		-- chess_bat11 = 'batrider_sticky_napalm',
		chess_luna11 = 'luna_moon_glaive',
		chess_tp11 = 'tp_seed',
		chess_sf11 = 'shadow_fiend_requiem_of_souls_lua',
		chess_dk11 = 'dragon_knight_elder_dragon_form',
		chess_viper11 = 'viper_viper_strike',
		chess_medusa11 = 'medusa_stone_gaze',
		chess_disruptor11 = 'ability_disruptor_static_storm',
		chess_ga11 = 'alchemist_chemical_rage',
		chess_tech11 = 'chess_tech_bomb',
		--
		chess_fur11 = 'fur_tree',
		chess_ld11 = 'ld_bear',
		--
		chess_morph11 = 'morphling_waveform',
		chess_tb11 = 'tb_mohua',
		chess_tiny11 = 'tiny_touzhi',
		--
		chess_riki11 = 'riki_smoke_screen',
		chess_pom11 = 'pom_arrow_far',
		chess_dp11 = 'death_prophet_exorcism',
		--
		chess_fv11 = 'fv_zhao',
		chess_kael11 = 'kael_???',
		--
		chess_zeus11 = 'zeus_thunder',
		chess_mars11 = 'mars_bulwark_attack',
		--

		chess_ck_ssr = 'ck_illusion',
		chess_ss_ssr = 'ss_ssr_wards',
		chess_lich_ssr = 'lich_evil_sacrifice',

		chess_dazzle = 'dazzle_bozang',
		chess_dazzle1 = 'dazzle_bozang',
		chess_dazzle11 = 'dazzle_bozang',

		chess_io = 'wisp_tether',
		chess_io1 = 'wisp_tether',
		chess_sven11 = 'sven_gods_strength',
		chess_ww11 = 'winter_wyvern_cold_embrace',
		chess_rubick11 = 'rubick_qiequ',
		chess_gs11 = 'gs_moji',

		chess_pudge = 'pudge_meat_hook_lua',
		chess_pudge1 = 'pudge_meat_hook_lua',
		chess_pudge11 = 'pudge_meat_hook_lua',


		chess_visage = 'baby_dragon',
		chess_visage1 = 'baby_dragon',
		chess_visage11 = 'baby_dragon',

		chess_lion = 'lion_mana_drain_datadriven',
		chess_lion1 = 'lion_mana_drain_datadriven',
		chess_lion11 = 'lion_mana_drain_datadriven',

		chess_oracle = 'oracle_mingyunsheling',
		chess_oracle1 = 'oracle_mingyunsheling',
		chess_oracle11 = 'oracle_mingyunsheling',

		chess_na = 'nyx_assassin_spiked_carapace_datadriven',
		chess_na1 = 'nyx_assassin_spiked_carapace_datadriven',
		chess_na11 = 'nyx_assassin_spiked_carapace_datadriven',

		chess_bs = 'bloodseeker_blood_bath',
		chess_bs1 = 'bloodseeker_blood_bath',
		chess_bs11 = 'bloodseeker_blood_bath',

		chess_huskar = 'burning_spear_datadriven',
		chess_huskar1 = 'burning_spear_datadriven',
		chess_huskar11 = 'burning_spear_datadriven',

		chess_mk = 'mk_ruyibangfa',
		chess_mk1 = 'mk_ruyibangfa',
		chess_mk11 = 'mk_ruyibangfa',

		chess_kael = "invoke",
		chess_kael1 = "invoke",
		chess_kael11 = "invoke",

		chess_lc = "lc_qianggong",
		chess_lc1 = "lc_qianggong",
		chess_lc11 = "lc_qianggong",

		chess_bh = 'bh_shuriken',
		chess_bh1 = 'bh_shuriken',
		chess_bh11 = 'bh_shuriken',

		chess_chen = 'chen_fuhuo',
		chess_chen1 = 'chen_fuhuo',
		chess_chen11 = 'chen_fuhuo',

		chess_thd = "jakiro_macropyre",
		chess_thd1 = "jakiro_macropyre",
		chess_thd11 = "jakiro_macropyre",

		chess_dw = "dark_willow_cursed_crown",
		chess_dw1 = "dark_willow_cursed_crown",
		chess_dw11 = "dark_willow_cursed_crown",

		chess_brew = "brewmaster_cinder_brew",
		chess_brew1 = "brewmaster_cinder_brew",
		chess_brew11 = "brewmaster_cinder_brew",
		chess_brew_ssr = "brew_ssr_3_pandas",

		chess_ember = 'sleight_of_fist_datadriven',
		chess_ember1 = 'sleight_of_fist_datadriven',
		chess_ember11 = 'sleight_of_fist_datadriven',

		chess_storm = 'storm_spirit_ball_lightning_datadriven',
		chess_storm1 = 'storm_spirit_ball_lightning_datadriven',
		chess_storm11 = 'storm_spirit_ball_lightning_datadriven',

		chess_earth = 'earth_rock_roll',
		chess_earth1 = 'earth_rock_roll',
		chess_earth11 = 'earth_rock_roll',

		chess_es = 'gouhe',
		chess_es1 = 'gouhe',
		chess_es11 = 'gouhe',

		chess_sb = 'sb_julizhongji',
		chess_sb1 = 'sb_julizhongji',
		chess_sb11 = 'sb_julizhongji',

		chess_meepo = 'poof',
		chess_meepo1 = 'poof',
		chess_meepo11 = 'poof',

		chess_et = 'et_earth_splitter',
		chess_et1 = 'et_earth_splitter',
		chess_et11 = 'et_earth_splitter',

		chess_pangolier = 'pangolier_swashbuckle_datadriven',
		chess_pangolier1 = 'pangolier_swashbuckle_datadriven',
		chess_pangolier11 = 'pangolier_swashbuckle_datadriven',
	}
	GameRules:GetGameModeEntity().summon_ability_list = {
		visage_dragon_1 = 'visage_grave_chill',
		visage_dragon_2 = 'visage_grave_chill',
		visage_dragon_3 = 'visage_grave_chill',
	}
	--释放技能：0=被动技能，1=随机敌人目标，2=无目标，3=点目标，4=自己目标，5=近身单位目标，6=先知周边树人，7=随机友军目标，8=随机周围空地目标（炸弹人），9=需要治疗的，10=等级最高的敌人（末日），11=沙王穿刺, 13= 自己脚下点目标，14=pom的特殊目标，15=小鱼人跳，16=需要护盾的队友，17=按伤害量计算最合适的目标，19=新蝙蝠，20=屠夫（最远的敌人单位目标），21=死灵龙佣兽，22=新大鱼点灯目标，23=全能治疗目标，24=蜘蛛织网点目标，25=天火点目标(选取方式同10)，26=最高费用目标（陈复活对象），27=双头龙两个技能切换，28=小精灵连等级最高的大哥，29=圆形AOE选目标点，30=蓝胖多重施法选择最合适的队友，31=沟壑位置，32=血量最低的敌人，33=随机能攻击到敌人的点目标（滚滚）
	--能看到这行字的代码哥哥，请勿将测试服拆包内容曝光和公开讨论，谢谢
	GameRules:GetGameModeEntity().ability_behavior_list = {
			pangolier_swashbuckle_datadriven = 33,
			shadow_shaman_shackles = 1,
			bh_shuriken = 32,
			fv_zhao = 13,
			sb_julizhongji = 0,
			gouhe = 31,
			et_earth_splitter = 31,
			earth_rock_roll = 2,
			storm_spirit_ball_lightning_datadriven = 11,
			ember_spirit_sleight_of_fist = 3,
			brewmaster_cinder_brew = 3,
			brew_ssr_3_pandas = 2,
			wisp_tether = 28,
			dark_willow_cursed_crown = 1,
			jakiro_macropyre = 27,
			jakiro_ice_path = 27,
			bh_zhuizongshu = 1,
			lc_qianggong = 0,
			invoke = 2,
			forge_spirit = 2,
			invoker_ice_wall = 2,
			invoker_sun_strike = 25,
			invoker_chaos_meteor = 3,
			alacrity = 7,
			invoker_emp = 3,
			invoker_cold_snap = 22,
			invoker_deafening_blast = 3,
			invoker_tornado = 3,
			br_web = 24,
			kunkka_torrent_storm = 2,
			ss_ssr_wards = 1,
			monkey_king_wukongs_command = 13,
			queenofpain_sonic_wave_datadriven = 3,
			snapfire_lil_shredder = 2,
			lich_chain_frost = 1,
			gege_sonicwave = 1,
			burning_spear_datadriven = 0,
			bloodseeker_blood_bath = 13,
			nyx_assassin_spiked_carapace_datadriven = 2,
			oracle_mingyunsheling = 1,
			nyx_assassin_spiked_carapace = 2,
			lion_mana_drain_datadriven = 18,
			slark_nengliangzhuanyi = 0,
			rubick_qiequ = 0,
			gs_moji = 3,
			axe_berserkers_call = 2,
			cm_mana_aura = 0,
			enchantress_natures_attendants = 2,
			om_multi_cast = 30,
			tusk_walrus_punch = 5,
			beastmaster_wild_axes = 3,
			juggernaut_blade_fury = 2,
			lyc_wolf = 2,
			shredder_whirling_death = 2,
			a108 = 2,
			dr_shooter_aura = 0,
			keeper_of_the_light_illuminate = 3,
			omniknight_purification = 23,
			razor_plasma_field = 2,
			windrunner_powershot = 3,
			doom_bringer_doom = 10,
			kunkka_ship = 3,
			lina_laguna_blade = 17,
			troll_warlord_whirling_axes_melee = 2,
			troll_warlord_whirling_axes_ranged = 1,
			troll_warlord_fervor = 0,
			venomancer_poison_nova = 2,
			veno_ward = 8,
			gyrocopter_call_down = 29,
			lich_bingjia = 16,
			queenofpain_scream_of_pain = 2,
			tidehunter_ravage = 2,
			antimage_mana_break = 0,
			bounty_hunter_shuriken_toss = 1,
			witch_doctor_paralyzing_cask = 1,
			rattletrap_battery_assault = 2,
			shadow_shaman_voodoo = 1,
			phantom_assassin_coup_de_grace = 0,
			puck_illusory_orb = 3,
			slardar_amplify_damage = 22,
			chaos_knight_chaos_bolt = 1,
			abaddon_aphotic_shield = 16,
			bump = 11,
			slark_shadow_dance = 2,
			sniper_assassinate = 17,
			necrolyte_death_pulse = 2,
			templar_assassin_refraction = 2,
			midnight_pulse_datadriven = 29,
			--
			batrider_sticky_napalm = 3,
			luna_moon_glaive = 0,
			tp_seed = 10,
			shadow_fiend_requiem_of_souls_lua = 2,
			dragon_knight_elder_dragon_form = 2,
			viper_viper_strike = 10,
			medusa_stone_gaze = 2,
			disruptor_static_storm = 29,
			ability_disruptor_static_storm = 29,
			alchemist_acid_spray = 3,
			chess_tech_bomb = 8,
			sven_great_cleave = 0,
			fur_tree = 6,
			ld_bear = 8,
			bm_beast = 8,
			--
			nec_ssr_scythe = 1,
			morphling_waveform = 11,
			sandking_burrowstrike = 11,
			tb_mohua = 2,
			tiny_touzhi = 12,
			ck_illusion = 2,
			--
			riki_smoke_screen = 13,
			death_prophet_exorcism = 2,
			pom_arrow_far = 20,
			slark_jump = 15,
			alchemist_chemical_rage = 2,
			--
			zeus_thunder = 2,
			mars_bulwark = 0,
			dazzle_bozang = 9,
			wisp_wildcard = 0,
			sven_gods_strength = 2,
			winter_wyvern_cold_embrace = 9,
			batrider_firefly = 19,
			baby_dragon = 2,
			pudge_meat_hook_lua = 20,
			visage_grave_chill = 21,
			slardar_slithereen_crush = 2,
			chen_fuhuo = 26,
			mk_ruyibangfa = 0,
			poof = 1,
			mars_bulwark_attack = 0,
		}
	
	--组合技技能ability
	--组合技条件condition：0=只有唯一1个同职业/种族的友军，1~3=需要1~3名同职业/种族的友军
	--组合技类型type：0=自身有效果，1=所有同职业/种族的友军的有效果，2=所有友军有效果，3=所有敌军有效果，4=随机一个友军有效果，5=随机一个敌军有效果，
	--6信使有效果，7=所有远程友军有效果，9=巫师效果
	GameRules:GetGameModeEntity().combo_ability_type = {
		--职业技能
		is_warrior = { ability = 'is_warrior_buff', condition = 3, type = 1 },
		is_warrior1 = { ability = 'is_warrior_buff_plus', condition = 6, type = 1 },
		is_warrior11 = { ability = 'is_warrior_buff_plus_plus', condition = 9, type = 2 },
		is_mage = { ability = 'is_mage_buff', condition = 3, type = 3 },
		is_mage1 = { ability = 'is_mage_buff_plus', condition = 6, type = 3 },
		is_mage11 = { ability = 'is_mage_buff_plus_plus', condition = 9, type = 3 },
		is_warlock = { ability = 'is_warlock_buff', condition = 2, type = 2 },
		is_warlock1 = { ability = 'is_warlock_buff_plus', condition = 4, type = 2 },
		is_warlock11 = { ability = 'is_warlock_buff_plus_plus', condition = 6, type = 2 },
		is_mech = { ability = 'is_mech_buff', condition = 3, type = 1 },
		is_mech1 = { ability = 'is_mech_buff_plus', condition = 6, type = 1 },
		is_assassin = { ability = 'is_assassin_buff', condition = 3, type = 1 },
		is_assassin1 = { ability = 'is_assassin_buff_plus', condition = 6, type = 2 },
		is_assassin11 = { ability = 'is_assassin_buff_plus_plus', condition = 9, type = 2 },
		is_hunter = { ability = 'is_hunter_buff', condition = 3, type = 1 },
		is_hunter1 = { ability = 'is_hunter_buff_plus', condition = 6, type = 1 },
		is_hunter11 = { ability = 'is_hunter_buff_plus_plus', condition = 9, type = 2 },
		is_knight = { ability = 'is_knight_buff', condition = 2, type = 1 },
		is_knight1 = { ability = 'is_knight_buff_plus', condition = 4, type = 1 },
		is_knight11 = { ability = 'is_knight_buff_plus_plus', condition = 6, type = 2 },
		is_shaman = {condition = 2 , type = 5},
		is_shaman1 = {condition = 4 , type = 1},
		is_demonhunter = {condition = 1 , type = 1},
		is_demonhunter1 = {condition = 2 , type = 1},
		is_druid = {condition = 2, type = 1},
		is_priest = {condition = 2, type = 2},
		is_wizard = { ability = 'is_wizard_buff', condition = 2, type = 1},
		is_wizard1 = { ability = 'is_wizard_buff_plus', condition = 3, type = 1},
		is_monk = { ability = 'is_monk_buff', condition = 2, type = 1},

		--种族技能
		is_troll = { ability = 'is_troll_buff', condition = 2, type = 2, is_race = true },
		is_troll1 = { ability = 'is_troll_buff_plus', condition = 4, type = 2, is_race = true },
		is_troll11 = { ability = 'troll_rexuezhanhun', condition = 6, type = 2, is_race = true },
		is_beast = { ability = 'is_beast_buff', condition = 2, type = 2, is_race = true },
		is_beast1 = { ability = 'is_beast_buff_plus', condition = 4, type = 2, is_race = true },
		is_beast11 = { ability = 'ursa_fury_swipes', condition = 6, type = 2, is_race = true },
		is_elf = { ability = 'is_elf_buff', condition = 3, type = 1, is_race = true },
		is_elf1 = { ability = 'is_elf_buff_plus', condition = 6, type = 2, is_race = true },
		is_elf11 = { ability = 'is_elf_buff_plus_plus', condition = 9, type = 2, is_race = true },
		is_human = { ability = 'is_human_buff', condition = 3, type = 1, is_race = true },
		is_human1 = { ability = 'is_human_buff_plus', condition = 6, type = 1, is_race = true },
		is_undead = { ability = 'is_undead_buff', condition = 2, type = 3, is_race = true },
		is_undead1 = { ability = 'is_undead_buff_plus', condition = 4, type = 3, is_race = true },
		is_undead11 = { ability = 'is_undead_buff_plus_plus', condition = 6, type = 3, is_race = true },
		is_orc = { ability = 'is_orc_buff', condition = 2, type = 2, is_race = true },
		is_orc1 = { ability = 'is_orc_buff_plus', condition = 4, type = 2, is_race = true },
		is_orc11 = { ability = 'is_orc_buff_plus_plus', condition = 6, type = 2, is_race = true },
		is_naga = { ability = 'is_naga_buff', condition = 2, type = 2, is_race = true },
		is_naga1 = { ability = 'is_naga_buff_plus', condition = 4, type = 2, is_race = true },
		is_goblin = { ability = 'is_goblin_buff', condition = 3, type = 4, is_race = true },
		is_goblin1 = { ability = 'is_goblin_buff', condition = 6, type = 2, is_race = true },
		is_element = { ability = 'is_element_buff', condition = 2, type = 1, is_race = true },
		is_element1 = { ability = 'is_element_buff_plus', condition = 4, type = 2, is_race = true },
		is_demon = { ability = 'is_demon_buff', condition = 0, type = 1, is_race = true },
		-- is_dwarf = { ability = 'is_dwarf_buff', condition = 1, type = 1, is_race = true },
		is_dwarf = { ability = 'is_dwarf_buff_plus', condition = 2, type = 7, is_race = true },
		is_ogre = { ability = 'is_ogre_buff', condition = 2, type = 1, is_race = true },
		is_dragon = {condition = 3 , type = 1, is_race = true },
		is_dragon1 = {condition = 5 , type = 1, is_race = true },
		is_nraqi = { ability = 'is_nraqi_buff',condition = 1 , type = 2, is_race = true },
		is_aqir = { ability = 'is_aqir_buff', condition = 2 , type = 2, is_race = true },
		is_aqir1 = { ability = 'is_aqir_buff', condition = 4 , type = 2, is_race = true },
		is_god = { condition = 2, type = 2, is_race = true },
		is_god1 = { condition = 4, type = 2, is_race = true },
		is_pandaman = { condition = 1, type = 1, is_race = true },
		is_pandaman1 = { condition = 2, type = 1, is_race = true },
		is_pandaman11 = { condition = 3, type = 1, is_race = true },
		is_tauren = {condition = 2, type = 0, is_race = true },
		is_tauren1 = {condition = 4, type = 0, is_race = true },
		is_kobold = {condition = 1, type = 2, is_race = true},
	}

	GameRules:GetGameModeEntity().class_type = {
		[201] = 'is_warrior',
		[202] = 'is_mage',
		[203] = 'is_warlock',
		[204] = 'is_mech',
		[205] = 'is_assassin',
		[206] = 'is_hunter',
		[207] = 'is_knight',
		[208] = 'is_shaman',
		[209] = 'is_demonhunter',
		[210] = 'is_priest',
		[211] = 'is_wizard',
		[212] = 'is_monk',

		[101] = 'is_troll',
		[102] = 'is_beast',
		[103] = 'is_elf',
		[104] = 'is_human',
		[105] = 'is_undead',
		[106] = 'is_orc',
		[107] = 'is_naga',
		[108] = 'is_goblin',
		[109] = 'is_element',
		[110] = 'is_demon',
		[111] = 'is_dwarf',
		[112] = 'is_ogre',
		[113] = 'is_dragon',
		[114] = 'is_druid',
		[115] = 'is_satyr',
		[116] = 'is_god',
		[117] = 'is_aqir',
		[118] = 'is_pandaman',
		[119] = 'is_tauren',
		[120] = 'is_kobold',
		[121] = 'is_nraqi',
	}

	GameRules:GetGameModeEntity().sm_hero_list = {
		h001 = "models/props_gameplay/donkey.vmdl",
		h002 = "models/props_gameplay/donkey_dire.vmdl",
		--普通信使 beginner
		h101 = "models/courier/skippy_parrot/skippy_parrot.vmdl",
		h102 = "models/courier/smeevil_mammoth/smeevil_mammoth.vmdl",
		h103 = "models/items/courier/arneyb_rabbit/arneyb_rabbit.vmdl",
		h104 = "models/items/courier/axolotl/axolotl.vmdl",
		h105 = "models/items/courier/coco_the_courageous/coco_the_courageous.vmdl",
		h106 = "models/items/courier/coral_furryfish/coral_furryfish.vmdl",
		h107 = "models/items/courier/corsair_ship/corsair_ship.vmdl",
		h108 = "models/items/courier/duskie/duskie.vmdl",
		h109 = "models/items/courier/itsy/itsy.vmdl",
		h110 = "models/items/courier/jumo/jumo.vmdl",
		h111 = "models/items/courier/mighty_chicken/mighty_chicken.vmdl",
		h112 = "models/items/courier/nexon_turtle_05_green/nexon_turtle_05_green.vmdl",
		h113 = "models/items/courier/pumpkin_courier/pumpkin_courier.vmdl",
		h114 = "models/items/courier/pw_ostrich/pw_ostrich.vmdl",
		h115 = "models/items/courier/scuttling_scotty_penguin/scuttling_scotty_penguin.vmdl",
		h116 = "models/items/courier/shagbark/shagbark.vmdl",
		h117 = "models/items/courier/snaggletooth_red_panda/snaggletooth_red_panda.vmdl",
		h118 = "models/items/courier/snail/courier_snail.vmdl",
		h119 = "models/items/courier/teron/teron.vmdl",
		h120 = "models/items/courier/xianhe_stork/xianhe_stork.vmdl",
		h121 = "models/items/courier/starladder_grillhound/starladder_grillhound.vmdl",
		h122 = "models/items/courier/pw_zombie/pw_zombie.vmdl",
		h123 = "models/items/courier/raiq/raiq.vmdl",
		h124 = "models/courier/frog/frog.vmdl",
		h125 = "models/courier/godhorse/godhorse.vmdl",
		h126 = "models/courier/imp/imp.vmdl",
		h127 = "models/courier/mighty_boar/mighty_boar.vmdl",
		h128 = "models/items/courier/onibi_lvl_03/onibi_lvl_03.vmdl",
		h129 = "models/items/courier/echo_wisp/echo_wisp.vmdl",  --蠕行水母
		h130 = "models/courier/sw_donkey/sw_donkey.vmdl", --驴法师new
		h131 = "models/items/courier/gnomepig/gnomepig.vmdl", --丰臀公主new
		h132 = "models/items/furion/treant/ravenous_woodfang/ravenous_woodfang.vmdl",--焚牙树精new
		h133 = "models/courier/mechjaw/mechjaw.vmdl",--机械咬人箱new
		h134 = "models/items/courier/mole_messenger/mole_messenger.vmdl",--1级矿车老鼠
		h135 = "models/items/courier/jumo_dire/jumo_dire.vmdl",
		h136 = "models/items/courier/courier_ti9/courier_ti9.vmdl",
		h137 = "models/items/courier/courier_ti9/courier_ti9_lvl2/courier_ti9_lvl2.vmdl",
		h138 = "models/props_gameplay/donkey.vmdl",
		h139 = "models/courier/gold_mega_greevil/gold_mega_greevil.vmdl",  --贪魔1
		h140 = "models/items/courier/catakeet/catakeet.vmdl",
		h141 = "models/items/courier/nexon_turtle_01_grey/nexon_turtle_01_grey.vmdl",
		h142 = "models/balloon/yun.vmdl",
		h143 = "models/balloon/pang.vmdl",
		h144 = "models/balloon/liang.vmdl",
		h145 = "models/balloon/pang.vmdl",
		h146 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant.vmdl",
		h147 = "models/items/courier/courier_ti10_dire/courier_ti10_dire.vmdl",
		h148 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h149 = "models/toon_reaper/toon_reaper.vmdl",
		h150 = "models/items/courier/autumn_wards_courier/autumn_wards_courier.vmdl",
		
		h199 = "models/gezi/ge.vmdl",

		--小英雄信使 ameteur
		h201 = "models/courier/doom_demihero_courier/doom_demihero_courier.vmdl",
		h202 = "models/courier/huntling/huntling.vmdl",
		h203 = "models/courier/minipudge/minipudge.vmdl",
		h204 = "models/courier/seekling/seekling.vmdl",
		h205 = "models/items/courier/baekho/baekho.vmdl",
		h206 = "models/items/courier/basim/basim.vmdl",
		h207 = "models/items/courier/devourling/devourling.vmdl",
		h208 = "models/items/courier/faceless_rex/faceless_rex.vmdl",
		h209 = "models/items/courier/tinkbot/tinkbot.vmdl",
		h210 = "models/items/courier/lilnova/lilnova.vmdl",
		h211 = "models/items/courier/amphibian_kid/amphibian_kid.vmdl",
		h212 = "models/courier/venoling/venoling.vmdl",
		h213 = "models/courier/juggernaut_dog/juggernaut_dog.vmdl",
		h214 = "models/courier/otter_dragon/otter_dragon.vmdl",
		h215 = "models/items/courier/boooofus_courier/boooofus_courier.vmdl",
		h216 = "models/courier/baby_winter_wyvern/baby_winter_wyvern.vmdl",
		h217 = "models/courier/yak/yak.vmdl",
		h218 = "models/items/furion/treant/eternalseasons_treant/eternalseasons_treant.vmdl",
		h219 = "models/items/courier/blue_lightning_horse/blue_lightning_horse.vmdl",
		h220 = "models/items/courier/waldi_the_faithful/waldi_the_faithful.vmdl",
		h221 = "models/items/courier/bajie_pig/bajie_pig.vmdl",
		h222 = "models/items/courier/courier_faun/courier_faun.vmdl",
		h223 = "models/items/courier/livery_llama_courier/livery_llama_courier.vmdl",
		h224 = "models/items/courier/onibi_lvl_05/onibi_lvl_05.vmdl",
		h225 = "models/items/courier/little_fraid_the_courier_of_simons_retribution/little_fraid_the_courier_of_simons_retribution.vmdl", --胆小南瓜人
		h226 = "models/items/courier/hermit_crab/hermit_crab.vmdl", --螃蟹1
		h227 = "models/items/courier/hermit_crab/hermit_crab_boot.vmdl", --螃蟹2
		h228 = "models/items/courier/hermit_crab/hermit_crab_shield.vmdl", --螃蟹3
		h229 = "models/courier/donkey_unicorn/donkey_unicorn.vmdl", --竭智法师new
		h230 = "models/items/courier/white_the_crystal_courier/white_the_crystal_courier.vmdl", --蓝心白隼new
		h231 = "models/items/furion/treant/furion_treant_nelum_red/furion_treant_nelum_red.vmdl",--莲花人new
		h232 = "models/courier/beetlejaws/mesh/beetlejaws.vmdl",--甲虫咬人箱new
		h233 = "models/courier/smeevil_bird/smeevil_bird.vmdl",
		h234 = "models/items/courier/mole_messenger/mole_messenger_lvl4.vmdl",--蜡烛头矿车老鼠
		h235 = "models/items/courier/chocobo/chocobo.vmdl", --迅捷陆行鸟
		h236 = "models/items/courier/flightless_dod/flightless_dod.vmdl", --嘟嘟鸟
		h237 = "models/items/courier/frostivus2018_courier_serac_the_seal/frostivus2018_courier_serac_the_seal.vmdl",
		h238 = "models/items/courier/pangolier_squire/pangolier_squire.vmdl",
		h239 = "models/hujing_wangyu/hujing.vmdl",
		h240 = "models/items/courier/courier_ti9/courier_ti9_lvl3/courier_ti9_lvl3.vmdl",
		h241 = "models/items/courier/axolotl/axolotl.vmdl",
		h242 = "models/items/courier/snaggletooth_red_panda/snaggletooth_red_panda.vmdl",
		h243 = "models/items/courier/xianhe_stork/xianhe_stork.vmdl",
		h244 = "models/hy/huya.vmdl",
		h245 = "models/daxiang/daxiang.vmdl",
		h246 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h247 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h248 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h249 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h250 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h251 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h252 = "models/items/courier/catakeet/catakeet.vmdl",
		h253 = "models/items/courier/nexon_turtle_06_green/nexon_turtle_06_green.vmdl",
		h254 = "models/items/courier/supernova_rave_courier/supernova_rave_courier.vmdl",
		h255 = "models/balloon/zhai.vmdl",
		h256 = "models/balloon/dai.vmdl",
		h257 = "models/balloon/meng.vmdl",
		h258 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl2/courier_ti10_radiant_lvl2.vmdl",
		h259 = "models/items/courier/courier_ti10_dire/courier_ti10_dire_lvl2/courier_ti10_dire_lvl2.vmdl",
		h260 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h261 = "models/items/courier/roddy_the_jerboa_courier/roddy_the_jerboa_courier.vmdl",
		h262 = "models/items/courier/longear_courier_courier/longear_courier_courier.vmdl",
		h263 = "models/toon_reaper/toon_reaper.vmdl",
		h264 = "models/items/courier/dplus_zao_jun_the_stove_god/dplus_zao_jun_the_stove_god.vmdl",
		h265 = "models/items/courier/mango_the_courier/mango_the_courier.vmdl",
		h266 = "models/items/courier/spooky_tear_of_the_swamp/spooky_tear_of_the_swamp.vmdl",
		h267 = "models/items/courier/hermid/hermid.vmdl",

		--珍藏信使 pro
		h301 = "models/items/courier/bookwyrm/bookwyrm.vmdl",
		h302 = "models/items/courier/captain_bamboo/captain_bamboo.vmdl",
		h303 = "models/items/courier/kanyu_shark/kanyu_shark.vmdl",
		h304 = "models/items/courier/tory_the_sky_guardian/tory_the_sky_guardian.vmdl",
		h305 = "models/items/courier/shroomy/shroomy.vmdl",
		h306 = "models/items/courier/courier_janjou/courier_janjou.vmdl",
		h307 = "models/items/courier/green_jade_dragon/green_jade_dragon.vmdl",
		h308 = "models/courier/drodo/drodo.vmdl",
		h309 = "models/courier/mech_donkey/mech_donkey.vmdl",
		h310 = "models/courier/donkey_crummy_wizard_2014/donkey_crummy_wizard_2014.vmdl",
		h311 = "models/courier/octopus/octopus.vmdl",
		h312 = "models/items/courier/scribbinsthescarab/scribbinsthescarab.vmdl",
		h313 = "models/courier/defense3_sheep/defense3_sheep.vmdl",
		h314 = "models/items/courier/snapjaw/snapjaw.vmdl",
		h315 = "models/items/courier/g1_courier/g1_courier.vmdl",
		h316 = "models/courier/donkey_trio/mesh/donkey_trio.vmdl",
		h317 = "models/items/courier/boris_baumhauer/boris_baumhauer.vmdl",
		h318 = "models/courier/baby_rosh/babyroshan.vmdl",
		h319 = "models/items/courier/bearzky/bearzky.vmdl",
		h320 = "models/items/courier/defense4_radiant/defense4_radiant.vmdl",
		h321 = "models/items/courier/defense4_dire/defense4_dire.vmdl",
		h322 = "models/items/courier/onibi_lvl_13/onibi_lvl_13.vmdl",
		h323 = "models/items/juggernaut/ward/fortunes_tout/fortunes_tout.vmdl", --招财猫
		h324 = "models/items/courier/hermit_crab/hermit_crab_necro.vmdl", --螃蟹4
		h325 = "models/items/courier/hermit_crab/hermit_crab_travelboot.vmdl", --螃蟹5
		h326 = "models/items/courier/hermit_crab/hermit_crab_lotus.vmdl", --螃蟹6
		h327 = "models/courier/donkey_ti7/donkey_ti7.vmdl",
		h328 = "models/items/courier/shibe_dog_cat/shibe_dog_cat.vmdl", --天猫地狗new
		h329 = "models/items/furion/treant/hallowed_horde/hallowed_horde.vmdl",--万圣树群new
		h330 = "models/courier/flopjaw/flopjaw.vmdl",--大嘴咬人箱new
		h331 = "models/courier/lockjaw/lockjaw.vmdl",--咬人箱洛克new
		h332 = "models/items/courier/butch_pudge_dog/butch_pudge_dog.vmdl",--布狗new
		h333 = "models/courier/turtle_rider/turtle_rider.vmdl",
		h334 = "models/courier/smeevil_crab/smeevil_crab.vmdl",
		h335 = "models/items/courier/mole_messenger/mole_messenger_lvl6.vmdl",--绿钻头矿车老鼠
		h336 = "models/items/courier/amaterasu/amaterasu.vmdl", --天照大神
		h337 = "models/qie/qie.vmdl",
		h338 = "models/courier/f2p_courier/f2p_courier.vmdl",
		h339 = "models/items/courier/azuremircourierfinal/azuremircourierfinal.vmdl",
		h340 = "models/items/courier/courier_ti9/courier_ti9_lvl6/courier_ti9_lvl6.vmdl",
		h341 = "models/bilibilitv/model/tv.vmdl",
		h342 = "models/courier/baby_rosh/babyroshan.vmdl",
		h343 = "models/courier/baby_rosh/babyroshan.vmdl",
		h344 = "models/courier/baby_rosh/babyroshan.vmdl",
		h345 = "models/courier/baby_winter_wyvern/baby_winter_wyvern.vmdl",
		h346 = "models/courier/beetlejaws/mesh/beetlejaws.vmdl",
		h347 = "models/courier/doom_demihero_courier/doom_demihero_courier.vmdl",
		h348 = "models/courier/huntling/huntling.vmdl",
		h349 = "models/courier/minipudge/minipudge.vmdl",
		h350 = "models/courier/seekling/seekling.vmdl",
		h351 = "models/courier/venoling/venoling.vmdl",
		h352 = "models/items/courier/axolotl/axolotl.vmdl",
		h353 = "models/items/courier/devourling/devourling.vmdl",
		h354 = "models/courier/baby_rosh/babyroshan_elemental.vmdl",
		h355 = "models/courier/baby_rosh/babyroshan_elemental.vmdl",
		h356 = "models/hujing_wangyu/hujing.vmdl",
		h357 = "models/rongyanquan/rongyanquan.vmdl",
		h358 = "models/courier/greevil/greevil.vmdl",  --贪魔3
		h359 = "models/courier/greevil/greevil.vmdl",  --贪魔2
		h360 = "models/items/courier/catakeet/catakeet.vmdl",
		h361 = "models/items/courier/nexon_turtle_11_blue/nexon_turtle_11_blue.vmdl",
		h362 = "models/balloon/hu.vmdl",
		h363 = "models/balloon/qiang.vmdl",
		h364 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl4/courier_ti10_radiant_lvl4.vmdl",
		h365 = "models/items/courier/courier_ti10_dire/courier_ti10_dire_lvl4/courier_ti10_dire_lvl4.vmdl",
		h366 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h367 = "models/items/courier/clockwerks_orange/clockwerks_orange.vmdl",
		h368 = "models/items/courier/enno_the_underlord/enno_the_underlord.vmdl",
		h369 = "models/items/courier/happy_koala/happy_koala.vmdl",
		h370 = "models/items/courier/courier_fall20/courier_fall20.vmdl",
		h371 = "models/toon_reaper/toon_reaper.vmdl",
		h372 = "models/items/courier/loco_the_crocodile_courier/loco_the_crocodile_courier.vmdl",

		h398 = "models/guge/guge.vmdl",
		h397 = "models/guge/guge.vmdl",
		h399 = "models/courier/baby_rosh/babyroshan_winter18.vmdl",--姜饼肉山

		--战队信使 master
		h401 = "models/courier/navi_courier/navi_courier.vmdl",
		h402 = "models/items/courier/courier_mvp_redkita/courier_mvp_redkita.vmdl",
		h403 = "models/items/courier/ig_dragon/ig_dragon.vmdl",
		h404 = "models/items/courier/lgd_golden_skipper/lgd_golden_skipper.vmdl",
		h405 = "models/items/courier/vigilante_fox_red/vigilante_fox_red.vmdl",
		h406 = "models/items/courier/virtus_werebear_t3/virtus_werebear_t3.vmdl",
		h407 = "models/items/courier/throe/throe.vmdl",
		h408 = "models/items/courier/vaal_the_animated_constructradiant/vaal_the_animated_constructradiant.vmdl",
		h409 = "models/items/courier/vaal_the_animated_constructdire/vaal_the_animated_constructdire.vmdl",
		h410 = "models/items/courier/carty/carty.vmdl",
		h411 = "models/items/courier/carty_dire/carty_dire.vmdl",
		h412 = "models/items/courier/dc_angel/dc_angel.vmdl",
		h413 = "models/items/courier/dc_demon/dc_demon.vmdl",
		h414 = "models/items/courier/vigilante_fox_green/vigilante_fox_green.vmdl",
		h415 = "models/items/courier/bts_chirpy/bts_chirpy.vmdl",
		h416 = "models/items/courier/krobeling/krobeling.vmdl",
		h417 = "models/items/courier/jin_yin_black_fox/jin_yin_black_fox.vmdl",
		h418 = "models/items/courier/jin_yin_white_fox/jin_yin_white_fox.vmdl",
		h419 = "models/items/courier/fei_lian_blue/fei_lian_blue.vmdl",
		h420 = "models/items/courier/gama_brothers/gama_brothers.vmdl",
		h421 = "models/items/courier/onibi_lvl_21/onibi_lvl_21.vmdl",
		h422 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl", --小飞侠
		h423 = "models/items/courier/hermit_crab/hermit_crab_octarine.vmdl", --螃蟹7
		h424 = "models/items/courier/hermit_crab/hermit_crab_skady.vmdl", --螃蟹8
		h425 = "models/items/courier/hermit_crab/hermit_crab_aegis.vmdl", --螃蟹9
		h426 = "models/items/furion/treant_flower_1.vmdl",--绽放树精new
		h427 = "models/courier/smeevil_magic_carpet/smeevil_magic_carpet.vmdl",
		h428 = "models/items/courier/mole_messenger/mole_messenger_lvl7.vmdl",--绿钻头金矿车老鼠
		h499 = "models/items/courier/krobeling_gold/krobeling_gold.vmdl",--金dp
		h429 = "models/items/courier/nilbog/nilbog.vmdl",--贪小疯魔
		h430 = "models/courier/frull/frull_courier.vmdl", --灵犀弗拉尔
		h431 = "models/items/courier/sltv_10_courier/sltv_10_courier.vmdl", --黄油小生
		h432 = "models/items/courier/nian_courier/nian_courier.vmdl", --年兽宝宝
		h433 = "models/courier/baby_rosh/babyroshan_ti9.vmdl",
		h434 = "models/items/courier/courier_ti9/courier_ti9_lvl7/courier_ti9_lvl7.vmdl",
		h435 = "models/shudaixiong/model/shudaixiong/shudaixiong.vmdl",
		h436 = "models/courier/baby_rosh/babyroshan.vmdl",
		h437 = "models/courier/baby_rosh/babyroshan.vmdl",
		h438 = "models/courier/baby_winter_wyvern/baby_winter_wyvern.vmdl",
		h439 = "models/courier/flopjaw/flopjaw.vmdl",
		h440 = "models/courier/juggernaut_dog/juggernaut_dog.vmdl",
		h441 = "models/courier/smeevil_crab/smeevil_crab.vmdl",
		h442 = "models/items/courier/axolotl/axolotl.vmdl",
		h443 = "models/items/courier/fei_lian_blue/fei_lian_blue.vmdl",
		h444 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl",
		h445 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl",
		h446 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl",
		h447 = "models/jieke/jieke.vmdl",
		h448 = "models/courier/greevil/gold_greevil.vmdl",  --贪魔4
		h449 = "models/douyu/douyu.vmdl", --斗鱼信使
		h450 = "models/items/courier/catakeet/catakeet.vmdl",
		h451 = "models/items/courier/nexon_turtle_15_red/nexon_turtle_15_red.vmdl",
		h452 = "models/items/courier/nexon_turtle_17_gold/nexon_turtle_17_gold.vmdl",
		h453 = "models/balloon/ou.vmdl",
		h454 = "models/balloon/shen.vmdl",
		h455 = "models/balloon/shuai.vmdl",
		h456 = "models/items/courier/onibi_lvl_20/onibi_lvl_20.vmdl",
		h457 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl5/courier_ti10_radiant_lvl5.vmdl",
		h458 = "models/items/courier/courier_ti10_dire/courier_ti10_dire_lvl5/courier_ti10_dire_lvl5.vmdl",
		h459 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl7/courier_ti10_radiant_lvl7.vmdl",
		h460 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h461 = "models/courier/baby_rosh/babyroshan_ti10.vmdl",
		h462 = "models/courier/baby_rosh/babyroshan_ti10_dire.vmdl",
		h463 = "models/items/courier/leafy_the_sea_dragon_courier_courier/leafy_the_sea_dragon_courier_courier.vmdl",
		h464 = "models/items/courier/ol_dirty_boot_courier_courier/ol_dirty_boot_courier_courier.vmdl",
		h465 = "models/items/juggernaut/ward/fortunes_tout/fortunes_tout.vmdl",
		h466 = "models/toon_reaper/toon_reaper.vmdl",
		h467 = "models/items/courier/frosty_the_courier/frosty_the_courier.vmdl",
	}

	GameRules:GetGameModeEntity().sm_hero_size = {
		h001 = 1,
		h002 = 1,
		--普通信使 beginner
		h101 = 1.1,
		h102 = 1.1,
		h103 = 1.1,
		h104 = 1,
		h105 = 1,
		h106 = 1,
		h107 = 1.2,
		h108 = 1,
		h109 = 1.1,
		h110 = 1.1,
		h111 = 1.1,
		h112 = 1.2,
		h113 = 1,
		h114 = 1.2,
		h115 = 1.2,
		h116 = 1,
		h117 = 1.3,
		h118 = 1.1,
		h119 = 1.3,
		h120 = 1.3,
		h121 = 1.1,
		h122 = 1.1,
		h123 = 1.2,
		h124 = 1,
		h125 = 1,
		h126 = 1,
		h127 = 1,
		h128 = 1.1,
		h129 = 1.2,  --蠕行水母
		h130 = 1, --驴法师new
		h131 = 1, --丰臀公主new
		h132 = 0.7,--焚牙树精new
		h133 = 1.1,--机械咬人箱new
		h134 = 1.1,--1级矿车老鼠
		h135 = 1.1,
		h136 = 1.1,
		h137 = 1.15,
		h138 = 1.15,
		h139 = 1.4,
		h140 = 1.45,
		h141 = 1.45,
		h142 = 1.3,
		h143 = 1.3,
		h144 = 1.3,
		h145 = 1.3,
		h146 = 0.95,
		h147 = 0.95,

		h199 = 1.5,
		--小英雄信使 ameteur
		h201 = 1.2,
		h202 = 1.2,
		h203 = 1.2,
		h204 = 1.2,
		h205 = 1.2,
		h206 = 1.2,
		h207 = 1.2,
		h208 = 1.3,
		h209 = 1.2,
		h210 = 1.25,

		h211 = 1.2,
		h212 = 1.1,
		h213 = 1,
		h214 = 1.25,
		h215 = 1.2,
		h216 = 1.25,
		h217 = 1.2,
		h218 = 1.1,
		h219 = 1.2,
		h220 = 1.25,
		h221 = 1.25,
		h222 = 1.3,
		h223 = 1.15,
		h224 = 1.25,
		h225 = 1.3, --胆小南瓜人
		h226 = 1.3, --螃蟹1
		h227 = 1.3, --螃蟹2
		h228 = 1.2, --螃蟹3

		h229 = 1.2, --竭智法师new
		h230 = 1.3, --蓝心白隼new
		h231 = 0.8,--莲花人new
		h232 = 1.2,--甲虫咬人箱new
		h233 = 1.2,
		h234 = 1.2,--蜡烛头矿车老鼠
		h235 = 1.2, --迅捷陆行鸟
		h236 = 1.2, --嘟嘟鸟
		h237 = 1.2,
		h238 = 0.8,
		h239 = 1.4,
		h240 = 1.25,
		h241 = 1.1,
		h242 = 1.4,
		h243 = 1.4,
		h244 = 2.5,
		h245 = 0.9,
		h246 = 1.2,
		h247 = 1.2,
		h248 = 1.2,
		h249 = 1.2,
		h250 = 1.2,
		h251 = 1.2,
		h252 = 1.5,
		h253 = 1.45,
		h254 = 1.15,
		h255 = 1.4,
		h256 = 1.4,
		h257 = 1.4,
		h258 = 1,
		h259 = 1,
		h261 = 1.2,
		h262 = 1.1,

		--珍藏信使 pro
		h301 = 1.3,
		h302 = 1.3,
		h303 = 1.3,
		h304 = 1.35,
		h305 = 1.3,
		h306 = 1.3,
		h307 = 1.3,
		h308 = 1.3,
		h309 = 1.2,

		h310 = 1.2,
		h311 = 1.25,
		h312 = 1.3,
		h313 = 1.3,
		h314 = 1.3,
		h315 = 1.25,
		h316 = 1.3,
		h317 = 1.4,
		h318 = 1.25,
		h319 = 1.3,
		h320 = 1.3,
		h321 = 1.3,
		h322 = 1.3,
		h323 = 1.1, --招财猫
		h324 = 1.3, --螃蟹4
		h325 = 1.25, --螃蟹5
		h326 = 1.25, --螃蟹6
		h327 = 1.25,

		h328 = 1.3, --天猫地狗new
		h329 = 0.9,--万圣树群new
		h330 = 1.3,--大嘴咬人箱new
		h331 = 1.25,--咬人箱洛克new
		h332 = 1.3,--布狗new
		h333 = 1.3,
		h334 = 1.3,
		h335 = 1.1,--绿钻头矿车老鼠
		h336 = 1.15, --天照大神
		h337 = 1.4,
		h338 = 1.3,
		h339 = 1.4,
		h340 = 1.3,
		h341 = 2.3,
		h342 = 1.25,
		h343 = 1.25,
		h344 = 1.25,
		h354 = 1.25,
		h355 = 1.25,
		h345 = 1.35,
		h346 = 1.3,
		h347 = 1.3,
		h348 = 1.3,
		h349 = 1.3,
		h350 = 1.3,
		h351 = 1.2,
		h352 = 1.2,
		h353 = 1.3,
		h356 = 1.45,
		h357 = 1.3,
		h358 = 1.25,
		h359 = 1.25,
		h360 = 1.55,
		h361 = 1.5,
		h362 = 1.5,
		h363 = 1.5,
		h364 = 1.05,
		h365 = 1.05,
		h369 = 1.3,
		h368 = 1.25,
		h367 = 1.5,
		h370 = 1,

		h399 = 1.17,--姜饼肉山

		--战队信使 master
		h401 = 1.4,
		h402 = 1.4,
		h403 = 1.4,
		h404 = 1.55,
		h405 = 1.4,
		h406 = 1.5,
		h407 = 1.3,

		h408 = 1.35,
		h409 = 1.35,
		h410 = 1.3,
		h411 = 1.3,
		h412 = 1.3,
		h413 = 1.3,
		h414 = 1.4,
		h415 = 1.35,
		h416 = 1.4,
		h417 = 1.4,
		h418 = 1.4,
		h419 = 1.4,
		h420 = 1.2,
		h421 = 1.35,
		h422 = 1.4, --小飞侠
		h423 = 1.3, --螃蟹7
		h424 = 1.3, --螃蟹8
		h425 = 1.35, --螃蟹9

		h426 = 1.1,--绽放树精new
		h427 = 1.55,
		h428 = 1.2,--绿钻头金矿车老鼠

		h499 = 1.55,--金dp
		h429 = 1.3,--贪小疯魔

		h430 = 1.3, --灵犀弗拉尔
		h431 = 1.2, --黄油小生
		h432 = 1.3, --年兽宝宝
		h433 = 1.3,
		h434 = 1.4,
		h435 = 1.0,
		h438 = 1.45,
		h439 = 1.35,
		h440 = 1.2,
		h441 = 1.4,
		h442 = 1.3,
		h444 = 1.4,
		h445 = 1.4,
		h446 = 1.4,
		h443 = 1.4,
		h436 = 1.35,
		h437 = 1.35,
		h447 = 1.15,
		h448 = 1.5,
		h449 = 1.1,
		h450 = 1.6,
		h451 = 1.55,
		h452 = 1.55,
		h453 = 1.6,
		h454 = 1.6,
		h455 = 1.6,
		h456 = 1.4,
		h457 = 1.1,
		h458 = 1.1,
		h459 = 1.15,

		h398 = 1.15,
		h397 = 1.15,

		h148 = 2.0,
		h260 = 2.2,
		h366 = 2.4,
		h460 = 2.6,
		h461 = 1.35,
		h462 = 1.35,
		h463 = 1.3,
		h464 = 1.15,
		h465 = 1.15, --招财猫

		h149 = 0.6,
		h263 = 0.6,
		h371 = 0.65,
		h466 = 0.65,

		h150 = 1.3,
		h264 = 1.6,
		h265 = 1.3,
		h266 = 1.3,
		h267 = 1.1,
		h372 = 1.25,
		h467 = 1.3,
	}

	GameRules:GetGameModeEntity().sm_hero_list_skin = {
		h138 = 1,
		h436 = 1,
		h437 = 2,
		h342 = 3,
		h343 = 4,
		h344 = 5,
		h354 = 1,
		h355 = 2,
		h345 = 1,
		h438 = 2,
		h346 = 1,
		h347 = 1,
		h348 = 1,
		h440 = 1,
		h349 = 1,
		h350 = 1,
		h441 = 1,
		h351 = 1,

		h241 = 1,
		h352 = 2,
		h442 = 3,
		h353 = 1,
		h242 = 1,
		h444 = 1,
		h445 = 2,
		h446 = 3,
		h243 = 1,
		h443 = 1,
		h439 = 1,
		h356 = 1,
		h397 = 1,
		h145 = 1,

		h148 = 3,
		h260 = 2,
		h366 = 1,
		h460 = 0,
		h465 = 1,

		h149 = 1,
		h263 = 2,
		h371 = 0,
		h466 = 3,
	}


	GameRules:GetGameModeEntity().courier_flyup_effect_list = {
		h208 = "effect/xukong/cour_rex_flying.vpcf",
		h432 = "effect/nianshou/courier_nian_ambient.vpcf",
		h499 = "effect/jin_dp/courier_krobeling_gold_ambient.vpcf",
		h399 = "effect/jiangbing/1.vpcf",
		h308 = "effect/drodo/1.vpcf",
		h199 = "effect/gewugu/3.vpcf",
		h239 = "effect/wangyu/1.vpcf",
		h303 = "effect/douyu/2.vpcf",
		h433 = "effect/roshan_ti9/1.vpcf",
		h341 = "effect/music/1.vpcf",
		h354 = "effect/lava_roshan/1.vpcf",
		h355 = "effect/frost_roshan/ambient.vpcf",
		h342 = "effect/darkmoon_roshan/1.vpcf",
		h343 = "effect/sand_roshan/baby_roshan_desert_sands_ambient.vpcf",
		h344 = "effect/biyu_roshan/1.vpcf",
		h436 = "effect/golden_roshan/ambient.vpcf",
		h437 = "effect/platinum_roshan/ambient.vpcf",
		h438 = "effect/golden_ww/1.vpcf",
		h439 = "effect/gold_angel/angels.vpcf",
		h440 = "effect/liansai_dog/1.vpcf",
		h441 = "effect/liansai_dog2/1.vpcf",
		h446 = "effect/wabbit/lvl3.vpcf",
		h244 = "effect/chongya/1econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship_marker.vpcf",
		h425 = "effect/xiexiaowo_guanjundun/1.vpcf",
		h434 = "effect/jinguizi/base.vpcf",
		h356 = "effect/wangyu/1.vpcf",
		-- h245 = "effect/xiaoxiang/pnt.vpcf",
		h397 = "effect/googie/397.vpcf",
		h398 = "effect/googie/398.vpcf",

		h358 = "particles/econ/courier/courier_greevil_white/courier_greevil_white_ambient_3.vpcf",
		h359 = "particles/econ/courier/courier_greevil_black/courier_greevil_black_ambient_3_parent.vpcf",
		h448 = "effect/golden_roshan/ambient.vpcf",
		h450 = "effect/mao/2.vpcf",
		h346 = "effect/golden_roshan/ambient.vpcf",
		h456 = "effect/golden_roshan/ambient.vpcf",
		h461 = "effect/roshan_ti10/flying.vpcf",
		h462 = "effect/roshan_ti10/dire/flying.vpcf",
		h465 = "effect/golden_roshan/ambient.vpcf",
		h466 = "effect/ground_gold/1.vpcf",
	}
	GameRules:GetGameModeEntity().courier_ground_effect_list = {
		h199 = "effect/gewugu/2.vpcf",
		h303 = "particles/gem/brewmaster_drunken_haze_debuff_bubbles_2.vpcf",
		h397 = "effect/googie/397.vpcf",
		h398 = "effect/googie/398.vpcf",
		h425 = "effect/yuhuofenshen/1_2_embers.vpcf",
		h434 = "effect/yuhuofenshen/1_2_embers.vpcf",
		h357 = "effect/ronghuo_equan/fire.vpcf",
		h356 = "particles/econ/events/ti7/golden_treasure_ti7_ambient_magic.vpcf",
		h349 = "particles/econ/courier/courier_minipudge/courier_minipudge_ambient.vpcf",
		h450 = "effect/mao/1.vpcf",
		h456 = "effect/yuhuofenshen/1_2_embers.vpcf",
		h466 = "effect/ground_gold/1.vpcf",
	}
	GameRules:GetGameModeEntity().projectile_list = {
		p000 = "particles/base_attacks/ranged_tower_good.vpcf",--默认弹道
		p001 = "particles/units/heroes/hero_skywrath_mage/skywrath_mage_arcane_bolt.vpcf",--vip
		p002 = "particles/base_attacks/ranged_tower_good.vpcf",--"effect/pj_nangua/1.vpcf",--南瓜

		p101 = "particles/econ/items/viper/viper_ti7_immortal/viper_poison_crimson_attack_ti7.vpcf",--毒液
		p102 = "particles/econ/items/clinkz/clinkz_maraxiform/clinkz_ti9_summon_projectile_arrow.vpcf",--灼热之箭
		p103 = "particles/econ/items/phantom_assassin/pa_ti8_immortal_head/pa_ti8_immortal_stifling_dagger_arcana_combined.vpcf",--飞镖|金色
		p104 = "particles/econ/items/shadow_fiend/sf_desolation/sf_base_attack_desolation_fire_arcana.vpcf",--灵魂火
		p105 = "effect/projectile/snowball/1.vpcf",--雪球
		p106 = "particles/units/heroes/hero_bane/bane_projectile.vpcf",--噩梦
		p107 = "particles/units/heroes/hero_phantom_lancer/phantomlancer_spiritlance_projectile.vpcf",--萤火虫

		p201 = "particles/econ/items/bristleback/ti7_head_nasal_goo/bristleback_ti7_crimson_nasal_goo_proj.vpcf", --粘稠鼻液
		p202 = "particles/econ/items/witch_doctor/wd_monkey/witchdoctor_cask_monkey.vpcf",--水果忍者|椰子
		p203 = "particles/econ/items/witch_doctor/wd_ti8_immortal_bonkers/wd_ti8_immortal_bonkers_cask.vpcf",--水果忍者|榴莲
		p204 = "particles/econ/items/luna/luna_ti9_weapon_gold/luna_ti9_gold_base_attack.vpcf",--月刃|金色
		p205 = "particles/units/heroes/hero_sven/sven_spell_storm_bolt.vpcf", --风暴之锤
		p206 = "particles/units/heroes/hero_medusa/medusa_mystic_snake_projectile.vpcf",--异术秘蛇
		p207 = "particles/econ/items/luna/luna_ti9_weapon/luna_ti9_base_attack.vpcf",--月刃|紫色
		p208 = "effect/pj_hw_candy/1.vpcf",--糖果炸弹
		p209 = "particles/units/heroes/hero_siren/siren_net_projectile.vpcf",--诱捕|银色
		p210 = "particles/units/heroes/hero_troll_warlord/troll_warlord_bersekers_net_projectile.vpcf",--诱捕|金色
		p211 = "particles/winter_fx/winter_present_projectile.vpcf",--圣诞礼物

		p301 = "particles/items4_fx/nullifier_proj.vpcf", --光之紫
		p302 = "particles/econ/items/wraith_king/wraith_king_ti6_bracer/wraith_king_ti6_hellfireblast.vpcf",--冥魂之怒
		p303 = "particles/econ/items/clockwerk/clockwerk_paraflare/clockwerk_para_rocket_flare.vpcf",--照明弹
		p304 = "particles/econ/items/rubick/rubick_arcana/rbck_arc_skeletonking_hellfireblast.vpcf",--风暴魔方
		p305 = "particles/econ/items/skywrath_mage/skywrath_ti9_immortal_back/skywrath_mage_ti9_arcane_bolt.vpcf",--飞鸟炸弹
		p306 = "particles/units/heroes/hero_meepo/meepo_earthbind_projectile_fx.vpcf",--天罗地网
		p307 = "particles/econ/events/ti10/hot_potato/hot_potato_projectile.vpcf",--辣椒

		p401 = "particles/econ/items/drow/drow_ti9_immortal/drow_ti9_marksman_frost.vpcf",--霜冻之箭
		p402 = "particles/econ/items/alchemist/alchemist_smooth_criminal/alchemist_smooth_criminal_unstable_concoction_projectile.vpcf", --不稳定化合物
		p403 = "particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle.vpcf",--羽毛弹|紫色
		p404 = "particles/econ/items/vengeful/vs_ti8_immortal_shoulder/vs_ti8_immortal_magic_missle_crimson.vpcf",--羽毛弹|红色
		p405 = "particles/econ/items/enchantress/enchantress_virgas/ench_impetus_virgas.vpcf",--彩虹之矛
		p406 = "particles/econ/items/lich/lich_ti8_immortal_arms/lich_ti8_chain_frost.vpcf",--巫妖王之怒
		p407 = "particles/units/heroes/hero_ancient_apparition/ancient_apparition_chilling_touch_projectile.vpcf",--霜寒之触
		p408 = "effect/cookie/projectile.vpcf",  --龙炎饼干
	}

	GameRules:GetGameModeEntity().projectile_sound_list = {
		p000 = "pj_hit.tower",--默认弹道
		p001 = "pj_hit.tiannu",--vip
		p002 = "pj_hit.tower",--"diretide.hit",--南瓜

		p101 = "pj_hit.duye",--毒液
		p102 = "pj_hit.zhuore",--灼热之箭
		p103 = "pj_hit.yueren",--飞镖|金色
		p104 = "pj_hit.linghun",--灵魂火
		p105 = "pj_hit.snowball",--雪球
		p106 = "pj_hit.emeng",--噩梦
		p107 = "pj_hit.snake",--萤火虫

		p201 = "pj_hit.duye", --粘稠鼻液
		p202 = "diretide.hit",--水果忍者|椰子
		p203 = "diretide.hit",--水果忍者|榴莲
		p204 = "pj_hit.yueren",--月刃|金色
		p205 = "pj_hit.chuizi", --风暴之锤
		p206 = "pj_hit.snake",--异术秘蛇
		p207 = "pj_hit.yueren",--月刃|紫色
		p208 = "pj_hit.snowball",--糖果炸弹
		p209 = "pj_hit.net",--诱捕|银色
		p210 = "pj_hit.net",--诱捕|金色
		p211 = "pj_hit.snowball",--圣诞礼物

		p301 = "pj_hit.magic_missile", --光之紫
		p302 = "pj_hit.linghun",--冥魂之怒
		p303 = "pj_hit.flare_explode",--照明弹
		p304 = "pj_hit.chuizi",--风暴魔方
		p305 = "pj_hit.tiannu",--飞鸟炸弹
		p306 = "pj_hit.net",--天罗地网
		p307 = "pj_hit.pepper",--辣椒

		p401 = "pj_hit.frost_arrow",--霜冻之箭
		p402 = "pj_hit.unstable_concoction", --不稳定化合物
		p403 = "pj_hit.magic_missile",--羽毛弹|紫色
		p404 = "pj_hit.magic_missile",--羽毛弹|红色
		p405 = "pj_hit.rainbow",--彩虹之矛
		p406 = "pj_hit.lichking",--巫妖王之怒
		p407 = "pj_hit.lichking",--霜寒之触
		p408 = "pj_hit.cookie", --龙炎饼干
	}

	GameRules:GetGameModeEntity().pet_list = {
		t101 = "models/qiyidan/qiyidan.vmdl", --奇异蛋圆圆
		t102 = "models/fatiao/fatiao.vmdl", --霸天者11型
		t103 = "models/pets/icewrack_wolf/icewrack_wolf.vmdl", --莉莱的单身狗
		t104 = "models/pets/armadillo/armadillo.vmdl", --小穿山迪洛
		t105 = "models/huaxiyi/huaxiyi.vmdl",--花蜥蜥

		t201 = "models/hailuomei/hailuomei.vmdl", --海螺妹娜娜
		t202 = "models/dujiaoshou/dujiaoshou.vmdl", --独角兽悠妮空
		t203 = "models/rongyanquan/rongyanquan.vmdl",--熔火恶犬
		t204 = "models/heroes/invoker_kid/invoker_kid_trainer_dragon.vmdl", --失落奇艺小龙
		
		t301 = "models/duye/duye.vmdl", --毒液波索拉贡
		t302 = "models/jinlinglong/h018s1.vmdl", --光羽龙帕拉贡
		t303 = "models/tuzimei/tuzimei.vmdl", --兔耳弩手婉
		t304 = "models/laoge/h30.vmdl", --老鸽婺
		t305 = "models/bose/bose01.vmdl", --哥布霍马

		t401 = "models/drodo/drodo.vmdl", --小鸟多多
		t402 = "models/creeps/greevil_shopkeeper/greevil_shopkeeper.vmdl",  --贪魔舞者
		
	}

	GameRules:GetGameModeEntity().pet_size_list = {
		t101 = 1.4,
		t102 = 0.8,
		t103 = 1.2,
		t104 = 1.05,
		t201 = 1.5,
		t202 = 1,
		t203 = 1,
		t204 = 0.9,
		t301 = 0.9,
		t302 = 1.6,
		t303 = 1.2,
		t304 = 2.3,
		t305 = 0.6,

		t401 = 1.3,
		t402 = 1,
		
	}

	GameRules:GetGameModeEntity().combined_items_recipe = {
		item_jingmixie = "item_suduzhixue;item_huifuzhihuan",
		item_bkb = "item_xiaofu;item_miyinchui",
		item_yangdao = "item_shenmifazhang;item_jixianfaqiu;item_xuwubaoshi",
		item_huiguang = "item_molifazhang;item_fashichangpao",
		item_tiaozhantoujin = "item_zhiliaozhihuan;item_huifuzhihuan;item_kangmodoupeng",
		item_dongchayandou = "item_zhiliaozhihuan;item_huifuzhihuan;item_kangmodoupeng;item_kangmodoupeng",
		item_hongzhang_1 = "item_molifazhang;item_wangguan",
		item_hongzhang_2 = "item_molifazhang;item_molifazhang;item_wangguan",
		item_hongzhang_3 = "item_molifazhang;item_molifazhang;item_molifazhang;item_wangguan",
		item_hongzhang_4 = "item_molifazhang;item_molifazhang;item_molifazhang;item_molifazhang;item_wangguan",
		item_hongzhang_5 = "item_molifazhang;item_molifazhang;item_molifazhang;item_molifazhang;item_molifazhang;item_wangguan",
		item_aoshuxie = "item_suduzhixue;item_nengliangqiu",
		item_jinghunzhiren = "item_fashichangpao;item_huanxinzhiren",
		item_qinglianbaozhu = "item_zhiliaozhihuan;item_xuwubaoshi;item_nengliangqiu",
		item_longxin = "item_dafu;item_huoliqiu;item_huoliqiu",
		item_jianrenqiu = "item_zhiliaozhihuan;item_xuwubaoshi",
		item_shuaxinqiu = "item_zhiliaozhihuan;item_xuwubaoshi;item_zhiliaozhihuan;item_xuwubaoshi",
		item_hudie = "item_yingjiaogong;item_shanbihufu;item_duangun",
		item_zhaohuanshenshi = "item_huoliqiu;item_kuweishi",
		item_bingyan = "item_jixianfaqiu;item_jixianfaqiu",
		item_sadan = "item_dafu;item_xixuemianju;item_duangun",
		item_kuangzhanfu = "item_zhiliaozhihuan;item_xuwubaoshi",
		item_huiyao = "shengzheyiwu;item_shanbihufu",
		item_anmie = "item_miyinchui;item_miyinchui;item_kuweishi",
		item_jingubang = "item_emodaofeng;item_biaoqiang;item_duangun",
		item_shengjian = "item_shengzheyiwu;item_emodaofeng",
		item_fengkuangmianju = "item_xixuemianju;item_duangun",
		item_yinyuezhijing = "item_zhenfenbaoshi;item_zhenfenbaoshi",
		item_xuanwo = "item_miyinchui;item_biaoqiang",
		item_dadianchui = "item_miyinchui;item_biaoqiang;item_zhenfenbaoshi",
		item_shuijingjian = "item_kuojian;item_gongjizhizhua",
		item_dapao = "item_kuojian;item_gongjizhizhua;item_emodaofeng",
		item_xianfengdun = "item_huoliqiu;item_yuandun;item_zhiliaozhihuan",
		item_qiongguidun = "item_yuandun;item_yuandun",
		item_renjia = "item_suozijia;item_kuojian",
		item_xiwa = "item_shenmifazhang;item_banjia",
		item_qiangxi = "item_banjia;item_suozijia;item_zhenfenbaoshi",
		item_yuanlifazhang = "item_molifazhang;item_huifuzhihuan",
		item_dianjinshou = "item_gongjizhizhua;item_zhiliaozhihuan",
		item_shirenmozhimao = "item_xiaofu;item_xiaofu;item_xiaofu;item_xiaofu;item_kangmodoupeng",
		item_baojunwangpao = "item_miyinchui;item_miyinchui;item_miyinchui;item_fashichangpao;item_wangguan",
		item_wangyuanjing = "item_duangun;item_nengliangqiu",
		item_huanyingfu = "item_jixianfaqiu;item_huanxinzhiren;item_gongjizhizhua",
		item_linkenfaqiu = "item_jianrenqiu;item_jixianfaqiu",
		item_chihongjia = "item_yuandun;item_zhiliaozhihuan;item_huoliqiu;item_suozijia",
	}
	GameRules:GetGameModeEntity().user_setting = {}

	GameRules:GetGameModeEntity().greevil_list = {
		--贪魔
		h246 = {
			skin = 1,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth1.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h247 = {
			skin = 2,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth1.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h248 = {
			skin = 3,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth1.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h249 = {
			skin = 4,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth2.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h250 = {
			skin = 5,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth2.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h251 = {
			skin = 6,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth2.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h358 = {
			skin = 7,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears2.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose3.vmdl",
			part5 = "models/courier/greevil/greevil_tail3.vmdl",
			part6 = "models/courier/greevil/greevil_teeth3.vmdl",
			part7 = "models/courier/greevil/greevil_wings3.vmdl",
		},
		h359 = {
			skin = 8,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears2.vmdl",
			part3 = "models/courier/greevil/greevil_horns3.vmdl",
			part4 = "models/courier/greevil/greevil_nose2.vmdl",
			part5 = "models/courier/greevil/greevil_tail4.vmdl",
			part6 = "models/courier/greevil/greevil_teeth4.vmdl",
			part7 = "models/courier/greevil/greevil_wings2.vmdl",
			part8 = "models/courier/greevil/greevil_feathers.vmdl",
		},
		--猫
		h140 = {
			skin = 1,
			part1 = "models/items/courier/catakeet/catakeet_head_curious.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_curious.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
		},
		h252 = {
			skin = 5,
			part1 = "models/items/courier/catakeet/catakeet_head_curious.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_good.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
		},
		h360 = {
			skin = 9,
			part1 = "models/items/courier/catakeet/catakeet_head_sly.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_sly.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
			part4 = "models/items/courier/catakeet/catakeet_wings_sly.vmdl",
		},
		h450 = {
			skin = 3,
			part1 = "models/items/courier/catakeet/catakeet_head_evil.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_evil.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
			part4 = "models/items/courier/catakeet/catakeet_wings_evil.vmdl",
		},
	}

	local greevil_unit_name = {
		[1] = 'h246',
		[2] = 'h247',
		[3] = 'h248',
		[4] = 'h249',
		[5] = 'h250',
		[6] = 'h251',
		[7] = 'h358',
		[8] = 'h359',
	}
	for i=1,8 do
		local greevil = Entities:FindByName(nil,"dac_greevil"..i)
		if greevil ~= nil then
			greevil.courier_name = greevil_unit_name[i]
			if i >=7 then 
				MakeGreevil(greevil,true)
			else
				MakeGreevil(greevil,false)
			end
		end
	end
end
function MakeGreevil(unit,is_flying)
	if unit.part1 ~= nil and unit.part1:IsNull() == false then
		unit.part1:Kill()
	end
	if unit.part2 ~= nil and unit.part2:IsNull() == false then
		unit.part2:Kill()
	end
	if unit.part3 ~= nil and unit.part3:IsNull() == false then
		unit.part3:Kill()
	end
	if unit.part4 ~= nil and unit.part4:IsNull() == false then
		unit.part4:Kill()
	end
	if unit.part5 ~= nil and unit.part5:IsNull() == false then
		unit.part5:Kill()
	end
	if unit.part6 ~= nil and unit.part6:IsNull() == false then
		unit.part6:Kill()
	end
	if unit.part7 ~= nil and unit.part7:IsNull() == false then
		unit.part7:Kill()
	end
	if unit.part8 ~= nil and unit.part8:IsNull() == false then
		unit.part8:Kill()
	end

	if unit == nil or (unit.courier_name == nil and unit.onduty_hero == nil) then
		return
	end
	local greevil_info = GameRules:GetGameModeEntity().greevil_list[unit.courier_name or unit.onduty_hero]
	if greevil_info == nil then
		return
	end


	local skin = greevil_info.skin or 0
	unit:SetSkin(skin)
	--眼睛
	local part1 = greevil_info.part1
	if part1 ~= nil then
		unit.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part1})
		unit.part1:FollowEntity(unit,true)
		unit.part1:SetSkin(skin)
	end
	--耳朵
	local part2 = greevil_info.part2
	if part2 ~= nil then
		unit.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part2})
		unit.part2:FollowEntity(unit,true)
		unit.part2:SetSkin(skin)
		
		if part2 == "models/items/courier/catakeet/catakeet_tail_sly.vmdl" and skin == 9 then
			--特例
			unit.part2:SetSkin(8)
		end
	end
	--角
	local part3 = greevil_info.part3
	if part1 ~= nil then
		unit.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part3})
		unit.part3:FollowEntity(unit,true)
		unit.part3:SetSkin(skin)
	end
	--鼻子
	local part4 = greevil_info.part4
	if part4 ~= nil then
		unit.part4 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part4})
		unit.part4:FollowEntity(unit,true)
		unit.part4:SetSkin(skin)
	end
	--尾巴
	local part5 = greevil_info.part5
	if part5 ~= nil then
		unit.part5 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part5})
		unit.part5:FollowEntity(unit,true)
		unit.part5:SetSkin(skin)
	end
	--牙齿
	local part6 = greevil_info.part6
	if part6 ~= nil then
		unit.part6 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part6})
		unit.part6:FollowEntity(unit,true)
		unit.part6:SetSkin(skin)
	end
	--翅膀
	if is_flying == true then
		local part7 = greevil_info.part7
		if part7 ~= nil then
			unit.part7 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part7})
			unit.part7:FollowEntity(unit,true)
			unit.part7:SetSkin(skin)
		end
	end
	if is_flying == true then
		local part8 = greevil_info.part8
		if part8 ~= nil then
			unit.part8 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part8})
			unit.part8:FollowEntity(unit,true)
			unit.part8:SetSkin(skin)
		end
	end
end

function RandomLegendary()
	local remove_table = {}
	local ll = table.maxn(GameRules:GetGameModeEntity().chess_list_by_mana[5])

	while ll > 8 do
		local rn = RandomInt(1,ll)
		local chess = GameRules:GetGameModeEntity().chess_list_by_mana[5][rn]
		table.insert(remove_table,chess)
		table.remove(GameRules:GetGameModeEntity().chess_list_by_mana[5],rn)
		for i,v in pairs(GameRules:GetGameModeEntity().chess_list_by_synergy) do
			if FindValueInTable(v,chess) == true then
				RemoveTableItem(v,chess)
			end
		end
		ll = table.maxn(GameRules:GetGameModeEntity().chess_list_by_mana[5])
	end
	-- while ll > 7 do
	-- 	local rn = RandomInt(1,ll)
	-- 	local chess = GameRules:GetGameModeEntity().chess_list_by_mana[5][rn]
	-- 	table.insert(remove_table,chess)
	-- 	table.remove(GameRules:GetGameModeEntity().chess_list_by_mana[5],rn)
	-- 	for i,v in pairs(GameRules:GetGameModeEntity().chess_list_by_synergy) do
	-- 		if FindValueInTable(v,chess) == true then
	-- 			RemoveTableItem(v,chess)
	-- 		end
	-- 	end
	-- 	ll = table.maxn(GameRules:GetGameModeEntity().chess_list_by_mana[5])
	-- end
	-- table.insert(GameRules:GetGameModeEntity().chess_list_by_mana[5],'chess_mk')
	return remove_table
end

function InitHeros()
	--拼接要向服务器发送的steamid数据
	for pid,sid in pairs(GameRules:GetGameModeEntity().playerid2steamid) do
		if PlayerResource:GetTeam(pid) >= 6 and PlayerResource:GetTeam(pid) <= 13 then
			
			table.insert(GameRules:GetGameModeEntity().send_status,sid)
			GameRules:GetGameModeEntity().upload_detail_stat[sid] = {}
			if GameRules:GetGameModeEntity().playerid2hero[pid] ~= nil then
				if GameRules:GetGameModeEntity().steamidlist == '' then
					GameRules:GetGameModeEntity().steamidlist = sid
					GameRules:GetGameModeEntity().steamidlist_heroindex = sid..'_'..GameRules:GetGameModeEntity().playerid2hero[pid]:entindex()
				else
					GameRules:GetGameModeEntity().steamidlist = GameRules:GetGameModeEntity().steamidlist..','..sid
					GameRules:GetGameModeEntity().steamidlist_heroindex = GameRules:GetGameModeEntity().steamidlist_heroindex..','..sid..'_'..GameRules:GetGameModeEntity().playerid2hero[pid]:entindex()
				end
				if PlayerResource:HasCustomGameTicketForPlayerID ( pid ) == true then
					GameRules:GetGameModeEntity().steamidlist_heroindex = GameRules:GetGameModeEntity().steamidlist_heroindex..'_vip'
				end
			end
		end
	end
	if string.find(GameRules:GetGameModeEntity().steamidlist,'76561198101849234') or string.find(GameRules:GetGameModeEntity().steamidlist,'76561198090961025') or string.find(GameRules:GetGameModeEntity().steamidlist,"76561198090931971") or string.find(GameRules:GetGameModeEntity().steamidlist,"76561198132023205") or string.find(GameRules:GetGameModeEntity().steamidlist,"76561198079679584") or string.find(GameRules:GetGameModeEntity().steamidlist,"76561198069865383") then
		GameRules:GetGameModeEntity().myself = true
	end
	--防控制台作弊
	if GameRules:GetGameModeEntity().myself ~= true then
		Timers:CreateTimer(1,function()
			if GameRules:IsCheatMode() == true then
				prt('CHEAT MODE! BYEBYE')
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)				
				return
			end
			return 5
		end)
	end

	if GameRules:GetGameModeEntity().playing_player_count == 0 then
		--没有玩家，这局凉了
		Timers:CreateTimer(30,function()
			GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)				
		end)
		return
	end

	GameRules:GetGameModeEntity().cloudlineup = {}
	if GameRules:GetGameModeEntity().playing_player_count == 1 then
		--单人获取云对战列表
		-- prt('#text_difficulty_select')
		-- prt('#text_difficulty_'..GameRules:GetGameModeEntity().difficulty)
		local url = "http://autochess.ppbizon.com/lineup/get?hehe="..RandomInt(1,10000)
		SendHTTP(url..	"&from=InitHeros&difficulty="..GameRules:GetGameModeEntity().difficulty, function(t)
			combat('LOAD CLOUD LINEUP OK!')
			GameRules:GetGameModeEntity().cloudlineup = t.data
		end)
	end

	--收集玩家的语言
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"request_player_language",{
			key = GetClientKey(team_i),
			hehe = RandomInt(1,100000),
		})
	end

	--从服务器获取玩家信息
	local url = "https://autochess.ppbizon.com/game/new/@"..GameRules:GetGameModeEntity().steamidlist_heroindex.."?hehe="..RandomInt(1,10000)..GetSendKey()
	SendHTTP(url.."&from=InitHeros", function(t)
		if t ~= nil and t.err == 0 then
			combat('CONNECT SERVER OK!')

			for steam_id,user_info in pairs(t.user_info) do

				table.insert(GameRules:GetGameModeEntity().user_md5_table,steam_id)
				local hero_index = user_info.hero_index
				local hero = EntIndexToHScript(hero_index)
				local player_id = hero:GetPlayerID()
				if user_info.settings ~= nil and user_info.settings ~= 'null' then
					GameRules:GetGameModeEntity().user_setting[steam_id] = json.decode(user_info.settings)
				else
					GameRules:GetGameModeEntity().user_setting[steam_id] = {
						is_click_select = 1,
						is_auto_combine = 1,
						is_fog_show = 1,
					}
				end
				CustomNetTables:SetTableValue( "setting_table", "show_settings", GameRules:GetGameModeEntity().user_setting)

				if user_info.mmr_level < 19 then
					hero.notbishop = true
				end

				if user_info.is_top_3 ~= nil then
					hero.is_top_3 = 1
				end

				if user_info['xhw'] ~= nil then
					prt('<font color="#ff4444">BANNED PLAYER: '..GameRules:GetGameModeEntity().steamid2name[steam_id]..'</font>')
					hero.is_banned = true

					-- Timers:CreateTimer(5,function()
					-- 	GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
					-- end)
				end
				if GameRules:GetGameModeEntity().playing_player_count == 1 and user_info.vip_tester == true then
					prt('<font color="#ffff44">WELCOME VIP TESTER!</font>')
					GameRules:GetGameModeEntity().myself = true
				end
				user_info['player_id'] = player_id
				hero.steam_id = steam_id
				if GameRules:GetGameModeEntity().steamid2name[steam_id] ~= nil then
					hero.player_name = GameRules:GetGameModeEntity().steamid2name[steam_id]
				end

				local onduty_hero_long = user_info.onduty_hero
				local onduty_hero = string.split(onduty_hero_long,'_')[1]
				local onduty_hero_effect = string.split(onduty_hero_long,'_')[2] or ''
				local onduty_hero_projectile = string.split(onduty_hero_long,'_')[4] or ''
				local onduty_hero_pet = string.split(onduty_hero_long,'_')[5] or ''
				local onduty_hero_animation = string.split(onduty_hero_long,'_')[6] or ''

				user_info['onduty_hero'] = onduty_hero
				user_info['onduty_hero_effect'] = onduty_hero_effect

				AddAbilityAndSetLevel(hero,'pick_chess')
				AddAbilityAndSetLevel(hero,'recall_chess')
			    AddAbilityAndSetLevel(hero,'remove_chess')
			    AddAbilityAndSetLevel(hero,'summon_hero')
			    AddAbilityAndSetLevel(hero,'exp_book')
			    AddAbilityAndSetLevel(hero,'transfer_chess')
			    hero:FindAbilityByName('transfer_chess'):SetHidden(true)
			    AddAbilityAndSetLevel(hero,'disarm_chess')
			    hero:FindAbilityByName('disarm_chess'):SetActivated(false)
			    AddAbilityAndSetLevel(hero,'ban_chess')
			    hero:FindAbilityByName('ban_chess'):SetActivated(false)
			    hero:FindAbilityByName('ban_chess'):SetHidden(true)
				AddAbilityAndSetLevel(hero,'jiaoxie_wudi_hero')
				AddAbilityAndSetLevel(hero,'wudi')
			    AddAbilityAndSetLevel(hero,'no_hp_add')
			    AddAbilityAndSetLevel(hero,'no_collision')

				if PlayerResource:HasCustomGameTicketForPlayerID ( player_id ) == true or user_info.is_author == true or user_info.is_vip == true then
					hero.is_vip = true
				end
				if user_info.is_author == true then
					hero.is_author = true
				end

			    local init_hp = 100
				GameRules:GetGameModeEntity().stat_info[steam_id] = {
					steam_id = steam_id,
					hp = init_hp,
					player_id = player_id,
					duration = 0,
					rank = 0,
					zhugong = onduty_hero,
					zhugong_model = GameRules:GetGameModeEntity().sm_hero_list[onduty_hero],
					zhugong_effect = onduty_hero_effect,
					round = 0,
					win_round = 0,
					lose_round = 0,
					draw_round = 0,
					kills = 0,
					deaths = 0,
					mmr_level = user_info.mmr_level,
					queen_rank = user_info.queen_rank,
					chess_lineup = '',
					chess_hand = '',
					candy = 0,
					biscuit = 0,
					hero_level = 0,
					buff = '',
					show_buff = '',
					hero_damage = 0,
					hero_damaged = 0,
					is_vip = hero.is_vip or false,
					is_author = hero.is_author or false,
					p2team = nil,
					team_id = hero:GetTeam(),
					total_money = 0,
					block_team = {},
					ban_synergy = nil,
				}
				hero.onduty_hero = onduty_hero
				hero.steam_id = steam_id
				hero.onduty_hero_effect = onduty_hero_effect

				if user_info.is_crown_current ~= nil then
					hero.is_crown = true
					ShowCrown(hero,1)
				end
				 --初始化任务
				if user_info.vip_info ~= nil and user_info.vip_info.biscuit_quest ~= nil then
					if GameRules:GetGameModeEntity().egg_quest == nil then
						GameRules:GetGameModeEntity().egg_quest = user_info.vip_info.biscuit_quest
						CustomNetTables:SetTableValue( "game_info", "quest", { 
							biscuit_quest = GameRules:GetGameModeEntity().egg_quest,
						})
					end
					for team,_ in pairs(GameRules:GetGameModeEntity().quest_status) do
						if hero:GetTeam() == team and hero.is_vip == true then
							GameRules:GetGameModeEntity().quest_status[team] = GameRules:GetGameModeEntity().quest_init[GameRules:GetGameModeEntity().egg_quest]
						end
					end
				end

				--装饰信使
				SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet, onduty_hero_animation)
				hero:MoveToPosition(hero:GetAbsOrigin())	
			end
			ShowQuest()
			GameRules:GetGameModeEntity().user_info = t.user_info


			print('[player_info]after game/new')
			CustomNetTables:SetTableValue( "dac_table", "player_info", { info = t.user_info, hehe = RandomInt(1,1000)})
			
			if t.chess_pool ~= nil  then
				if t.chess_pool.pool_size ~= nil then
					GameRules:GetGameModeEntity().CHESS_POOL_SIZE = t.chess_pool.pool_size
				end
				if t.chess_pool.chess_init_1 ~= nil then
					GameRules:GetGameModeEntity().CHESS_INIT_COUNT[1] = t.chess_pool.chess_init_1
				end
				if t.chess_pool.chess_init_2 ~= nil then
					GameRules:GetGameModeEntity().CHESS_INIT_COUNT[2] = t.chess_pool.chess_init_2
				end
				if t.chess_pool.chess_init_3 ~= nil then
					GameRules:GetGameModeEntity().CHESS_INIT_COUNT[3] = t.chess_pool.chess_init_3
				end
				if t.chess_pool.chess_init_4 ~= nil then
					GameRules:GetGameModeEntity().CHESS_INIT_COUNT[4] = t.chess_pool.chess_init_4
				end
				if t.chess_pool.chess_init_5 ~= nil then
					GameRules:GetGameModeEntity().CHESS_INIT_COUNT[5] = t.chess_pool.chess_init_5
				end
				if t.chess_pool.chess_africa_1 ~= nil then
					GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE[1] = t.chess_pool.chess_africa_1
				end
				if t.chess_pool.chess_africa_2 ~= nil then
					GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE[2] = t.chess_pool.chess_africa_2
				end
				if t.chess_pool.chess_africa_3 ~= nil then
					GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE[3] = t.chess_pool.chess_africa_3
				end
				if t.chess_pool.chess_africa_4 ~= nil then
					GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE[4] = t.chess_pool.chess_africa_4
				end
				if t.chess_pool.chess_africa_5 ~= nil then
					GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE[5] = t.chess_pool.chess_africa_5
				end
			end

			if t.ranking_info ~= nil then

				local tb = {}
				local count = 0
				for i,v in pairs(t.ranking_info) do
					tb[i] = {
						steam_id = v.player,
						mmr_level = v.mmr_level,
						queen_rank = v.queen_rank,
						is_vip = v.is_vip,
					}
					count = count + 1
					if count > 20 then
						break
					end
				end

				CustomNetTables:SetTableValue( "ranking_top_table", "ranking_top", tb )			
			end

			StartGame()
			table.sort(GameRules:GetGameModeEntity().user_md5_table)
			local user_md5_string = ''
			for _,tt in pairs(GameRules:GetGameModeEntity().user_md5_table) do
			    user_md5_string = user_md5_string..tt..','
			end
			local user_md5 = calmd5(string.sub(user_md5_string,1,-2))
			Timers:CreateTimer(3,function()
				-- if math.fmod(GameRules:GetGameModeEntity().playing_player_count,2) == 0 and math.floor(GameRules:GetGameModeEntity().playing_player_count/2) >= 2 then
				if GetMapName() == 'casual_2x4_ob' or GetMapName() == 'casual_2x4' or GetMapName() == 'ranked_2x4' then
					local p2_result = InitP2Mode()
					if p2_result == true then
						prt('#mode_2p')
					else
						if GameRules:GetGameModeEntity().myself ~= true then
							prt('#mode_2p_invalid_player_count')

							GameRules:GetGameModeEntity().is_game_ended = true
							prt('GAME OVER')

							Timers:CreateTimer(5,function()
								GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
							end)
						end
					end
				end
				local heiheurl = 'http://api.xiaoheihe.cn/api/rpg/autochess/report_match_start/?apikey=69f395b2-f7e8-4032-bd0c-41200cfe9dad'
				local heihedata = {
					steamids = GameRules:GetGameModeEntity().steamidlist,
				  	version = '2.0',
				  	key = GetDedicatedServerKey('max'),
				  	key2 = GetDedicatedServerKey('heihe'),
				  	key3 = GetDedicatedServerKeyV2('heihe'),
				}
				SendHTTPPost(heiheurl,heihedata)
				local dotamindurl = 'https://apidota.gamesmindai.com/wisp/handler'
				local localtime = LocalTime()
				local dotaminddata = {
					route = "wisp.game.init",
 					message = {
						appId = '2533c49c3ac74f478253b8ce19d47f7f',
						matchId = localtime.Hours..localtime.Minutes..localtime.Seconds..RandomInt(10000,99999),
						map = GetMapName(),
						players = string.split(GameRules:GetGameModeEntity().steamidlist,',')
					},
				}
				SendHTTPPost(dotamindurl,dotaminddata,{serverKey=GetDedicatedServerKeyV2('dotamind')})
			end)
		elseif t ~= nil and t.err == 1100 then
			prt('对不起，连接服务器失败，游戏无法开始。')
			GameRules:GetGameModeEntity().is_game_ended = true
			prt('GAME OVER')
			Timers:CreateTimer(0.1,function()
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
			end)
			return
		else
			--连接服务器失败了，用默认信使玩
			if t ~= nil then
				prt('CONNECT SERVER ERROR : '..t.err)
			end
			if GetDedicatedServerKeyV2('hehe') == 'Invalid_NotOnDedicatedServer' then
				prt('对不起，连接服务器失败，游戏无法开始。')
				GameRules:GetGameModeEntity().is_game_ended = true
				prt('GAME OVER')
				Timers:CreateTimer(0.1,function()
					GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
				end)
				return
			end

			local user_info_table = {}
			is_game_can_start = true
			local steamid_table = string.split(GameRules:GetGameModeEntity().steamidlist_heroindex,',')

			--默认玩家数据
			for _,v in pairs(steamid_table) do 
				local steamid = string.split(v,'_')[1]
				local hero_index = string.split(v,'_')[2]
				local hero = EntIndexToHScript(hero_index)
				user_info_table[steamid] = {
					steamid = steamid,
					candy = 0,
					biscuit = 0,
					mmr = 0,
					match = 0,
					zhugong = {
						[1] = "h001_e000"
					},
					onduty_hero = "h001_e000",
					mmr_level = 0,
					hero_index = tonumber(hero_index),
				}
			end

			for steam_id,user_info in pairs(user_info_table) do
				local hero_index = user_info.hero_index
				local hero = EntIndexToHScript(hero_index)
				local player_id = hero:GetPlayerID()
				user_info['player_id'] = player_id
				hero.steam_id = steam_id
				if GameRules:GetGameModeEntity().steamid2name[steam_id] ~= nil then
					hero.player_name = GameRules:GetGameModeEntity().steamid2name[steam_id]
				end

				local onduty_hero_long = user_info.onduty_hero
				local onduty_hero = string.split(onduty_hero_long,'_')[1]
				local onduty_hero_effect = string.split(onduty_hero_long,'_')[2] or ''
				local onduty_hero_projectile = string.split(onduty_hero_long,'_')[4] or ''
				local onduty_hero_pet = string.split(onduty_hero_long,'_')[5] or ''

				user_info['onduty_hero'] = onduty_hero
				user_info['onduty_hero_effect'] = onduty_hero_effect
				AddAbilityAndSetLevel(hero,'pick_chess')
				AddAbilityAndSetLevel(hero,'recall_chess')
			    AddAbilityAndSetLevel(hero,'remove_chess')
			    AddAbilityAndSetLevel(hero,'summon_hero')
			    AddAbilityAndSetLevel(hero,'exp_book')
			    AddAbilityAndSetLevel(hero,'transfer_chess')
			    hero:FindAbilityByName('transfer_chess'):SetHidden(true)
			    AddAbilityAndSetLevel(hero,'disarm_chess')
			    hero:FindAbilityByName('disarm_chess'):SetActivated(false)
			    AddAbilityAndSetLevel(hero,'ban_chess')
			    hero:FindAbilityByName('ban_chess'):SetActivated(false)
			    hero:FindAbilityByName('ban_chess'):SetHidden(true)
				AddAbilityAndSetLevel(hero,'jiaoxie_wudi_hero')
				AddAbilityAndSetLevel(hero,'wudi')
			    AddAbilityAndSetLevel(hero,'no_hp_add')
			    AddAbilityAndSetLevel(hero,'no_collision')

				--装饰信使
				SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet)

				local init_hp = 100
				GameRules:GetGameModeEntity().stat_info[steam_id] = {
					steam_id = steam_id,
					hp = init_hp,
					player_id = player_id,
					duration = 0,
					rank = 0,
					zhugong = onduty_hero,
					zhugong_model = GameRules:GetGameModeEntity().sm_hero_list[onduty_hero],
					zhugong_effect = onduty_hero_effect,
					round = 0,
					win_round = 0,
					lose_round = 0,
					draw_round = 0,
					kills = 0,
					deaths = 0,
					mmr_level = user_info.mmr_level,
					queen_rank = user_info.queen_rank,
					chess_lineup = '',
					chess_hand = '',
					candy = 0,
					biscuit = 0,
					hero_level = 0,
					buff = '',
					show_buff = '',
					hero_damage = 0,
					hero_damaged = 0,
					p2team = nil,
					team_id = hero:GetTeam(),
					total_money = 0,
					block_team = {},
					ban_synergy = nil,
				}

				hero.steam_id = steam_id
				hero.onduty_hero = onduty_hero

				hero:MoveToPosition(hero:GetAbsOrigin())
				
			end
			GameRules:GetGameModeEntity().user_info = user_info_table
			CustomNetTables:SetTableValue( "dac_table", "player_info", { info = user_info_table, hehe = RandomInt(1,1000)})
			StartGame()
			Timers:CreateTimer(3,function()
				if GetMapName() == 'casual_2x4_ob' or GetMapName() == 'casual_2x4' or GetMapName() == 'ranked_2x4' then
					local p2_result = InitP2Mode()
					if p2_result == true then
						prt('#mode_2p')
					else
						if GameRules:GetGameModeEntity().myself ~= true then
							prt('#mode_2p_invalid_player_count')

							GameRules:GetGameModeEntity().is_game_ended = true
							prt('GAME OVER')

							Timers:CreateTimer(5,function()
								GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
							end)
						end
					end
				end
			end)
		end
	end, function()
		--连接服务器失败了，用默认信使玩
		prt('CONNECT SERVER ERROR')
		if GetDedicatedServerKeyV2('hehe') == 'Invalid_NotOnDedicatedServer' then
			prt('对不起，有玩家没有获得内测资格，游戏无法开始。')
			GameRules:GetGameModeEntity().is_game_ended = true
			prt('GAME OVER')
			Timers:CreateTimer(0.1,function()
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
			end)
			return
		end

		local user_info_table = {}
		is_game_can_start = true
		local steamid_table = string.split(GameRules:GetGameModeEntity().steamidlist_heroindex,',')
		--默认玩家数据
		for _,v in pairs(steamid_table) do 
			local steamid = string.split(v,'_')[1]
			local hero_index = string.split(v,'_')[2]
			local hero = EntIndexToHScript(tonumber(hero_index))
			user_info_table[steamid] = {
				steamid = steamid,
				candy = 0,
				biscuit = 0,
				mmr = 0,
				match = 0,
				zhugong = {
					[1] = "h001_e000"
				},
				onduty_hero = "h001_e000",
				mmr_level = 0,
				hero_index = tonumber(hero_index),
			}
		end

		for steam_id,user_info in pairs(user_info_table) do
			local hero_index = user_info.hero_index
			local hero = EntIndexToHScript(hero_index)
			local player_id = hero:GetPlayerID()
			user_info['player_id'] = player_id
			hero.steam_id = steam_id
			if GameRules:GetGameModeEntity().steamid2name[steam_id] ~= nil then
				hero.player_name = GameRules:GetGameModeEntity().steamid2name[steam_id]
			end

			local onduty_hero_long = user_info.onduty_hero
			local onduty_hero = string.split(onduty_hero_long,'_')[1]
			local onduty_hero_effect = string.split(onduty_hero_long,'_')[2] or ''
			local onduty_hero_projectile = string.split(onduty_hero_long,'_')[4] or ''
			local onduty_hero_pet = string.split(onduty_hero_long,'_')[5] or ''

			user_info['onduty_hero'] = onduty_hero
			user_info['onduty_hero_effect'] = onduty_hero_effect


			AddAbilityAndSetLevel(hero,'pick_chess')
			AddAbilityAndSetLevel(hero,'recall_chess')
		    AddAbilityAndSetLevel(hero,'remove_chess')
		    AddAbilityAndSetLevel(hero,'summon_hero')
		    AddAbilityAndSetLevel(hero,'exp_book')
		    AddAbilityAndSetLevel(hero,'transfer_chess')
			hero:FindAbilityByName('transfer_chess'):SetHidden(true)
			AddAbilityAndSetLevel(hero,'disarm_chess')
			hero:FindAbilityByName('disarm_chess'):SetActivated(false)
			AddAbilityAndSetLevel(hero,'ban_chess')
			hero:FindAbilityByName('ban_chess'):SetActivated(false)
			hero:FindAbilityByName('ban_chess'):SetHidden(true)
			AddAbilityAndSetLevel(hero,'jiaoxie_wudi_hero')
			AddAbilityAndSetLevel(hero,'wudi')
		    AddAbilityAndSetLevel(hero,'no_hp_add')
		    AddAbilityAndSetLevel(hero,'no_collision')



			--装饰信使
			SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet)

			local init_hp = 100
			GameRules:GetGameModeEntity().stat_info[steam_id] = {
				steam_id = steam_id,
				hp = init_hp,
				player_id = player_id,
				duration = 0,
				rank = 0,
				zhugong = onduty_hero,
				zhugong_model = GameRules:GetGameModeEntity().sm_hero_list[onduty_hero],
				zhugong_effect = onduty_hero_effect,
				round = 0,
				win_round = 0,
				lose_round = 0,
				draw_round = 0,
				kills = 0,
				deaths = 0,
				mmr_level = user_info.mmr_level,
				queen_rank = user_info.queen_rank,
				chess_lineup = '',
				chess_hand = '',
				candy = 0,
				biscuit = 0,
				hero_level = 0,
				buff = '',
				show_buff = '',
				hero_damage = 0,
				hero_damaged = 0,
				p2team = nil,
				team_id = hero:GetTeam(),
				total_money = 0,
				block_team = {},
				ban_synergy = nil,
			}

			hero.steam_id = steam_id
			hero.onduty_hero = onduty_hero

			hero:MoveToPosition(hero:GetAbsOrigin())
			
		end
		GameRules:GetGameModeEntity().user_info = user_info_table
		CustomNetTables:SetTableValue( "dac_table", "player_info", { info = user_info_table, hehe = RandomInt(1,1000)})
		StartGame()
		Timers:CreateTimer(3,function()
			if GetMapName() == 'casual_2x4_ob' or GetMapName() == 'casual_2x4' or GetMapName() == 'ranked_2x4' then
				local p2_result = InitP2Mode()
				if p2_result == true then
					prt('#mode_2p')
				else
					if GameRules:GetGameModeEntity().myself ~= true then
						prt('#mode_2p_invalid_player_count')

						GameRules:GetGameModeEntity().is_game_ended = true
						prt('GAME OVER')

						Timers:CreateTimer(5,function()
							GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
						end)
					end
				end
			end
		end)
	end)
end
--2、自动选英雄后给主公加技能
function DAC:OnPlayerPickHero(keys)
	if IsServer() == true then
		local player = EntIndexToHScript(keys.player)
	    local hero = EntIndexToHScript(keys.heroindex)
	    local children = hero:GetChildren()
	    for k,child in pairs(children) do
	       if child:GetClassname() == "dota_item_wearable" then
	           child:RemoveSelf()
	       end
	    end
	    for slot=0,9 do
			if hero:GetItemInSlot(slot)~= nil then
				hero:RemoveItem(hero:GetItemInSlot(slot))
			end
		end
	    hero:SetHullRadius(1)
	    hero:SetAbilityPoints(0)
	    for i=1,16 do
	    	hero:RemoveAbility("empty"..i)
	    end
		hero:SetMana(0)
		hero:SetStashEnabled(false)

		hero.team = hero:GetTeam()
		hero.team_id = hero:GetTeam()
		hero.is_auto_combine = 1

		--设置玩家颜色
		-- PlayerResource:SetCustomPlayerColor(hero:GetPlayerID(),GameRules:GetGameModeEntity().team_color[hero:GetTeam()].r,GameRules:GetGameModeEntity().team_color[hero:GetTeam()].g,GameRules:GetGameModeEntity().team_color[hero:GetTeam()].b)


		GameRules:GetGameModeEntity().team2playerid[hero:GetTeam()] = player:GetPlayerID()
		GameRules:GetGameModeEntity().counterpart[hero:GetTeam()] = 0
		GameRules:GetGameModeEntity().playerid2team[player:GetPlayerID()] = hero:GetTeam()

		--将所有玩家的英雄存到一个数组
		local heroindex = keys.heroindex
	    GameRules:GetGameModeEntity().hero[heroindex] = EntIndexToHScript(heroindex)
	    GameRules:GetGameModeEntity().playerid2hero[player:GetPlayerID()] = EntIndexToHScript(heroindex)
	    GameRules:GetGameModeEntity().teamid2hero[hero:GetTeam()] = EntIndexToHScript(heroindex)
	    local playercount = 0
	    for i,vi in pairs(GameRules:GetGameModeEntity().hero) do
	    	playercount = playercount +1
	    end

	    local all_playing_player_count = GetPlayingPlayerCount()
	    combat("PLAYER JOINED: "..playercount.."/"..GameRules:GetGameModeEntity().playing_player_count)

	    if playercount == all_playing_player_count then
	    	InitPlayerIDTable()

	    	Timers:CreateTimer(0.1,function()
	    		-- EmitGlobalSound("diretide.begin")
	    		EmitGlobalSound('dac.season.gamestart')
	    		-- Timers:CreateTimer(4,function()
	    		-- 	EmitGlobalSound("welcome.crystal_maiden")
	    		-- end)
	    		UpdatePlayerWorldPanel()
	    		InitHeros()
	    	end)
	    end 
	end
end
--英雄升级
function DAC:OnPlayerGainedLevel(keys)
	local i = 0
	for i = 6, 13 do
		GameRules:GetGameModeEntity().population_max[i] = GetMaxChessCount(i)
		if GameRules:GetGameModeEntity().egg_quest == 'q013' and GameRules:GetGameModeEntity().population_max[i] >= 10 then
			SetQuest(i,true)
		end

		local hero = TeamId2Hero(i)

		if hero ~= nil then 
			hero:SetAbilityPoints(0)
			local level = hero:GetLevel()
			SetStat(hero:GetPlayerID(),'hero_level',level)
			-- for j=1,10 do
			-- 	if hero:FindAbilityByName('hero_level_'..j) ~= nil then
			-- 		hero:RemoveAbility('hero_level_'..j)
			-- 		hero:RemoveModifierByName('modifier_hero_level'..j)
			-- 	end
			-- end
			local summon_level = level
			if summon_level > 10 then
				summon_level = 10
			end
			AddAbilityAndSetLevel(hero,'summon_hero',summon_level)
		end

		--同步ui人口
		CustomGameEventManager:Send_ServerToTeam(i,"population",{
			key = GetClientKey(i),
			max_count = GameRules:GetGameModeEntity().population_max[i],
			count = GameRules:GetGameModeEntity().population[i],
		})

	end
end

--每次连接后保存userid到player的映射关系
function DAC:OnPlayerConnectFull(keys)
	-- prt('[OnPlayerConnectFull] PlayerID='..keys.PlayerID..',userid='..keys.userid..',index='..keys.index)

	GameRules:GetGameModeEntity().playerid2steamid[keys.PlayerID] = tostring(PlayerResource:GetSteamID(keys.PlayerID))
	GameRules:GetGameModeEntity().steamid2playerid[tostring(PlayerResource:GetSteamID(keys.PlayerID))] = keys.PlayerID
	GameRules:GetGameModeEntity().steamid2name[tostring(PlayerResource:GetSteamID(keys.PlayerID))] = tostring(PlayerResource:GetPlayerName(keys.PlayerID))
	GameRules:GetGameModeEntity().userid2player[keys.userid] = keys.index+1

	GameRules:GetGameModeEntity().connect_state[keys.PlayerID] = true
	if GameRules:GetGameModeEntity().isConnected[keys.index + 1] == true then
		local hero = PlayerId2Hero(keys.PlayerID)
		if hero ~= nil then
			hero.is_auto_combine = 1
		end

		if hero.loot_table ~= nil then
			--如果有弹出的战利品选择，重新显示它
			local loot_str = ''
			for _,v in pairs(hero.loot_table) do
				loot_str = loot_str..v..','
			end

			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_loot_box",{
				key = GetClientKey(hero:GetTeam()),
				loot_list = loot_str,
			})
		end

		--重连
		CustomGameEventManager:Send_ServerToAllClients("player_reconnect",{
			id = keys.PlayerID,
			hehe = RandomFloat(1,10000),
		})

		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_reconnect",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})

		Timers:CreateTimer(RandomFloat(0.1,0.5),function()
			CustomNetTables:SetTableValue( "dac_table", "player_info", {info = GameRules:GetGameModeEntity().user_info, hehe = RandomInt(1,1000)})
			if hero ~= nil then
				Timers:CreateTimer(RandomFloat(0.1,0.5),function()
					SetStat(hero:GetPlayerID(),'hp',hero:GetHealth())
					CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,1000)})

					--同步ui血量
					CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
						player_id = hero:GetPlayerID(),
						hp = hero:GetHealth(),
						hp_max = hero:GetMaxHealth(),
						mp = hero:GetMana(),
						level = hero:GetLevel(),
						win_streak = hero.win_streak,
					})
				end)
			end
		end)
		Timers:CreateTimer(RandomFloat(0.1,1),function()
			CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,1000)})

			--同步ui血量
			for i=0,GameRules:GetGameModeEntity().playing_player_count-1 do
				local h = PlayerId2Hero(i)
				if h ~= nil and h:IsNull() == false and h:IsAlive() == true then
					CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"sync_hp",{
						player_id = i,
						hp = h:GetHealth(),
						hp_max = h:GetMaxHealth(),
						mp = h:GetMana(),
						level = h:GetLevel(),
						win_streak = h.win_streak,
					})
				else
					CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"sync_hp",{
						player_id = i,
						hp = 0,
						hp_max = 100,
						mp = h:GetMana(),
						level = h:GetLevel(),
						win_streak = h.win_streak,
					})
				end
			end
		end)
		if hero == nil then
			return
		end
		GameRules:GetGameModeEntity().population_max[hero:GetTeam()] = hero:GetLevel()
		
		--同步ui人口
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"population",{
			key = GetClientKey(hero:GetTeam()),
			max_count = GameRules:GetGameModeEntity().population_max[hero:GetTeam()],
			count = GameRules:GetGameModeEntity().population[hero:GetTeam()],
		})
		Timers:CreateTimer(RandomFloat(0.1,0.5),function()
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_gold",{
				key = GetClientKey(hero:GetTeam()),
				gold = hero:GetMana(),
				lose_streak = hero.lose_streak or 0,
				win_streak = hero.win_streak or 0,
			})
			--同步ui血量
			CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
				player_id = hero:GetPlayerID(),
				hp = hero:GetHealth(),
				hp_max = hero:GetMaxHealth(),
				mp = hero:GetMana(),
				level = hero:GetLevel(),
				win_streak = hero.win_streak,
			})
		end)
		Timers:CreateTimer(RandomFloat(0.1,0.5),function()
			local cardstr = ''
			for _,card in pairs(hero.curr_chess_table) do
				cardstr = cardstr..card..','
			end
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_draw_card",{
				key = GetClientKey(hero:GetTeam()),
				cards = cardstr,
				curr_money = hero:GetMana(),
				key = GetClientKey(hero:GetTeam()),
			})
		end)
		hero.isDisconnected = false
	end
	GameRules:GetGameModeEntity().isConnected[keys.index+1] = true
end
--断线
function DAC:OnPlayerDisconnect(keys)
	if IsServer() then
		local hero = PlayerId2Hero(keys.PlayerID)
		if hero == nil then
			return
		end
		hero.isDisconnected = true
		GameRules:GetGameModeEntity().connect_state[keys.PlayerID] = false
		CustomNetTables:SetTableValue( "dac_table", "disconnect", 
			{ 
				table = GameRules:GetGameModeEntity().connect_state,
				hehe = RandomInt(1,100000)
			} 
		)

		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_disconnect",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})

		-- CustomGameEventManager:Send_ServerToAllClients("player_disconnect",{
		-- 	disconnectid = keys.PlayerID
		-- })
	end
end

function StatAllPlayerLineup()
	for team_i=6,13 do
		local hero = TeamId2Hero(team_i)
		if IsUnitExist(hero) == true and hero.steam_id ~= nil then
			local lineup_count = 0
			local lineup = ''
			local chess_5 = 0
			for _,v in pairs(GameRules:GetGameModeEntity().mychess[team_i]) do
				if v ~= nil and v.chess ~= nil and lineup_count < hero:GetLevel() then 
					lineup = lineup..v.chess..','
					lineup_count = lineup_count + 1

					local cname = GetChessBaseName(v.chess)
					local ccost = GameRules:GetGameModeEntity().chess_2_mana[cname]
					if ccost == 5 then
						chess_5 = chess_5 + 1
					end
				end
			end
			if GameRules:GetGameModeEntity().egg_quest == 'q029' and chess_5 >= 3 then
				SetQuest(team_i,true)
			end
			SetStat(hero:GetPlayerID(),'chess_lineup',lineup,false)

			local hands = ''
			if hero.hand_entities ~= nil then
				for _,ent in pairs(hero.hand_entities) do
					if ent ~= nil and ent:IsNull() == false then
						hands = hands..ent:GetUnitName()..','
					end
				end
			end
			SetStat(hero:GetPlayerID(),'chess_hand',hands,false)
		end
	end
end

--容错：检查有没有2P队友没一起死的，杀死他
function CheckP2Status()
	if GameRules:GetGameModeEntity().p2_mode == true then
		for i,v in pairs(GameRules:GetGameModeEntity().p2_player) do
			if table.maxn(v) > 0 and v[1] ~= nil and v[2] ~= nil and TeamId2Hero(v[1]) ~= nil and TeamId2Hero(v[2]) ~= nil then
				if TeamId2Hero(v[1]):IsAlive() == false and TeamId2Hero(v[2]):IsAlive() == true then
					--杀死v[2]
					local hh = TeamId2Hero(v[2])
					hh:ForceKill(false)
					GameRules:GetGameModeEntity().counterpart[hh:GetTeam()] = -1
					SyncHP(hh)

				end
				if TeamId2Hero(v[2]):IsAlive() == false and TeamId2Hero(v[1]):IsAlive() == true then
					--杀死v[1]
					local hh = TeamId2Hero(v[1])
					hh:ForceKill(false)
					GameRules:GetGameModeEntity().counterpart[hh:GetTeam()] = -1
					SyncHP(hh)
				end
			end
		end
	end
end
function CheckEndingStatus()
	local live_count = GetAlivePlayerCount()
	local last_steamid = GameRules:GetGameModeEntity().send_status[1]
	local last_hero = PlayerId2Hero(GameRules:GetGameModeEntity().steamid2playerid[last_steamid])
	if GameRules:GetGameModeEntity().playing_player_count > 1 then
		--1P
		if GameRules:GetGameModeEntity().p2_mode ~= true and live_count <= 1 and last_hero ~= nil then
			SetPlayerDead(last_hero)
		end
		--2P
		if GameRules:GetGameModeEntity().p2_mode == true and GetAlivePlayerCount() <= 2 then
			if last_hero ~= nil then
				SetPlayerDead(last_hero)
				if GetP2Ally(last_hero:GetTeam()) ~= nil and TeamId2Hero(GetP2Ally(last_hero:GetTeam())) ~= nil then
					local hh = TeamId2Hero(GetP2Ally(last_hero:GetTeam()))
					SetPlayerDead(hh)
				end
			end
		end
	end
end
function PrecacheAUnit(delay,unitname)
	Timers:CreateTimer(delay,function()
		PrecacheUnitByNameAsync(unitname,function()
		end)
	end)
end
--游戏循环1——开始一轮准备回合
function StartAPrepareRound()
	if GameRules:GetGameModeEntity().is_game_ended == true then
		return
	end

	UpdatePlayerWorldPanel()
	CheckEndingStatus()
	CheckP2Status()
	-- StatChess()
	PostPlayerInfo()

	--野怪提醒
	if GameRules:GetGameModeEntity().battle_round == 15 then
		Timers:CreateTimer(5,function()
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			EmitGlobalSound('warning.wolf')
			for team_id = 6,13 do
		    	SayCheerBubble(team_id, nil, 'creep', 1)
		    end
		end)
	end
	if GameRules:GetGameModeEntity().battle_round == 35 then
		Timers:CreateTimer(5,function()
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			EmitGlobalSound('warning.qianjiaomonv')
			for team_id = 6,13 do
		    	SayCheerBubble(team_id, nil, 'creep', 1)
		    end
		end)
	end
	if GameRules:GetGameModeEntity().battle_round == 50 then
		Timers:CreateTimer(5,function()
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			EmitGlobalSound('warning.tangyimaowang')
			for team_id = 6,13 do
		    	SayCheerBubble(team_id, nil, 'creep', 1)
		    end
		end)
		
	end
	--加载棋子
	if GameRules:GetGameModeEntity().battle_round < 5 then
		for k,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana[GameRules:GetGameModeEntity().battle_round+1]) do
			PrecacheAUnit(k,v)
    	end
	end
	if GameRules:GetGameModeEntity().battle_round >= 5 and GameRules:GetGameModeEntity().battle_round < 7 then
		for k,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana[GameRules:GetGameModeEntity().battle_round-1]) do
			PrecacheAUnit(k,v..'1')
    	end
	end
	if GameRules:GetGameModeEntity().battle_round >= 7 and GameRules:GetGameModeEntity().battle_round < 12 then
		for k,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana[GameRules:GetGameModeEntity().battle_round-6]) do
			PrecacheAUnit(k,v..'11')
    	end
	end
	if GameRules:GetGameModeEntity().battle_round == 12 then
		for k,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana_gold) do
			PrecacheAUnit(k,v)
    	end
    end
    if GameRules:GetGameModeEntity().battle_round == 13 then
		for k,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana_gold) do
			PrecacheAUnit(k,v..'1')
    	end
    end
    if GameRules:GetGameModeEntity().battle_round == 14 then
		for k,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana_gold) do
			PrecacheAUnit(k,v..'11')
    	end
    end
    
	--50回合以后，疲劳
	if GameRules:GetGameModeEntity().battle_round > GameRules:GetGameModeEntity().pilao_round then
		for _,heroent in pairs (GameRules:GetGameModeEntity().hero) do
			if heroent ~= nil and heroent:IsNull() == false and heroent:IsAlive() == true then
				local bite_hp = math.floor(heroent:GetHealth() / 2)
				local after_hp = heroent:GetHealth() - bite_hp
				if after_hp <= 0 then
					after_hp = 0
				end
				prt('#text_grand_final_pilao')
				EmitSoundOn('diretide_select_target_Stinger',heroent)
				play_particle("particles/econ/items/legion/legion_overwhelming_odds_ti7/legion_commander_odds_ti7_proj_hit_streaks.vpcf",PATTACH_ABSORIGIN_FOLLOW,heroent,3)
				if after_hp <= 0 then
					--死了
					heroent:ForceKill(false)
					GameRules:GetGameModeEntity().counterpart[heroent:GetTeam()] = -1
					SyncHP(heroent)
					AMHC:CreateNumberEffect(heroent,bite_hp,2,AMHC.MSG_MISS,"red",9)
					return
				end
				heroent:SetHealth(after_hp)
				SyncHP(heroent)
				AMHC:CreateNumberEffect(heroent,bite_hp,2,AMHC.MSG_MISS,"red",9)
				-- EmitSoundOn("Frostivus.PointScored.Enemy",hero)
				EmitSoundOn("diretide.sad",hero)
				
			end
		end		
	end
	
	--显示玩家排名
	CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,1000)})
	
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"battle_info",{
			key = GetClientKey(team_i),
			type = "prepare",
			round = GameRules:GetGameModeEntity().battle_round,
		})
	end

	CustomNetTables:SetTableValue( "game_info", "round_info", { round = GameRules:GetGameModeEntity().battle_round } )

	local alldead = true
	for i,v in pairs (GameRules:GetGameModeEntity().counterpart) do
		if v ~= -1 then
			local hhh = TeamId2Hero(i)
			RemoveAbilityAndModifier(hhh,'is_priest_buff')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_plus')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_plus_plus')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_courier')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_courier_plus')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_courier_plus_plus')
			if hhh.hand_entities ~= nil then
				for _,ent in pairs(hhh.hand_entities) do
					if ent ~= nil and ent:IsNull() == false then
						ent:RemoveAbility('outofgame')
						ent:RemoveModifierByName('modifier_outofgame')
					end
				end
			end
			if GameRules:GetGameModeEntity().battle_round >= 35 and GameRules:GetGameModeEntity().egg_quest == 'q006' then
				SetQuest(hhh.team_id,true)
			end
			alldead = false
		end
	end
	if alldead == true then
		--所有玩家都死亡了，不开始准备回合了
		return
	end

	--决定准备回合时长
	GameRules:GetGameModeEntity().prepare_timer = 35
	if GetMapName() == 'casual_2x4_ob' or GetMapName() == 'casual_2x4' or GetMapName() == 'ranked_2x4' then
		GameRules:GetGameModeEntity().prepare_timer = 40
	end

	if GameRules:GetGameModeEntity().custom_round_time ~= nil then
		GameRules:GetGameModeEntity().prepare_timer = GameRules:GetGameModeEntity().custom_round_time
	end

	--正式开始准备回合
	GameRules:SetTimeOfDay(0.8)
	EmitGlobalSound("Loot_Drop_Stinger_Legendary")
	GameRules:GetGameModeEntity().game_status = 1
	GameRules:GetGameModeEntity().start_ai = false

	Timers:CreateTimer(function()
		if GameRules:GetGameModeEntity().prepare_timer <= 10 and GameRules:GetGameModeEntity().prepare_timer > 5 then
			--5~10秒，倒计时音效
			-- EmitGlobalSound("diretide.countdown")
			EmitGlobalSound("dac.season.countdown")
		end

		local center_index = ''..Entities:FindByName(nil,"center0"):entindex()..','..Entities:FindByName(nil,"center1"):entindex()..','..Entities:FindByName(nil,"center2"):entindex()..','..Entities:FindByName(nil,"center3"):entindex()..','..Entities:FindByName(nil,"center4"):entindex()..','..Entities:FindByName(nil,"center5"):entindex()..','..Entities:FindByName(nil,"center6"):entindex()..','..Entities:FindByName(nil,"center7"):entindex()
		--发送当前游戏时间给客户端
		UpdateTimer()
		if GameRules:GetGameModeEntity().prepare_timer > 5 then
			for team_i=6,13 do
				CustomGameEventManager:Send_ServerToTeam(team_i,"show_time",{
					key = GetClientKey(team_i),
					timer_round = GameRules:GetGameModeEntity().prepare_timer - 5,
					round_status = "prepare",
					total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
					center_index = center_index,
				})
			end
			CustomGameEventManager:Send_ServerToTeam(1,"show_time",{
				key = GetClientKey(1),
				timer_round = GameRules:GetGameModeEntity().prepare_timer - 5,
				total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
				center_index = center_index,
				round_status = "prepare",
			})
		else
			for team_i=6,13 do
				CustomGameEventManager:Send_ServerToTeam(team_i,"show_time",{
					key = GetClientKey(team_i),
					timer_round = GameRules:GetGameModeEntity().prepare_timer,
					round_status = "ready",
					total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
					center_index = center_index,
				})
			end
			CustomGameEventManager:Send_ServerToTeam(1,"show_time",{
				key = GetClientKey(1),
				timer_round = GameRules:GetGameModeEntity().prepare_timer,
				total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
				center_index = center_index,
				round_status = "ready",
			})
		end

		if GameRules:GetGameModeEntity().prepare_timer <= 5 then
			--5秒，准备战斗
			if GameRules:GetGameModeEntity().prepare_timer == 5 then
				--通知UI初始化胜负显示
				for team_i=6,13 do
					CustomGameEventManager:Send_ServerToTeam(team_i,"clear_round_win_lose",{
						key = GetClientKey(team_i),
					})
				end
				CustomGameEventManager:Send_ServerToTeam(1,"clear_round_win_lose",{
						key = GetClientKey(1),
					})

				-- if GameRules:GetGameModeEntity().battle_round == 50 then

				-- 	Timers:CreateTimer(1,function()
				-- 		EmitGlobalSound("diretide.darkwillow")
				-- 	end)
				-- end

				for team_i=6,13 do
					ShowStarsOnAllChess(team_i)
				end
				EmitGlobalSound("GameStart.DireAncient")
				-- EmitGlobalSound("GameStart.RadiantAncient")

				if GameRules:GetGameModeEntity().battle_boss[GameRules:GetGameModeEntity().battle_round] ~= nil then
					ShowCombat({
						t = 'round_pve',
						text = GameRules:GetGameModeEntity().battle_round
					})
				else
					ShowCombat({
						t = 'round_pvp',
						text = GameRules:GetGameModeEntity().battle_round
					})

					--分配对手
					if GameRules:GetGameModeEntity().p2_mode == true then
						AllocateP2Counterpart()
					else
						AllocateABattleRoundV3()
					end
				end
				Timers:CreateTimer(3,function()
					ShowBattleInfo()
				end)
			end

			if GameRules:GetGameModeEntity().prepare_timer == 3 then
				--4秒，踢回多的棋子
				RandomRecallChess()
			end
			
			for i,v in pairs (GameRules:GetGameModeEntity().hero) do
				CancelPickChess(v)
				v:FindAbilityByName('pick_chess'):SetActivated(false)
				v:FindAbilityByName('recall_chess'):SetActivated(false)
			end
		end
		if GameRules:GetGameModeEntity().prepare_timer <= 0 then
			--0秒，开始战斗AI
			Timers:CreateTimer(1,function()
				GameRules:GetGameModeEntity().battle_round = GameRules:GetGameModeEntity().battle_round + 1
				Timers:CreateTimer(1,function()
					GameRules:GetGameModeEntity().start_ai = true
				end)
			end)
			return
		end
		if GameRules:GetGameModeEntity().prepare_timer == 2 then
			--2秒，开始战斗回合
			GameRules:GetGameModeEntity().game_status = 2
			StartABattleRound()
		end

		GameRules:GetGameModeEntity().prepare_timer = GameRules:GetGameModeEntity().prepare_timer - 1
		return 1
	end)
	Timers:CreateTimer(0.3,function()
		if GameRules:GetGameModeEntity().battle_round == 1 then
			--第1回合显示退出按钮
			for team_i=6,13 do
				CustomGameEventManager:Send_ServerToTeam(team_i,"show_liuju",{
					key = GetClientKey(team_i),
					hehe = RandomInt(1,100000)
				})
			end
		end
		--第2-3回合判断流局
		if GameRules:GetGameModeEntity().battle_round == 2 then
			local liuju_player_count = 0
			for _,h in pairs(GameRules:GetGameModeEntity().hero) do
				if h == nil or h:IsNull() == true or h:IsAlive() == false or h.isDisconnected == true or h.isSuggestLiuju == true then
					liuju_player_count = liuju_player_count + 1
				end
			end
			if liuju_player_count >= GameRules:GetGameModeEntity().playing_player_count/2.0 then
				--流局
				prt('#txt_liuju_go')
				--EmitGlobalSound("Frostivus.PointScored.Enemy")
				EmitGlobalSound("dac.season.liuju")
				GameRules:GetGameModeEntity().is_game_ended = true
				prt('GAME OVER')
				PostGame()
				Timers:CreateTimer(3,function()
					GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
				end)
				return
			end
		end
		if GameRules:GetGameModeEntity().battle_round == 3 or GameRules:GetGameModeEntity().battle_round == 4 then
			--第3回合移除退出按钮
			for team_i=6,13 do
				CustomGameEventManager:Send_ServerToTeam(team_i,"hide_liuju",{
					key = GetClientKey(team_i),
					hehe = RandomInt(1,100000)
				})
				-- local hh = TeamId2Hero(team_i)
				-- if IsUnitExist(hh) then
				-- 	hh:FindAbilityByName('ban_chess'):SetActivated(true)
				-- end
				EnableBanChess()
			end
		end
		for i,v in pairs(GameRules:GetGameModeEntity().hero) do
			if IsUnitExist(v) == true and v.is_banned == true then
				KillSelfTeam(v:GetTeam(),true)
			elseif IsUnitExist(v) == true then
				AddPickAndRemoveAbility(v)
				if v ~= nil then 
					local level = v:GetLevel()
					AddAbilityAndSetLevel(v,'summon_hero',level)
				end

				v.is_battle_completed = nil

				Timers:CreateTimer(1,function()
					--给蓝
					local mana = math.floor(GameRules:GetGameModeEntity().battle_round/2+0.5)
					if mana> 5 then
						mana = 5
					end

					local lixi = math.floor(v:GetMana()/10)
					if lixi > 5 then
						lixi = 5
					end
					if lixi == 5 and GameRules:GetGameModeEntity().egg_quest == 'q031' then
						SetQuest(v:GetTeam(),true)
					end
					mana = mana + lixi

					local anwei = math.floor(((v.lose_streak or 0)+3)/2 ) - 2
					if anwei < 0 then
						anwei = 0
					end
					if anwei > 3 then
						anwei = 3
					end
					mana = mana + anwei

					local jiangli = math.floor(((v.win_streak or 0)+3)/2 ) - 2
					if jiangli < 0 then
						jiangli = 0
					end
					if jiangli > 3 then
						jiangli = 3
					end
					mana = mana + jiangli
					AddMana(v, mana)
					AddTotalMoneyStat(v:GetPlayerID(), mana)
				end)
				Timers:CreateTimer(0.5,function()
					--自动抽卡一次
					Draw5ChessAndShow(v:GetTeam(), false)
				end)
				
				--给一点经验
				if GameRules:GetGameModeEntity().battle_round ~= 1 then
					if v:GetLevel() < 10 then
						v:AddExperience(1,0,false,false)					
					end
					if v:GetLevel() >= 10 then
						v:FindAbilityByName('exp_book'):SetActivated(false)						
					end
				end

				GameRules:GetGameModeEntity().damage_stat[v:GetTeam()] = {}

				--熊猫人钓鱼
				Timers:CreateTimer(0.5,function()
					Fish(v)
				end)
				--人类经验
				if GetHumanCount(v:GetTeam()) >= 3 then
					AddItemPlus(v,'item_zhishizhishu')
					EmitSoundOn("is_human.magic",hero)
				end
				-- if GetHumanCount(v:GetTeam()) >= 6 then
				-- 	AddItemPlus(v,'item_zhishizhishu')
				-- end
			end
		end
	end)
end

--钓鱼
function Fish(hero)
	local team_id = hero:GetTeam()
	local pandaman_count = GetPandamanCount(team_id)
	if pandaman_count == 1 then
		RandomAFish(team_id,1)
	elseif pandaman_count >= 2 then
		RandomAFish(team_id,2)
	end
	if pandaman_count >= 3 then
		Timers:CreateTimer(0.5,function()
			RandomAFish(team_id,3)
		end)
	end
end
function RandomAFish(team_id,pandaman_count)
	local v = TeamId2Hero(team_id)
	local pandaman_set = {
		[1] = 'chess_ember',
		[2] = 'chess_brew',
		[3] = 'chess_storm',
		[4] = 'chess_earth',
	}
	local fish_dice_table = {
		[1] = 10,
		[2] = 25,
		[3] = 50,
	}
	local fish_pandaman_dice_table = {
		[1] = 70,
		[2] = 70,
		[3] = 100,
	}
	local fish_dice = fish_dice_table[pandaman_count] or 0
	local fish_pandaman_dice = fish_pandaman_dice_table[pandaman_count] or 0
	if pandaman_count <= 3 then
		fish_dice = fish_dice * GetFishAfricaValue(v)
	end

	--整理base table，统计场上已有棋子
	local chess_base_table = {}
	for _,chess in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		local base_name = chess.chess
		if string.find(base_name,'11') ~= nil then
			base_name = string.sub(base_name,1,-2)
		end
		if string.find(base_name,'1') ~= nil then
			base_name = string.sub(base_name,1,-2)
		end
		table.insert(chess_base_table,base_name)
	end

	local ran_chess = nil
	local dice = RandomFloat(1,100)
	if dice < fish_dice then
		--有鱼上钩了！
		local table_11chess = Get11ChessBaseNameTable(team_id)
		local trytime = 0
		if RandomInt(1,100) < fish_pandaman_dice and v.synergy_banned ~= 'is_pandaman' then
			--先考虑钓熊猫人
			trytime = 0
			while trytime < 100 and ran_chess == nil do
				ran_chess = pandaman_set[RandomInt(1,table.maxn(pandaman_set))]
				if GetChessClass(ran_chess) == v.synergy_banned then
					--排除ban的职业
					ran_chess = nil
				end
				if FindValueInTable(table_11chess,ran_chess) == true then
					--排除已经三星的棋子
					ran_chess = nil
				end
				trytime = trytime + 1
			end
		elseif fish_pandaman_dice < 100 then
			--后考虑钓同种族棋子
			trytime = 0
			while trytime < 100 and ran_chess == nil do
				trytime = trytime + 1
				local ran_host = chess_base_table[RandomInt(1,table.maxn(chess_base_table))]
				local ran_race,ran_race2 = GetChessRace(ran_host)
				if ran_race2 ~= nil and RandomInt(1,100) < 50 then
					--用种族2
					ran_race = ran_race2
				end

				if ran_race ~= v.synergy_banned then
					local race_table = GameRules:GetGameModeEntity().chess_list_by_synergy[ran_race]
					local ran_a_chess = race_table[RandomInt(1,table.maxn(race_table))]
					ran_chess = ran_a_chess
					local ran_race_check,ran_race2_check = GetChessRace(ran_chess)
					if v.synergy_banned ~= nil and (ran_race_check == v.synergy_banned or ran_race2_check == v.synergy_banned) then
						--排除ban的种族
						ran_chess = nil
					end
					if GetChessClass(ran_a_chess) == v.synergy_banned then
						--排除ban的职业
						ran_chess = nil
					end
					if FindValueInTable(table_11chess,ran_chess) == true then
						--排除已经三星的棋子
						ran_chess = nil
					end
				end
			end
		end
	end

	if ran_chess ~= nil then
		InitFishAfricaValue(v)
	else
		AddFishAfricaValue(v)
	end

	if ran_chess ~= nil then
		PlayRandomFishDiague(team_id)
		local cost = GetChessCostByName(ran_chess)
		if cost ~= nil and cost > 0 then
			--从棋库中移除
			RemoveOneKeyInTable(GameRules:GetGameModeEntity().chess_pool[cost],ran_chess)
		end
		Timers:CreateTimer(2,function()
			--创建鱼棋子，播动画
			local cc = CreateChessInHand(v,ran_chess,nil)
			BlinkChessX({caster=cc,blink_type="fall"})
			--发弹幕：合成棋子
			CustomGameEventManager:Send_ServerToAllClients("bullet",{
				player_id = v:GetPlayerID(),
				vip = v.is_vip,
				win_streak = v.win_streak or 0,
				target = ran_chess,
			})
		end)
	end

	return ran_chess
end
--钓鱼防非概率
function GetFishAfricaValue(hero)
	if hero.fish_africa_value == nil then
		hero.fish_africa_value = -4
	end
	return math.pow(1.1, hero.fish_africa_value) 
end
function InitFishAfricaValue(hero)
	hero.fish_africa_value = -4
end
function AddFishAfricaValue(hero)
	if hero.fish_africa_value == nil then
		hero.fish_africa_value = -4
	end
	hero.fish_africa_value = hero.fish_africa_value + 1
end

function GetChessClass(base_name)
	if base_name == nil then
		return nil
	end
	local class = nil
	for kk,vv in pairs(GameRules:GetGameModeEntity().chess_list_by_synergy) do
		if FindValueInTable(vv,base_name) == true and GameRules:GetGameModeEntity().combo_ability_type[kk]['is_race'] ~= true then
			class = kk
		end
	end
	--特殊的不在卡池的
	if base_name == 'chess_storm' then
		return 'is_mage'
	end
	if base_name == 'chess_ember' then
		return 'is_assassin'
	end
	if base_name == 'chess_earth' then
		return 'is_shaman'
	end
	return class
end
function GetChessRace(base_name)
	if base_name == nil then
		return nil
	end
	local race = nil
	local race2 = nil
	for kk,vv in pairs(GameRules:GetGameModeEntity().chess_list_by_synergy) do
		if FindValueInTable(vv,base_name) == true and GameRules:GetGameModeEntity().combo_ability_type[kk]['is_race'] == true then
			if race == nil then
				race = kk
			else
				race2 = kk
			end
		end
	end
	--特殊的不在卡池的
	if base_name == 'chess_storm' or base_name == 'chess_ember' or base_name == 'chess_earth' then
		return 'is_pandaman'
	end
	return race,race2
end
function PlayRandomFishDiague(team_id,fished_chess)
	local u = FindRandomChessByTeamAndSynergy(team_id,'is_pandaman')
	if IsUnitExist(u) == true then
		PlayChessDialogue(u,'fish')
	end
end

function DAC:OnSuggestLiuju(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)

	if hero == nil then
		return
	end

	if GameRules:GetGameModeEntity().battle_round > 3 then
		return
	end

	if keys.player_id ~= keys.PlayerID then
		hero.is_banned = true
		return
	end

	if hero == nil or hero:IsNull() == true then
		return
	end
	if hero.isSuggestLiuju == nil then
		if hero.steam_id ~= nil then
			prt(GameRules:GetGameModeEntity().steamid2name[hero.steam_id]..' SUGGESTED END GAME.')
		end
		hero.isSuggestLiuju = true

		--更新流局人数
		local liuju_player_count = 0
		for _,h in pairs(GameRules:GetGameModeEntity().hero) do
			if h == nil or h:IsNull() == true or h:IsAlive() == false or h.isDisconnected == true or h.isSuggestLiuju == true then
				if h.is_top_3 ~= nil then
					-- prt('调试信息：一个段位排名前三的玩家 投了票。算2票')
					liuju_player_count = liuju_player_count + 2
				else
					liuju_player_count = liuju_player_count + 1
				end
			end
		end

		for team_i=6,13 do
			CustomGameEventManager:Send_ServerToTeam(team_i,"update_liuju",{
				key = GetClientKey(team_i),
				count = liuju_player_count,
				total = math.ceil(GameRules:GetGameModeEntity().playing_player_count/2),
				hehe = RandomInt(1,100000) 
			})
		end
	
		if liuju_player_count >= math.ceil(GameRules:GetGameModeEntity().playing_player_count/2) then
			--流局
			prt('#txt_liuju_go')
			--EmitGlobalSound("Frostivus.PointScored.Enemy")
			EmitGlobalSound("dac.liuju")
			GameRules:GetGameModeEntity().is_game_ended = true
			prt('GAME OVER')
			PostGame()
			Timers:CreateTimer(3,function()
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
			end)
			return
		end
	end
end

function AddPickAndRemoveAbility(v)
	--野怪回合后给一次拆装备机会
	if GameRules:GetGameModeEntity().battle_round == 11 or
		GameRules:GetGameModeEntity().battle_round == 16 or 
		GameRules:GetGameModeEntity().battle_round == 21 or 
		GameRules:GetGameModeEntity().battle_round == 26 or 
		GameRules:GetGameModeEntity().battle_round == 31 or 
		GameRules:GetGameModeEntity().battle_round == 36 or 
		GameRules:GetGameModeEntity().battle_round == 41 or 
		GameRules:GetGameModeEntity().battle_round == 46 or 
		GameRules:GetGameModeEntity().battle_round == 51 then
		v:FindAbilityByName('disarm_chess'):SetActivated(true)
	end
	Timers:CreateTimer(1.5,function()
		if v:FindAbilityByName('pick_chess') == nil then
			AddAbilityAndSetLevel(v,'pick_chess')
		end
	   	if v:FindAbilityByName('recall_chess') == nil then
	   		AddAbilityAndSetLevel(v,'recall_chess')
	   	end
		if v:FindAbilityByName('remove_chess') == nil then
	    	AddAbilityAndSetLevel(v,'remove_chess')
	    end
		v:FindAbilityByName('pick_chess'):SetActivated(true)
		v:FindAbilityByName('recall_chess'):SetActivated(true)
	end)
	-- v:FindAbilityByName('remove_chess'):SetActivated(true)
end
--游戏循环1.1——清理战斗场地并重新摆上自己的随从
function ShowDamageStatOfTeam(teamid)
	if GameRules:GetGameModeEntity().egg_quest == 'q016' then
		for i,v in pairs(GameRules:GetGameModeEntity().damage_stat[teamid]) do
			if v >= 10000 then
				SetQuest(teamid,true)
			end
		end
	end
	--显示伤害统计
	CustomGameEventManager:Send_ServerToTeam(teamid,"show_damage_stat",{
		key = GetClientKey(teamid),
		damage_table = GameRules:GetGameModeEntity().damage_stat[teamid],
		time_this_level = 51 - GameRules:GetGameModeEntity().battle_timer,
		hehe = RandomInt(1,100000)
	})
end

function RestoreARound(teamid)
	GameRules:GetGameModeEntity().restore_check = true
	ClearARound(teamid)

	--重置英雄身上的装备，使他们归属自己
	-- local hero = TeamId2Hero(teamid)
	-- for slot=0,9 do
	-- 	if hero:GetItemInSlot(slot)~= nil then
	-- 		if hero:GetItemInSlot(slot):GetPurchaser() == nil or hero:GetItemInSlot(slot):GetPurchaser():entindex() ~= hero:entindex() then
	-- 			local name = hero:GetItemInSlot(slot):GetAbilityName()
	-- 			-- hero:RemoveItem(hero:GetItemInSlot(slot))
	-- 			-- Timers:CreateTimer(0.03,function()
	-- 			-- 	hero:AddItemByName(name)
	-- 			-- end)
	-- 		end
	-- 	end
	-- end
	
	Timers:CreateTimer(0.8,function()
		GameRules:GetGameModeEntity().restore_check = false
		local prepare_riki = false
		for _,v in pairs(GameRules:GetGameModeEntity().mychess[teamid]) do
			RestoreOneChess(v,teamid)
		end
		if prepare_riki == true then
			HidePrepare(teamid)
		end
	end)
end

function RestoreOneChess(v,teamid)
	--获取出场动画
	local hero = TeamId2Hero(teamid)
	if IsUnitExist(hero) == false then
		return
	end
	local animation_info = GetAnimation(hero.animation or 'n000')

	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector(v.x,v.y,teamid),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end

			if TeamId2Hero(teamid):IsAlive() ~= true then
				return
			end
			local x = CreateUnitByName(v.chess,XY2Vector(v.x,v.y,teamid),true,nil,nil,teamid)
			if string.find(v.chess,'riki') ~= nil then
				prepare_riki = true
			end
			MakeTiny(x)
			table.insert(GameRules:GetGameModeEntity().to_be_destory_list[teamid],x)
			x:SetForwardVector(Vector(0,1,0))
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			x.y_x = ''..v.y..'_'..v.x
			x.y = v.y
			x.x = v.x
			x.vchess_index = ''..v.y..'_'..v.x
			x.press_count = v.press_count
			x.track_money_count = v.track_money_count
			x.team_id = teamid
			-- x.is_respawning = true
			local item_table = v.item  
			InitChessRemindedItem(x,item_table)
			if table.maxn(item_table) > 0 then
				-- DeepPrintTable(item_table)
				for p,vp in pairs (item_table) do
					x:AddItemByName(vp)
				end
			end
			
			-- Timers:CreateTimer(1,function()
			-- 	x.is_respawning = nil
			-- end)
			GameRules:GetGameModeEntity().mychess[teamid][''..v.y..'_'..v.x]['index'] = x:entindex()
			GameRules:GetGameModeEntity().mychess[teamid][''..v.y..'_'..v.x]['lastitem'] = CopyTable(GameRules:GetGameModeEntity().mychess[teamid][''..v.y..'_'..v.x]['item'])
			GameRules:GetGameModeEntity().mychess[teamid][''..v.y..'_'..v.x]['item'] = {}

			GameRules:GetGameModeEntity().unit[teamid][v.y..'_'..v.x] = 1
			--添加战斗技能
			if string.find(v.chess,'rubick') ~= nil and v.rubick_a ~= nil then
				if x:FindAbilityByName(v.rubick_a) == nil then
					AddAbilityAndSetLevel(x,v.rubick_a,0)
					x.steal_ability = v.rubick_a
					if v.rubick_range ~= nil and v.rubick_range > 210 then
						if x:Script_GetAttackRange() > 410 then
							AddAbilityAndSetLevel(x,'attackrange_600',1)
						else
							AddAbilityAndSetLevel(x,'attackrange_400',1)
						end
					end
				end
			elseif GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()] ~= nil then
				local a = GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()]
				if x:FindAbilityByName(a) == nil then
					AddAbilityAndSetLevel(x,a,0)
				end

				if a == 'lc_qianggong' and x.press_count ~= nil and x.press_count > 0 then
					SetPressStack(x)
				end
				if x.track_money_count ~= nil and x.track_money_count > 0 then
					SetTrackMoneyStack(x)
				end
			end

			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
			if animation_info.end_effect ~= nil then
				play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,x,3)
			end
			
		end)
	end)
end


function ClearARound(teamid)
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
		if v ~= nil and v:IsNull() == false then
			-- AddAbilityAndSetLevel(v,'no_selectable')

			Timers:CreateTimer(0.1,function()
				if v.team_id ~= 4 then
					v.is_clearing = true
					FillEmptySlot(v)
					SaveItem(teamid,v:entindex(),function()
						v:Destroy()
					end)
				else
					v:Destroy()
				end
			end)
		end
	end
	GameRules:GetGameModeEntity().to_be_destory_list[teamid] = {}
	GameRules:GetGameModeEntity().unit[teamid] = {}

	local hero = TeamId2Hero(teamid)
	if hero.mirror_chesser ~= nil then
		Timers:CreateTimer(4,function()
			if hero.mirror_chesser.pet2 ~= nil then
				hero.mirror_chesser.pet2:Destroy()
				hero.mirror_chesser.pet2 = nil
			end
			hero.mirror_chesser:Destroy()
			hero.mirror_chesser = nil
		end)
		
	end
end
function SaveItem(teamid,uindex,cb)
	if cb ~= nil then
		Timers:CreateTimer(0.5,function()
			cb()
		end)
	end
	local thischess = nil
	if uindex == nil then
		return
	end
	local unit = EntIndexToHScript(uindex)
	if unit == nil or unit:IsNull() == true or unit.is_tuihuaed == true or unit.is_youhun == true then
		return
	end
	if GameRules:GetGameModeEntity().mychess[teamid] == nil then
		return
	end
	--先清空物品table
	for _,c in pairs (GameRules:GetGameModeEntity().mychess[teamid]) do
		if c.index == uindex then
			c.item = {}
		end
	end
	--记录装备情况
	for slot=0,9 do
		if unit:GetItemInSlot(slot)~= nil then
			local item = unit:GetItemInSlot(slot)
			local name = unit:GetItemInSlot(slot):GetAbilityName()
			if name ~= 'item_null' then
				local charges = unit:GetItemInSlot(slot):GetCurrentCharges()
				if unit.is_summoned == true and unit.is_fuhuo ~= true then
					--召唤物
					if item:IsPermanent() == false then
						--消耗品： 按charges个数丢出来
						for i=1,charges do
							local newItem = CreateItem( name, unit, unit )
							local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
							local dropRadius = RandomFloat( 50, 200 )
							newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
						end
					else
						--永久物品： 丢出来
						local newItem = CreateItem( name, unit, unit )
						local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
						local dropRadius = RandomFloat( 50, 200 )
						newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
					end
				else
					--非召唤物
					for i,v in pairs(GameRules:GetGameModeEntity().mychess[teamid]) do
						if v.index == uindex then
							if item:IsPermanent() == false then
								--消耗品： 丢出来
								for i=1,charges do
									if name ~= 'item_null' then
										local newItem = CreateItem( name, unit, unit )
										local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
										local dropRadius = RandomFloat( 50, 200 )
										newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
									end
								end
							else
								table.insert(v.item,name)
							end
						end
					end
				end
			end
		end
	end
end
function FindValueInTable(tbl,value)
	local found = false
	for i,v in pairs(tbl) do
		if v == value then
			found = true
		end
	end
	return found
end
function CopyTable(origin_table)
	local new_table = {}
	if origin_table ~= nil then
		for k,v in pairs(origin_table) do
			table.insert(new_table,v)
		end
		return new_table
	else
		return {}
	end
end
function DiffTable(big_table,small_table)
	local temp_table  = {}
	for k,v in pairs(big_table) do
		table.insert(temp_table,v)
	end
	for k1,v1 in pairs(small_table) do
		RemoveOneKeyInTable(temp_table,v1)
	end
	if table.maxn(temp_table) > 0 then
		return temp_table
	else
		return {}
	end
end
function RemoveOneKeyInTable(tbl,key)
	local max = table.maxn(tbl)
	for i = max,1,-1 do
		if key == tbl[i] then
			table.remove(tbl,i)
			return true
		end
	end
	return false
end
function DAC:OnEntityKilled(keys)
	local u = EntIndexToHScript(keys.entindex_killed)
	if u == nil then
		return
	end
	if u:IsHero() == true then
		return
	end
	if u:GetUnitName() == "invisible_unit" then
		return
	end
	if u:GetUnitName() == "chess_tech_bomb" then
		return
	end
	if u:GetUnitName() == "player_image" then
		return
	end
	if u:GetUnitName() == "cheer_courier" then
		return
	end
	if u:GetUnitName() == "gemtd_pet" then
		return
	end

	RemoveInvisibleUnitTable(u)
	if GameRules:GetGameModeEntity().game_status == 2 then
		--战斗阶段
		if u.team_id == 4 and string.find(u:GetUnitName(),'pve') ~= nil and u.is_summoned ~= true then  
		    --pve敌人掉宝
			DropItem(u)
			--pve敌人击杀者得钱
			local drop_money = GetHitDamage(u)
			if TeamId2Hero(u.at_team_id) ~= nil then
				AddMana(TeamId2Hero(u.at_team_id), drop_money, false)
				AddTotalMoneyStat(TeamId2Hero(u.at_team_id):GetPlayerID(), drop_money)
				AMHC:CreateNumberEffect(u,drop_money,3,AMHC.MSG_MISS,{255,255,0},0)
				AMHC:CreateParticle("particles/generic_gameplay/rune_bounty_owner.vpcf",PATTACH_OVERHEAD_FOLLOW,false,u,5)
			end
		end
		local xx = Vector2X(u:GetAbsOrigin(),u.at_team_id or u.team_id)
		local yy = Vector2Y(u:GetAbsOrigin(),u.at_team_id or u.team_id)

		if u.at_team_id ~= nil or u.team_id ~= nil then
			if u.y_x ~= nil then
				GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][u.y_x] = nil
			end
		end
		RemoveFromToBeDestroyList(u)
		if u.team_id ~= 4 then
			SaveItem(u.team_id,u:entindex())
		end

		if u.at_team_id ~= nil then
			if string.find(u:GetUnitName(),'pve') == nil then
				AddStat(TeamId2Hero(u.at_team_id):GetPlayerID(),'kills')
			end
		end
	end
	--杀人者
	if keys.entindex_attacker == nil then
		return
	end
	local attacker = EntIndexToHScript(keys.entindex_attacker)
	attacker = attacker.damage_owner or attacker


	--点金手
	if string.find(u:GetUnitName(),'pve') == nil then 
		BhTrackDeath({attacker = attacker})
	end

	RefreshAssassinJump({
		caster = attacker
	})

	--蓝猫/火猫/土猫 击杀重置cd
	if IsUnitExist(attacker) and GetChessAbility(attacker) == 'storm_spirit_ball_lightning_datadriven' or GetChessAbility(attacker) == 'sleight_of_fist_datadriven' or GetChessAbility(attacker) == 'earth_rock_roll' then
		local a = GetChessAbility(attacker)
		if attacker:FindAbilityByName(a) ~= nil then
			attacker:FindAbilityByName(a):EndCooldown()
		end
	end

	--赏金飞镖，击杀弹跳


	--亡语
	DeathRattle(u,attacker)

	--进坟场
	if u:HasAbility('is_ward') == false then
		AddChess2DeadChessList({
			at_team_id = u.at_team_id or u.team_id,
			chess_base_name = GetUnitBaseName(u),
			items = GetAllItemsInUnits({[1] = u}),
			level = u:GetLevel(),
		})
	end


	if attacker == nil then
		return
	end
	if string.find(attacker:GetUnitName(),'pve') ~= nil then
		return
	end
	if string.find(u:GetUnitName(),'pve') ~= nil then
		return
	end

	--连杀数
	if attacker.killing_spree_time == nil or GameRules:GetGameTime() - attacker.killing_spree_time < 3 then
		attacker.killing_spree_time = GameRules:GetGameTime()
		-- +1
		if attacker.killing_spree_count == nil then
			attacker.killing_spree_count = 1
		else
			attacker.killing_spree_count = attacker.killing_spree_count + 1
		end
	else
		-- =1
		attacker.killing_spree_time = GameRules:GetGameTime()
		attacker.killing_spree_count = 1
	end

	if attacker.killing_spree_count == 3 then
		--三杀
		play_particle("effect/3sha/vr_killbanner_triplekill.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,5)
		EmitSoundOn("announcer_killing_spree_announcer_kill_triple_01",attacker)
	end
	if attacker.killing_spree_count == 5 then
		--暴走
		play_particle("effect/5sha/vr_killbanner_rampage.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,5)
		EmitSoundOn("announcer_killing_spree_announcer_kill_rampage_01",attacker)

		attacker.is_baozou = true

		if attacker.team_id == 4 then
			if attacker.from_team_id ~= nil then
				ShowCombat({
					t = 'killing_spree_5_creep',
					player = GameRules:GetGameModeEntity().team2playerid[attacker.from_team_id],
					text = attacker:GetUnitName(),
					hero = 'npc_dota_hero_wisp',
				})
			else
				ShowCombat({
					t = 'killing_spree_5_creep',
					player = GameRules:GetGameModeEntity().team2playerid[4],
					text = attacker:GetUnitName(),
					hero = 'npc_dota_hero_wisp',
				})
			end
		else
			ShowCombat({
				t = 'killing_spree_5',
				player = GameRules:GetGameModeEntity().team2playerid[attacker.from_team_id or attacker.team_id],
				text = attacker:GetUnitName(),
				hero = 'npc_dota_hero_wisp',
			})
		end
	end 

	if attacker.killing_spree_count > 5 then
		local chess_team = attacker.team_id
		if chess_team == 4 then
			if attacker.from_team_id ~= nil then
				chess_team = attacker.from_team_id
			else
				chess_team = nil
			end
		end
		if GameRules:GetGameModeEntity().egg_quest == 'q005' and chess_team ~= nil then
			SetQuest(chess_team,true)
		end
		--暴走
		play_particle("effect/5sha/vr_killbanner_rampage.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,5)
		EmitSoundOn("announcer_killing_spree_announcer_kill_rampage_01",attacker)
	end
end

--游戏循环1.2.x——抽卡用到的方法(第二个参数可以指定下一个棋子)
function Draw5ChessAndShow(team_id, unlock, is_gold)
	--unlock==false表示是系统自动抽牌
	--is_gold==true表示抽5橙卡
	local h = TeamId2Hero(team_id)
	if h.chesslock == true then
		CustomGameEventManager:Send_ServerToTeam(h:GetTeam(),"show_draw_card",{
			key = GetClientKey(h:GetTeam()),
			cards = nil,
			curr_money = h:GetMana(),
			auto_unlock = true,
		})
		h.chesslock = false
		return
	end
	--把上次剩的洗回棋库
	--D+：洗回的-->ban_chess_list
	--D++：ban_chess_list-->ban_chess_list2
	h.ban_chess_list2 = {}
	if h.ban_chess_list ~= nil then
		for _,chess in pairs(h.ban_chess_list) do
			if chess ~= nil then
				table.insert(h.ban_chess_list2,chess)
			end
		end
	end

	h.ban_chess_list = {}
	if h.curr_chess_table ~= nil then
		for _,chess in pairs(h.curr_chess_table) do
			if chess ~= nil and h.is_gold_draw == nil then
				table.insert(h.ban_chess_list,chess)
				AddAChessToChessPool(chess)
			end
		end
	end
	--把上上次的删掉，
	h.curr_chess_table = {}
	--抽！
	if is_gold == true then
		h.is_gold_draw = true
	else
		h.is_gold_draw = nil
	end
	local cards,curr_chess_table = RandomNDrawChessNew(team_id,5,unlock,is_gold)
	h.curr_chess_table = curr_chess_table
	local level_one_chess = FindLevelOneChess(h)

	CustomGameEventManager:Send_ServerToTeam(team_id,"show_draw_card",{
		key = GetClientKey(team_id),
		chesses = curr_chess_table,
		cards = cards,
		level_one_chess = level_one_chess,
		curr_money = h:GetMana(),
		unlock = unlock,
	})
end
function FindLevelOneChess(hero)
	local level_one_chess = ''
	if hero ~= nil then
		for _,v in pairs(GameRules:GetGameModeEntity().mychess[hero.team_id]) do
			if GetChessNameStar(v.chess) == 1 or GetChessNameStar(v.chess) == 2 then
				level_one_chess = level_one_chess..v.chess..','
			end
		end
		if hero.hand_entities ~= nil then
			for k,v in pairs(hero.hand_entities) do
				if GetChessStar(v) == 1 or GetChessStar(v) == 2 then
					level_one_chess = level_one_chess..v:GetUnitName()..','
				end
			end
		end
	end
	return level_one_chess
end 

function RandomNDrawChessNew(team_id,n,is_auto_draw,is_gold)
	local new_chess_list_str = ""
	local new_chess_list_table = {}
	local chess_count = 0
		
	while chess_count < n do
		local new_chess = RandomDrawChessNew(team_id,is_auto_draw,is_gold)
		if new_chess ~= nil then
			new_chess_list_str = new_chess_list_str..new_chess..','
			-- table.insert(new_chess_list_table,new_chess)
			chess_count = chess_count + 1
			new_chess_list_table[chess_count] = new_chess
		end
	end
	return new_chess_list_str,new_chess_list_table
end
function Get11ChessBaseNameTable(team_id)
	local table_11chess = {}
	for _,chess in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		if string.find(chess.chess,'11') then
			table.insert(table_11chess,string.sub(chess.chess,1,-3))
		end
	end
	return table_11chess
end
function RandomDrawChessNew(team_id,is_auto_draw,is_gold)
	local h = TeamId2Hero(team_id)
	local this_chess = nil
	local ran = RandomInt(1,100)
	local chess_level = 1
	local curr_per = 0
	local hero_level = h:GetLevel()

	local table_11chess = Get11ChessBaseNameTable(team_id)

	local ran1 = RandomInt(1,10000)
	local ran2 = RandomInt(1,10000)
	if h:GetLevel() >= 7 and ran1 <= 1 and ran2 <= 1 then
		this_chess = GameRules:GetGameModeEntity().chess_list_ssr[RandomInt(1,table.maxn(GameRules:GetGameModeEntity().chess_list_ssr))]
	elseif ran1 <= 20 then --and h.synergy_banned ~= 'is_elf' 
		this_chess = 'chess_io'
	else
		--正常抽牌
		if GameRules:GetGameModeEntity().chess_gailv[hero_level] ~= nil then
			for per,lv in pairs(GameRules:GetGameModeEntity().chess_gailv[hero_level]) do
				if ran>per and curr_per<=per then
					curr_per = per
					chess_level = lv
				end
			end
		end
		if is_gold == true then
			this_chess = DrawAChessFromGoldPool(chess_level, table_11chess, {}, {},h)
		else
			if is_auto_draw == true then
				this_chess = DrawAChessFromChessPool(chess_level, table_11chess, h.ban_chess_list, h.ban_chess_list2,h)
			else
				this_chess = DrawAChessFromChessPool(chess_level, table_11chess, {}, {},h)
			end
		end
	end
	return this_chess
end

function DAC:OnRequestBuyChess(keys)
	local buy_index = keys.buy_index

	local team_id = GameRules:GetGameModeEntity().playerid2team[keys.PlayerID]
	local h = TeamId2Hero(team_id)
	if PlayerResource:GetPlayer(GameRules:GetGameModeEntity().team2playerid[team_id]) == nil then
		return
	end
	if h == nil or h:IsAlive() == false or h.curr_chess_table == nil or h.curr_chess_table[buy_index + 1] == nil then
		return
	end

	local chess = h.curr_chess_table[buy_index + 1]
	local price = GameRules:GetGameModeEntity().chess_2_mana[chess]
	--判断能不能买得起
	if price > h:GetMana() then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_no_mana"
		})
		return
	end

	--判断手牌里是否有两个一样的，有的话直接合成
	local have_exist_count,chess1,chess2,chess3 = Find2SameChessInHandOrOnBoard(h,chess)

	--寻找手牌空位
	local index = FindEmptyHandSlot(team_id)
	if index == nil and have_exist_count < 2 and h.is_auto_combine == 1 then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_hand_full"
		})
		return
	end
	if index == nil and h.is_auto_combine ~= 1 then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_hand_full"
		})
		return
	end

	CustomGameEventManager:Send_ServerToTeam(team_id,"request_buy_chess_cb",{
		key = GetClientKey(team_id),
		buy_index = buy_index,
	})

	if chess == 'chess_io' then
		--小精灵发弹幕
		CustomGameEventManager:Send_ServerToAllClients("bullet",{
			player_id = h:GetPlayerID(),
			win_streak = h.win_streak or 0,
			vip = h.is_vip,
			target = chess,
		})
	end

	--验证完毕，可以购买
	h.curr_chess_table[buy_index + 1] = nil
	CostMana(h,price)

	--直接合成一个2星的 或者 添加一个1星的
	local have_exist_count,chess1,chess2 = Find2SameChessInHandOrOnBoard(h,chess)
	if have_exist_count >= 2 and chess1 ~= nil and chess2 ~= nil and h.is_auto_combine == 1 then
		-- CombineChessPlus({[1] = chess1,[2] = chess2},(chess..'1'))
		-- local advanve_chess = chess..'1'
		-- local advanve_have_exist_count,advanve_chess1,advanve_chess2 = Find2SameChessInHandOrOnBoard(h,advanve_chess)
		-- if advanve_have_exist_count >= 2 then
		-- 	CombineChessPlus({[1] = chess1,[2] = chess2,[3] = advanve_chess1,[4] = advanve_chess2},(chess..'11'))
		-- else
			CombineChessPlus({[1] = chess1,[2] = chess2},(chess..'1'))
		-- end
	else
		CreateChessInHand(h,chess)
	end
end

function TriggerCombineHand(h,chess)
	if string.find(chess,'11') ~= nil or h.is_auto_combine ~= 1 then
		return
	end
	local have_exist_count,chess1,chess2,chess3 = Find2SameChessInHandOrOnBoard(h,chess)
	if have_exist_count >= 3 and chess1 ~= nil and chess2 ~= nil and chess3 ~= nil then
		CombineChessPlus({[1] = chess1,[2] = chess2, [3] = chess3},chess..'1')
	end
end

--在队伍的等待区域创建一个指定的棋子
function CreateChessInHand(h,chess,particle,spawn_dialog)
	if spawn_dialog == nil then
		spawn_dialog = 'spawn'
	end
	local team_id = h.team_id
	local p = particle or "particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ribbon_bright.vpcf"
	local index = FindEmptyHandSlot(team_id)
	if index == nil then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_hand_full"
		})
		return
	end
	local x = CreateUnitByName(chess,HandIndex2Vector(team_id,index),true,nil,nil,team_id)
	if x == nil then
		return
	end
	MakeTiny(x)
	if spawn_dialog ~= 'nil' then
		PlayChessDialogue(x,spawn_dialog)
	end

	GameRules:GetGameModeEntity().hand[team_id][index] = 1
	if h.hand_entities == nil then
		h.hand_entities = {}
	end
	h.hand_entities[index] = x

	x:SetForwardVector(Vector(0,1,0))
	x.hand_index = index
	x.team_id = team_id
	
	AddAbilityAndSetLevel(x,'root_self')
	AddAbilityAndSetLevel(x,'jiaoxie_wudi')

	play_particle(p,PATTACH_ABSORIGIN_FOLLOW,x,5)

	--添加战斗技能
	if GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()] ~= nil then
		local a = GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()]
		if x:FindAbilityByName(a) == nil then
			AddAbilityAndSetLevel(x,a,0)
		end
	end
	FindRikiAndToggle(x)
	return x
end


function IsHandFull(team_id)
	if FindEmptyHandSlot(team_id) == nil then
		return true
	else
		return false
	end
end
function FindEmptyHandSlot(team_id)
	local empty_index = nil
	for i=1,8 do
		if GameRules:GetGameModeEntity().hand[team_id][i] == 0 then
			empty_index = i
			break
		end
	end
	return empty_index
end
function CheckEmptyHandSlot(team_id,index)
	if GameRules:GetGameModeEntity().hand[team_id][index] == 0 then
		return true
	else
		return false
	end
end
function ClearHand(team_id)
	local h = TeamId2Hero(team_id)
	if h ~= nil and h.hand_entities ~= nil then
		for _,v in pairs(h.hand_entities) do
			if v ~= nil and v:IsNull() == false then
				v:ForceKill(false)
			end
		end
	end
	GameRules:GetGameModeEntity().population[team_id] = 0
	GameRules:GetGameModeEntity().hand[team_id] = {}
	GameRules:GetGameModeEntity().mychess[team_id] = {}
	ClearARound(team_id)
end


--游戏循环1.4——上场相关操作
function RecallChess(keys)
	--撤回手牌
	local picked_chess = keys.target
	local caster = keys.caster
	if IsUnitExist(picked_chess) == false then
		return
	end
	local team_id = picked_chess.team_id
	local origin_x = picked_chess.x
	local origin_y = picked_chess.y
	
	if picked_chess.is_removing == true then
		return
	end

	CancelPickChess(caster)

	if picked_chess.hand_index ~= nil then
		--已经在手牌了
		-- CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
		-- 	key = GetClientKey(caster:GetTeam()),
		-- 	text = "text_mima_must_select_a_chess_in_batle_ground"
		-- })
		-- EmitSoundOn("General.CastFail_NoMana",keys.caster)
		-- return

		--跳上去
		local origin_pos = HandIndex2Vector(team_id, picked_chess.hand_index)
		local chess_pos_type,x1,y1,_ = GetTargetPositionType(origin_pos, caster, team_id)

		local target_pos = nil
		for _,j in pairs({0,1,-1,2,-2,3,-3,4,-4}) do
			for i=1,4 do
				if IsBlocked(x1+j,i,team_id) == false and target_pos == nil then
					target_pos = XY2Vector(x1+j,i,team_id)
				end
			end
		end
		if target_pos then
			caster.picked_chess = picked_chess
			DAC:OnPickChessPosition({
				caster = caster,
				x = target_pos.x,
				y = target_pos.y,
				z = target_pos.z,
				player_id = caster:GetOwner():GetPlayerID(),
				PlayerID = caster:GetOwner():GetPlayerID(),
			})
		end
		return
	end

	local target_index = FindEmptyHandSlot(team_id)
	
	if target_index == nil then
		--手牌已经满了
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_hand_is_full"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end

	GameRules:GetGameModeEntity().mychess[team_id][''..origin_y..'_'..origin_x] = nil
	GameRules:GetGameModeEntity().unit[team_id][''..origin_y..'_'..origin_x] = nil
	GameRules:GetGameModeEntity().hand[team_id][target_index] = 1
	if caster.hand_entities == nil then
		caster.hand_entities = {}
	end

	caster.hand_entities[target_index] = picked_chess
	for p,vp in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if vp:entindex() == picked_chess:entindex() then
			table.remove(GameRules:GetGameModeEntity().to_be_destory_list[team_id],p)
		end
	end

	--跳过去	
	picked_chess:SetForwardVector((HandIndex2Vector(team_id,target_index) - Vector(0,1,0)):Normalized())
	picked_chess.hand_index = target_index
	picked_chess.team_id = team_id
	BlinkChessX({p=HandIndex2Vector(team_id,target_index),caster=picked_chess})
	GameRules:GetGameModeEntity().population[team_id] = GameRules:GetGameModeEntity().population[team_id] - 1
	local position = HandIndex2Vector(team_id,target_index)
	local origin_p = picked_chess:GetAbsOrigin()
	Timers:CreateTimer((position-origin_p):Length2D()/1000+0.5,function()
		TriggerCombineHand(caster,picked_chess:GetUnitName())
	end)

	--隐藏手牌
	FindRikiAndToggle(picked_chess)
	--同步ui人口
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = GameRules:GetGameModeEntity().population_max[team_id],
		count = GameRules:GetGameModeEntity().population[team_id],
	})
	
	AddAbilityAndSetLevel(picked_chess,'root_self')
	AddAbilityAndSetLevel(picked_chess,'jiaoxie_wudi')

	--战斗技能变0
	if string.find(picked_chess:GetUnitName(),'rubick') ~= nil and picked_chess.steal_ability ~= nil then
		if picked_chess:FindAbilityByName(picked_chess.steal_ability) ~= nil then
			picked_chess:FindAbilityByName(picked_chess.steal_ability):SetLevel(0)
		end
	elseif GameRules:GetGameModeEntity().chess_ability_list[picked_chess:GetUnitName()] ~= nil then
		local a = GameRules:GetGameModeEntity().chess_ability_list[picked_chess:GetUnitName()]
		if picked_chess:FindAbilityByName(a) ~= nil then
			picked_chess:FindAbilityByName(a):SetLevel(0)
		end
	end

	StatClassCount(team_id)
end
--多余的滚回去
function RandomRecallChess()
	for i=6,13 do
		CheckChess(i)
		local teamcount = GameRules:GetGameModeEntity().population[i]
		local teammax = GameRules:GetGameModeEntity().population_max[i]
		if teamcount > 0 and teammax < teamcount then
			local recall_amount = teamcount - teammax
			if recall_amount > 0 then
				CustomGameEventManager:Send_ServerToTeam(i,"mima",{
					key = GetClientKey(i),
					text = "text_mima_chess_max_recall"
				})
			end
			local recalled = 0
			Timers:CreateTimer(function()
				if recalled < recall_amount then
					local smallest_chess = GameRules:GetGameModeEntity().to_be_destory_list[1]
					local smallest_level = 4
					for k,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[i]) do
						local a_level = 1
						if string.find(v:GetUnitName(),'1') then
							a_level = 2
						end
						if string.find(v:GetUnitName(),'11') then
							a_level = 3
						end
						if a_level < smallest_level and v.combining ~= true then
							smallest_chess = v
							smallest_level = a_level
						end
					end
					local target_index = FindEmptyHandSlot(i)
					if target_index == nil then
						RemoveChess({
							caster = GameRules:GetGameModeEntity().teamid2hero[i],
							target = smallest_chess,
							force_remove = true,
						})
					else
						RecallChess({
							caster = GameRules:GetGameModeEntity().teamid2hero[i],
							target = smallest_chess
						})
					end
					recalled = recalled + 1
					return 0.05
				else
					return
				end
			end)
		end
	end
end
function PickChess(keys)
	local target = keys.target
	local caster = keys.caster
	local team = target.team_id

	CancelPickChess(caster)

	AddAbilityAndSetLevel(target,'chess_picked')


	caster.picked_chess = target
	EmitSoundOn("ui.browser_click_right",caster)
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_cursor_hero_icon",{
		key = GetClientKey(caster:GetTeam()),
		unit = target:GetUnitName(),
		unit_index = target:entindex(),
	})
	caster:FindAbilityByName('pick_chess'):SetActivated(false)
	caster:FindAbilityByName('recall_chess'):SetActivated(false)
end
function GetMinionManaCost(u)
	local mana = 0
	if u:FindAbilityByName('mana_cost1') ~= nil then
		mana = 1
	end
	if u:FindAbilityByName('mana_cost2') ~= nil then
		mana = 2
	end
	if u:FindAbilityByName('mana_cost3') ~= nil then
		mana = 3
	end
	if u:FindAbilityByName('mana_cost4') ~= nil then
		mana = 4
	end
	if u:FindAbilityByName('mana_cost5') ~= nil then
		mana = 5
	end
	return mana
end
function CancelPickChess(u)
	if u.picked_chess ~= nil and u.picked_chess:IsNull() ~= true then
		u.picked_chess:RemoveAbility('chess_picked')
		u.picked_chess:RemoveModifierByName('modifier_chess_picked')
	end
	u.picked_chess = nil
	CustomGameEventManager:Send_ServerToTeam(u:GetTeam(),"show_cursor_hero_icon",{
		key = GetClientKey(u:GetTeam())
	})
	if GameRules:GetGameModeEntity().game_status == 1 and GameRules:GetGameModeEntity().prepare_timer > 5 then
		u:FindAbilityByName('pick_chess'):SetActivated(true)
		u:FindAbilityByName('recall_chess'):SetActivated(true)
	end
end 
function DAC:OnCancelPickChessPosition(keys)
	local caster = PlayerId2Hero(keys.PlayerID)

	if keys.PlayerID ~= keys.player_id then
		caster.is_banned = true
	end

	CancelPickChess(caster)
end

function DAC:OnPickChessPosition(keys)
	local caster = PlayerId2Hero(keys.PlayerID)
	local picked_chess = caster.picked_chess
	if IsUnitExist(picked_chess) == false or picked_chess.is_removing == true then
		--picked_chess不存在
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_must_select_a_chess"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		if GameRules:GetGameModeEntity().game_status == 1 and GameRules:GetGameModeEntity().prepare_timer > 5 then
			caster:FindAbilityByName('pick_chess'):SetActivated(true)
			caster:FindAbilityByName('recall_chess'):SetActivated(true)
		end
		return
	end
	if keys.player_id ~= keys.PlayerID then
		--防止伪造的假消息祸害他人
		caster.is_banned = true
		return
	end
	local target_pos = Vector(keys.x,keys.y,keys.z)

	local team_id = picked_chess.team_id
	CancelPickChess(caster)
	picked_chess.io_target = nil

	local origin_pos = nil
	if picked_chess.hand_index == nil then
		origin_pos = XY2Vector(picked_chess.x, picked_chess.y,team_id)
	else
		origin_pos = HandIndex2Vector(team_id, picked_chess.hand_index)
	end

	local chess_pos_type,x1,y1,_ = GetTargetPositionType(origin_pos, caster, team_id)
	local target_pos_type,x2,y2,target_chess = GetTargetPositionType(target_pos, caster, team_id)

	if chess_pos_type == 0 or target_pos_type == 0 then
		--无效地点
		return
	end
	if x1 == x2 and y1 == y2 then
		return
	end

	local blink_duration = 0

	if chess_pos_type == 1 then
		--选中的棋子在手牌
		if target_pos_type == 1 then
			--选中的棋子在手牌，目标位置在手牌
			RemoveChessFromHand(picked_chess,caster)
			if target_chess ~= nil then
				--目标位置有棋子target_chess，交换
				RemoveChessFromHand(target_chess,caster)
				AddChess2Hand(target_chess,x1,caster)
				BlinkChessX({ p = HandIndex2Vector(team_id,x1), caster = target_chess, set_forward = true, })
			end
			AddChess2Hand(picked_chess,x2,caster)
			blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
		elseif target_pos_type == 2 then
			--选中的棋子在手牌，目标位置在场上
			if target_chess ~= nil then
				--目标位置有棋子target_chess，找个附近的空格子跳，不交换
				local closest_xy = GetClosestEmptyArea(x2,y2,team_id)
				if closest_xy ~= nil then
					x2 = closest_xy.x
					y2 = closest_xy.y
					RemoveChessFromHand(picked_chess,caster)
					AddChess2Board(picked_chess,x2,y2,caster)
					blink_duration = BlinkChessX({ p = XY2Vector(x2,y2,team_id), caster = picked_chess, set_forward = true, })
				end
				picked_chess.io_target_index = target_chess:entindex()
				-- RemoveChessFromBoard(target_chess,caster)
				-- AddChess2Hand(target_chess,x1,caster)
				-- BlinkChessX({ p = HandIndex2Vector(team_id,x1), caster = target_chess, set_forward = true, })
			else
				RemoveChessFromHand(picked_chess,caster)
				AddChess2Board(picked_chess,x2,y2,caster)
				blink_duration = BlinkChessX({ p = XY2Vector(x2,y2,team_id), caster = picked_chess, set_forward = true, })
			end
		end
	elseif chess_pos_type == 2 then
		--选中的棋子在场上
		if target_pos_type == 1 then
			--选中的棋子在场上，目标位置在手牌
			
			if target_chess ~= nil then
				--目标位置有棋子target_chess，找个附近的手牌位置跳，不交换
				local closest_empty_hand_index = GetClosestEmptyHandIndex(x2,team_id)
				if closest_empty_hand_index ~= nil then
					x2 = closest_empty_hand_index
					RemoveChessFromBoard(picked_chess,caster)
					AddChess2Hand(picked_chess,x2,caster)
					blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
				end
				-- RemoveChessFromHand(target_chess,caster)
				-- AddChess2Board(target_chess,x1,y1,caster)
				-- BlinkChessX({ p = XY2Vector(x1,y1,team_id), caster = target_chess, set_forward = true, })
			else
				RemoveChessFromBoard(picked_chess,caster)
				AddChess2Hand(picked_chess,x2,caster)
				blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
			end
		elseif target_pos_type == 2 then
			--选中的棋子在场上，目标位置在场上
			RemoveChessFromBoard(picked_chess,caster)
			if target_chess ~= nil then
				--目标位置有棋子target_chess，交换
				RemoveChessFromBoard(target_chess,caster)
				AddChess2Board(target_chess,x1,y1,caster)
				BlinkChessX({ p = XY2Vector(x1,y1,team_id), caster = target_chess, set_forward = true, })
				picked_chess.io_target_index = target_chess:entindex()
			end
			AddChess2Board(picked_chess,x2,y2,caster)
			blink_duration = BlinkChessX({ p = XY2Vector(x2,y2,team_id), caster = picked_chess, set_forward = true, })
		end
	end

	--统计场上羁绊
	StatClassCount(team_id)
	--同步ui人口
	CheckChess(team_id)
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = GameRules:GetGameModeEntity().population_max[team_id],
		count = GameRules:GetGameModeEntity().population[team_id],
	})
	if blink_duration > 0 then
		if y2 == -1 then
			Timers:CreateTimer(blink_duration+0.1,function()
				TriggerCombineHand(caster,picked_chess:GetUnitName())
			end)
		else
			Timers:CreateTimer(blink_duration+0.1,function()
				TriggerChessCombineAtGrid(x2,y2,team_id)
			end)
			
		end
	end
end

function GetTargetPositionType(pos, caster, team_id)
	local x = Vector2X(pos,team_id)
	local y = Vector2Y(pos,team_id)

	if x < 1 then x = 1 end
	if x > 8 then x = 8 end
	if y > 4 then y = 4 end
	if y == 0 then y = 1 end
	if y < 0 then y = -1 end

	if x >= 1 and x <= 8 and y == -1 then
		--在手牌
		local target_chess = caster.hand_entities[x] 
		
		return 1,x,-1,target_chess
	elseif x >= 1 and x <= 8 and y >= 1 and y <= 8 then
		--在场上
		if GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x] ~= nil then
			local target_chess_index = GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x].index
			local target_chess = EntIndexToHScript(target_chess_index)
			return 2,x,y,target_chess
		else
			return 2,x,y,nil
		end
	else
		return 0,nil,nil
	end
end

function RemoveChessFromHand(chess,caster)
	local team_id = chess.team_id
	local curr_index = chess.hand_index
	GameRules:GetGameModeEntity().hand[team_id][curr_index] = 0
	caster.hand_entities[curr_index] = nil
	chess.hand_index = nil
end

function RemoveChessFromBoard(chess,caster)
	local team_id = chess.team_id
	local x = chess.x
	local y = chess.y
	GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x] = nil
	GameRules:GetGameModeEntity().unit[team_id][''..y..'_'..x] = nil
	chess.x = nil
	chess.y = nil
	chess.y_x = nil

	for p,vp in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if vp:entindex() == chess:entindex() then
			table.remove(GameRules:GetGameModeEntity().to_be_destory_list[team_id],p)
		end
	end
end

function AddChess2Hand(chess,hand_index,caster)
	local team_id = chess.team_id
	GameRules:GetGameModeEntity().hand[team_id][hand_index] = 1
	chess.hand_index = hand_index
	caster.hand_entities[hand_index] = chess

	chess.y_x = nil
	chess.y = nil
	chess.x = nil
	chess.vchess_index = nil
	AddAbilityAndSetLevel(chess,'root_self')
	AddAbilityAndSetLevel(chess,'jiaoxie_wudi')

	--棋子的技能等级设为0
	if string.find(chess:GetUnitName(),'rubick') ~= nil and chess.steal_ability ~= nil then
		if chess:FindAbilityByName(chess.steal_ability) ~= nil then
			chess:FindAbilityByName(chess.steal_ability):SetLevel(0)
		end
	elseif GameRules:GetGameModeEntity().chess_ability_list[chess:GetUnitName()] ~= nil then
		local a = GameRules:GetGameModeEntity().chess_ability_list[chess:GetUnitName()]
		if chess:FindAbilityByName(a) ~= nil then
			chess:FindAbilityByName(a):SetLevel(0)
		end
	end
end

function AddChess2Board(chess,x,y,caster)
	local team_id = chess.team_id
	table.insert(GameRules:GetGameModeEntity().to_be_destory_list[team_id],chess)

	chess.y_x = ''..y..'_'..x
	chess.y = y
	chess.x = x
	chess.vchess_index = ''..y..'_'..x

	GameRules:GetGameModeEntity().unit[team_id][''..y..'_'..x] = 1
	GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x] = {
		index = chess:entindex(),
		chess = chess:GetUnitName(),
		item = {},
		x = x,
		y = y,
		press_count = chess.press_count,
		track_money_count = chess.track_money_count,
	}

	--调整拉比克的攻击距离
	if string.find(chess:GetUnitName(),'rubick') ~= nil and chess.steal_ability ~= nil then
		GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x]['rubick_a'] = chess.steal_ability
		if chess:FindAbilityByName('attackrange_600') ~= nil then
			GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x]['rubick_range'] = 600
		end
		if chess:FindAbilityByName('attackrange_400') ~= nil then
			GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x]['rubick_range'] = 400
		end
	end
end


function BlinkChessX(keys)
	local caster = keys.caster
	if caster == nil or caster:IsNull() == true then
		return
	end

	local p = keys.p or caster:GetOrigin()
	local team_id = caster.at_team_id or caster.team_id
	local x = Vector2X(p,team_id)
	local y = Vector2Y(p,team_id)
	local position = XY2Vector(x,y,team_id)
	local sound = keys.sound
	local animation = keys.animation
	local blink_type = keys.blink_type or 'jump' -- run/jump/...
	local set_forward = keys.set_forward or false

	if set_forward == true then
		caster:SetForwardVector((position - caster:GetAbsOrigin()):Normalized())
	end

	caster.y_x = Vector2Y(position,team_id)..'_'..Vector2X(position,team_id)
	caster.y = Vector2Y(position,team_id)
	caster.x = Vector2X(position,team_id)
	caster:Stop()
	-- caster:InterruptMotionControllers(false)
	-- caster:RemoveHorizontalMotionController(caster)
	-- caster:RemoveVerticalMotionController(caster)
	if caster:HasModifier("modifier_jump") or caster:HasModifier("modifier_run") or caster:HasModifier("modifier_tuitui") or caster:HasModifier("modifier_elfrun") or caster:HasModifier("modifier_toss") then
		-- return
		caster:RemoveModifierByName("modifier_jump")
		caster:RemoveModifierByName("modifier_run")
		caster:RemoveModifierByName("modifier_elfrun")
		caster:RemoveModifierByName("modifier_tuitui")
		caster:RemoveModifierByName("modifier_toss")
	end

	local modifier = caster:AddNewModifier(caster,nil,"modifier_"..blink_type,
	{
		vx = position.x,
		vy = position.y,
		sound = sound,
		animation = animation,
	})	

	--容错卡住的情况
	caster.blink_start_p = caster:GetOrigin()
	caster.blink_stop_count = 0
	Timers:CreateTimer(0.1,function()
		if IsUnitExist(caster) == false or caster.is_moving ~= true then
			return
		end
		local blink_p = caster:GetOrigin()
		if (blink_p - caster.blink_start_p):Length2D() < 5 then
			caster.blink_stop_count = caster.blink_stop_count + 1
		else
			caster.blink_stop_count = 0
		end
		caster.blink_start_p = blink_p
		if caster.blink_stop_count > 100 then
			BlinkChessX({
				caster = caster,
				p = p,
				sound = sound,
				animation = animation,
				blink_type = blink_type,
			})
			return
		end
		return 0.1
	end)

	return (position-caster:GetOrigin()):Length2D()/1000
end
function TransferChess(keys)
	local target = keys.target
	local caster = keys.caster
	local position_1 = target:GetAbsOrigin()
	local team_id = target.team_id
	local x_1 = Vector2X(position_1,team_id)
	local y_1 = Vector2Y(position_1,team_id)

	local ally_team_id = GetP2Ally(team_id)
	if ally_team_id == nil then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_find_ally"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end
	if string.find(target:GetUnitName(),'chess_') == nil then
		return
	end
	if target.is_removing == true then
		return
	end
	if target.hand_index == nil then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_transfer_battle_chess"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end
	local ally_hand_index = FindEmptyHandSlot(ally_team_id)
	if ally_hand_index == nil then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_ally_hand_full"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end
	if caster:GetMana() < target:GetLevel()*2 then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_no_mana"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end

	FindRikiAndToggle(target)
	CancelPickChess(caster)
	target.is_removing = true    
	local mama_cost = target:GetLevel()*2
	CostMana(caster,mama_cost)
	EmitSoundOn("courier.transfer_chess",caster)

	GameRules:GetGameModeEntity().hand[team_id][target.hand_index] = 0
	caster.hand_entities[target.hand_index] = nil

	local position_2 = HandIndex2Vector(ally_team_id,ally_hand_index)
	local x_2 = Vector2X(position_2,ally_team_id)
	local y_2 = Vector2Y(position_2,ally_team_id)
	local ally_hero = TeamId2Hero(ally_team_id)

	GameRules:GetGameModeEntity().hand[ally_team_id][ally_hand_index] = 1
	if ally_hero.hand_entities == nil then
		ally_hero.hand_entities = {}
	end
	ally_hero.hand_entities[ally_hand_index] = target
	target.hand_index = ally_hand_index
	target.team_id = ally_team_id
	target.y_x = nil
	target.y = nil
	target.x = nil
	target:SetTeam(ally_team_id)
	--跳过去
	target.transfer_chess = true
	target:SetForwardVector((HandIndex2Vector(ally_team_id,ally_hand_index) - target:GetAbsOrigin()):Normalized())

	--头上的特效
	play_particle("particles/econ/events/ti9/high_five/high_five_lvl1_overhead.vpcf",PATTACH_OVERHEAD_FOLLOW,target,8)

	BlinkChessX({p=HandIndex2Vector(ally_team_id,ally_hand_index),caster=target})
	FindRikiAndToggle(target)
	AddAbilityAndSetLevel(target,'root_self')
	AddAbilityAndSetLevel(target,'jiaoxie_wudi')

	if IsUnitExist(ally_hero) then
		CourierCP(caster, ally_hero)
	end
	
	CustomGameEventManager:Send_ServerToTeam(ally_team_id,"chat_bubble",{
		key = GetClientKey(ally_team_id),
		player_from = caster:GetPlayerID(),
		player_to = TeamId2Hero(ally_team_id):GetPlayerID(),
		text = 'DOTA_Tooltip_ability_transfer_chess',
		chess = target:GetUnitName(),
		is_vip = caster.is_vip,
	})
	CustomGameEventManager:Send_ServerToTeam(team_id,"chat_bubble",{
		key = GetClientKey(team_id),
		player_from = caster:GetPlayerID(),
		player_to = TeamId2Hero(ally_team_id):GetPlayerID(),
		text = 'DOTA_Tooltip_ability_transfer_chess',
		chess = target:GetUnitName(),
		is_vip = caster.is_vip,
	})
end
function RemoveChess(keys)
	local target = keys.target
	local caster = keys.caster
	local position = target:GetAbsOrigin()
	local team_id = target.team_id
	local x = Vector2X(position,team_id)
	local y = Vector2Y(position,team_id)

	local extra_time = 0
	if GetMapName() == 'casual_2x4_ob' or GetMapName() == 'casual_2x4' or GetMapName() == 'ranked_2x4' then
		extra_time = 5
	end

	if string.find(target:GetUnitName(),'chess_') == nil then
		return
	end

	if target.is_removing == true then
		return
	end	
	if keys.force_remove ~= true then
		if (GameRules:GetGameModeEntity().game_status == 2 and target.hand_index == nil) or (GameRules:GetGameModeEntity().game_status == 1 and target.hand_index == nil and (GameRules:GetGameModeEntity().prepare_timer > 33 + extra_time or GameRules:GetGameModeEntity().prepare_timer < 2)) then
			CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
				key = GetClientKey(caster:GetTeam()),
				text = "text_mima_cannot_delete_battle_chess"
			})
			EmitSoundOn("General.CastFail_NoMana",keys.caster)
			return
		end
	end
	if keys.is_sell == nil or keys.is_sell == true then
		-- play_particle("effect/remove_chess/1.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)

		local pp = ParticleManager:CreateParticle("effect/remove_chess/1.vpcf", PATTACH_ABSORIGIN_FOLLOW, target)
		-- ParticleManager:SetParticleControlEnt( pp, 0, u, pos, nil, u:GetOrigin(), true );
		ParticleManager:SetParticleControlEnt( pp, 1, caster, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
		Timers:CreateTimer(3,function()
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
		end)

		EmitSoundOn("dac.remove_chess",caster)
		if GameRules:GetGameModeEntity().chess_2_mana[GetChessTypeName(target)] == 5 and FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_mana[5],GetChessTypeName(target)) == false then
		else
			AddAChessToChessPool(target:GetUnitName())
		end
	end

	local is_removing_hand = false
	if target.hand_index == nil then
		GameRules:GetGameModeEntity().mychess[team_id][target.y_x] = nil
		GameRules:GetGameModeEntity().population[team_id] = GameRules:GetGameModeEntity().population[team_id] - 1

		--同步ui人口
		CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
			key = GetClientKey(team_id),
			max_count = GameRules:GetGameModeEntity().population_max[team_id],
			count = GameRules:GetGameModeEntity().population[team_id],
		})
	else
		is_removing_hand = true
		GameRules:GetGameModeEntity().hand[team_id][target.hand_index] = 0
		caster.hand_entities[target.hand_index] = nil
	end
	RemoveFromToBeDestroyList(target)
	if target.y_x ~= nil then
		GameRules:GetGameModeEntity().unit[team_id][target.y_x] = nil
	end
	FindRikiAndToggle(target)
	CancelPickChess(caster)

	local children = target:GetChildren()
    for k,child in pairs(children) do
       if child:IsNull() == false and child:GetClassname() == "dota_item_wearable" then
           child:RemoveSelf()
       end
    end
	target.is_removing = true    
    AddAbilityAndSetLevel(target,'no_minimap_icon')
	target:SetModelScale(0.0001)
	AddAbilityAndSetLevel(target,'no_hp_bar')
	target:RemoveAbility('act_teleport')
	target:RemoveModifierByName('modifier_act_teleport')

	if keys.is_sell == nil or keys.is_sell == true then
		local price = target:GetLevel()
		if target.track_money_count ~= nil and target.track_money_count > 0 then
			price = price + tonumber(target.track_money_count)
		end
		target.track_money_count = 0
    	AddMana(caster, price)
    	if tonumber(target.track_money_count) > 0 then
	    	AddTotalMoneyStat(caster:GetPlayerID(),tonumber(target.track_money_count))
	    end

		for slot=0,9 do
			if target:GetItemInSlot(slot)~= nil then
				local name = target:GetItemInSlot(slot):GetAbilityName()
				local charges = target:GetItemInSlot(slot):GetCurrentCharges()
				if target:GetItemInSlot(slot):IsPermanent() == false then
					for i=1,charges do
						if name ~= nil and name ~= 'item_null' then
							DropItemAppointed(caster,target,name)
						end
					end
				else
					if name ~= nil and name ~= 'item_null' then
						DropItemAppointed(caster,target,name)
					end
				end
			end
		end
	end

	local last_chess = false
	if FindEmptyHandSlot(team_id) == 1 then
		last_chess = true
	end
	Timers:CreateTimer(3,function()
		target:Destroy()
	end)

	if is_removing_hand == false then
		StatClassCount(team_id)
	end
	local level_one_chess = FindLevelOneChess(caster)

	CustomGameEventManager:Send_ServerToTeam(team_id,"show_gold",{
		key = GetClientKey(team_id),
		gold = caster:GetMana(),
		lose_streak = caster.lose_streak or 0,
		win_streak = caster.win_streak or 0,
		level_one_chess = level_one_chess,
	})
end
--触发team_id的场地中i,j这个格子的棋子合成
function TriggerChessCombineAtGrid(i,j,team_id,is_move)
	--找到这个格子上的棋子（obj）
	local curr_chess = GameRules:GetGameModeEntity().mychess[team_id][j..'_'..i]
	if curr_chess == nil then
		return
	end
	local chess_index = curr_chess.index
	local chess = EntIndexToHScript(chess_index)
	local chess_name = chess:GetUnitName()

	--检测是否有2巫师帮助德鲁伊合成
	local wizard_count = GetWizardCount(team_id)
	--在mychess中找到两个跟chess名字一样的chess obj：u1，u2
	local u1 = nil
	local u2 = nil
	for u,v in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		if u1 == nil and v.index ~= chess_index and v.chess == chess_name and v.combining ~= true then
			u1 = v
		elseif u2 == nil and v.index ~= chess_index and v.chess == chess_name and v.combining ~= true then
			u2 = v
		end
	end
	local druid_count = GetDruidCount(team_id)
	if wizard_count >= 2 and druid_count >= 3 then
		druid_count = druid_count + 1
	end
	if wizard_count >= 3 and druid_count == 2 then
		druid_count = druid_count + 1
	end

	--合成
	if u1 ~= nil and chess:FindAbilityByName('is_druid') ~= nil and EntIndexToHScript(u1.index):GetUnitName() == chess_name and string.find(chess_name,'1') == nil and druid_count >= 2 then
		--德鲁伊（2）：两个一样的1星可以合
		if u1.chess == 'chess_eh' and curr_chess.chess == 'chess_eh' then
			AddTotalMoneyStat(TeamId2Hero(team_id):GetPlayerID(),1)
		end
		CombineChessPlus({[1] = curr_chess,[2] = u1})
	elseif u1 ~= nil and EntIndexToHScript(chess_index):FindAbilityByName('is_druid') ~= nil and EntIndexToHScript(u1.index):GetUnitName() == chess_name and string.find(chess_name,'11') == nil and druid_count >= 4 then
		--德鲁伊（4）：两个一样的2星可以合
		-- if u1.chess == 'chess_eh1' and curr_chess.chess == 'chess_eh1' then
		-- 	AddTotalMoneyStat(TeamId2Hero(team_id):GetPlayerID(),1)
		-- end
		CombineChessPlus({[1] = curr_chess,[2] = u1})
	elseif u1 ~=nil and u2 ~=nil and EntIndexToHScript(u2.index):GetUnitName() == chess_name and EntIndexToHScript(u1.index):GetUnitName() == chess_name and string.find(chess_name,'11')  == nil then
		--普通情况：三个一样的可以合
		-- CombineChess(curr_chess,u1,u2)
		CombineChessPlus({[1] = curr_chess,[2] = u1,[3] = u2})
	else
		--不能合成：如果是小精灵，看看能不能合
		if chess_name == 'chess_io' then
			--找两个一样的一星就能合 一星棋子名字..'1'
			local io_u1,io_u2 = Find2SameChessByIO(team_id,1,i,j)

			if io_u1 ~= nil and io_u2 ~= nil then
				-- CombineChess(curr_chess,io_u1,io_u2,(io_u1.chess..'1'))
				CombineChessPlus({[1] = curr_chess,[2] = io_u1,[3] = io_u2},(io_u1.chess..'1'))
			else
				--如果有2德鲁伊，找一个1星德就能合
				if druid_count >= 2 then
					local io_ud1 = Find1ChessByIO(team_id,1,i,j)
					if io_ud1 ~= nil then
						-- CombineChess(curr_chess,io_ud1,nil,(io_ud1.chess..'1'))
						CombineChessPlus({[1] = curr_chess,[2] = io_ud1,},(io_ud1.chess..'1'))
					end
				end
			end
		end
		if chess_name == 'chess_io1' then
			--找两个一样的二星就能合 二星棋子名字..'1'
			local io_u1,io_u2 = Find2SameChessByIO(team_id,2,i,j)
			if io_u1 ~= nil and io_u2 ~= nil then
				-- CombineChess(curr_chess,io_u1,io_u2,(io_u1.chess..'1'))
				CombineChessPlus({[1] = curr_chess,[2] = io_u1,[3] = io_u2,},(io_u1.chess..'1'))
			else
				--如果有4德鲁伊，找一个2星德就能合
				if druid_count >= 4 then
					local io_ud2 = Find1ChessByIO(team_id,2,i,j)
					if io_ud2 ~= nil then
						-- CombineChess(curr_chess,io_ud2,nil,(io_ud2.chess..'1'))
						CombineChessPlus({[1] = curr_chess,[2] = io_ud2},(io_ud2.chess..'1'))
					end
				end
			end
		end
	end
end
--为小精灵找两个指定level星级的相同棋子。如果有多组，优先找小精灵的io_target，其次找费用最高的
function Find2SameChessByIO(team_id,level,x,y)
	local c1,c2
	local max_cost = 0
	local io = EntIndexToHScript(GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x].index)

	for _,v1 in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		if v1 ~= nil and v1.chess ~= 'chess_io' and v1.chess ~= 'chess_io1' and v1.combining ~= true and GetChessNameStar(v1.chess) == level then
			for _,v2 in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
				if v2 ~= nil and v2.index ~= v1.index and v2.chess ~= 'chess_io' and v2.chess ~= 'chess_io1' and v2.combining ~= true and GetChessNameStar(v2.chess) == level and v1.chess == v2.chess then

					local v1_chess = EntIndexToHScript(v1.index)
					local v2_chess = EntIndexToHScript(v2.index)
					local v1_cost = GameRules:GetGameModeEntity().chess_2_mana[GetChessTypeName(v1_chess)]
					local v2_cost = GameRules:GetGameModeEntity().chess_2_mana[GetChessTypeName(v2_chess)]
					if io.io_target_index ~= nil and v1.index == io.io_target_index then
						v1_cost = 999
					end
					if io.io_target_index ~= nil and v2.index == io.io_target_index then
						v2_cost = 999
					end

					if max_cost < v1_cost then
						c1 = v1
						c2 = v2
						max_cost = v1_cost
					end
					if max_cost < v2_cost then
						c1 = v1
						c2 = v2
						max_cost = v2_cost
					end
				end
			end
		end
	end
	return c1,c2
end
--为小精灵找一个指定level星级的德鲁伊棋子。如果有多组，优先找小精灵的io_target，其次找费用最高的
function Find1ChessByIO(team_id,level,x,y)
	local c1
	local max_cost = 0
	local io = EntIndexToHScript(GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x].index)

	for uuu,v1 in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		if v1 ~= nil and v1.index ~= nil and v1.combining ~= true and EntIndexToHScript(v1.index):FindAbilityByName('is_druid') ~= nil then
			local v1_chess = EntIndexToHScript(v1.index)
			if v1 ~= nil and GetChessStar(v1_chess) == level then
				local v1_cost = GameRules:GetGameModeEntity().chess_2_mana[GetChessTypeName(v1_chess)]
				if io.io_target_index ~= nil and v1.index == io.io_target_index then
					v1_cost = 999
				end
				if max_cost < v1_cost then
					c1 = v1
					max_cost = v1_cost
				end
			end
		end
	end
	return c1
end



function GetHumanCount(team_id)
	local human_table = {}
	for w,vw in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		local find_name = vw.chess
		if string.find(find_name,'11') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if string.find(find_name,'1') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy['is_human'],find_name) == true and FindValueInTable(human_table,find_name) ~= true then
			table.insert(human_table,find_name)
		end
	end
	local human_count = table.maxn(human_table) or 0
	local wizard_count = GetWizardCount(team_id)
	if wizard_count >= 2 and human_count >= 4 then
		human_count = human_count + 1
	end
	if TeamId2Hero(team_id).the_only_combo_self ~= nil and TeamId2Hero(team_id).the_only_combo_self == 'is_human' and wizard_count >= 3 then
		human_count = 6
	end
	return human_count
end
function GetDruidCount(team_id)
	--德鲁伊种族技能
	--统计有多少不同的德鲁伊
	local druid_table = {}
	for w,vw in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		local find_name = vw.chess
		if string.find(find_name,'11') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if string.find(find_name,'1') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_druid,find_name) == true and FindValueInTable(druid_table,find_name) ~= true then
			table.insert(druid_table,find_name)
		end
	end
	return table.maxn(druid_table) or 0
end
function GetPandamanCount(team_id)
	--获取当前熊猫人数量，最多为3
	local pandaman_set = {
		[1] = 'chess_ember',
		[2] = 'chess_brew',
		[3] = 'chess_storm',
		[4] = 'chess_earth',
	}
	local pandaman_table = {}
	for w,vw in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		local find_name = vw.chess
		if string.find(find_name,'11') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if string.find(find_name,'1') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if FindValueInTable(pandaman_set,find_name) == true and FindValueInTable(pandaman_table,find_name) ~= true then
			table.insert(pandaman_table,find_name)
		end
	end
	local wizard_count = GetWizardCount(team_id)
	local panda_count = table.maxn(pandaman_table) or 0
	if panda_count > 3 then
		panda_count = 3
	end
	if TeamId2Hero(team_id).the_only_combo_self ~= nil and TeamId2Hero(team_id).the_only_combo_self == 'is_pandaman' and wizard_count >= 3 then
		panda_count = 3
	end

	return panda_count
end

--结算一名玩家，兼容1P和2P的模式
function PostOneToServer(hero,steamid,rank,mode)
	SetStat(hero:GetPlayerID(), 'rank', rank)

	local quest = GameRules:GetGameModeEntity().quest_status[hero:GetTeam()]
	local chess_lineup = GetStat(hero:GetPlayerID(),'chess_lineup')
	local url = "http://autochess.ppbizon.com/game/post/one/@"..GameRules:GetGameModeEntity().steamidlist.."@"..steamid.."@"..rank.."?hehe="..RandomInt(1,10000).."&duration="..math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME)..GetSendKey()..'&map='..GetMapName()..'&chess_lineup='..chess_lineup

	if mode == 'p1' then
		url = url..'&settings='..json.encode(GameRules:GetGameModeEntity().user_setting[steamid])
	else
		url = url..'&mode=p2&teammate='..TeamId2Hero(GetP2Ally(hero:GetTeam())).steam_id..'&settings='..json.encode(GameRules:GetGameModeEntity().user_setting[steamid])
	end
	if quest == true then
		url = url..'&finish_quest=1'
	end
	local tt = GameRules:GetGameModeEntity().stat_info[steamid]
	local total_team = GameRules:GetGameModeEntity().playing_player_count
	if GameRules:GetGameModeEntity().p2_mode == true then
		total_team = math.floor(GameRules:GetGameModeEntity().playing_player_count/2)
	end
	GameRules:GetGameModeEntity().send_info[steamid] = {
		account_id = steamid,
		rank = rank,
		total = total_team,
		level = tt['mmr_level'],
		candy = 0,
		biscuit = 0,
		chess = tt['chess_lineup'],
		win_round = tt['win_round'],
		lose_round = tt['lose_round'],
		kills = tt['kills'],
		deaths = tt['deaths'],
		gold = tt['gold'],
		duration = tt['duration'],
	}
	SendHTTP(url.."&from=SyncHP", function(t)
		if t.err == 0 then
			-- print(json.encode(t))
			-- prt(json.encode(t))
			local v = t.mmr_info
			if GameRules:GetGameModeEntity().stat_info[v.userid] ~= nil then
				GameRules:GetGameModeEntity().send_info[v.userid]['account_id'] = v.userid
				GameRules:GetGameModeEntity().send_info[v.userid]['rank'] = v.rank
				GameRules:GetGameModeEntity().send_info[v.userid]['total'] = v.total
				GameRules:GetGameModeEntity().send_info[v.userid]['level'] = v.level
				GameRules:GetGameModeEntity().send_info[v.userid]['candy'] = v.candy or 0
				GameRules:GetGameModeEntity().send_info[v.userid]['biscuit'] = v.biscuit or 0

				GameRules:GetGameModeEntity().stat_info[v.userid]['candy'] = v.candy or 0
				GameRules:GetGameModeEntity().stat_info[v.userid]['biscuit'] = v.biscuit or 0
				GameRules:GetGameModeEntity().stat_info[v.userid]['level_delta'] = v.level_delta or 0
				GameRules:GetGameModeEntity().stat_info[v.userid]['delta'] = v.mmr_delta or 0
				GameRules:GetGameModeEntity().stat_info[v.userid]['mmr_level'] = v.level
				GameRules:GetGameModeEntity().stat_info[v.userid]['queen_rank'] = v.queen_rank

				GameRules:GetGameModeEntity().send_time = {
					end_time = t.end_time,
					year = t.year,
					month = t.month,
					date = t.date,
					hour = t.hour,
					minute = t.minute,
					second = t.second,
				}
				local totalrank = 1
				if mode == 'p1' then
					totalrank = GameRules:GetGameModeEntity().playing_player_count
				else
					totalrank = GetP2TeamCount()
				end
				CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_gameover",{
					key = GetClientKey(hero:GetTeam()),
					hehe = RandomInt(1,100000),
					rank = v.rank,
					total_rank = totalrank,
					level = v.level,
					candy = v.candy,
					biscuit = v.biscuit,
					mmr_delta = v.mmr_delta,
					level_delta = v.level_delta,
					queen_rank = v.queen_rank,
					mode = mode,
					exp_info = t.exp_info,
					quest_id = GameRules:GetGameModeEntity().egg_quest,
					quest_status = v.quest_status,
				})
				if mode == 'p1' and rank == 1 then
					local dur = GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME+3
					-- if hero == nil then
					-- 	prt('hero nil')
					-- end
					SetStat(GameRules:GetGameModeEntity().steamid2playerid[hero.steam_id], 'duration', dur)
					SetStat(GameRules:GetGameModeEntity().steamid2playerid[hero.steam_id], 'round', GameRules:GetGameModeEntity().battle_round)
					--保存最终阵容
					local lineup = ''
					for _,v in pairs(GameRules:GetGameModeEntity().mychess[hero:GetTeam()]) do
						if v ~= nil and v.chess ~= nil then 
							lineup = lineup..v.chess..','
						end
					end
					SetStat(GameRules:GetGameModeEntity().steamid2playerid[hero.steam_id], 'chess_lineup',lineup)
					Timers:CreateTimer(2,function()
						local ready_2_post = false
						local ready_1_post = false
						for y,z in pairs(GameRules:GetGameModeEntity().send_info) do
							if z.rank == 1 then
								ready_1_post = true
							end
							if z.rank == 2 then
								ready_2_post = true
							end
						end
						--展示结束面板，结束游戏！
						Timers:CreateTimer(8,function()
							GameRules:SetGameWinner(hero:GetTeam())
							GameRules:GetGameModeEntity().setwin = 1
						end)
						Timers:CreateTimer(5,function()
							PostGame()
						end)
						if ready_2_post == true and ready_1_post == true then
							prt('Send Amazon Data')
							local t = GameRules:GetGameModeEntity().send_time
							local amzdate = string.format(
							    '%s%s%sT%s%s%sZ',
							    t.year, t.month, t.date, t.hour, t.minute, t.second
							)
							local datestamp = string.format(
							    '%s%s%s',
							    t.year, t.month, t.date
							)
							SendAmazonData(CollectAmazonData(dur),amzdate,datestamp)					
						end
					end)
					EmitGlobalSound("DOTAMusic_Diretide_Finale")

					--提交阵容
					if table.maxn(GameRules:GetGameModeEntity().upload_lineup) > 0 then
						local str = ''
						for i,v in pairs(GameRules:GetGameModeEntity().upload_lineup) do
							str = str..json.encode(v)..'|'
						end
						str = string.sub(str,1,-2)
						local url_up = "http://autochess.ppbizon.com/lineup/add?lineups="..str.."&bans="..GameRules:GetGameModeEntity().bans.."&hehe="..RandomInt(1,10000)..GetSendKey()
						local req_up = CreateHTTPRequestScriptVM("GET", url_up)
						req_up:SetHTTPRequestAbsoluteTimeoutMS(20000)
						req_up:Send(function (result)
							local t_up = json.decode(result["Body"])
							if t_up.err == 0 then
								prt('SAVE CLOUD LINEUP OK!')
							end
						end)
					end
				elseif mode == 'p2' and rank == 1 then
					local dur = GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME+3
					SetStat(hero:GetPlayerID(), 'duration', dur)
					SetStat(hero:GetPlayerID(), 'round', GameRules:GetGameModeEntity().battle_round)
					--保存最终阵容
					local lineup = ''
					for _,v in pairs(GameRules:GetGameModeEntity().mychess[hero:GetTeam()]) do
						if v ~= nil and v.chess ~= nil then 
							lineup = lineup..v.chess..','
						end
					end
					SetStat(hero:GetPlayerID(), 'chess_lineup',lineup)
					--胜利队伍第一个人提交
					if GameRules:GetGameModeEntity().p2_win_settle == false then
						GameRules:GetGameModeEntity().p2_win_settle = true
					--胜利队伍第二个人提交
					else
						prt('2P END GAME')
						EmitGlobalSound("DOTAMusic_Diretide_Finale")
						local dur = GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME+3
						SetStat(hero:GetPlayerID(), 'duration', dur)
						SetStat(hero:GetPlayerID(), 'round', GameRules:GetGameModeEntity().battle_round)

						Timers:CreateTimer(4,function()
							prt('Send Amazon Data')					
							local t = GameRules:GetGameModeEntity().send_time
							local amzdate = string.format(
							    '%s%s%sT%s%s%sZ',
							    t.year, t.month, t.date, t.hour, t.minute, t.second
							)
							local datestamp = string.format(
							    '%s%s%s',
							    t.year, t.month, t.date
							)
							SendAmazonData(CollectAmazonData(dur,'2p'),amzdate,datestamp)
						end)
						--提交阵容
						if table.maxn(GameRules:GetGameModeEntity().upload_lineup) > 0 then
							local str = ''
							for i,v in pairs(GameRules:GetGameModeEntity().upload_lineup) do
								str = str..json.encode(v)..'|'
							end
							str = string.sub(str,1,-2)
							local url_up = "http://autochess.ppbizon.com/lineup/add?lineups="..str.."&hehe="..RandomInt(1,10000)..GetSendKey()
							local req_up = CreateHTTPRequestScriptVM("GET", url_up)
							req_up:SetHTTPRequestAbsoluteTimeoutMS(20000)
							req_up:Send(function (result)
								local t_up = json.decode(result["Body"])
								if t_up.err == 0 then
									prt('SAVE CLOUD LINEUP OK!')
								end
							end)
						end
						-- 展示结束面板，结束游戏！
						Timers:CreateTimer(8,function()
							GameRules:SetGameWinner(hero:GetTeam())
							GameRules:GetGameModeEntity().setwin = 1
						end)
						Timers:CreateTimer(5,function()
							PostGame()
						end)
					end
				end
			end
		else
			prt('GAME POST FAILED...')
			--单独结算失败了，不应该结束游戏
			-- PostGame()
			-- Timers:CreateTimer(3,function()
			-- 	GameRules:SetGameWinner(hero:GetTeam())
			-- 	GameRules:GetGameModeEntity().setwin = 1
			-- end)
		end
	end,function(t)
		prt('GAME POST FAILED...')
		--单独结算失败了，不应该结束游戏
		-- PostGame()
		-- Timers:CreateTimer(3,function()
		-- 	GameRules:SetGameWinner(hero:GetTeam())
		-- 	GameRules:GetGameModeEntity().setwin = 1
		-- end)
	end)

	if rank == 1 then
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_win",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
			emoji = 12,
		})

		if RandomInt(1,100) <= 50 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'chicken', 1)
	    end
	    if RandomInt(1,100) <= 50 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'chicken', 4)
	    end
	    if RandomInt(1,100) <= 50 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'chicken', 7)
	    end
	end
end
function SyncHP(hero)
	SetStat(hero:GetPlayerID(),'hp',hero:GetHealth())
	if hero:GetHealth() < 100 and GameRules:GetGameModeEntity().battle_round <= 10 and GameRules:GetGameModeEntity().egg_quest == 'q010' then
		SetQuest(hero.team_id,false)
	end
	CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,1000)})

	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = hero:GetPlayerID(),
		hp = hero:GetHealth(),
		hp_max = hero:GetMaxHealth(),
		mp = hero:GetMana(),
		level = hero:GetLevel(),
		win_streak = hero.win_streak,
	})

	if GameRules:GetGameModeEntity().START_TIME == nil then
		return
	end
	SetStat(hero:GetPlayerID(), 'duration', GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME)
	SetStat(hero:GetPlayerID(), 'round', GameRules:GetGameModeEntity().battle_round)
	Timers:CreateTimer(0.3,function()
		if hero:IsAlive() == false or hero:GetHealth() <= 0 then
			SetPlayerDead(hero)
		end
	end)
end

function SetPlayerDead(hero)
	if GameRules:GetGameModeEntity().death[hero:GetTeam()] == true then
		return
	end
	GameRules:GetGameModeEntity().death[hero:GetTeam()] = true
	SetRankingState(hero)
	Timers:CreateTimer(0.5,function()
		DealFuneralAffairs(hero)
	end)

	RemoveAllCheerCourier(hero:GetTeam())
end

function DealFuneralAffairs(hero)
	if hero:IsAlive() == true then
		hero:ForceKill(false)
	end
	EmitSoundOn("diretide.sad",hero)	

	--保存最终阵容
	local lineup = ''
	local lineup_count = 0

	--统计这个死亡的玩家都有哪些装备
	local gg_items = {}

	for _,v in pairs(GameRules:GetGameModeEntity().mychess[hero:GetTeam()]) do
		if v ~= nil and v.chess ~= nil and lineup_count < hero:GetLevel() then 
			lineup = lineup..v.chess..','
			AddAChessToChessPool(v.chess)
			lineup_count = lineup_count + 1

			if v.lastitem ~= nil then
				for _,i in pairs(v.lastitem) do
					if i ~= nil then
						table.insert(gg_items,i)
					end
				end
			end
		end
	end
	--把牌+洗回牌库
	if hero.hand_entities ~= nil then
		for i=1,8 do
			local unitname = ''
			if hero.hand_entities[i] ~= nil and hero.hand_entities[i]:IsNull() == false then
				unitname = hero.hand_entities[i]:GetUnitName()
				AddAChessToChessPool(unitname)

				for slot=0,9 do
					if hero.hand_entities[i]:GetItemInSlot(slot) ~= nil then
						local name = hero.hand_entities[i]:GetItemInSlot(slot):GetAbilityName()
						table.insert(gg_items,name)
					end
				end								
			end
		end
	end
	SetStat(hero:GetPlayerID(), 'chess_lineup',lineup)

	--清理商店残留棋子
	if hero.curr_chess_table ~= nil then
		for _,chess in pairs(hero.curr_chess_table) do
			if chess ~= nil then
				AddAChessToChessPool(chess)
			end
		end
	end

	for slot=0,9 do
		if hero:GetItemInSlot(slot)~= nil then
			local name = hero:GetItemInSlot(slot):GetAbilityName()
			table.insert(gg_items,name)
			hero:RemoveItem(hero:GetItemInSlot(slot))
		end
	end
	--遗产
	local gg_item_count = 0
	local alive_player_count = GetAlivePlayerCount()
	for _,gg_item in pairs(gg_items) do
		if RandomInt(1,100) < (alive_player_count*10) then
			if GameRules:GetGameModeEntity().combined_items_recipe[gg_item] ~= nil then
				for _,v in pairs(string.split(GameRules:GetGameModeEntity().combined_items_recipe[gg_item],';')) do
					RandomDropOneGGItem(v,hero)
					gg_item_count = gg_item_count + 1
				end
			else
				RandomDropOneGGItem(gg_item,hero)
				gg_item_count = gg_item_count + 1
			end
		end
	end
	--棺材本
	local guancai_money = math.floor(hero:GetMana()*(alive_player_count*10)/100)
	local lucky_team_table = {
		[6] = 0,
		[7] = 0,
		[8] = 0,
		[9] = 0,
		[10] = 0,
		[11] = 0,
		[12] = 0,
		[13] = 0,
	}
	local try_count = 0
	local money_left = guancai_money
	while try_count < 10000 and money_left > 0 do 
		local random_team = RandomInt(6,13)
		local h = TeamId2Hero(random_team)
		if h ~= nil and h:IsAlive() == true and random_team ~= hero:GetTeam() then
			lucky_team_table[random_team] = lucky_team_table[random_team] + 1
			money_left = money_left - 1
		end
		try_count = try_count + 1
	end

	for t,count in pairs(lucky_team_table) do
		if count > 0 then
			local position_to = CenterVector(t) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
			DropMoneyBag(Vector(0,0,128), position_to, 300, ( count or 1 ))
			-- local hero = TeamId2Hero(t)
			-- if hero ~= nil and hero:GetPlayerID() ~= nil then
			-- 	AddTotalMoneyStat(hero:GetPlayerID(),count)
			-- end
		end
	end

	ShowCombat({
		t = 'player_dead',
		player = hero:GetPlayerID(),
		num = gg_item_count,
		gold = guancai_money,
	})

	--给击杀者一个大红包
	local last_damaged_by_team = hero.last_damaged_by_team
	local win_round = math.floor(GetStat(hero:GetPlayerID(),'win_round')/2.0+0.5)
	-- prt('击杀者：'..last_damaged_by_team)
	if last_damaged_by_team ~= nil and last_damaged_by_team ~= hero:GetTeam() and win_round ~= nil and win_round > 0 then
		local position_to = CenterVector(last_damaged_by_team) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
		DropMoneyBag(Vector(0,0,128), position_to, 100, ( win_round or 1 ))
		ShowCombat({
			t = 'terminate',
			player = hero:GetPlayerID(),
			player2 = TeamId2Hero(last_damaged_by_team):GetPlayerID(),
			num = win_round,
		})
	end

	Timers:CreateTimer(0.3,function()
		ClearHand(hero:GetTeam())
	end)
end

function GetAlivePlayerCount()
	return table.maxn(GameRules:GetGameModeEntity().send_status)
end
--根据玩家存活情况结算刚刚战败的玩家hero
function SetRankingState(hero)
	GameRules:GetGameModeEntity().counterpart[hero:GetTeam()] = -1
	if GetAlivePlayerCount() == 1 and GameRules:GetGameModeEntity().playing_player_count == 1 then
		--1P单人模式，直接结束游戏
		GameRules:GetGameModeEntity().is_game_ended = true
		prt('GAME OVER')
		EmitGlobalSound("dac.season.gameover")
		PostGame()
		Timers:CreateTimer(3,function()
			GameRules:SetGameWinner(DOTA_TEAM_NEUTRALS)
		end)
		return
	end
	if GameRules:GetGameModeEntity().p2_mode == true and FindValueInTable(GameRules:GetGameModeEntity().p2_death_table,hero.p2team) == false then
		table.insert(GameRules:GetGameModeEntity().p2_death_table,hero.p2team)
	end

	local alive_player_count = GetAlivePlayerCount()

	if GameRules:GetGameModeEntity().p2_mode == true and alive_player_count >= 2 then
		--2P模式，剩余队伍>=1，正常结算
		local team_rank = nil
		for xx,yy in pairs(GameRules:GetGameModeEntity().p2_death_table) do
			if hero.p2team == yy then
				team_rank = GetP2TeamCount()+1-xx
			end
		end
		if team_rank ~= nil then
			if FindValueInTable(GameRules:GetGameModeEntity().send_status,hero.steam_id) == true then
				RemoveTableItem(GameRules:GetGameModeEntity().send_status,hero.steam_id)
				PostOneToServer(hero,hero.steam_id,team_rank,'p2')
				local teammate = TeamId2Hero(GetP2Ally(hero:GetTeam()))
				if teammate ~= nil and FindValueInTable(GameRules:GetGameModeEntity().send_status,teammate.steam_id) == true then
					RemoveTableItem(GameRules:GetGameModeEntity().send_status,teammate.steam_id)
					PostOneToServer(teammate,teammate.steam_id,team_rank,'p2')
				end
			end
		end
	end
	if GameRules:GetGameModeEntity().p2_mode == true and alive_player_count <= 2 then
		--2P模式，剩余队伍<=1，结算胜者（2个玩家），游戏结束
		if GameRules:GetGameModeEntity().p2_win_sent == true then
			return
		end
		GameRules:GetGameModeEntity().p2_win_sent = true
		GameRules:GetGameModeEntity().is_game_ended = true
		prt('GAME OVER')
		if alive_player_count > 0 then
			if GameRules:GetGameModeEntity().send_status[2] ~= nil then
				local steamid_2 = GameRules:GetGameModeEntity().send_status[2]
				RemoveTableItem(GameRules:GetGameModeEntity().send_status,steamid_2)
				local h_2 = PlayerId2Hero(GameRules:GetGameModeEntity().steamid2playerid[steamid_2])
				if GameRules:GetGameModeEntity().egg_quest == 'q002' and GetMapName() == 'ranked_2x4' then
					SetQuest(h_2.team_id,true)
				end
				PostOneToServer(h_2,steamid_2,1,'p2')
			end
			if GameRules:GetGameModeEntity().send_status[1] ~= nil then
				local steamid_1 = GameRules:GetGameModeEntity().send_status[1]
				RemoveTableItem(GameRules:GetGameModeEntity().send_status,steamid_1)
				local h_1 = PlayerId2Hero(GameRules:GetGameModeEntity().steamid2playerid[steamid_1])
				if GameRules:GetGameModeEntity().egg_quest == 'q002' and GetMapName() == 'ranked_2x4' then
					SetQuest(h_1.team_id,true)
				end
				PostOneToServer(h_1,steamid_1,1,'p2')
			end
		end
	end

	if alive_player_count >= 2 and GameRules:GetGameModeEntity().p2_mode ~= true and GameRules:GetGameModeEntity().playing_player_count > 1 then
		--1P多人模式，当前名次>=2，正常结算
		if FindValueInTable(GameRules:GetGameModeEntity().send_status,hero.steam_id) == true then
			RemoveTableItem(GameRules:GetGameModeEntity().send_status,hero.steam_id)
			PostOneToServer(hero,hero.steam_id,alive_player_count,'p1')
		end
	end
	if alive_player_count <= 2 and GameRules:GetGameModeEntity().p2_mode ~= true and GameRules:GetGameModeEntity().playing_player_count > 1 then
		GameRules:GetGameModeEntity().is_game_ended = true
		--1P第一名
		if GetAlivePlayerCount() == 1 then
			local last_steamid = GameRules:GetGameModeEntity().send_status[1]
			local last_hero = PlayerId2Hero(GameRules:GetGameModeEntity().steamid2playerid[last_steamid])
			RemoveTableItem(GameRules:GetGameModeEntity().send_status,last_steamid)
			if GameRules:GetGameModeEntity().egg_quest == 'q001' and GetMapName() == 'ranked_1x8' then
				SetQuest(last_hero.team_id,true)
			end

			PostOneToServer(last_hero,last_steamid,1,'p1')
		end
		--为防止发送失败了，30秒后自动结束游戏
		Timers:CreateTimer(30,function()
			if GameRules:GetGameModeEntity().setwin == nil then
				GameRules:SetGameWinner(last_hero:GetTeam())
			end
		end)
	end
	--hero是刚刚战败的玩家
	if GetAlivePlayerCount() == 2 and GameRules:GetGameModeEntity().playing_player_count > 2 and GameRules:GetGameModeEntity().p2_mode ~= true then
		--1P模式：决赛提醒
		GameRules:GetGameModeEntity().pilao_round = GameRules:GetGameModeEntity().battle_round + 6 --野怪关不算
		prt('#text_grand_final_start')
		-- EmitGlobalSound("diretide_eventstart_Stinger")
		EmitGlobalSound("dac.season.grandfinal")

		--给决赛双方添加一些观众
		for _,steam_id in pairs(GameRules:GetGameModeEntity().send_status) do
			local player_id = GameRules:GetGameModeEntity().steamid2playerid[steam_id]
			local team_id = GameRules:GetGameModeEntity().playerid2team[player_id]
			SummonCheerCourier(team_id,3)
		end
		if RandomInt(1,100) < 25 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'grand_final', 3)
	    end
	    if RandomInt(1,100) < 25 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'grand_final', 6)
	    end
	end
end
function PostGame()
	CustomNetTables:SetTableValue( "dac_table", "end_board", { data = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,100000)})
end
function PostPlayerInfo()
	StatAllPlayerLineup()
	UpdateStatUI()
end
function LoadPVEEnemy(wave,team)
	if GameRules:GetGameModeEntity().battle_boss[wave] ~= nil then
		for _,vi in pairs(GameRules:GetGameModeEntity().battle_boss[wave]) do
			LoadOnePVEEnemy(vi,team)
		end
	end
	Timers:CreateTimer(4.5,function()
		AddComboAbility(team)
	end)
end

function LoadOnePVEEnemy(vi,team)
	local animation_info = GetAnimation('n101')
	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector(vi.x,vi.y,team),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end
			GameRules:GetGameModeEntity().unit[team][vi.y..'_'..vi.x] = 1
			local x = CreateUnitByName(vi.enemy,XY2Vector(vi.x,vi.y,team),true,nil,nil,DOTA_TEAM_NEUTRALS)
			x:SetForwardVector(Vector(0,-1,0))
			x.y_x = vi.y..'_'..vi.x
			x.y = vi.y
			x.x = vi.x
			x.team_id = 4
			x.at_team_id = team
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			table.insert(GameRules:GetGameModeEntity().to_be_destory_list[team],x)

			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
		end)
	end)

end



--掉宝
function DropItem(unit)
	local unit_level = unit:GetLevel()
	if unit_level <= 2 or unit.is_summoned == true then 
		return
	end


	local hero = TeamId2Hero(unit.at_team_id )
	local ran = RandomInt(1,100)
	if hero.undrop_item_count_total ~= nil and hero.undrop_item_count_total > 0 then
		ran = ran + hero.undrop_item_count_total
	end
	if ran > 100 then
		ran = 100
	end
	local item_level = 0
	local curr_per = 0
	



	if GameRules:GetGameModeEntity().drop_item_gailv[unit_level] ~= nil then
		for per,lv in pairs(GameRules:GetGameModeEntity().drop_item_gailv[unit_level]) do
			if ran >= per and curr_per<=per then
				curr_per = per
				item_level = lv
			end
		end
	end
	
	

	if item_level > 0 then
		if hero.undrop_item_count_total == nil then
			hero.undrop_item_count_total = -1
		else
			hero.undrop_item_count_total = hero.undrop_item_count_total - item_level
		end

		-- prt(hero.player_name..'的非气值为'..hero.undrop_item_count_total..' (ceshi用，这句话不会在正式服显示)')

		--掉
		local i = GameRules:GetGameModeEntity().DROP_ITEM_LIST[item_level][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().DROP_ITEM_LIST[item_level]))]

		-- hero:AddItemByName(i)

		local newItem = CreateItem( i, hero, hero )
		local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
		local dropRadius = RandomFloat( 50, 200 )
		newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
		hero.undrop_item_count = 0
	else
		--没掉
		if hero.undrop_item_count_total == nil then
			hero.undrop_item_count_total = 1
		else
			hero.undrop_item_count_total = hero.undrop_item_count_total + 1
		end

		if hero.undrop_item_count == nil then
			hero.undrop_item_count = 1
		else
			hero.undrop_item_count = hero.undrop_item_count + 1
			if hero.undrop_item_count >= 5 then
				hero.undrop_item_count = 0
				local i = GameRules:GetGameModeEntity().ITEM_FOOD_LIST[RandomInt(1,table.maxn(GameRules:GetGameModeEntity().ITEM_FOOD_LIST))]

				-- hero:AddItemByName(i)

				local newItem = CreateItem( i, hero, hero )
				local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
				local dropRadius = RandomFloat( 50, 200 )
				newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
			end
		end
	end
end

function DropItemAppointed(hero,unit,item)
	-- hero:AddItemByName(item)
	local newItem = CreateItem( item, hero, hero )
	local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
	local dropRadius = RandomFloat( 10, 100 )
	if unit == nil or unit:IsNull() == true or unit:GetAbsOrigin() == nil then
		unit = hero
	end
	newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
end
function StartAPVERound()
	-- GameRules:GetGameModeEntity().battle_count = 0
	InitBattleTable()

	--为每个场地加载敌人
	for i,v in pairs (GameRules:GetGameModeEntity().counterpart) do
		if v ~= -1 then
			-- GameRules:GetGameModeEntity().battle_count = GameRules:GetGameModeEntity().battle_count + 1
			SetBattleTable(i,true)
			v = 0
			local h = TeamId2Hero(i)
			CheckChess(i)
			CancelPickChess(h)
			StatClassCount(i)
			LoadPVEEnemy(GameRules:GetGameModeEntity().battle_round,i)
			local mana = h:GetMana()
			if mana>5 then
				mana = 5
			end
		end
	end

	--每秒判断每个场地是否决出了胜负
	Timers:CreateTimer(1,function()
		if GameRules:GetGameModeEntity().start_ai == false then
			return 1
		end
		for m,n in pairs (GameRules:GetGameModeEntity().to_be_destory_list) do
			if table.maxn(n) > 0 then
				Timers:CreateTimer(function()
					if GameRules:GetGameModeEntity().battle_timer <= 0 then
						--平局
						SetBattleTable(m,false)
						EmitSoundOn("dac.round.win",TeamId2Hero(m))
						ShowCombat({
							t = 'battle_pve_draw',
							player = TeamId2Hero(m):GetPlayerID(),
							text = '#pve_'..(GameRules:GetGameModeEntity().battle_round-1),
						})
						SaveMaxObj(m,'draw')

						--通知UI显示胜负
						for team_i=6,13 do
							CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
								key = GetClientKey(team_i),
								player_id = TeamId2Hero(m):GetPlayerID(),
								winlose = "draw",
							})
						end
						CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
							key = GetClientKey(1),
							player_id = TeamId2Hero(m):GetPlayerID(),
							winlose = "draw",
						})
						TeamId2Hero(m).is_battle_completed = true
						ShowDamageStatOfTeam(m)
						return
					else
						local mychess = 0
						local enemychess = 0
						local my_last_chess = nil
						for p,q in pairs(GameRules:GetGameModeEntity().to_be_destory_list[m]) do
							if q.team_id == m then
								mychess = mychess + 1
								my_last_chess = q
							else
								enemychess = enemychess + 1
							end
						end
						if enemychess == 0 then
							SetBattleTable(m,false)
							HoorayAndMechHuman(m)
							local hero = TeamId2Hero(m)
							if my_last_chess ~= nil or hero.pet1 ~= nil then
								if hero.pet1 ~= nil and RandomInt(1,100) < 50 then
									PlayPetDialogue(hero.pet1, true, hero.language)
								else
									if my_last_chess ~= nil then
										PlayChessDialogue(my_last_chess,'win')
									end
								end
							end
							ShowCombat({
								t = 'battle_pve_win',
								player = TeamId2Hero(m):GetPlayerID(),
								text = '#pve_'..(GameRules:GetGameModeEntity().battle_round-1),
								num = mychess,
							})

							EmitSoundOn("dac.round.win",TeamId2Hero(m))
							SaveMaxObj(m,'win'..mychess)
							GiveALootBox(TeamId2Hero(m))
							AddHistoryWin(m,4)
							TeamId2Hero(m).is_battle_completed = true
							ShowDamageStatOfTeam(m)

							--通知UI显示胜负
							for team_i=6,13 do
								CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
									key = GetClientKey(team_i),
									player_id = TeamId2Hero(m):GetPlayerID(),
									winlose = "win",
								})
							end
							CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
								key = GetClientKey(1),
								player_id = TeamId2Hero(m):GetPlayerID(),
								winlose = "win",
							})

							return
						elseif mychess == 0 then
							Timers:CreateTimer(0.5,function()
								local enemychess_new = 0
								for p,q in pairs(GameRules:GetGameModeEntity().to_be_destory_list[m]) do
									if q.team_id ~= m then
										enemychess_new = enemychess_new + 1
									end
								end
								if enemychess_new == 0 then
									SetBattleTable(m,false)
									HoorayAndMechHuman(m)
									local hero = TeamId2Hero(m)
									if my_last_chess ~= nil or hero.pet1 ~= nil then
										if hero.pet1 ~= nil and RandomInt(1,100) < 50 then
											PlayPetDialogue(hero.pet1, true, hero.language)
										else
											if my_last_chess ~= nil then
												PlayChessDialogue(my_last_chess,'win')
											end
										end
									end
									ShowCombat({
										t = 'battle_pve_win',
										player = TeamId2Hero(m):GetPlayerID(),
										text = '#pve_'..(GameRules:GetGameModeEntity().battle_round-1),
										num = mychess,
									})
									SaveMaxObj(m,'win'..mychess)
									GiveALootBox(TeamId2Hero(m))
									EmitSoundOn("dac.round.win",TeamId2Hero(m))
									AddHistoryWin(m,4)

									--通知UI显示胜负
									for team_i=6,13 do
										CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
											key = GetClientKey(team_i),
											player_id = TeamId2Hero(m):GetPlayerID(),
											winlose = "win",
										})
									end
									CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
										key = GetClientKey(1),
										player_id = TeamId2Hero(m):GetPlayerID(),
										winlose = "win",
									})
								else
									if GameRules:GetGameModeEntity().egg_quest == 'q017' then
										SetQuest(m,false)
									end
									SetBattleTable(m,false)

									local hero = TeamId2Hero(m)
									local curr_hp = hero:GetHealth()

									ShowCombat({
										t = 'battle_pve_lose',
										player = TeamId2Hero(m):GetPlayerID(),
										text = '#pve_'..(GameRules:GetGameModeEntity().battle_round-1),
										num = enemychess_new,
									})

									--通知UI显示胜负
									for team_i=6,13 do
										CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
											key = GetClientKey(team_i),
											player_id = TeamId2Hero(m):GetPlayerID(),
											winlose = "lose",
										})
										CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
											key = GetClientKey(1),
											player_id = TeamId2Hero(m):GetPlayerID(),
											winlose = "lose",
										})
									end
									SaveMaxObj(m,'lose'..enemychess_new)
									EmitSoundOn("dac.round.lose",hero)
									AddHistoryLose(m,4)
									--清除拉比克技能
									for _,rchess in pairs(GameRules:GetGameModeEntity().mychess[m]) do
										if string.find(rchess.chess,'rubick') ~= nil then
											rchess.rubick_a = nil
										end
									end
								end
								TeamId2Hero(m).is_battle_completed = true
								ShowDamageStatOfTeam(m)
								return
							end)
						else
							return 1
						end
					end
				end)
			end
		end
	end)
	
	Timers:CreateTimer(1,function()
		if GameRules:GetGameModeEntity().start_ai == false then
			return 1
		end
		--战斗回合倒计时，所有比赛结束或者时间到了就终止，每秒同步倒计时时间给客户端
		CheckP2Status()
		if GameRules:GetGameModeEntity().battle_timer <= 0 then
			Timers:CreateTimer(2,function()
				for i,v in pairs(GameRules:GetGameModeEntity().hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				GameRules:GetGameModeEntity().game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		elseif GetBattleCount() == 0 and GameRules:GetGameModeEntity().battle_timer >= 3 then
			Timers:CreateTimer(2,function()
				for i,v in pairs(GameRules:GetGameModeEntity().hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				GameRules:GetGameModeEntity().game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		else
			local center_index = ''..Entities:FindByName(nil,"center0"):entindex()..','..Entities:FindByName(nil,"center1"):entindex()..','..Entities:FindByName(nil,"center2"):entindex()..','..Entities:FindByName(nil,"center3"):entindex()..','..Entities:FindByName(nil,"center4"):entindex()..','..Entities:FindByName(nil,"center5"):entindex()..','..Entities:FindByName(nil,"center6"):entindex()..','..Entities:FindByName(nil,"center7"):entindex()
			--发送当前游戏时间给客户端
			UpdateTimer()
			for team_i=6,13 do
				CustomGameEventManager:Send_ServerToTeam(team_i,"show_time",{
					key = GetClientKey(team_i),
					timer_round = GameRules:GetGameModeEntity().battle_timer,
					round_status = "battle",
					total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
					center_index = center_index,
				})
			end
			CustomGameEventManager:Send_ServerToTeam(1,"show_time",{
				key = GetClientKey(1),
				timer_round = GameRules:GetGameModeEntity().battle_timer,
				round_status = "battle",
				total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
				center_index = center_index,
			})

			GameRules:GetGameModeEntity().battle_timer = GameRules:GetGameModeEntity().battle_timer - 1
			return 1
		end
	end)
	Timers:CreateTimer(4.5,function()
		--添加战斗技能，开启ai
		for t = 6,13 do
			for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[t]) do
				v.is_in_battle = true
				if GameRules:GetGameModeEntity().chess_ability_list[v:GetUnitName()] ~= nil then
					local a = GameRules:GetGameModeEntity().chess_ability_list[v:GetUnitName()]
					if v.steal_ability ~= nil then
						a = v.steal_ability
					end
					local a_level = 1
					if string.find(v:GetUnitName(),'1') then
						a_level = 2
					end
					if string.find(v:GetUnitName(),'11') then
						a_level = 3
					end
					if v:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(v,a,a_level)
					else
						v:FindAbilityByName(a):SetLevel(a_level)
					end
					if v.is_dragon_zhanhou == nil then
						InitChessMana(v)
					end
				end
				Timers:CreateTimer(0.5,function()
					if v == nil or v:IsNull() == true or v:IsAlive() == false or v.alreadywon == true then
						return
					end
					ChessAI(v)
					return 1
				end)
			end
		end
	end)
end
function SaveMaxObj(team,outcome)
	local inserttable = {}
	for _,insertchess in pairs(GameRules:GetGameModeEntity().mychess[team]) do
		table.insert(inserttable,{
			x = insertchess.x,
			y = insertchess.y,
			chess = insertchess.chess
		})
	end

	local against = TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team])
	if against == nil then
		enemy = ''
	else
		enemy = against.steam_id
	end
	local maxobj = {
		owner = TeamId2Hero(team).steam_id,
		lineup = inserttable,
		round = GameRules:GetGameModeEntity().battle_round - 1,
		hp = TeamId2Hero(team):GetHealth(),
		against = enemy,
		outcome = outcome,
	}
	table.insert(GameRules:GetGameModeEntity().upload_detail_stat[TeamId2Hero(team).steam_id],maxobj)
end
--查户口
function CheckChess(team_id)
	local index_table = {}
	local dup_table = {}
	local chess_count = 0
	if TeamId2Hero(team_id) == nil then
		return
	end
	local hero_level = TeamId2Hero(team_id):GetLevel()
	for y_x,obj in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		if FindValueInTable(index_table,obj.index) == true and string.find(obj.chess,'1') then
			--重复了
			table.insert(dup_table,y_x)
		else
			table.insert(index_table,obj.index)
			chess_count = chess_count + 1
		end
	end
	GameRules:GetGameModeEntity().population[team_id] = chess_count
	GameRules:GetGameModeEntity().population_max[team_id] = hero_level
	
	if table.maxn(dup_table) > 0 then
		for _,y_x in pairs(dup_table) do
			GameRules:GetGameModeEntity().mychess[team_id][y_x] = nil
		end
	end
end
function StartAPVPRound()
	local send_table = {}
	for p,vp in pairs(GameRules:GetGameModeEntity().counterpart) do
		send_table[p] = GameRules:GetGameModeEntity().team2playerid[vp]
	end
	--为每个场地加载敌人（延时0.1-0.5秒）
	for i,v in pairs (GameRules:GetGameModeEntity().counterpart) do
		if v ~= -1 then
			local h = TeamId2Hero(i)
			if h.hand_entities ~= nil then
				for _,ent in pairs(h.hand_entities) do
					AddAbilityAndSetLevel(ent,'outofgame',1)
				end
			end
			CheckChess(i)
			CancelPickChess(h)
			StatClassCount(i)
			if GameRules:GetGameModeEntity().playing_player_count == 1 and GameRules:GetGameModeEntity().cloudlineup[''..GameRules:GetGameModeEntity().battle_round] ~= nil then
				local chesses = nil
				for _,data in pairs(GameRules:GetGameModeEntity().cloudlineup[''..GameRules:GetGameModeEntity().battle_round]) do
					chesses = json.decode(data)
				end
				
				LoadCloudEnemy(GameRules:GetGameModeEntity().battle_round,i)
				h.cloud_opp_name = chesses.owner
			else
				MirrorARound(i)
				h.cloud_opp_name = nil
			end

			if RandomInt(1,100) < 25 then
		    	SayCheerBubble(h:GetTeam(), nil, 'battle', 6)
		    end
		end
	end
	InitBattleTable()
	--添加战斗技能和棋子AI
	Timers:CreateTimer(4.5,function()
		for t = 6,13 do
			for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[t]) do
				v.is_in_battle = true
				if GameRules:GetGameModeEntity().chess_ability_list[v:GetUnitName()] ~= nil then
					local a = GameRules:GetGameModeEntity().chess_ability_list[v:GetUnitName()]
					if v.steal_ability ~= nil then
						a = v.steal_ability
					end
					local a_level = 1
					if string.find(v:GetUnitName(),'1') then
						a_level = 2
					end
					if string.find(v:GetUnitName(),'11') then
						a_level = 3
					end
					if v:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(v,a,a_level)
					else
						v:FindAbilityByName(a):SetLevel(a_level)
					end
					-- v:RemoveAbility('jiaoxie_wudi')
					-- v:RemoveModifierByName('modifier_jiaoxie_wudi')
					if v.is_dragon_zhanhou == nil then
						-- v:SetMana(0)
						InitChessMana(v)
					end

					if a == 'lc_qianggong' and v.press_count ~= nil and v.press_count > 0 then
						SetPressStack(v)
					end
					if v.track_money_count ~= nil and v.track_money_count > 0 then
						SetTrackMoneyStack(v)
					end
				end
				Timers:CreateTimer(0.5,function()
					if v == nil or v:IsNull() == true or v:IsAlive() == false or v.alreadywon == true then
						return
					end
					ChessAI(v)
					return 1
				end)
			end
		end
	end)
	--启动判断每个场地胜负的计时器（延时2秒）
	Timers:CreateTimer(2,function()
		for team = 6,13 do
			if GameRules:GetGameModeEntity().counterpart[team] ~= nil and GameRules:GetGameModeEntity().counterpart[team] ~= -1 then
				-- SaveMaxObj(team)
				-- GameRules:GetGameModeEntity().battle_count = GameRules:GetGameModeEntity().battle_count + 1
				SetBattleTable(team,true)
				StartWinLoseDrawTimerForTeam(team)
			end
		end
	end)

	--判断分是否战斗回合结束、进入准备回合的计时器（延时3秒）
	Timers:CreateTimer(3,function()
		CheckP2Status()
		if GameRules:GetGameModeEntity().battle_timer <= 0 then
			--战斗时间到了，进入准备回合
			Timers:CreateTimer(2,function()
				for i,v in pairs(GameRules:GetGameModeEntity().hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				GameRules:GetGameModeEntity().game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		elseif GetBattleCount() == 0 and GameRules:GetGameModeEntity().battle_timer >= 3 then
			--没有正在战斗的了，进入准备回合
			Timers:CreateTimer(2,function()
				for i,v in pairs(GameRules:GetGameModeEntity().hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				GameRules:GetGameModeEntity().game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		else
			--还有正在战斗的，发送时间给客户端
			local center_index = ''..Entities:FindByName(nil,"center0"):entindex()..','..Entities:FindByName(nil,"center1"):entindex()..','..Entities:FindByName(nil,"center2"):entindex()..','..Entities:FindByName(nil,"center3"):entindex()..','..Entities:FindByName(nil,"center4"):entindex()..','..Entities:FindByName(nil,"center5"):entindex()..','..Entities:FindByName(nil,"center6"):entindex()..','..Entities:FindByName(nil,"center7"):entindex()
			--发送当前游戏时间给客户端
			UpdateTimer()
			for team_i=6,13 do
				CustomGameEventManager:Send_ServerToTeam(team_i,"show_time",{
					key = GetClientKey(team_i),
					timer_round = GameRules:GetGameModeEntity().battle_timer,
					round_status = "battle",
					total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
					center_index = center_index
				})
			end
			CustomGameEventManager:Send_ServerToTeam(1,"show_time",{
				key = GetClientKey(1),
				timer_round = GameRules:GetGameModeEntity().battle_timer,
				round_status = "battle",
				total_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME),
				center_index = center_index
			})


			GameRules:GetGameModeEntity().battle_timer = GameRules:GetGameModeEntity().battle_timer - 1
			return 1
		end
	end)
end

--BattleTable是记录每个场地战斗情况的table，true为正在战斗
function InitBattleTable()
	GameRules:GetGameModeEntity().battle_count = {
		[6] = false,
		[7] = false,
		[8] = false,
		[9] = false,
		[10] = false,
		[11] = false,
		[12] = false,
		[13] = false,
	}
end
function InitDeathTable()
	GameRules:GetGameModeEntity().death = {
		[6] = false,
		[7] = false,
		[8] = false,
		[9] = false,
		[10] = false,
		[11] = false,
		[12] = false,
		[13] = false,
	}
end
function SetBattleTable(team_id,value)
	GameRules:GetGameModeEntity().battle_count[team_id] = value
end
function GetBattleCount()
	local battle_count = 0
	for _,i in pairs(GameRules:GetGameModeEntity().battle_count) do
		if i == true then
			battle_count = battle_count + 1
		end
	end
	return battle_count
end


--为指定队伍的场地开启一个胜平负判断计时器
function StartWinLoseDrawTimerForTeam(m)
	Timers:CreateTimer(3,function()
		if GameRules:GetGameModeEntity().battle_timer <= 0 then
			--第一种情况：时间到了，平局
			DrawARound(m)
			SaveMaxObj(m,'draw')
			TeamId2Hero(m).is_battle_completed = true
			ShowDamageStatOfTeam(m)
			return
		end
		
		--统计活着的敌我单位数量
		local mychess,enemychess,my_last_chess = GetChessCountInBattleGround(m)

		if mychess == 0 and enemychess == 0 then
			--第二种情况，敌我都没人了，平局
			DrawARound(m)
			SaveMaxObj(m,'draw')
			TeamId2Hero(m).is_battle_completed = true
			ShowDamageStatOfTeam(m)
			return
		end

		if mychess > 0 and enemychess == 0 then
			--第三种情况：敌方死光了，获胜
			WinARound(m,mychess,my_last_chess)
			SaveMaxObj(m,'win'..mychess)
			TeamId2Hero(m).is_battle_completed = true
			ShowDamageStatOfTeam(m)
			return
		elseif mychess == 0 then
			Timers:CreateTimer(0.5,function()
				--重新统计活着的敌我单位数量
				local mychess,enemychess_new,my_last_chess = GetChessCountInBattleGround(m)
				if enemychess_new == 0 then
					--第四种情况：敌我都死光了，平局
					DrawARound(m)
					SaveMaxObj(m,'draw')
					TeamId2Hero(m).is_battle_completed = true
					ShowDamageStatOfTeam(m)
					return
				else
					--第五种情况：只剩敌人了，失败
					LoseARound(m,enemychess_new)
					SaveMaxObj(m,'lose'..enemychess_new)
					TeamId2Hero(m).is_battle_completed = true
					ShowDamageStatOfTeam(m)
					return
				end
			end)
		else
			return 1
		end
	end)
end

function DrawARound(team)

	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	
	-- GameRules:GetGameModeEntity().battle_count = GameRules:GetGameModeEntity().battle_count - 1
	SetBattleTable(team,false)

	if TeamId2Hero(team).cloud_opp_name ~= nil then
		ShowCombat({
			t = 'battle_cloud_draw',
			player = TeamId2Hero(team):GetPlayerID(),
			text = TeamId2Hero(team).cloud_opp_name,
		})
	else
		ShowCombat({
			t = 'battle_pvp_draw',
			player = TeamId2Hero(team):GetPlayerID(),
			player2 = TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team]):GetPlayerID(),
		})
	end

	EmitGlobalSound('crowd.lv_01')
	AddStat(TeamId2Hero(team):GetPlayerID(),'draw_round')
	RemoveLoseStreak(team)
	RemoveWinStreak(team)

	--通知UI显示胜负
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
			key = GetClientKey(team_i),
			player_id = hero:GetPlayerID(),
			winlose = "draw",
		})
	end
	CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
			key = GetClientKey(1),
			player_id = hero:GetPlayerID(),
			winlose = "draw",
		})
end
function HoorayAndMechHuman(team)
	--显示胜利！
	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	EmitSoundOn("dac.round.win",hero)
	
	play_particle("effect/winaround/1/shovel_baby_roshan_spawn.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,3)
	play_particle("particles/units/heroes/hero_legion_commander/legion_commander_duel_victory.vpcf",PATTACH_OVERHEAD_FOLLOW,hero,3)
	local alive_units = GameRules:GetGameModeEntity().to_be_destory_list[team]
	local alive_mech = {}
	local mech_level = 0
	local alive_human = {}
	local human_level = 0
	for _,unit in pairs(alive_units) do
		if unit:HasAbility('lc_qianggong') == true then
			AddAbilityAndSetLevel(unit,'act_victory_lc')
			EmitSoundOn("chess_lc.qianggong",unit)
			AddPressCount(unit)
		else
			AddAbilityAndSetLevel(unit,'act_victory')
		end
		unit.alreadywon = true
		--工匠技能
		if unit:FindAbilityByName('is_mech') ~= nil then
			table.insert(alive_mech,unit)
			if hero.combo_self ~= nil and hero.combo_self['is_mech'] ~= nil and hero.combo_self['is_mech'] >= 3 then
				mech_level = 1
			end
			if hero.combo_self ~= nil and hero.combo_self['is_mech1'] ~= nil and hero.combo_self['is_mech1'] >= 6 then
				mech_level = 2
			end
		end
		--人类技能
		if unit:FindAbilityByName('is_human') ~= nil then
			table.insert(alive_human,unit)
			if hero.combo_self ~= nil and hero.combo_self['is_human'] ~= nil and hero.combo_self['is_human'] >= 3 then
				human_level = 1
			end
			if hero.combo_self ~= nil and hero.combo_self['is_human1'] ~= nil and hero.combo_self['is_human1'] >= 6 then
				human_level = 2
			end
		end
	end
	--工匠发明
	if table.maxn(alive_mech) >= 1 and mech_level == 1 then
		-- hero:AddItemByName('item_jixiezhixin')
		AddItemPlus(hero,'item_jixiezhixin')
		for _,unit in pairs(alive_mech) do
			play_particle("particles/econ/items/dazzle/dazzle_ti6/dazzle_ti6_shallow_grave_glyph_flare.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,2)
		end
		EmitSoundOn("ex_machina_get",hero)
	end
	if table.maxn(alive_mech) >= 1 and mech_level == 2 then
		AddItemPlus(hero,'item_jixiezhixin_gold')
		for _,unit in pairs(alive_mech) do
			play_particle("particles/econ/items/dazzle/dazzle_ti6_gold/dazzle_ti6_shallow_grave_gold_glyph_flare.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,2)
		end
		EmitSoundOn("ex_machina_get",hero)
	end
	--人类思想火花
	if table.maxn(alive_human) >= 1 and human_level == 2 then
		AddItemPlus(hero,'item_zhishizhishu')
		AddItemPlus(hero,'item_zhishizhishu')
		for _,unit in pairs(alive_human) do
			play_particle("particles/units/heroes/hero_wisp/wisp_death.vpcf",PATTACH_ABSORIGIN_FOLLOW,unit,2)
		end
		EmitSoundOn("is_human.magic",hero)
	end
end
function WinARound(team,mychess,my_last_chess)
	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	HoorayAndMechHuman(team)
	SetBattleTable(team,false)
	--宠物庆祝动作
	if hero.pet1 ~= nil then
		AddAbilityAndSetLevel(hero.pet1,'act_victory')
		
		Timers:CreateTimer(10,function()
			if hero.pet1 ~= nil then
				RemoveAbilityAndModifier(hero.pet1,'act_victory')
			end
		end)
		--发表胜利感言
		if my_last_chess ~= nil or hero.pet1 ~= nil then
			if hero.pet1 ~= nil and RandomInt(1,100) < 20 then
				PlayPetDialogue(hero.pet1, true, hero.language)
			else
				if my_last_chess ~= nil then
					PlayChessDialogue(my_last_chess,'win')
				end
			end
		end
	end
	if TeamId2Hero(team).cloud_opp_name ~= nil then
		AddHistoryWin(team,5)
		ShowCombat({
			t = 'battle_cloud_win',
			player = TeamId2Hero(team):GetPlayerID(),
			num = mychess,
			text = TeamId2Hero(team).cloud_opp_name,
		})
	else
		if GameRules:GetGameModeEntity().counterpart[team] ~= nil and TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team]) ~= nil then
			AddHistoryWin(team,GameRules:GetGameModeEntity().counterpart[team])
			ShowCombat({
				t = 'battle_pvp_win',
				player = TeamId2Hero(team):GetPlayerID(),
				player2 = TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team]):GetPlayerID(),
				num = mychess,
			})
		end
	end
	
	AddStat(TeamId2Hero(team):GetPlayerID(),'win_round')
	RemoveLoseStreak(team)
	AddWinStreak(team)

	local hero = TeamId2Hero(team)
	if hero.mirror_chesser ~= nil then
		hero.mirror_chesser:ForceKill(false)
		hero.mirror_chesser = nil
	end
	--得1金币
	AddMana(hero, 1)
	AddTotalMoneyStat(hero:GetPlayerID(), 1)
	--通知UI显示胜负
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
			key = GetClientKey(team_i),
			player_id = hero:GetPlayerID(),
			winlose = "win",
		})
	end
	CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
		key = GetClientKey(1),
		player_id = hero:GetPlayerID(),
		winlose = "win",
	})

	--召唤观战信使
	if RandomInt(1,100) <= 20 then
		RandomSummonCheerCourier(hero:GetTeam())
	end
	if RandomInt(1,100) < 50 then
    	SayCheerBubble(hero:GetTeam(), nil, 'win', 1)
    end
    if RandomInt(1,100) < 25 then
    	SayCheerBubble(hero:GetTeam(), nil, 'win', 4)
    end
	
	--概率存阵容
	if RandomInt(1,100) < 5 then
		local lineup_table = {}
		local chess_count = 0
		for _,savechess in pairs(GameRules:GetGameModeEntity().mychess[team]) do
			table.insert(lineup_table,{
				x = savechess.x,
				y = savechess.y,
				lastitem = CopyTable(savechess.lastitem),
				chess = savechess.chess,
			})
			chess_count = chess_count + 1
		end
		local obj = {
			owner = TeamId2Hero(team).steam_id,
			chess_count = chess_count,
			lineup = lineup_table,
			round = GameRules:GetGameModeEntity().battle_round - 1,
			result = 'win'
		}
		table.insert(GameRules:GetGameModeEntity().upload_lineup,obj)
	end
end

function LoseARound(team,enemychess_new)
	
	-- GameRules:GetGameModeEntity().battle_count = GameRules:GetGameModeEntity().battle_count - 1
	SetBattleTable(team,false)

	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	local curr_hp = hero:GetHealth()
	local delay_time = 0
	local damage_all = 0
	local is_have_thunder =false

	local oppo_hero = TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team])
	local pj = 'p000'
	local projectile_partical = GameRules:GetGameModeEntity().projectile_list['p000']
	if oppo_hero.is_vip == true then
		pj = 'p001'
		projectile_partical = GameRules:GetGameModeEntity().projectile_list['p001']
	end

	if oppo_hero.projectile ~= nil and GameRules:GetGameModeEntity().projectile_list[oppo_hero.projectile] ~= nil then
		pj = oppo_hero.projectile
		projectile_partical = GameRules:GetGameModeEntity().projectile_list[oppo_hero.projectile]
	end

	--宠物庆祝动作
	local mirror_chesser = TeamId2Hero(team).mirror_chesser
	if mirror_chesser ~= nil and mirror_chesser.pet2 ~= nil then
		AddAbilityAndSetLevel(mirror_chesser.pet2,'act_victory')
		
		Timers:CreateTimer(10,function()
			if mirror_chesser.pet2 ~= nil then
				RemoveAbilityAndModifier(mirror_chesser.pet2,'act_victory')
			end
		end)
		PlayPetDialogue(mirror_chesser.pet2, true, mirror_chesser.language)
	end

	--显示胜利！
	for _,u in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team]) do
		if IsUnitExist(u) == true and u.team_id ~= team then
			u.alreadywon = true
			delay_time = (hero:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() / 1000
			AddStat(hero:GetPlayerID(),'deaths')

			if u:FindAbilityByName('zeus_thunder') == nil then
				--普通敌人
				AddAbilityAndSetLevel(u,'act_victory')

				projectile = ProjectileManager:CreateTrackingProjectile({
			        Target = hero,
			        Source = u,
			        Ability = nil,
			        EffectName = projectile_partical,
			        bDodgeable = false,
			        iMoveSpeed = 1000,
			        bProvidesVision = false,
			        iVisionRadius = 0,
			        iVisionTeamNumber = u:GetTeamNumber(),
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    })
			    damage_all = damage_all + math.floor(GetHitDamage(u) or 1)
			else
				--宙斯，要雷劈的
				AddAbilityAndSetLevel(u,'act_thunder')
				local u_thunder_level = u:FindAbilityByName('zeus_thunder'):GetLevel()
				local u_thunder_table = {
					[1] = 15,
					[2] = 25,
					[3] = 45,
				}
				damage_all = damage_all + math.floor(hero:GetHealth()*(u_thunder_table[u_thunder_level])/100)
				is_have_thunder = true
				if damage_all == 0 then
					damage_all = 1
				end
			end
		end
	end

	Timers:CreateTimer(delay_time,function()
		--牧师护盾效果
		if GameRules:GetGameModeEntity().big_damage ~= 1 then
			damage_all = damage_all * GameRules:GetGameModeEntity().big_damage
		end
		if is_have_thunder ~= true and hero:FindModifierByName('modifier_item_fengwangjiang') ~= nil and damage_all >= 3 then
			--消耗一个蜂王浆
			local fengwangjiang = FindItemInInventory(hero,'item_fengwangjiang')
			if fengwangjiang ~= nil then
				damage_all = math.floor(damage_all*0.8 + 0.5)
				if damage_all == 0 then
					damage_all = 1
				end
				fengwangjiang:SpendCharge()
			end
		end
		--牧师护盾效果
		if is_have_thunder ~= true and damage_all >= hero:GetHealth() and hero:FindModifierByName('modifier_item_pingguo') ~= nil then
			--消耗一个苹果
			local pingguo = FindItemInInventory(hero,'item_pingguo')
			if pingguo ~= nil then
				damage_all = hero:GetHealth() - 1
				pingguo:SpendCharge()
				if GameRules:GetGameModeEntity().egg_quest == 'q030' then
					SetQuest(team,true)
				end
			end
		end
		
		--牧师职业技能
		if hero:FindModifierByName('modifier_is_priest_buff_courier') ~= nil then
			if damage_all > 16 then
				AddItemPlus(hero,'item_pingguo')
			elseif damage_all > 6 then
				AddItemPlus(hero,'item_chishu',0.1)
			elseif damage_all > 0 then
				AddItemPlus(hero,'item_fengwangjiang',0.2)
			end
			play_particle("particles/items_fx/aegis_respawn_spotlight.vpcf",PATTACH_OVERHEAD_FOLLOW,hero,5)
		end
		
		if is_have_thunder == true then
			--雷击特效和音效
			EmitSoundOn('Hero_Zuus.GodsWrath.Target',hero)
			PlayParticleOnUnitUntilDeath({
				caster = hero,
				p = "particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_bolt_parent.vpcf",
			})
		end
		
		if GameRules:GetGameModeEntity().p2_mode == true and GetP2Ally(team) ~= nil then
			--2P模式，队友分担伤害
			local damage_all_2p = math.floor(damage_all/2+0.5)
			if damage_all_2p == 0 then
				damage_all_2p = 1
			end
			--记录最后造成伤害的队伍
			TeamId2Hero(team).last_damaged_by_team = GameRules:GetGameModeEntity().counterpart[team]
			TeamId2Hero(GetP2Ally(team)).last_damaged_by_team = GameRules:GetGameModeEntity().counterpart[team]
			DamageTeam(team, damage_all_2p, pj)
			DamageTeam(GetP2Ally(team), damage_all_2p, pj)

			AddStat(TeamId2Hero(team):GetPlayerID(),'hero_damaged',damage_all)
			
		else
			--记录最后造成伤害的队伍
			TeamId2Hero(team).last_damaged_by_team = GameRules:GetGameModeEntity().counterpart[team]
			--1P模式，正常伤害
			DamageTeam(team, damage_all, pj)
			AddStat(TeamId2Hero(team):GetPlayerID(),'hero_damaged',damage_all)
		end
	end)

	--显示战报
	if TeamId2Hero(team).cloud_opp_name ~= nil then
		AddHistoryLose(team,5)
		ShowCombat({
			t = 'battle_cloud_lose',
			player = TeamId2Hero(team):GetPlayerID(),
			num = enemychess_new,
			text = TeamId2Hero(team).cloud_opp_name,
		})
	else
		AddHistoryLose(team,GameRules:GetGameModeEntity().counterpart[team])
		ShowCombat({
			t = 'battle_pvp_lose',
			player = TeamId2Hero(team):GetPlayerID(),
			player2 = TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team]):GetPlayerID(),
			num = enemychess_new,
		})

		AddStat(TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team]):GetPlayerID(),'hero_damage',damage_all)

		if GameRules:GetGameModeEntity().egg_quest == 'q020' and GetStat(TeamId2Hero(GameRules:GetGameModeEntity().counterpart[team]):GetPlayerID(),'hero_damage') >= 150 then
			SetQuest(GameRules:GetGameModeEntity().counterpart[team],true)
		end
	end
	
	EmitSoundOn("dac.round.lose",hero)
	AddStat(TeamId2Hero(team):GetPlayerID(),'lose_round')
	AddLoseStreak(team)
	RemoveWinStreak(team, GameRules:GetGameModeEntity().counterpart[team])

	--通知UI显示胜负
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
			key = GetClientKey(team_i),
			player_id = hero:GetPlayerID(),
			winlose = "lose",
		})
	end
	CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
			key = GetClientKey(1),
			player_id = hero:GetPlayerID(),
			winlose = "lose",
		})

	if RandomInt(1,100) < 25 then
    	SayCheerBubble(hero:GetTeam(), nil, 'lose', 3)
    end
    if RandomInt(1,100) < 25 then
    	SayCheerBubble(hero:GetTeam(), nil, 'lose', 6)
    end

	--概率存阵容
	if RandomInt(1,100) < 5 then
		local lineup_table = {}
		local chess_count = 0
		for _,savechess in pairs(GameRules:GetGameModeEntity().mychess[team]) do
			table.insert(lineup_table,{
				x = savechess.x,
				y = savechess.y,
				lastitem = CopyTable(savechess.lastitem),
				chess = savechess.chess
			})
			chess_count = chess_count + 1
		end
		if chess_count > 2 then
			local obj = {
				owner = TeamId2Hero(team).steam_id,
				chess_count = chess_count,
				lineup = lineup_table,
				round = GameRules:GetGameModeEntity().battle_round - 1,
				result = 'lose'
			}
			table.insert(GameRules:GetGameModeEntity().upload_lineup,obj)
		end
	end
	--清除拉比克技能
	for _,rchess in pairs(GameRules:GetGameModeEntity().mychess[team]) do
		if string.find(rchess.chess,'rubick') ~= nil then
			-- print('losearound removed')
			rchess.rubick_a = nil
		end
	end
	--圣剑掉落
	DropShengJian(team)
end

function DropShengJian(team)
	for _,obj in pairs(GameRules:GetGameModeEntity().mychess[team]) do
		local items = obj['item']

		for item_index,item in pairs(items) do
			if item == 'item_shengjian' then
				local lucky_team = RandomDropOneGGItem('item_shengjian',TeamId2Hero(team),team)
				--圣剑掉落消息通知
				if lucky_team ~= nil then
					table.remove(items,item_index)
					ShowCombat({
						t = 'drop_shengjian',
						player = TeamId2Hero(team):GetPlayerID(),
						player2 = TeamId2Hero(lucky_team):GetPlayerID(),
					})
				end
			end
		end
	end
end

function GetChessCountInBattleGround(m)
	local mychess_count = 0
	local enemychess_count = 0
	local my_last_chess = nil
	if GameRules:GetGameModeEntity().to_be_destory_list[m] ~= nil then
		for p,q in pairs(GameRules:GetGameModeEntity().to_be_destory_list[m]) do
			if q:GetUnitName() ~= 'fissure' then
				if q.team_id == m then
					mychess_count = mychess_count + 1
					my_last_chess = q
				else
					enemychess_count = enemychess_count + 1
				end
			end
		end
	end

	return mychess_count,enemychess_count,my_last_chess
end

function GetHitDamage(u)
	local d = math.floor(1+(1.0*u:GetLevel()/3))
	return d
end
--游戏循环2——开始一轮战斗回合（包括回合结果判断）
function StartABattleRound()
	if GameRules:GetGameModeEntity().is_game_ended == true then
		return
	end
	PostPlayerInfo()
	for i = 6,13 do
		ShowPrepare(i)
	end
	CustomNetTables:SetTableValue( "dac_table", "hide_damage_stat", 
		{ 
			hehe = RandomInt(1,100000) 
		} 
	)

	GameRules:SetTimeOfDay(0.3)
	
	GameRules:GetGameModeEntity().game_status = 2
	GameRules:GetGameModeEntity().battle_timer = 50

	ResetAllDeadChessList()

	if GameRules:GetGameModeEntity().battle_boss[GameRules:GetGameModeEntity().battle_round] ~= nil then
		StartAPVERound()
	else
		StartAPVPRound()
	end
end
--2v2相关的方法
function SetP2Team(team,p2team)
	local h = TeamId2Hero(team)
	if h ~= nil then
		h.p2team = p2team
		table.insert(GameRules:GetGameModeEntity().p2_player[p2team],team)
		h:FindAbilityByName('transfer_chess'):SetHidden(false)
		SetStat(TeamId2Hero(team):GetPlayerID(),'p2team',p2team)
		CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,1000)})
	end
end
function GetP2Team(team)
	local h = TeamId2Hero(team)
	if h ~= nil then
		return h.p2team
	else
		return nil
	end
end
function GetP2Ally(team)
	local h = TeamId2Hero(team)
	if h ~= nil and h.p2team ~= nil then
		for i,v in pairs(GameRules:GetGameModeEntity().p2_player[h.p2team]) do
			if v ~= team then
				return v
			end
		end 
	else
		return nil
	end
end
function IsP2TeamAlive(p2team)
	local hero_1 = TeamId2Hero(GameRules:GetGameModeEntity().p2_player[p2team][1])
	local hero_2 = TeamId2Hero(GameRules:GetGameModeEntity().p2_player[p2team][2])
	if IsUnitExist(hero_1) == false or IsUnitExist(hero_2) == false then
		GameRules:GetGameModeEntity().p2_battle[p2team] = -1
		return false
	else
		return true
	end
end
function GetP2TeamCount()
	local count_team = 0
	for i,v in pairs(GameRules:GetGameModeEntity().p2_player) do
		if table.maxn(v) == 2 then
			count_team = count_team + 1
		end
	end
	return count_team
end
function GetP2TeamAliveCount()
	local alive_team = 0
	for i,v in pairs(GameRules:GetGameModeEntity().p2_player) do
		if IsP2TeamAlive(i) == true then
			alive_team = alive_team + 1
		end
	end
	return alive_team
end
function AllocateP2Battle()
	local alive_team = GetP2TeamAliveCount()
	if GameRules:GetGameModeEntity().lastalive_team == nil or GameRules:GetGameModeEntity().lastalive_team ~= alive_team then
		GameRules:GetGameModeEntity().lastrandomn_team = nil
	end
	GameRules:GetGameModeEntity().lastalive_team = alive_team
	--随即一种方案
	local rann = GameRules:GetGameModeEntity().lastrandomn_team or 1
	local check_duplicate = 1
	if alive_team <= 2 then
		rann = 1
	else
		while rann == GameRules:GetGameModeEntity().lastrandomn_team or check_duplicate == 1 do
			rann = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().p2_match[alive_team]))
			check_duplicate = 0
			if GameRules:GetGameModeEntity().lastrandomn_team ~= nil then
				for j,k in pairs(GameRules:GetGameModeEntity().p2_match[alive_team][rann]) do
					if k == GameRules:GetGameModeEntity().p2_match[alive_team][GameRules:GetGameModeEntity().lastrandomn_team][j] then
						check_duplicate = 1
					end
				end
			end
		end
	end
	GameRules:GetGameModeEntity().lastrandomn_team = rann
	local allo_table = {}
	for i=1,4 do
		if IsP2TeamAlive(i) == true then
			table.insert(allo_table,i)
		end
	end
	for j=1,#allo_table do
		GameRules:GetGameModeEntity().p2_battle[allo_table[j]] = allo_table[j+GameRules:GetGameModeEntity().p2_match[alive_team][rann][j]]
	end
end
function AllocateP2Counterpart()
	AllocateP2Battle()
	for i,v in pairs(GameRules:GetGameModeEntity().p2_battle) do
		if v ~= -1 then
			if RandomInt(1,100) > 50 then
				GameRules:GetGameModeEntity().counterpart[GameRules:GetGameModeEntity().p2_player[i][1]] = GameRules:GetGameModeEntity().p2_player[v][1]
				GameRules:GetGameModeEntity().counterpart[GameRules:GetGameModeEntity().p2_player[i][2]] = GameRules:GetGameModeEntity().p2_player[v][2]
			else
				GameRules:GetGameModeEntity().counterpart[GameRules:GetGameModeEntity().p2_player[i][1]] = GameRules:GetGameModeEntity().p2_player[v][2]
				GameRules:GetGameModeEntity().counterpart[GameRules:GetGameModeEntity().p2_player[i][2]] = GameRules:GetGameModeEntity().p2_player[v][1]
			end
		else
			if table.maxn(GameRules:GetGameModeEntity().p2_player[i]) > 0 then
				GameRules:GetGameModeEntity().counterpart[GameRules:GetGameModeEntity().p2_player[i][1]] = -1
				GameRules:GetGameModeEntity().counterpart[GameRules:GetGameModeEntity().p2_player[i][2]] = -1
			end
		end
	end
end
--游戏循环2.1——分配对手
function AllocateABattleRound()
	local finished = false
	--local trytime = 0

	-- while finished == false and trytime < 10000 do
		--trytime = trytime + 1
		local alive_player_count = 0
		--统计玩家死活
		for u,v in pairs(GameRules:GetGameModeEntity().counterpart) do
			if TeamId2Hero(u) ~= nil and TeamId2Hero(u):IsNull() == false and TeamId2Hero(u):IsAlive() == true then
				--活玩家
				GameRules:GetGameModeEntity().counterpart[u] = u
				alive_player_count = alive_player_count +1
			else
				--死玩家
				GameRules:GetGameModeEntity().counterpart[u] = -1
			end
		end
		local rann = GameRules:GetGameModeEntity().lastrandomn
		if alive_player_count < 1 then
			return
		elseif alive_player_count == 1 then
			rann = 0
		elseif alive_player_count == 2 then
			rann = 1
		else
			while rann == GameRules:GetGameModeEntity().lastrandomn do
				rann = RandomInt(1,alive_player_count-1)
			end
		end
		GameRules:GetGameModeEntity().lastrandomn = rann
		--给活玩家分配一个随机对手
		for rotate_count = 1,rann do
			for i,j in pairs(GameRules:GetGameModeEntity().counterpart) do
				if j ~= -1 then
					local aliveteam = j
					
					local n = 1
					local try_count = 0
					while (aliveteam == j or GameRules:GetGameModeEntity().counterpart[aliveteam] == nil or GameRules:GetGameModeEntity().counterpart[aliveteam] == -1) and try_count<10000 do
						aliveteam = aliveteam + 1
						if aliveteam > 13 then
							aliveteam = 6
						end
						try_count = try_count + 1
					end
					GameRules:GetGameModeEntity().counterpart[i] = aliveteam
				end
			end
		end
	-- 	finished = CheckCounterpart()
	-- end
end
function GetMyHostEnemyTeam(t)
	return GameRules:GetGameModeEntity().counterpart[t]
end
function GetMyGuestEnemyTeam(t)
	for i,v in pairs(GameRules:GetGameModeEntity().counterpart) do
		if v == t then
			return i
		end
	end
	return nil
end


--游戏循环2.1.x——分配对手用到的方法
function CheckCounterpart()
	local all_team_count = 0
	for _,__ in pairs(GameRules:GetGameModeEntity().counterpart) do
		all_team_count = all_team_count + 1
	end
	for team,conter in pairs(GameRules:GetGameModeEntity().counterpart) do
		if team == conter and all_team_count > 1 then
			return false
		end
	end
	return true
end
function InitChessListByLevel()
	for i,t in pairs(GameRules:GetGameModeEntity().chess_list_by_mana) do
		if i == 5 then
			t = GameRules:GetGameModeEntity().chess_list_by_mana_gold
		end
		for ii,vv in pairs(t) do
			--1星
			if GameRules:GetGameModeEntity().chess_list_by_level[i] == nil then
				GameRules:GetGameModeEntity().chess_list_by_level[i] = {}
			end
			table.insert(GameRules:GetGameModeEntity().chess_list_by_level[i],vv)
			--2星
			if GameRules:GetGameModeEntity().chess_list_by_level[i+2] == nil then
				GameRules:GetGameModeEntity().chess_list_by_level[i+2] = {}
			end
			table.insert(GameRules:GetGameModeEntity().chess_list_by_level[i+2],vv..'1')
			--3星（有特殊情况）
			if vv == 'chess_eh' or vv == 'chess_fur' or vv == 'chess_tp' or vv == 'chess_ld' or vv == 'chess_et' or vv == 'chess_meepo' then
				if GameRules:GetGameModeEntity().chess_list_by_level[i+3] == nil then
					GameRules:GetGameModeEntity().chess_list_by_level[i+3] = {}
				end
				table.insert(GameRules:GetGameModeEntity().chess_list_by_level[i+3],vv..'11')
			else
				if GameRules:GetGameModeEntity().chess_list_by_level[i+4] == nil then
					GameRules:GetGameModeEntity().chess_list_by_level[i+4] = {}
				end
				table.insert(GameRules:GetGameModeEntity().chess_list_by_level[i+4],vv..'11')
			end
		end
	end
end
function RandomEvolveChess(seed,delta)
	if table.maxn(GameRules:GetGameModeEntity().chess_list_by_level) == 0 then
		InitChessListByLevel()
	end
	local level = seed:GetLevel()
	local elevel = level + delta
	if elevel > 9 then
		elevel = 9
	end
	if elevel < 1 then
		elevel = 1
	end
	local chesstable = GameRules:GetGameModeEntity().chess_list_by_level[elevel]
	local chessname = chesstable[RandomInt(1,table.maxn(chesstable))]
	return chessname
end
function RandomStarEvolveChess(seed,delta)
	local star = GetChessNameStar(seed:GetUnitName())
	local cost = GameRules:GetGameModeEntity().chess_2_mana[GetUnitBaseName(seed)]
	local c = cost
	if c == nil or c < 1 then
		c = 1
	end
	if c > 5 then
		c = 5
	end
	
	local t = GameRules:GetGameModeEntity().chess_list_by_mana[c]
	local uname = t[RandomInt(1,table.maxn(t))]
	local name_suffix = ''
	if star == 2 then
		name_suffix = '1'
	elseif star == 3 then
		name_suffix = '11'
	end
	return uname..name_suffix
end
--为teamid的场地上所有的敌我棋子添加组合技
function AddComboAbility(teamid)
	local combo_chess_table_self = {}
	local combo_chess_table_enemy = {}
	local combo_count_table_self = {}
	local combo_count_table_enemy = {}
	local max_combo_self = 0
	local baojun_table_self = {}
	local baojun_table_enemy = {}
	local baojun_ability_table_self = {}
	local baojun_ability_table_enemy = {}
	--第一次循环：棋子分组，将棋子实体归类进combo_chess_table_self/combo_chess_table_enemy
	for w,vw in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
		if vw.team_id == teamid then --我的棋子
			if IsUnitExist(vw) == true and vw:HasModifier('modifier_item_baojunwangpao') then
				table.insert(baojun_table_self,vw)
			end
			
			for k,vk in pairs(GameRules:GetGameModeEntity().combo_ability_type) do
				if combo_chess_table_self[k] == nil then
					combo_chess_table_self[k] = {}
				end
				if vw:FindAbilityByName(k) ~= nil or vw:FindAbilityByName(string.sub(k,1,-2)) ~= nil or vw:FindAbilityByName(string.sub(k,1,-3)) ~= nil then
					table.insert(combo_chess_table_self[k],vw)
				end
			end
		else --敌人的棋子
			if IsUnitExist(vw) == true and vw:HasModifier('modifier_item_baojunwangpao') then
				table.insert(baojun_table_enemy,vw)
			end
			local opp = 0
			--找到被镜像的棋子对手是谁
			for teama,teamb in pairs(GameRules:GetGameModeEntity().counterpart) do
				if teamb == vw.at_team_id then
					opp = teama
				end
			end
			for k,vk in pairs(GameRules:GetGameModeEntity().combo_ability_type) do
				if combo_chess_table_enemy[k] == nil then
					combo_chess_table_enemy[k] = {}
				end
				if vw:FindAbilityByName(k) ~= nil or vw:FindAbilityByName(string.sub(k,1,-2)) ~= nil or vw:FindAbilityByName(string.sub(k,1,-3)) ~= nil then
					table.insert(combo_chess_table_enemy[k],vw)
				end
			end
		end
	end
	--第二次循环：计数，把职业/种族的独特数量写入combo_count_table_self/combo_count_table_enemy
	for k,vk in pairs(combo_chess_table_self) do
		--统计不同的种类数
		local diff_count = 0
		local diff_string = ''
		for _,chess in pairs(combo_chess_table_self[k]) do
			--去掉等级变量
			local find_name = chess:GetUnitName()
			if string.find(find_name,'11') ~= nil then
				find_name = string.sub(find_name,1,-3)
			end
			if string.find(find_name,'1') ~= nil then
				find_name = string.sub(find_name,1,-2)
			end
			--搜索是否重复了
			if string.find(diff_string,find_name) == nil then
				diff_count = diff_count + 1
				diff_string = diff_string..'-'..find_name
			end
		end
		if TeamId2Hero(teamid):FindAbilityByName(k) ~= nil then
			diff_count = diff_count + 1
		end
		combo_count_table_self[k] = diff_count
	end
	TeamId2Hero(teamid).combo_self = combo_count_table_self
	for k,vk in pairs(combo_chess_table_enemy) do
		--统计不同的种类数
		local diff_count = 0
		local diff_string = ''
		for _,chess in pairs(combo_chess_table_enemy[k]) do
			--去掉等级变量
			local find_name = chess:GetUnitName()
			if string.find(find_name,'11') ~= nil then
				find_name = string.sub(find_name,1,-3)
			end
			if string.find(find_name,'1') ~= nil then
				find_name = string.sub(find_name,1,-2)
			end
			--搜索是否重复了
			if string.find(diff_string,find_name) == nil then
				diff_count = diff_count + 1
				diff_string = diff_string..'-'..find_name
			end
		end
		combo_count_table_enemy[k] = diff_count
	end
	--第三次循环：巫师、恶魔猎手相关的数量变换，以及统计唯一羁绊

	local the_only_combo_self = nil  --是否有唯一combo，初始=nil，有=combo名（去掉1和11），没有='not_only'
	local the_only_combo_enemy = nil  --是否有唯一combo，初始=nil，有=combo名（去掉1和11），没有='not_only'
	

	for m,vm in pairs(combo_count_table_self) do
		local find_combo_name = m
		if string.find(find_combo_name,'11') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-3)
		end
		if string.find(find_combo_name,'1') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-2)
		end

		if m ~= 'is_demon' and m ~= 'is_wizard' and m ~= 'is_wizard1' and combo_count_table_self[m] >= 3 and combo_count_table_self['is_wizard'] >= 2 and GameRules:GetGameModeEntity().combo_ability_type[m]['condition'] >= 4 then
			--2巫师
			combo_count_table_self[m] = combo_count_table_self[m] + 1
		end

		--恶魔
		if find_combo_name == 'is_demon' then
			if (vm == 1 and combo_count_table_enemy['is_demonhunter'] == 0) or combo_count_table_self['is_demonhunter'] >= 2 then
				combo_count_table_self['is_demon'] = 1
				vm = 1
			else
				combo_count_table_self['is_demon'] = 0
				vm = 0
			end
		end

		if vm > 0 then
			--唯一羁绊
			local c = GameRules:GetGameModeEntity().combo_ability_type[find_combo_name]['condition']
			if vm >= c and the_only_combo_self ~= nil and the_only_combo_self ~= 'not_only' and find_combo_name ~= 'is_wizard' and the_only_combo_self ~= find_combo_name then
				the_only_combo_self = 'not_only'
			end
			if vm >= c and the_only_combo_self == nil and find_combo_name ~= 'is_wizard' then
				the_only_combo_self = find_combo_name
			end
		end
	end
	
	for m,vm in pairs(combo_count_table_enemy) do
		local find_combo_name = m
		if string.find(find_combo_name,'11') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-3)
		end
		if string.find(find_combo_name,'1') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-2)
		end

		if m ~= 'is_demon' and m ~= 'is_wizard' and m ~= 'is_wizard1' and combo_count_table_enemy[m] >= 3 and combo_count_table_enemy['is_wizard'] >= 2 and GameRules:GetGameModeEntity().combo_ability_type[m]['condition'] >= 4 then
			--2巫师
			combo_count_table_enemy[m] = combo_count_table_enemy[m] + 1
		end

		--恶魔
		if find_combo_name == 'is_demon' then
			if (vm == 1 and combo_count_table_self['is_demonhunter'] == 0) or combo_count_table_enemy['is_demonhunter'] >= 2 then
				combo_count_table_enemy['is_demon'] = 1
				vm = 1
			else
				combo_count_table_enemy['is_demon'] = 0
				vm = 0
			end
		end
		if vm > 0 then
			--唯一羁绊
			local c = GameRules:GetGameModeEntity().combo_ability_type[find_combo_name]['condition']
			if vm >= c and the_only_combo_enemy ~= nil and the_only_combo_enemy ~= 'not_only' and find_combo_name ~= 'is_wizard' and the_only_combo_enemy ~= find_combo_name then
				the_only_combo_enemy = 'not_only'
			end
			if vm >= c and the_only_combo_enemy == nil and find_combo_name ~= 'is_wizard' then
				the_only_combo_enemy = find_combo_name
			end
		end
	end


	--暂存the_only_combo_self
	TeamId2Hero(teamid).the_only_combo_self = the_only_combo_self

	--补充4巫师触发了的唯一羁绊数量
	if combo_count_table_self['is_wizard'] ~= nil and combo_count_table_self['is_wizard'] >= 3 and the_only_combo_self ~= nil and the_only_combo_self ~= 'not_only' then
		if combo_count_table_self[the_only_combo_self] ~= nil then
			combo_count_table_self[the_only_combo_self] = GameRules:GetGameModeEntity().combo_ability_type[the_only_combo_self]['condition']
		end
		if combo_count_table_self[the_only_combo_self..'1'] ~= nil then
			combo_count_table_self[the_only_combo_self..'1'] = GameRules:GetGameModeEntity().combo_ability_type[the_only_combo_self..'1']['condition']
		end
		if combo_count_table_self[the_only_combo_self..'11'] ~= nil then
			combo_count_table_self[the_only_combo_self..'11'] = GameRules:GetGameModeEntity().combo_ability_type[the_only_combo_self..'11']['condition']
		end
	end
	if combo_count_table_enemy['is_wizard'] ~= nil and combo_count_table_enemy['is_wizard'] >= 3 and the_only_combo_enemy ~= nil and the_only_combo_enemy ~= 'not_only' then
		if combo_count_table_enemy[the_only_combo_enemy] ~= nil then
			combo_count_table_enemy[the_only_combo_enemy] = GameRules:GetGameModeEntity().combo_ability_type[the_only_combo_enemy]['condition']
		end
		if combo_count_table_enemy[the_only_combo_enemy..'1'] ~= nil then
			combo_count_table_enemy[the_only_combo_enemy..'1'] = GameRules:GetGameModeEntity().combo_ability_type[the_only_combo_enemy..'1']['condition']
		end
		if combo_count_table_enemy[the_only_combo_enemy..'11'] ~= nil then
			combo_count_table_enemy[the_only_combo_enemy..'11'] = GameRules:GetGameModeEntity().combo_ability_type[the_only_combo_enemy..'11']['condition']
		end
	end
	--统计keal_combo（人数最多的羁绊）记录在英雄上，卡尔在切技能的时候读取自己英雄或者找到敌方英雄的keal_combo决定用什么技能
	TeamId2Hero(teamid).kael_combo = nil
	for a,b in pairs(combo_count_table_self) do
		local con = GameRules:GetGameModeEntity().combo_ability_type[a]['condition']
		if string.find(a,'1') == nil and b >= 3 and b > max_combo_self then
			max_combo_self = b
			TeamId2Hero(teamid).kael_combo = a
		end
	end

	if GameRules:GetGameModeEntity().egg_quest == 'q014' then
		for pp,qq in pairs(combo_count_table_self) do
			local con = GameRules:GetGameModeEntity().combo_ability_type[pp]['condition']
			if GameRules:GetGameModeEntity().quest_14_buff_list[pp] ~= nil and qq >= GameRules:GetGameModeEntity().quest_14_buff_list[pp] then
				SetQuest(teamid,true)
			end
			if GameRules:GetGameModeEntity().quest_14_buff_list[pp] ~= nil and TeamId2Hero(teamid).the_only_combo_self ~= nil and TeamId2Hero(teamid).the_only_combo_self == pp then
				SetQuest(teamid,true)
			end
			if GameRules:GetGameModeEntity().quest_14_buff_list[pp] ~= nil and combo_count_table_self['is_wizard'] >= 2 and qq+1 >= GameRules:GetGameModeEntity().quest_14_buff_list[pp] then
				SetQuest(teamid,true)
			end
		end
	end

	--第四次循环：为所有棋子添加羁绊技能
	local combo_count_race = 0
	local dragon_sound = false --龙战吼的声音是否触发过（只吼一次，否则声音太吵了）
	local god_sound = false --神战吼的声音是否触发过（只吼一次，否则声音太吵了）
	local combo_type_table = {} --用来统计combo种类数（比如3猎人和猎人6算1个combo_type）
	for s,x in pairs(combo_count_table_self) do
		local condition_0 = GameRules:GetGameModeEntity().combo_ability_type[s]['condition']
		local condition = condition_0
		local is_race = GameRules:GetGameModeEntity().combo_ability_type[s]['is_race']
		if x >= condition and is_race ~= true then
			for m,n in pairs(combo_chess_table_self[s]) do
				n.class = 1
			end
		end
		if x >= condition and is_race == true and string.find(s,'god') == nil and string.find(s,'is_demon') == nil then
			for m,n in pairs(combo_chess_table_self[s]) do
				n.race = 1
			end
		end
	end
	--恩拉基（在统计神的触发之后）
	if the_only_combo_self ~= 'is_nraqi' then
		combo_count_table_self['is_nraqi'] = 0
	end
	for p,vp in pairs(combo_chess_table_self) do
		local shaman_hex = false
		local shaman_hexhex = false
		local tauren_ward = false
		local kobold_together = false
		local type1 = GameRules:GetGameModeEntity().combo_ability_type[p]['type']
		local condition_0 = GameRules:GetGameModeEntity().combo_ability_type[p]['condition']
		local condition = condition_0
		local buff_ability = GameRules:GetGameModeEntity().combo_ability_type[p]['ability']
		local is_race = GameRules:GetGameModeEntity().combo_ability_type[p]['is_race']
		if condition == 0 then
			--恶魔
			if combo_count_table_self[p] == 1 then
				SAdd(combo_type_table,p)
				for _,chess in pairs(vp) do
					if buff_ability ~= nil then
						AddAbilityAndSetLevelDelay(chess,buff_ability)
						table.insert(baojun_ability_table_self,buff_ability)
						if is_race == true then
							chess.race = 1
							combo_count_race = combo_count_race + 1
						end
					end
				end
			end
		else
			if combo_count_table_self[p] >= condition then
				if is_race == true then
					combo_count_race = combo_count_race + 1
				end
				SAdd(combo_type_table,p)
				local tauren_level = nil
				if combo_count_table_self['is_tauren'] ~= nil and combo_count_table_self['is_tauren'] >= GameRules:GetGameModeEntity().combo_ability_type['is_tauren']['condition'] then
					tauren_level = 'is_tauren'
					if combo_count_table_self['is_tauren1'] >= GameRules:GetGameModeEntity().combo_ability_type['is_tauren1']['condition'] then
						tauren_level = 'is_tauren1'
					end
				end
				for _,chess in pairs(combo_chess_table_self[p]) do
					if p == 'is_kobold' and kobold_together == false then
						kobold_together = true
						local double_table = {}
						for _,cc in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
							if cc.team_id == teamid then
								if IsUnitExist(cc) == true then
									if double_table[cc:GetUnitName()] == nil then
										double_table[cc:GetUnitName()] = {}
									end
									table.insert(double_table[cc:GetUnitName()],cc)
								end
							end
						end
						local kobold_active = false
						for _,kk in pairs(double_table) do
							if string.find(_,'chess_meepo') ~= nil and table.maxn(kk) == 2 then
								kobold_active = true
							end
						end
						if kobold_active == true then
							for _,kk in pairs(double_table) do
								if table.maxn(kk) == 2 then
									kk[1].kobold_result = true
								end
							end
						end
					end
					if p == 'is_shaman' and shaman_hex == false then
						shaman_hex =  true
						local shaman_target = nil
						-- if RandomInt(0,100) < 10 then
							local trycount = 0
							while shaman_target == nil and trycount < 100 do
								trycount = trycount + 1
								for _,cc in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
									if cc:GetTeam() ~= teamid and RandomInt(1,100) > 25 and string.find(cc:GetUnitName(),'chess_') ~= nil then
										shaman_target = cc
										break
									end
								end
							end
						-- else
						-- 	local max_level = 1
						-- 	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						-- 		local lv = unit:GetLevel()
						-- 		if unit:GetMaxMana() <= 0 then
						-- 			lv = 1
						-- 		end

						-- 		if lv > max_level and unit.team_id == 4 then
						-- 			shaman_target = unit
						-- 			max_level = lv
						-- 		end
						-- 	end
						-- end
						if IsUnitExist(shaman_target) == true then
							if BlockByLinken(shaman_target) == false then
								AddAbilityAndSetLevel(shaman_target,'no_selectable')
								shaman_target.devolve_result = RandomEvolveChess(shaman_target,0)
							end
						end
					end
					if p == 'is_shaman1' and shaman_hexhex == false then
						shaman_hexhex = true
						for _,cc in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
							if cc.team_id == teamid and cc:HasAbility('is_shaman') then
								if IsUnitExist(cc) == true then
									AddAbilityAndSetLevel(cc,'no_selectable')
									cc.evolve_result = RandomEvolveChess(cc,2)
								end
							end
						end
						table.insert(baojun_ability_table_self,'is_shaman1')
					end
					if p == 'is_dragon' then
						play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,chess,5)
						if dragon_sound == false then
							EmitSoundOn('Hero_DragonKnight.DragonTail.Target',chess)
							dragon_sound = true
						end
						chess.is_dragon_zhanhou = true
						chess:SetMana(100)
						AMHC:CreateNumberEffect(chess,100,2,AMHC.MSG_MISS,{128,128,255},0)
						table.insert(baojun_ability_table_self,'flag_dragon3')
					end
					if p == 'is_dragon1' then
						if combo_count_table_self[p] >= condition then
							for kkkk,vvvv in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if vvvv.team_id == teamid and vvvv.class ~= 1 then
									vvvv.is_dragon_zhanhou = true
									vvvv:SetMana(100)
									AMHC:CreateNumberEffect(vvvv,100,2,AMHC.MSG_MISS,{128,128,255},0)
									play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
								end
							end
						end
					end
					if p == 'is_god' then
						if combo_count_table_self[p] >= condition then
							local demon_active = false
							if (combo_count_table_self['is_demon'] == 1 and combo_count_table_enemy['is_demonhunter'] == 0) or combo_count_table_self['is_demonhunter1'] == 2 then
								demon_active = true
							end
							for kkkk,vvvv in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if vvvv.team_id == teamid then
									if vvvv:FindAbilityByName('is_demon') ~= nil then
										if demon_active == false then
											if god_sound == false then
												EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
												god_sound = true
											end
											if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff') == nil then
												AddAbilityAndSetLevelDelay(vvvv,'is_god_buff')
												table.insert(baojun_ability_table_self,'flag_god2')
												play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
											end
										end
									elseif vvvv.race ~= 1 then
										if god_sound == false then
											EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
											god_sound = true
										end
										if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff') == nil then
											AddAbilityAndSetLevelDelay(vvvv,'is_god_buff')
											table.insert(baojun_ability_table_self,'flag_god2')
											play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
										end
									end
								end
							end
						end
					end
					if p == 'is_god1' then
						if combo_count_table_self[p] >= condition then
							local demon_active = false
							if (combo_count_table_self['is_demon'] == 1 and combo_count_table_enemy['is_demonhunter'] == 0) or combo_count_table_self['is_demonhunter1'] == 2 then
								demon_active = true
							end
							for kkkk,vvvv in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if vvvv.team_id == teamid then
									if vvvv:FindAbilityByName('is_demon') ~= nil then
										if demon_active == false then
											if god_sound == false then
												EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
												god_sound = true
											end
											if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff_plus') == nil then
												AddAbilityAndSetLevelDelay(vvvv,'is_god_buff_plus')
												table.insert(baojun_ability_table_self,'flag_god4')
												play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
											end
										end
									elseif vvvv.race ~= 1 then
										if god_sound == false then
											EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
											god_sound = true
										end
										if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff_plus') == nil then
											AddAbilityAndSetLevelDelay(vvvv,'is_god_buff_plus')
											table.insert(baojun_ability_table_self,'flag_god4')
											play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
										end
									end
								end
							end
						end
					end
					if p == tauren_level then
						if tauren_ward == false then
							tauren_ward = true
							local first_tauren = nil
							for i0,v0 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if v0:HasAbility('is_tauren') and v0:GetTeam() == teamid then
									first_tauren = v0
								end
							end
							if first_tauren ~= nil then
								if tauren_level == 'is_tauren' then
									SummonTaurenWard(first_tauren,1)
								elseif tauren_level == 'is_tauren1' then
									SummonTaurenWard(first_tauren,2)
								end
							end
						end
					end
				end
				--同类有技能
				if type1 == 1 then
					for _,chess in pairs(combo_chess_table_self[p]) do
						if buff_ability ~= nil then
							AddAbilityAndSetLevelDelay(chess,buff_ability)
							table.insert(baojun_ability_table_self,buff_ability)
						end
					end
				end
				--友军有技能
				if type1 == 2 then
					for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						--是友军
						if chess.team_id == teamid then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									if buff_ability == 'is_aqir_buff' then
										-- if HasSameNameFriendChess(chess) == true then
											--特殊情况，亚基
											if condition == 2 then
												if chess:HasAbility('is_aqir') == false then
													AddAbilityAndSetLevelDelay(chess,buff_ability)
													table.insert(baojun_ability_table_self,buff_ability)
												end
											else
												AddAbilityAndSetLevelDelay(chess,buff_ability)
												table.insert(baojun_ability_table_self,buff_ability)
											end
										-- end
									elseif buff_ability == 'is_orc_buff_plus_plus' then
										local hero = TeamId2Hero(teamid)
										local lost_hp = 100 - hero:GetHealth()
										ModMaxHP({
											caster = chess,
											const = lost_hp*10
										})
										chess:SetRenderColor(255, 255-(2*lost_hp), 255-(2*lost_hp))
										AddAbilityAndSetLevelDelay(chess,buff_ability)
									else
										--正常情况
										AddAbilityAndSetLevelDelay(chess,buff_ability)
									end
								end
							end
						end
					end
				end
				--敌军有技能
				if type1 == 3 then
					for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						--是敌军
						if chess.team_id == 4 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
								end
							end
						end
					end
				end
				--随机一个友军有技能
				if type1 == 4 then
					local try_count = 0
					local is_ok = false
					while is_ok == false and try_count < 100 do
						local r = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[teamid]))
						local chess = GameRules:GetGameModeEntity().to_be_destory_list[teamid][r]
						if chess.team_id == teamid then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									table.insert(baojun_ability_table_self,buff_ability)
									is_ok = true
								end
							end
						end
						try_count = try_count + 1
					end
				end
				--随机一个敌军有技能
				if type1 == 5 then
					local try_count = 0
					local is_ok = false
					while is_ok == false and try_count < 100 do
						local r = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[teamid]))
						local chess = GameRules:GetGameModeEntity().to_be_destory_list[teamid][r]
						if chess.team_id == 4 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									is_ok = true
								end
							end
						end
						try_count = try_count + 1
					end
				end
				--远程友军有技能
				if type1 == 7 then
					for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						--是友军
						if chess.team_id == teamid and chess:Script_GetAttackRange() > 205 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									table.insert(baojun_ability_table_self,'flag_drawf2')
								end
							end
						end
					end
				end
			end
		end
	end
	--priest
	local courier = TeamId2Hero(teamid)
	if combo_count_table_self['is_priest'] ~= nil and combo_count_table_self['is_priest'] >= 2 then
		AddAbilityAndSetLevelDelay(courier,'is_priest_buff_courier')
	end
	
	if GameRules:GetGameModeEntity().egg_quest == 'q015' and table.maxn(combo_type_table) >= 6 then
		SetQuest(teamid,true)
	end

	local combo_count_race = 0
	local dragon_sound_enemy = false
	local god_sound_enemy = false
	
	for s,x in pairs(combo_count_table_enemy) do
		local condition_0 = GameRules:GetGameModeEntity().combo_ability_type[s]['condition']
		local condition = condition_0
		local is_race = GameRules:GetGameModeEntity().combo_ability_type[s]['is_race']
		if x >= condition and is_race ~= true then
			for m,n in pairs(combo_chess_table_enemy[s]) do
				n.class = 1
			end
		end
		if x >= condition and is_race == true and string.find(s,'god') == nil and string.find(s,'is_demon') == nil then
			for m,n in pairs(combo_chess_table_enemy[s]) do
				n.race = 1
			end
		end
	end

	--恩拉基
	if the_only_combo_enemy ~= 'is_nraqi' then
		combo_count_table_enemy['is_nraqi'] = 0
	end
	for p,vp in pairs(combo_chess_table_enemy) do
		local shaman_hex = false
		local shaman_hexhex = false
		local tauren_wardward = false
		local kobold_tt = false
		local type1 = GameRules:GetGameModeEntity().combo_ability_type[p]['type']
		local condition_0 = GameRules:GetGameModeEntity().combo_ability_type[p]['condition']
		local condition = condition_0
		local buff_ability = GameRules:GetGameModeEntity().combo_ability_type[p]['ability']
		local is_race = GameRules:GetGameModeEntity().combo_ability_type[p]['is_race']
		if condition == 0 then
			if combo_count_table_enemy[p] == 1 then
				for _,chess in pairs(vp) do
					if buff_ability ~= nil then
						AddAbilityAndSetLevelDelay(chess,buff_ability)
						table.insert(baojun_ability_table_enemy,buff_ability)
						if is_race == true then
							chess.race = 1
							combo_count_race = combo_count_race + 1
						end
					end
				end
			end
		else
			if combo_count_table_enemy[p] >= condition then
				if is_race == true then
					combo_count_race = combo_count_race + 1
				end
				local troll_levels = 0
				local tauren_level = nil
				if combo_count_table_enemy['is_tauren'] ~= nil and combo_count_table_enemy['is_tauren'] >= GameRules:GetGameModeEntity().combo_ability_type['is_tauren']['condition'] then
					tauren_level = 'is_tauren'
					if combo_count_table_enemy['is_tauren1'] >= GameRules:GetGameModeEntity().combo_ability_type['is_tauren1']['condition'] then
						tauren_level = 'is_tauren1'
					end
				end
				for _,chess in pairs(combo_chess_table_enemy[p]) do
					if p == 'is_kobold' and kobold_tt == false then
						kobold_tt = true
						local double_table = {}
						for _,cc in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
							if cc.team_id ~= teamid then
								if IsUnitExist(cc) == true then
									if double_table[cc:GetUnitName()] == nil then
										double_table[cc:GetUnitName()] = {}
									end
									table.insert(double_table[cc:GetUnitName()],cc)
								end
							end
						end
						local kobold_active = false
						for _,kk in pairs(double_table) do
							if string.find(_,'chess_meepo') ~= nil and table.maxn(kk) == 2 then
								kobold_active = true
							end
						end
						if kobold_active == true then
							for _,kk in pairs(double_table) do
								if table.maxn(kk) == 2 then
									kk[1].kobold_result = true
								end
							end
						end
					end
					if p == 'is_shaman' and shaman_hex == false then
						shaman_hex = true
						local shaman_target = nil
						-- if RandomInt(0,100) < 30 then
							local trycount = 0
							while shaman_target == nil and trycount < 100 do
								trycount = trycount + 1
								for _,cc in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
									if cc:GetTeam() == teamid and RandomInt(1,100) > 25 and string.find(cc:GetUnitName(),'chess_') ~= nil then
										shaman_target = cc
										break
									end
								end
							end
						-- else
						-- 	local max_level = 1
						-- 	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						-- 		local lv = unit:GetLevel()
						-- 		if unit:GetMaxMana() <= 0 then
						-- 			lv = 1
						-- 		end

						-- 		if lv > max_level and unit.team_id == teamid then
						-- 			shaman_target = unit
						-- 			max_level = lv
						-- 		end
						-- 	end
						-- end
						if IsUnitExist(shaman_target) == true then
							if BlockByLinken(shaman_target) == false then
								AddAbilityAndSetLevel(shaman_target,'no_selectable')
								shaman_target.devolve_result = RandomEvolveChess(shaman_target,0)
							end
						end
					end
					if p == 'is_shaman1' and shaman_hexhex == false then
						shaman_hexhex = true
						for _,cc in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
							if cc.team_id == 4 and cc:HasAbility('is_shaman') then
								if IsUnitExist(cc) == true then
									AddAbilityAndSetLevel(cc,'no_selectable')
									cc.evolve_result = RandomEvolveChess(cc,2)
								end
							end
						end
						table.insert(baojun_ability_table_enemy,'is_shaman1')
					end
					if p == 'is_dragon' then
						play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,chess,5)
						if dragon_sound_enemy == false then
							dragon_sound_enemy = true
							EmitSoundOn('Hero_DragonKnight.DragonTail.Target',chess)
						end
						chess.is_dragon_zhanhou = true
						chess:SetMana(100)
						AMHC:CreateNumberEffect(chess,100,2,AMHC.MSG_MISS,{128,128,255},0)
						table.insert(baojun_ability_table_enemy,'flag_dragon3')
					end
					if p == 'is_dragon1' then
						if combo_count_table_enemy[p] >= condition then
							for kkkk,vvvv in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if vvvv.team_id == 4 and vvvv.class ~= 1 then
									vvvv.is_dragon_zhanhou = true
									vvvv:SetMana(100)
									AMHC:CreateNumberEffect(vvvv,100,2,AMHC.MSG_MISS,{128,128,255},0)
									play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)

								end
							end
						end
					end
					if p == 'is_god' then
						if combo_count_table_enemy[p] >= condition then
							local demon_active = false
							if (combo_count_table_enemy['is_demon'] == 1 and combo_count_table_self['is_demonhunter'] == 0) or combo_count_table_enemy['is_demonhunter1'] == 2 then
								demon_active = true
							end
							for kkkk,vvvv in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if vvvv.team_id == 4 then
									if vvvv:FindAbilityByName('is_demon') ~= nil then
										if demon_active == false then
											if god_sound == false then
												EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
												god_sound = true
											end
											if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff') == nil then
												AddAbilityAndSetLevelDelay(vvvv,'is_god_buff')
												table.insert(baojun_ability_table_enemy,'flag_god2')
												play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
											end
										end
									elseif vvvv.race ~= 1 then
										if god_sound == false then
											EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
											god_sound = true
										end
										if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff') == nil then
											AddAbilityAndSetLevelDelay(vvvv,'is_god_buff')
											table.insert(baojun_ability_table_enemy,'flag_god2')
											play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
										end
									end
								end
							end
						end
					end
					if p == 'is_god1' then
						if combo_count_table_enemy[p] >= condition then
							local demon_active = false
							if (combo_count_table_enemy['is_demon'] == 1 and combo_count_table_self['is_demonhunter'] == 0) or combo_count_table_enemy['is_demonhunter1'] == 2 then
								demon_active = true
							end
							for kkkk,vvvv in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if vvvv.team_id == 4 then
									if vvvv:FindAbilityByName('is_demon') ~= nil then
										if demon_active == false then
											if god_sound == false then
												EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
												god_sound = true
											end
											if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff_plus') == nil then
												AddAbilityAndSetLevelDelay(vvvv,'is_god_buff_plus')
												table.insert(baojun_ability_table_enemy,'flag_god4')
												play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
											end
										end
									elseif vvvv.race ~= 1 then
										if god_sound == false then
											EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
											god_sound = true
										end
										if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff_plus') == nil then
											AddAbilityAndSetLevelDelay(vvvv,'is_god_buff_plus')
											table.insert(baojun_ability_table_enemy,'flag_god4')
											play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
										end
									end
								end
							end
						end
					end
					if p == tauren_level then
						if tauren_wardward == false then
							tauren_wardward = true
							local first_tauren = nil
							for i0,v0 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
								if v0:HasAbility('is_tauren') and v0:GetTeam() ~= teamid then
									first_tauren = v0
								end
							end
							if first_tauren ~= nil then
								if tauren_level == 'is_tauren' then
									SummonTaurenWard(first_tauren,1)
								elseif tauren_level == 'is_tauren1' then
									SummonTaurenWard(first_tauren,2)
								end
							end
						end
					end
				end
				--同类有技能
				if type1 == 1 then
					for _,chess in pairs(combo_chess_table_enemy[p]) do
						if buff_ability ~= nil then
							AddAbilityAndSetLevelDelay(chess,buff_ability)
							table.insert(baojun_ability_table_enemy,buff_ability)
						end
					end
				end
				--友军有技能
				if type1 == 2 then
					for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						if chess.team_id == 4 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									if buff_ability == 'is_aqir_buff' then
										--特殊情况，亚基
										if condition == 2 then
											if chess:HasAbility('is_aqir') == false then
												AddAbilityAndSetLevelDelay(chess,buff_ability)
												table.insert(baojun_ability_table_enemy,buff_ability)
											end
										else
											AddAbilityAndSetLevelDelay(chess,buff_ability)
											table.insert(baojun_ability_table_enemy,buff_ability)
										end
									elseif buff_ability == 'is_orc_buff_plus_plus' then
										local oppo = GameRules:GetGameModeEntity().counterpart[teamid]
										local hero = TeamId2Hero(oppo)
										local lost_hp = 100 - hero:GetHealth()
										ModMaxHP({
											caster = chess,
											const = lost_hp*10
										})
										AddAbilityAndSetLevelDelay(chess,buff_ability)
									else
										AddAbilityAndSetLevelDelay(chess,buff_ability)
										table.insert(baojun_ability_table_enemy,buff_ability)
									end
								end
							end
						end
					end
				end
				--敌军有技能
				if type1 == 3 then
					for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						--是敌军
						if chess.team_id == teamid then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevel(chess,buff_ability)
								end
							end
						end
					end
				end
				--随机一个友军有技能
				if type1 == 4 then
					local try_count = 0
					local is_ok = false
					while is_ok == false and try_count < 100 do
						local r = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[teamid]))
						local chess = GameRules:GetGameModeEntity().to_be_destory_list[teamid][r]
						if chess.team_id == 4 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									table.insert(baojun_ability_table_enemy,buff_ability)
									is_ok = true
								end
							end
						end
						try_count = try_count + 1
					end
				end
				--随机一个敌军有技能
				if type1 == 5 then
					local try_count = 0
					local is_ok = false
					while is_ok == false and try_count < 100 do
						local r = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[teamid]))
						local chess = GameRules:GetGameModeEntity().to_be_destory_list[teamid][r]
						if chess.team_id ~= 4 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									table.insert(baojun_ability_table_enemy,buff_ability)
									is_ok = true
								end
							end
						end
						try_count = try_count + 1
					end
				end
				--远程友军有技能
				if type1 == 7 then
					for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
						if chess.team_id == 4 and chess:Script_GetAttackRange() > 205 then
							if string.find(chess:GetUnitName(),'hero') == nil then
								if buff_ability ~= nil then
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									table.insert(baojun_ability_table_enemy,'flag_drawf2')
								end
							end
						end
					end
				end
			end
		end
	end

	--第四次循环：给暴君添加所有友军享受的技能
	if table.maxn(baojun_table_self) > 0 and table.maxn(baojun_ability_table_self) > 0 then
		for _,baojun in pairs(baojun_table_self) do
			for _,ability in pairs(baojun_ability_table_self) do
				AddABaojunAbility(baojun, ability)
			end
		end
	end
	if table.maxn(baojun_table_enemy) > 0 and table.maxn(baojun_ability_table_enemy) > 0 then
		for _,baojun in pairs(baojun_table_enemy) do
			for _,ability in pairs(baojun_ability_table_enemy) do
				AddABaojunAbility(baojun, ability)
			end
		end
	end
end

--给暴君添加所有友军享受的技能
function AddABaojunAbility(baojun, ability)
	if baojun == nil or IsUnitExist(baojun) == false or baojun:HasModifier('modifier_item_baojunwangpao') == false then
		return
	end
	--特例：
	if ability == 'flag_dragon3' then
		play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,baojun,5)
		EmitSoundOn('Hero_DragonKnight.DragonTail.Target',baojun)
		baojun.is_dragon_zhanhou = true
		baojun:SetMana(100)
		AMHC:CreateNumberEffect(baojun,100,2,AMHC.MSG_MISS,{128,128,255},0)
	elseif ability == 'flag_god2' then
		if baojun:HasAbility('is_god_buff') == false then
			AddAbilityAndSetLevelDelay(baojun,'is_god_buff')
			play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,baojun,5)
		end
	elseif ability == 'flag_god4' then
		if baojun:HasAbility('is_god_buff_plus') == false then
			AddAbilityAndSetLevelDelay(baojun,'is_god_buff_plus')
			play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,baojun,5)
		end
	elseif ability == 'flag_drawf2' or ability == 'is_dwarf_buff' or ability == 'is_dwarf_buff_plus' then
		if baojun:HasAbility(ability) == false and baojun:Script_GetAttackRange() > 205 then
			AddAbilityAndSetLevelDelay(baojun,ability)
		end
	elseif ability == 'is_shaman1' then
		AddAbilityAndSetLevel(baojun,'no_selectable')
		baojun.evolve_result = RandomEvolveChess(baojun,2)
	else
		--非特例
		if baojun:HasAbility(ability) == false then
			AddAbilityAndSetLevelDelay(baojun,ability)
		end
	end
end

function AddAbilityAndSetLevelDelay(chess,buff_ability)
	-- Timers:CreateTimer(RandomFloat(0.1,1),function()
		AddAbilityAndSetLevel(chess,buff_ability)
	-- end)
end

function AddAbilty2BaoJunList(baojun_table,buff_ability)
	for _,v in pairs(baojun_table) do
		AddAbilityAndSetLevel(v,buff_ability)
	end
end


--游戏循环2.2——镜像要打的敌人和给他们加组合技
function MirrorARound(teamid)
	local opp = nil
	local my_opp = nil
	
	Timers:CreateTimer(0.1,function()
		for myteam,enemyteam in pairs(GameRules:GetGameModeEntity().counterpart) do
			if enemyteam == teamid then
				opp = myteam
			end
			if myteam == teamid then
				my_opp = enemyteam
			end
		end
		if opp ~= nil then
			--镜像棋手
			Timers:CreateTimer(1,function()
				local opp_hero = TeamId2Hero(my_opp)
				local opp_steam_id = opp_hero.steam_id
				local opp_model = GetStat(opp_hero:GetPlayerID(),'zhugong_model')
				local opp_effect = GetStat(opp_hero:GetPlayerID(),'zhugong_effect')
				local mirror_chesser = MirrorChesser(teamid,opp_model,opp_effect,opp_hero:GetModelScale(),opp_hero.ori_skin)
				mirror_chesser.onduty_hero = GetStat(opp_hero:GetPlayerID(),'zhugong')
				opp_hero.my_away_mirror_chesser = mirror_chesser
				MakeGreevil(mirror_chesser,true)

				if mirror_chesser ~= nil and opp_hero.pet_name1 ~= nil and opp_hero.pet_name1 ~= 't000' then
					local pet = RefreshPets(mirror_chesser,mirror_chesser.pet1,opp_hero.pet_name1,2)
					if pet ~= nil then
						pet:SetForwardVector(Vector(0,-1,0))
					end
				end
			end)

			for i=1,4 do
				for j=1,8 do
					if GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j] ~= nil then
						GameRules:GetGameModeEntity().unit[teamid][i..'_'..j] = 1
						GameRules:GetGameModeEntity().unit[opp][(9-i)..'_'..(9-j)] = 1
						--复制棋子
						MirrorAChess(teamid,i,j,opp)
					end
				end
			end
			
			Timers:CreateTimer(4.5,function()
				AddComboAbility(teamid)
			end)
		end
	end)
end

function ShowTPEffectAtPosition(p,e)
	if e ~= nil then
		local ppp = ParticleManager:CreateParticle(e, PATTACH_WORLDORIGIN ,nil)
	    ParticleManager:SetParticleControl(ppp, 0, p)
	    ParticleManager:SetParticleControl(ppp, 1, p)
	    return ppp
	else
		return nil
	end
end

function MirrorAChess(teamid,i,j,opp)
	--获取出场动画
	local hero = TeamId2Hero(teamid)
	if IsUnitExist(hero) == false then
		return
	end
	local animation_info = GetAnimation(hero.animation or 'n000')


	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector(9-j,9-i,opp),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end
			local x = CreateUnitByName(GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].chess,XY2Vector(9-j,9-i,opp),true,nil,nil,DOTA_TEAM_NEUTRALS)
			MakeTiny(x)
			x:SetForwardVector(Vector(0,-1,0))

			x.y_x = (9-i)..'_'..(9-j)
			x.y = 9-i
			x.x = 9-j
			x.press_count = GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].press_count
			x.track_money_count = GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].track_money_count

			x.team_id = 4
			x.at_team_id = opp
			x.from_team_id = teamid
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			table.insert(GameRules:GetGameModeEntity().to_be_destory_list[opp],x)

			if GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].rubick_a ~= nil then
				AddAbilityAndSetLevel(x,GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].rubick_a,0)
				x.steal_ability = GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].rubick_a
				if GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].rubick_range ~= nil then
					if GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].rubick_range > 210 then
						if GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].rubick_range > 410 then
							AddAbilityAndSetLevel(x,'attackrange_600',1)
						else
							AddAbilityAndSetLevel(x,'attackrange_400',1)
						end
					end
				end
			end
			--复制物品
			local uindex = GameRules:GetGameModeEntity().mychess[teamid][i..'_'..j].index
			for slot=0,9 do
				if EntIndexToHScript(uindex):GetItemInSlot(slot)~= nil then
					local name = EntIndexToHScript(uindex):GetItemInSlot(slot):GetAbilityName()
					if name ~= nil then
						x:AddItemByName(name)
					end
				end
			end

			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
		end)
	end)

	
end

--为teamid场地镜像my_opp队伍的敌人棋手镜像
function MirrorChesser(teamid,opp_model,opp_effect,model_scale,skin)
	local mirror_chesser_position = Entities:FindByName(nil,"center"..(teamid-6)):GetAbsOrigin()
	local mirror_chesser = CreateUnitByName("player_image",mirror_chesser_position+Vector(0,128*6.5,256),true,nil,nil,DOTA_TEAM_NEUTRALS)
	mirror_chesser:SetForwardVector(Vector(0,-1,0))
	if model_scale == nil then
		model_scale = 1
	end
	mirror_chesser:SetModelScale(model_scale)
	TeamId2Hero(teamid).mirror_chesser = mirror_chesser
	--镜像棋手形象
	if opp_model ~= nil then
		local new_m = ChangeFlyingCourierModel(opp_model)

		mirror_chesser:SetOriginalModel(new_m)
		mirror_chesser:SetModel(new_m)
		mirror_chesser:SetSkin(skin)
		AddAbilityAndSetLevel(mirror_chesser,'courier_fly')
	end

	if opp_effect ~= nil and opp_effect ~= 'e000' then
		AddAbilityAndSetLevel(mirror_chesser,opp_effect)
	end

	-- BlinkChessX({caster=mirror_chesser,blink_type="fall"})

	return mirror_chesser
end

function LoadCloudEnemy(wave,team)
	if GameRules:GetGameModeEntity().cloudlineup[''..wave] ~= nil then
		local chesses = nil
		for _,data in pairs(GameRules:GetGameModeEntity().cloudlineup[''..GameRules:GetGameModeEntity().battle_round]) do
			chesses = json.decode(data)
		end

		--镜像棋手
		if chesses['zhugong'] ~= nil then
			local cloud_hero = string.split(chesses['zhugong'],'_')[1]
			local cloud_hero_effect = string.split(chesses['zhugong'],'_')[2] or ''

			local opp_model = GameRules:GetGameModeEntity().sm_hero_list[cloud_hero]

			Timers:CreateTimer(1,function()
				MirrorChesser(team,opp_model,cloud_hero_effect,(GameRules:GetGameModeEntity().sm_hero_size[cloud_hero] or 1),(GameRules:GetGameModeEntity().sm_hero_list_skin[cloud_hero] or 0))
			end)
		end

		if chesses ~= nil then
			for i,vi in pairs(chesses.lineup) do
				LoadOneCloudChess(vi,team)
				
			end
		end
	end
	Timers:CreateTimer(4.5,function()
		AddComboAbility(team)
	end)
end
function LoadOneCloudChess(vi,team)
	--获取出场动画
	--TODO: 暂时用默认的TP，后续可以改造为获取镜像玩家装备的动画
	local animation_info =  GetAnimation('n000')

	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector((9-vi.x),(9-vi.y),team),animation_info.tp_effect)


		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end
			GameRules:GetGameModeEntity().unit[team][(9-vi.y)..'_'..(9-vi.x)] = 1
			local x = CreateUnitByName(vi.chess,XY2Vector((9-vi.x),(9-vi.y),team),true,nil,nil,DOTA_TEAM_NEUTRALS)
			x:SetForwardVector(Vector(0,-1,0))
			x.y_x = (9-vi.y)..'_'..(9-vi.x)
			x.y = (9-vi.y)
			x.x = (9-vi.x)
			x.team_id = 4
			x.at_team_id = team
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			table.insert(GameRules:GetGameModeEntity().to_be_destory_list[team],x)
			--复制物品
			if vi.lastitem ~= nil then
				for _,it in pairs(vi.lastitem) do
					x:AddItemByName(it)
				end
			end
			
			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
		end)
	end)
end

-- function ToggleAbility(u,a,delay)
-- 	Timers:CreateTimer(delay,function()
-- 		local newOrder = {
-- 	 		UnitIndex = u:entindex(), 
-- 	 		OrderType = DOTA_UNIT_ORDER_CAST_TOGGLE,
-- 	 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
-- 	 		Position = nil, --Optional.  Only used when targeting the ground
-- 	 		Queue = 0 --Optional.  Used for queueing up abilities
-- 	 	}
-- 	 	ExecuteOrderFromTable(newOrder)
-- 	end)
-- end

function EvolveAChess(u)
	FillEmptySlot(u)
	
	-- local transfer_target_level = u:GetLevel()+2
	-- if transfer_target_level > 9 then
	-- 	transfer_target_level = 9
	-- end
	-- local transfer_duration = transfer_target_level/2
	local transfer_duration = RandomFloat(2.5,3)
	u:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(u,u,'modifier_transfer_buff',{ duration = transfer_duration})
	play_particle("effect/evolve.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,transfer_duration)
	AddAbilityAndSetLevel(u,'jiaoxie')
	RemoveAbilityAndModifier(u,'jiaoxie_wudi')
	-- u:AddNewModifier(u,nil,'modifier_teleport',{ duration = transfer_duration,})
	Timers:CreateTimer(transfer_duration,function()
		if IsUnitExist(u) == true then
			local aposition = u:GetAbsOrigin()
			local team_id = u:GetTeam()
			local at_team_id = u.at_team_id or u.team_id
			local items = GetAllItemsInUnits({[1] = u})
			local hp_per = u:GetHealth()/u:GetMaxHealth()

			if IsUnitExist(u) == true then
				RemoveFromToBeDestroyList(u)
				if u:FindAbilityByName('dr_shooter_aura') ~= nil then
					RemoveDrShooterAura({
						caster = u,
						ability = u:FindAbilityByName('dr_shooter_aura'),
					})
				end
				if team_id ~= 4 then
					SaveItem(u.team_id,u:entindex(),function()
						u:Destroy()
					end)
				else
					u:Destroy()
				end

				local x = SummonAChess(team_id,aposition,u.evolve_result,at_team_id,100,0,{},false)
				x:SetHealth(x:GetMaxHealth()*hp_per)
				EmitSoundOn("shaman.evolve",x)
				play_particle("particles/econ/events/ti10/hero_levelup_ti10.vpcf",PATTACH_ABSORIGIN_FOLLOW,x,3)
			end
		end
	end)
end
function DevolveAChess(u)
	FillEmptySlot(u)
	local transfer_duration = RandomFloat(2.5,3)
	u:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(u,u,'modifier_transfer_debuff',{ duration = transfer_duration})
	AddAbilityAndSetLevel(u,'jiaoxie')
	RemoveAbilityAndModifier(u,'jiaoxie_wudi')
	Timers:CreateTimer(transfer_duration,function()
		if IsUnitExist(u) == true then
			local aposition = u:GetAbsOrigin()
			local team_id = u:GetTeam()
			local at_team_id = u.at_team_id or u.team_id
			local items = GetAllItemsInUnits({[1] = u})
			local hp_per = u:GetHealth()/u:GetMaxHealth()
			RemoveFromToBeDestroyList(u)
			if IsUnitExist(u) == true then
				if u:FindAbilityByName('dr_shooter_aura') ~= nil then
					RemoveDrShooterAura({
						caster = u,
						ability = u:FindAbilityByName('dr_shooter_aura'),
					})
				end
				if team_id ~= 4 then
					SaveItem(u.team_id,u:entindex(),function()
						u:Destroy()
					end)
				else
					u:Destroy()
				end
				local x = SummonAChess(team_id,aposition,u.devolve_result,at_team_id,100,0,items,true)
				x:SetHealth(x:GetMaxHealth()*hp_per)
				EmitSoundOn("shaman.devolve",x)
				play_particle("particles/units/heroes/hero_lion/lion_spell_voodoo.vpcf",PATTACH_ABSORIGIN_FOLLOW,x,3)
			end
		end
	end)
end

--游戏循环2.3——自走！
function ChessAI(u)
	if GameRules:GetGameModeEntity().start_ai == true and (u.aitimer == nil or Timers.timers[u.aitimer] == nil) then
		u:RemoveGesture(ACT_DOTA_SPAWN)
		u:RemoveGesture(ACT_DOTA_IDLE)
		--kobold
		if u.kobold_result == true and GameRules:GetGameModeEntity().is_game_ended ~= true then
			Timers:CreateTimer(RandomFloat(0.01,0.1),function()
				local aposition = FindEmptyGridAtUnit(u)
				local team_id = u:GetTeam()
				local at_team_id = u.at_team_id or u.team_id
				local x = SummonAChess(team_id,aposition,u:GetUnitName(),at_team_id,100,0,{},false)
				BlinkChessX({caster=x,blink_type="breaksoil"})
				u.kobold_result = nil
			end)
		end
		--shaman
		if u.evolve_result ~= nil then
			EvolveAChess(u)
			return
		elseif u.devolve_result ~= nil then
			DevolveAChess(u)
			return
		end
		--rubick
		if u:FindAbilityByName('rubick_qiequ') ~= nil then
			--拉比克窃取技能
			local steal_chess = nil
			local steal_chess_unit = nil
			local try_time = 0
			while steal_chess == nil and try_time < 100 do
				local rant = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[(u.at_team_id or u.team_id)]))
				local cc = GameRules:GetGameModeEntity().to_be_destory_list[(u.at_team_id or u.team_id)][rant]
				if cc:GetTeam() ~= u.team_id and not string.find(cc:GetUnitName(),'chess_rubick') and not string.find(cc:GetUnitName(),'chess_meepo') and not string.find(cc:GetUnitName(),'chess_kael') and not cc:HasAbility('is_ward') and GameRules:GetGameModeEntity().ability_behavior_list[GameRules:GetGameModeEntity().chess_ability_list[cc:GetUnitName()]] ~= 0 then
					steal_chess = cc:GetUnitName()
					steal_chess_unit = cc
				end
				try_time = try_time + 1
			end
			if steal_chess ~= nil and not string.find(steal_chess,'chess_rubick') then
				if steal_chess_unit:Script_GetAttackRange() > 210 then
					if steal_chess_unit:Script_GetAttackRange() > 410 then
						AddAbilityAndSetLevel(u,'attackrange_600',1)
					else
						AddAbilityAndSetLevel(u,'attackrange_400',1)
					end
				end
				local a = GameRules:GetGameModeEntity().chess_ability_list[steal_chess]
				if a ~= nil then
					u.steal_ability = a
					if u.team_id ~= 4 then
						for ii,vv in pairs(GameRules:GetGameModeEntity().mychess[u.team_id]) do
							if vv.index == u:entindex() then
								vv.rubick_a = a
								vv.rubick_range = steal_chess_unit:Script_GetAttackRange()
							end
						end
					end
					local a_level = 1
					if string.find(u:GetUnitName(),'1') then
						a_level = 2
					end
					if string.find(u:GetUnitName(),'11') then
						a_level = 3
					end
					if u:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(u,a,a_level)
					else
						u:FindAbilityByName(a):SetLevel(a_level)
					end
					RemoveAbilityAndModifier(u,'rubick_qiequ')
					--特效、音效
					local effect_name = "particles/units/heroes/hero_rubick/rubick_spell_steal.vpcf"
					if u:GetUnitName() == 'chess_rubick11' then
						effect_name = "particles/econ/items/rubick/rubick_arcana/rubick_arc_spell_steal_default.vpcf"
					end
					ProjectileManager:CreateTrackingProjectile({
				        Target = u,
				        Source = steal_chess_unit,
				        Ability = nil,
				        EffectName = effect_name,
				        bDodgeable = false,
				        iMoveSpeed = 1200,
				        bProvidesVision = false,
				        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
				    })
				    u:StartGesture(ACT_DOTA_CAST_ABILITY_4)
				    EmitSoundOn("Hero_Rubick.SpellSteal.Cast",u)
				end
			end
		end
		--kael
		if u:FindAbilityByName('invoke') ~= nil then
			local a_level = 1
			if string.find(u:GetUnitName(),'1') then
				a_level = 2
			end
			if string.find(u:GetUnitName(),'11') then
				a_level = 3
			end

			local find_team = 0
			if GameRules:GetGameModeEntity().battle_boss[GameRules:GetGameModeEntity().battle_round-1] == nil then
				if u.team_id == 4 then
					find_team = u.at_team_id
				else
					find_team = GameRules:GetGameModeEntity().counterpart[u.team_id]
				end
			end
			local a_list = {
				is_mage = 'invoker_emp',
				is_shaman = 'invoker_emp',
				is_god ='invoker_emp',
				is_warrior = 'forge_spirit',
				is_orc = 'forge_spirit',
				is_goblin = 'forge_spirit',
				is_warlock = 'alacrity',
				is_mech = 'alacrity',
				is_naga = 'alacrity',
				is_hunter = 'invoker_deafening_blast',
				is_assassin = 'invoker_deafening_blast',
				is_troll = 'invoker_deafening_blast',
				is_monk = 'invoker_deafening_blast',
				is_knight = 'invoker_sun_strike',
				is_human = 'invoker_sun_strike',
				is_undead = 'invoker_sun_strike',
				is_beast = 'invoker_chaos_meteor',
				is_elf = 'invoker_chaos_meteor',
				is_aqir = 'invoker_chaos_meteor',
				is_druid = 'invoker_tornado',
				is_element = 'invoker_tornado',
				is_dragon = 'invoker_tornado',
				is_pandaman = 'invoker_tornado',
				is_tauren = 'invoker_tornado',
			}
			local aa_list = {
				[1] = 'is_warrior',
				[2] = 'is_mage',
				[3] = 'is_knight',
				[4] = 'is_warlock',
				[5] = 'is_hunter',
				[6] = 'is_mech',
				[7] = 'is_assassin',
				[8] = 'is_druid',
				[9] = 'is_shaman',
				[10] = 'is_god',
				[11] = 'is_goblin',
				[12] = 'is_orc',
				[13] = 'is_naga',
				[14] = 'is_troll',
				[15] = 'is_human',
				[16] = 'is_undead',
				[17] = 'is_beast',
				[18] = 'is_elf',
				[19] = 'is_aqir',
				[20] = 'is_element',
				[21] = 'is_dragon',
				[22] = 'is_tauren',
				[23] = 'is_pandaman',
				[24] = 'is_monk',
			}
			local kael_ability = a_list[aa_list[RandomInt(1,table.maxn(aa_list))]]
			if find_team ~= 0 then
				local find_combo = TeamId2Hero(find_team).kael_combo
				if find_combo ~= nil and a_list[find_combo] ~= nil then
					kael_ability = a_list[find_combo]
				end
			end
			local orb_table = {
				forge_spirit = {'invoker_exort','invoker_exort','invoker_quas'},
				invoker_ice_wall = {'invoker_exort','invoker_quas','invoker_quas'},
				invoker_sun_strike = {'invoker_exort','invoker_exort','invoker_exort'},
				invoker_chaos_meteor = {'invoker_exort','invoker_exort','invoker_wex'},
				alacrity = {'invoker_exort','invoker_wex','invoker_wex'},
				invoker_emp = {'invoker_wex','invoker_wex','invoker_wex'},
				invoker_cold_snap = {'invoker_quas','invoker_quas','invoker_quas'},
				invoker_tornado = {'invoker_quas','invoker_wex','invoker_wex'},
				invoker_deafening_blast = {'invoker_quas','invoker_wex','invoker_exort'},
			}
			AddAbilityAndSetLevel(u,'invoker_quas',a_level)
			AddAbilityAndSetLevel(u,'invoker_wex',a_level)
			AddAbilityAndSetLevel(u,'invoker_exort',a_level)
			AddAbilityAndSetLevel(u,'invoker_invoke',a_level)
			for iii,vvv in pairs(orb_table[kael_ability]) do
				u:AddNewModifier(u,u:FindAbilityByName(vvv),"modifier_"..vvv.."_instance",nil)
			end
			u.kael_ability = kael_ability
			RemoveAbilityAndModifier(u,'invoke')
			AddAbilityAndSetLevel(u,kael_ability,a_level)
		end
		if u:HasAbility('lc_qianggong') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"legion_commander_moment_of_courage",3)
		elseif u:HasAbility('lc_qianggong') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"legion_commander_moment_of_courage",2)
		elseif u:HasAbility('lc_qianggong') then
			AddAbilityAndSetLevel(u,"legion_commander_moment_of_courage",1)
		end
		if u:HasAbility('enchantress_natures_attendants') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"enchantress_untouchable",3)
		elseif u:HasAbility('enchantress_natures_attendants') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"enchantress_untouchable",2)
		elseif u:HasAbility('enchantress_natures_attendants') then
			AddAbilityAndSetLevel(u,"enchantress_untouchable",1)
		end

		if u:HasAbility('templar_assassin_refraction') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"templar_assassin_psi_blades",3)
		elseif u:HasAbility('templar_assassin_refraction') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"templar_assassin_psi_blades",2)
		elseif u:HasAbility('templar_assassin_refraction') then
			AddAbilityAndSetLevel(u,"templar_assassin_psi_blades",1)
		end

		if u:HasAbility('medusa_stone_gaze') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"medusa_split_shot",3)
			u:FindAbilityByName("medusa_split_shot"):ToggleAbility()
		elseif u:HasAbility('medusa_stone_gaze') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"medusa_split_shot",2)
			u:FindAbilityByName("medusa_split_shot"):ToggleAbility()
		elseif u:HasAbility('medusa_stone_gaze') then
			AddAbilityAndSetLevel(u,"medusa_split_shot",1)
			u:FindAbilityByName("medusa_split_shot"):ToggleAbility()
		end

		if u:HasAbility('winter_wyvern_cold_embrace') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"ww_frost",3)
		elseif u:HasAbility('winter_wyvern_cold_embrace') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"ww_frost",2)
		elseif u:HasAbility('winter_wyvern_cold_embrace') then
			AddAbilityAndSetLevel(u,"ww_frost",1)
		end


		
		--以技能名做判断，让拉比克偷窃sven技能后，在攻击近身目标时有分裂效果
		if u:HasAbility('sven_gods_strength') then
			AddAbilityAndSetLevel(u,"sven_great_cleave")
		end

		if u:HasAbility('mars_bulwark_attack') then	
			StartMarsShieldCD(u)
		end
		if u:HasAbility('mk_ruyibangfa') then	
			Timers:CreateTimer(1,function()
				if IsUnitExist(u) then
					AddAbilityAndSetLevel(u,"monkey_king_boundless_strike",u:FindAbilityByName('mk_ruyibangfa'):GetLevel())
					-- u:FindAbilityByName("monkey_king_boundless_strike"):SetHidden(true)
				end
			end)
		end
		
		if u:HasAbility('pudge_meat_hook_lua') then
			AddAbilityAndSetLevel(u,"pudge_dismember",u:FindAbilityByName('pudge_meat_hook_lua'):GetLevel())
			-- u:FindAbilityByName("pudge_dismember"):SetHidden(true)
		end
		if u:HasAbility('lion_mana_drain_datadriven') then
			AddAbilityAndSetLevel(u,"keeper_of_the_light_chakra_magic",1)
			u:FindAbilityByName("keeper_of_the_light_chakra_magic"):SetHidden(true)
		end
		if u:HasAbility('jakiro_macropyre') then
			AddAbilityAndSetLevel(u,"jakiro_ice_path",u:FindAbilityByName('jakiro_macropyre'):GetLevel())
			if RandomInt(1,100) > 50 then
				u:FindAbilityByName("jakiro_ice_path"):SetHidden(true)
				u.ice_or_fire = 'fire'
			else
				u:FindAbilityByName("jakiro_macropyre"):SetHidden(true)
				u.ice_or_fire = 'ice'
			end			
		end
		

		if u:HasAbility('is_assassin') then
			u.has_assassin_blink = true
		end

		AddAbilityAndSetLevel(u,'jiaoxie')
		RemoveAbilityAndModifier(u,'jiaoxie_wudi')

		local start_delay = 0
		if u:FindAbilityByName('is_assassin') ~= nil and GameRules:GetGameModeEntity().chess_ability_list[u:GetUnitName()] ~= nil then
			-- start_delay = 0.75
		end
		if u:HasAbility('is_assassin') == false and u:HasModifier('modifier_is_assassin_buff_plus_plus') then
			--非刺客的9刺buff，一开始不跳跃，也不延迟
			u.assassin_blinked = true
			-- start_delay = 0
		end
		local delay = RandomFloat(0.1,1.0)

		if u.y == 1 or u.y == 8 then
			start_delay = RandomFloat(0.3,0.4)
		elseif u.y == 2 or u.y == 7 then
			start_delay = RandomFloat(0.2,0.3)
		elseif u.y == 3 or u.y == 6 then
			start_delay = RandomFloat(0.1,0.2)
		elseif u.y == 4 or u.y == 5 then
			start_delay = RandomFloat(0,0.1)
		end

		--新版delay方案，按星级启动
		local chess_star = GetChessStar(u)
		if u:HasAbility('is_assassin') or chess_star == 1 then
			delay = RandomFloat(1.1,1.5)
		elseif chess_star == 2 then
			delay = RandomFloat(0.6,1)
		elseif chess_star == 3 then
			delay = RandomFloat(0.1,0.5)
		end

		delay = delay + start_delay

		if GameRules:GetGameModeEntity().is_game_ended == true then
			return
		end

		-- ShowStarsOnChess(u,delay+1)
		u.aitimer = Timers:CreateTimer(delay, function()
			if u == nil or u:IsNull() == true or u:IsAlive() == false or u.alreadywon == true or GameRules:GetGameModeEntity().is_game_ended == true then
				return
			end

			--容错
			if u:FindAbilityByName('modifier_no_hp_bar') ~= nil or u:FindAbilityByName('modifier_jiaoxie_wudi') ~= nil then
				u:Destroy()
				return
			end

			local ai_delay = 0
			-- if u:FindModifierByName('modifier_batrider_sticky_napalm') ~= nil then
			-- 	ai_delay = u:FindModifierByName('modifier_batrider_sticky_napalm'):GetStackCount()
			-- end

			--骑士启动必开盾
			if u.knight_first_shield == nil then
				if u:HasAbility('is_knight_buff_plus_plus') then
					u.knight_first_shield = true
					u:FindAbilityByName('is_knight_buff_plus_plus'):ApplyDataDrivenModifier(u,u,'modifier_is_knight_buff_2_plus_plus',{duration = 3})
					u:Heal(200, u)
				elseif u:HasAbility('is_knight_buff_plus') then
					u.knight_first_shield = true
					u:FindAbilityByName('is_knight_buff_plus'):ApplyDataDrivenModifier(u,u,'modifier_is_knight_buff_2_plus',{duration = 3})
					u:Heal(100, u)
				elseif u:HasAbility('is_knight_buff') then
					u.knight_first_shield = true
					u:FindAbilityByName('is_knight_buff'):ApplyDataDrivenModifier(u,u,'modifier_is_knight_buff_2',{duration = 3})
					u:Heal(50, u)
				end
			end

			if u:IsStunned() == true or u.is_moving == true or u.is_comboing == true or u:IsChanneling() == true or u:IsFrozen() == true then
				return 0.03
			end
			--使用物品
			if u:HasModifier('modifier_doom_bringer_doom') == false and u:HasModifier('modifier_skeleton_king_reincarnation_scepter_active') == false and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and u:IsHexed() == false then
				local bkb_result = TriggerBKB(u)
				if bkb_result ~= nil and bkb_result > 0 then
					return bkb_result + ai_delay
				end

				local renjia_result = TriggerRenjia(u)
				if renjia_result ~= nil and renjia_result > 0 then
					return renjia_result + ai_delay
				end

				local hudie_result = TriggerHudie(u)
				if hudie_result ~= nil and hudie_result > 0 then
					return hudie_result + ai_delay
				end

				local sadan_result = TriggerSadan(u)
				if sadan_result ~= nil and sadan_result > 0 then
					return sadan_result + ai_delay
				end

				local refresh_result = TriggerRefreshOrb(u)
				if refresh_result ~= nil and refresh_result > 0 then
					return refresh_result + ai_delay
				end

				local tiaodao_result = TriggerTiaodao(u)
				if tiaodao_result ~= nil and tiaodao_result > 0 then
					return tiaodao_result + ai_delay
				end

				local sheep_result = TriggerSheepStick(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local dagon_result = TriggerDagon(u)
				if dagon_result ~= nil and dagon_result > 0 then
					return dagon_result + ai_delay
				end

				local huanying_result = TriggerHuanyingfu(u)
				if huanying_result ~= nil and huanying_result > 0 then
					return huanying_result + ai_delay
				end

				local xiwa_result = TriggerXiwa(u)
				if xiwa_result ~= nil and xiwa_result > 0 then
					return xiwa_result + ai_delay
				end

				local pipe_result = TriggerPipe(u)
				if pipe_result ~= nil and pipe_result > 0 then
					return pipe_result + ai_delay
				end

				local chihongjia_result = TriggerChihongjia(u)
				if chihongjia_result ~= nil and chihongjia_result > 0 then
					return chihongjia_result + ai_delay
				end

				-- local gua_result = TriggerFrogGua(u)
				-- if gua_result ~= nil and gua_result > 0 then
				-- 	return gua_result + ai_delay
				-- end

				local fenglian_result = TriggerFengKuangMianJu(u)
				if fenglian_result ~= nil and fenglian_result > 0 then
					return fenglian_result + ai_delay
				end

				local mifaxie_result = TriggerMiFaXie(u)
				if mifaxie_result ~= nil and mifaxie_result > 0 then
					return mifaxie_result + ai_delay
				end

				local tuitui_result = TriggerTuiTui(u)
				if tuitui_result ~= nil and tuitui_result > 0 then
					return tuitui_result + ai_delay
				end
			end

			if u:HasModifier('modifier_om_multi_cast') == true then
				local refresh_result = MultiCast(u)
				if refresh_result ~= nil and refresh_result > 0 then
					return refresh_result + ai_delay
				end
			end
			--释放技能：14可以重新分配，原来的pom，11=新沙王，0=被动技能，1=单位目标，2=无目标，3=点目标，4=自己目标，5=近身单位目标，6=先知在地图边缘招树人，7=随机友军目标（嗜血术），8=随机周围空地目标（炸弹人），9=血量百分比最低的队友，10=等级最高的敌人（末日）12=小小投掷身边的敌人到最远的格子，13=自己为中心的点目标
			local a = nil
			if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
				a = u.steal_ability
			elseif string.find(u:GetUnitName(),'chess_kael') and u.kael_ability ~= nil then
				a = u.kael_ability
			else
				a = GameRules:GetGameModeEntity().chess_ability_list[u:GetUnitName()] or GameRules:GetGameModeEntity().summon_ability_list[u:GetUnitName()]
			end
			if u.ice_or_fire == 'fire' then
				a = 'jakiro_macropyre'
			end
			if u.ice_or_fire == 'ice' then
				a = 'jakiro_ice_path'
			end
			--决定是否要放技能
			if a ~= nil and u:HasModifier('modifier_axe_berserkers_call') == false and u:FindModifierByName('modifier_doom_bringer_doom') == nil and IsHexxed(u) == false and u:FindModifierByName('modifier_medusa_stone_gaze_stone') == nil and u:IsSilenced() == false and u:FindAbilityByName(a) ~= nil then
				if u:GetMana() >= u:FindAbilityByName(a):GetManaCost(u:FindAbilityByName(a):GetLevel()) and GameRules:GetGameModeEntity().ability_behavior_list[a] ~= 0 and u:FindAbilityByName(a):IsCooldownReady() == true then
					--有蓝，释放技能
					if GameRules:GetGameModeEntity().ability_behavior_list[a] == 1 then
						--单位目标
						local unluckydog = FindUnluckyDog(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							-- if a == 'lina_laguna_blade' then
							-- 	local level = u:FindAbilityByName('lina_laguna_blade'):GetLevel()
							-- 	InvisibleUnitCast({
							-- 		caster = u,
							-- 		ability = 'give_fiery_soul',
							-- 		level = level,
							-- 		unluckydog = u,
							-- 	})
							-- end
							if a == 'shadow_shaman_voodoo' then
								TriggerHex({
									target = unluckydog
								})
							end
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil and a ~= 'poof' then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 2 then
                        --无目标
                        local unluckydog = nil
                        if a == 'tiny_touzhi' then
                            unluckydog = FindUnluckyDog190(u)
                        end
 
                        if a == 'axe_berserkers_call' or a == 'juggernaut_blade_fury' or a == 'shredder_whirling_death' or a == 'rattletrap_battery_assault' then
                            --确保斧王、剑圣、发条、伐木机近身范围内有敌人（如果希望靠近敌人前就放技能，可以调整 205 的值。）
                            if FindUnluckyDogInRange(u, 205) ~= nil then
                                local newOrder = {
	                                UnitIndex = u:entindex(),
	                                OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	                                TargetIndex = nil, --Optional.  Only used when targeting units
	                                AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
	                                Position = nil, --Optional.  Only used when targeting the ground
	                                Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                SetMultiCastEnable(u)
                                return RandomFloat(0.5,2) + ai_delay
                            end
                        elseif a == 'queenofpain_scream_of_pain' then
                            --确保痛苦女王技能范围内有敌人
                            if FindUnluckyDogInRange(u, 400) ~= nil then
                                local newOrder = {
	                                UnitIndex = u:entindex(),
	                                OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	                                TargetIndex = nil, --Optional.  Only used when targeting units
	                                AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
	                                Position = nil, --Optional.  Only used when targeting the ground
	                                Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                SetMultiCastEnable(u)
                                return RandomFloat(0.5,2) + ai_delay
                            end
                        elseif unluckydog ~= nil or a ~= 'tiny_touzhi' then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							if a == 'alchemist_chemical_rage' then
								AcidSpray({
									caster = u,
									ability_level = u:FindAbilityByName(a):GetLevel(),
								})
							end
							if a == 'dragon_knight_elder_dragon_form' then
								
								local dragon_level = u:FindAbilityByName('dragon_knight_elder_dragon_form'):GetLevel()

								if dragon_level == 2 then
									Timers:CreateTimer(1,function()
										u:SetRangedProjectileName("effect/dragon/baseattack/2.vpcf")
									end)
								end
								if dragon_level == 3 then
									Timers:CreateTimer(1,function()
										u:SetRangedProjectileName("effect/dragon/baseattack/3.vpcf")
									end)
								end
							end
							if a == "sven_gods_strength" then
								CastGodsStrength(u)
							end
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 4 then
						--以自己为目标
						if u ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = u:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 5 then
						--近身单位目标
						local unluckydog = FindUnluckyDogInRange(u, u:Script_GetAttackRange())
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 6 then
						--棋盘边缘的空格点目标，先知用
						local unluckypoint = FindUnluckyPoint(u)
						if unluckypoint ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckypoint, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 7 then
						--随机友军单位目标
						local unluckydog = FindUnluckyDogRandomFriend(u,a,true)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 8 then
						--点目标，随机一个空格子
						local unluckypoint = FindEmptyGridAtUnit(u)--FindRandomEmptyGrid(u)
						if unluckypoint ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckypoint, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 9 then
						local unluckydog = FindShallowGraveFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 10 then
						--等级最高的敌方单位目标
						local unluckydog = FindHighLevelUnluckyDog(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							if a == 'shadow_shaman_voodoo' then
								TriggerHex({
									target = unluckydog
								})
							end
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 11 then
						local tt = FindFarthestGridForAbility(u,a)
					    local unluckypoint = tt['skip_postion']
					    if unluckypoint ~= nil then

					        --先占领目标格子
					        local target_x = Vector2X(unluckypoint,u.at_team_id or u.team_id)
					        local target_y = Vector2Y(unluckypoint,u.at_team_id or u.team_id)
					        GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][target_y..'_'..target_x] = 1
					        GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][u.y_x] = nil
					        u.y_x = target_y..'_'..target_x
					        u.x = target_x
					        u.y = target_y
					    
					        --计算位移过程的时长+技能前后摇时长
					        local go_duration = 2
					        if a == "morphling_waveform" then
					            go_duration = (unluckypoint - u:GetAbsOrigin()):Length2D() / u:FindAbilityByName(a):GetSpecialValueFor('speed') + 0.6
					        elseif a == "sandking_burrowstrike" then
					            go_duration = (unluckypoint - u:GetAbsOrigin()):Length2D() / u:FindAbilityByName(a):GetSpecialValueFor('burrow_speed') + 0.6
					        elseif a == "storm_spirit_ball_lightning" then
					            go_duration = (unluckypoint - u:GetAbsOrigin()):Length2D() / u:FindAbilityByName(a):GetSpecialValueFor('ball_lightning_move_speed') + 0.6
					        end
					    
					        --穿刺/波浪 过去！
					        local newOrder = {
					             UnitIndex = u:entindex(), 
					             OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
					             TargetIndex = nil, --Optional.  Only used when targeting units
					             AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
					             Position = unluckypoint, --Optional.  Only used when targeting the ground
					             Queue = 0 --Optional.  Used for queueing up abilities
					        }
					        ExecuteOrderFromTable(newOrder)
					    
					        --如果是水人，在施法完成后标准化他的位置，避免近战可以隔行打到他的问题
					        if a == 'morphling_waveform' then
					            Timers:CreateTimer(go_duration, function()
					                --如果不在波浪形态状态，则重设水人位置
					                if (u:GetAbsOrigin() - unluckypoint):Length2D() < 50 and u:FindModifierByName('modifier_morphling_waveform') ~= true then
					                    ChangeUnitPosition(u, unluckypoint, true)
					                end
					            end)
					        end
					        SetMultiCastEnable(u)
					        return RandomFloat(0.5,1.5) + go_duration + ai_delay
					    end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 12 then
                        --小小投掷，确认周围有敌人
                        local unluckydog = FindUnluckyDog190(u)
                        if IsUnitExist(unluckydog) == true and unluckydog.is_moving ~= true then
                            local unluckypoint = FindFarthestEmptyGrid(u)
                            if unluckypoint ~= nil then
                                local newOrder = {
                                    UnitIndex = u:entindex(),
                                    OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
                                    TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
                                    AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
                                    Position = unluckypoint, --Optional.  Only used when targeting the ground
                                    Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                SetMultiCastEnable(u)
                                return RandomFloat(0.5,2) + ai_delay
                            end
                        end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 13 then
						--自己为中心的点目标
						local unluckydog = FindUnluckyDogInRange(u, 300)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = u:GetAbsOrigin(),
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)

							if a == "bloodseeker_blood_bath" then
								BsDelaySilenceEnemy(u,u:FindAbilityByName(a):GetLevel())
							end
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 15 then
						--小鱼人跳
						local unluckydog = FindSlarkJumpUnluckyDogClosest(u)

						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(),--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(1.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 16 then
						local unluckydog = FindNeedShieldFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 17 then
						local unluckydog = FindUnluckyDogByAbilityDamage(u,a)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							-- if a == 'lina_laguna_blade' then
							-- 	local level = u:FindAbilityByName('lina_laguna_blade'):GetLevel()
							-- 	InvisibleUnitCast({
							-- 		caster = u,
							-- 		ability = 'give_fiery_soul',
							-- 		level = level,
							-- 		unluckydog = u,
							-- 	})
							-- end
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 18 then
						--寻找蓝最多的敌人
						local unluckydog = FindMaxManaUnluckydog(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 19 then
						-- 蝙蝠火
						local tt = FindFarthestGridForAbility(u,a)
						local unluckypoint = tt['skip_postion']
						if unluckypoint ~= nil and u.stop_moving ~= true then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							-- 跳跃
							local target_x = Vector2X(unluckypoint,u.at_team_id or u.team_id)
							local target_y = Vector2Y(unluckypoint,u.at_team_id or u.team_id)
							local xx = u.x
							local yy = u.y
							u.y_x = target_y..'_'..target_x
							u.y = target_y
							u.x = target_x
							GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][yy..'_'..xx] = nil
							GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][target_y..'_'..target_x] = 1
							u.is_moving = true
							Timers:CreateTimer(0.5,function()
								u:SetForwardVector((unluckypoint - u:GetAbsOrigin()):Normalized())
								if u.stop_moving ~= true and u:HasModifier('modifier_toss') ~= true then
									BlinkChessX({
										p = unluckypoint,
										caster = u,
										blink_type = 'run',
									})
								end
							end)
							SetMultiCastEnable(u)
							return 2 + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 20 then
						--屠夫的连招
						local unluckydog = FindUnluckyDogFarthest(u)
						if unluckydog ~= nil and unluckydog.is_moving ~= true then
							unluckydog.stop_moving = true
							u.hook_unluckydog = unluckydog
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(),
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = nil,
						 		Queue = 0
						 	}
							ExecuteOrderFromTable(newOrder)

							Timers:CreateTimer((u:GetAbsOrigin() - unluckydog:GetAbsOrigin()):Length2D() / 800 + 0.4,function()
								unluckydog.stop_moving = nil
							end)

							unluckydog.hook_cb = (function(uuu)
								if IsUnitExist(uuu.hook_unluckydog) == true then
									uuu.is_comboing = true --is_comboing为true的时候，不会执行其他AI打断连招操作
									local new_position = FindClosestEmptyGrid(uuu.hook_unluckydog)
									--改变目标位置
									ChangeUnitPosition(uuu.hook_unluckydog, new_position, true)

									play_particle("particles/econ/items/pudge/pudge_ti6_immortal/pudge_meathook_witness_impact_ti6.vpcf",PATTACH_ABSORIGIN_FOLLOW,uuu.hook_unluckydog,3)
									unluckydog.stop_moving = nil


									if ((new_position - uuu:GetAbsOrigin()):Length2D() < 200) then
										--肢解
										-- uuu:SwapAbilities('pudge_meat_hook_lua','pudge_dismember', false, true)
										Timers:CreateTimer(0.1,function()
											if uuu:FindAbilityByName('pudge_dismember') ~= nil then
												ExecuteOrderFromTable({
											 		UnitIndex = uuu:entindex(), 
											 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
											 		TargetIndex = uuu.hook_unluckydog:entindex(), --Optional.  Only used when targeting units
											 		AbilityIndex = u:FindAbilityByName('pudge_dismember'):entindex(), --Optional.  Only used when casting abilities
											 		Position = nil, --Optional.  Only used when targeting the ground
											 		Queue = 0 --Optional.  Used for queueing up abilities
											 	})
											 	if uuu:GetUnitName() == 'chess_pudge11' then
											 		EmitSoundOn("dac.pudge.fresh_meat",uuu)
											 	end
											 	
											 	Timers:CreateTimer(2,function()
											 		if IsUnitExist(uuu) == false then
											 			return
											 		end
											 		if uuu:IsChanneling() == false then
												 		-- uuu:SwapAbilities('pudge_dismember','pudge_meat_hook_lua', false, true)
												 		uuu.is_comboing = nil
												 		return
												 	end
											 		return 0.1
											 	end)
											end
										end)
									else
										--不肢解
										uuu.is_comboing = nil
									end
								end
								unluckydog.stop_moving = nil
							end)
							-- 将钩子来回的总时间加上随机量，做为进行下一次行动前的延迟。避免屠夫提前移动导致连招失败。
							SetMultiCastEnable(u)
							return (u:GetAbsOrigin() - unluckydog:GetAbsOrigin()):Length2D() / 800 + RandomFloat(0.5,1) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 21 then
						-- 佣兽寻找攻速最快的敌人
						local unluckydog_1 = nil
						local speed_1 = 0.1
						for i1,v1 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
							if v1:GetAttacksPerSecond() > speed_1 and v1.team_id ~= u.team_id and v1:HasModifier("modifier_visage_grave_chill_debuff") ~= true then
								speed_1 = v1:GetAttacksPerSecond()
								unluckydog_1 = v1
							end
						end
						if unluckydog_1 ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog_1:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end	
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 22 then
						--新大鱼点灯目标
						local unluckydog = nil
						if u:GetAttackTarget() ~= nil and IsUnitExist(u:GetAttackTarget()) == true then
							unluckydog = u:GetAttackTarget()
						else
							unluckydog = FindUnluckyDogInRange(u, u:Script_GetAttackRange(),'modifier_slardar_amplify_damage')
						end
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 23 then
						--全能选择目标
						local unluckydog = FindPurificationFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 24 then
						--蜘蛛选择目标
						local unluckydog = FindUnluckyDogInRange(u, 300,'modifier_br_web_debuff')
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 25 then
						--天火选择目标
						local unluckydog = FindUnluckyDogFarthest(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)

							if u:FindAbilityByName(a):GetLevel() == 2 then
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 2,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
							end
							if u:FindAbilityByName(a):GetLevel() == 3 then
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 3,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 3,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 3,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
							end
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 26 then
						--陈复活目标buff
						local unluckydog = GetMaxLevelChessFromDeadChessList({
							at_team_id = u.at_team_id or u.team_id,
						})
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 27 then
						--双头龙两个头的技能切换
						local tt = FindFarthestGridForAbility(u,a)
						local target_enemy = tt['target_enemy']
						local target_postion = tt['skip_postion']
						if target_enemy ~= nil then
							unluckydog = target_enemy
						else
							unluckydog = FindUnluckyDog(u) or unluckydog
						end

						--根据现在是什么技能决定怎么放
						if u.ice_or_fire == nil or u.ice_or_fire == 'fire' then
							a = 'jakiro_macropyre'
						else
							a = 'jakiro_ice_path'
						end
						if target_postion ~= nil and u:FindAbilityByName(a):IsCooldownReady() == true then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = target_postion, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
							Timers:CreateTimer(1,function()
								if u.ice_or_fire == 'ice' then
									--冰切火
									u.ice_or_fire = 'fire'
									local cd = u:FindAbilityByName("jakiro_ice_path"):GetCooldown(u:FindAbilityByName("jakiro_ice_path"):GetLevel())
									u:FindAbilityByName("jakiro_ice_path"):SetHidden(true)
									u:FindAbilityByName("jakiro_macropyre"):SetHidden(false)
									if u:HasAbility('is_god_buff_plus') then
										u:FindAbilityByName("jakiro_macropyre"):StartCooldown(cd*0.25+1)
									elseif u:HasAbility('is_god_buff') then
										u:FindAbilityByName("jakiro_macropyre"):StartCooldown(cd*0.5+1)
									else
										u:FindAbilityByName("jakiro_macropyre"):StartCooldown(cd+1)
									end
								else
									--火切冰
									u.ice_or_fire = 'ice'
									local cd = u:FindAbilityByName("jakiro_macropyre"):GetCooldown(u:FindAbilityByName("jakiro_macropyre"):GetLevel())
									u:FindAbilityByName("jakiro_macropyre"):SetHidden(true)
									u:FindAbilityByName("jakiro_ice_path"):SetHidden(false)
									if u:HasAbility('is_god_buff_plus') then
										u:FindAbilityByName("jakiro_ice_path"):StartCooldown(cd*0.25+1)
									elseif u:HasAbility('is_god_buff') then
										u:FindAbilityByName("jakiro_ice_path"):StartCooldown(cd*0.5+1)
									else
										u:FindAbilityByName("jakiro_ice_path"):StartCooldown(cd+1)
									end
								end
							end)

							SetMultiCastEnable(u)
							return RandomFloat(1,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 28 then
						local luckydog = FindHighLevelLuckyDog(u)
						if luckydog ~= nil and luckydog:HasModifier('modifier_wisp_tether') == false then
							u.tether_target = luckydog
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = luckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 29 then
						--圆形AOE施法AI
						local target_position = FindBestGridForCircleAOE(u,a)
						if target_position ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = target_position, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
						 	SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end	
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 30 then
						--多重施法选择合适目标AI
						local unluckydog = FindBestMulticastFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							SetMultiCastEnable(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 31 then
						local di = FindGouheDirection(u)
						if di ~= nil then
							local point = u:GetAbsOrigin() + Vector(di.x*128,di.y*128,0)
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = point, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
						 	SetMultiCastEnable(u)
						 	return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 32 then
						local unluckydog = FindMinHPEnemy(u)
						if unluckydog ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
						 	SetMultiCastEnable(u)
						 	if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
						 	return RandomFloat(0.5,2) + ai_delay
						end
					elseif GameRules:GetGameModeEntity().ability_behavior_list[a] == 33 then
						--滚滚，找个随机地点冲刺过去
						local point = FindRandomCanAttackEnemyEmptyGrid(u)
						if point ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = point,
						 		Queue = 0,
						 	})
						 	SetMultiCastEnable(u)
						 	return RandomFloat(0.5,2) + ai_delay
						end
					else
						--点目标
						local unluckydog = FindUnluckyDog(u)
						if unluckydog ~= nil then
							if a == "windrunner_powershot" then
								--强力击+束缚击
								local tt = FindFarthestGridForAbility(u,a)
								local target_enemy = tt['target_enemy']
								local target_postion = tt['skip_postion']
								if target_enemy ~= nil then
									unluckydog = target_enemy
								else
									unluckydog = FindUnluckyDogClosest(u) or unluckydog
								end
								if unluckydog ~= nil then
									InvisibleUnitCast({
										caster = u,
										ability = "windrunner_shackleshot",
										level = u:FindAbilityByName(a):GetLevel(),
										unluckydog = unluckydog,
										ignore_nether_ward = true,
									})

									ExecuteOrderFromTable({
								 		UnitIndex = u:entindex(), 
								 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
								 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
								 		Position = target_postion, --Optional.  Only used when targeting the ground
								 		Queue = 0 --Optional.  Used for queueing up abilities
								 	})

								 	if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
										CopyAbility2FuhunUnit(u,unluckydog,'windrunner_shackleshot')
									end
									if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
										CopyAbility2QinglianbaozhuUnit(u,unluckydog,'windrunner_shackleshot')
									end
								end
							elseif a == "keeper_of_the_light_illuminate" then
								--光法冲击波
								local tt = FindFarthestGridForAbility(u,a)
								local target_postion = tt['skip_postion']
								if target_postion ~= nil then
									ExecuteOrderFromTable({
								 		UnitIndex = u:entindex(), 
								 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
								 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
								 		Position = target_postion, --Optional.  Only used when targeting the ground
								 		Queue = 0 --Optional.  Used for queueing up abilities
								 	})
								end
							elseif a == "invoker_chaos_meteor" then
								--陨石
								local tt = FindFarthestGridForAbility(u,a)
								local target_enemy = tt['target_enemy']
								local target_postion = tt['skip_postion']
								if target_enemy ~= nil then
									unluckydog = target_enemy
								else
									unluckydog = FindUnluckyDogClosest(u) or unluckydog
								end
								if unluckydog ~= nil then
									ExecuteOrderFromTable({
								 		UnitIndex = u:entindex(), 
								 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
								 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
								 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
								 		Queue = 0 --Optional.  Used for queueing up abilities
								 	})
								end
							else
								ExecuteOrderFromTable({
							 		UnitIndex = u:entindex(), 
							 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
							 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
							 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
							 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
							 		Queue = 0 --Optional.  Used for queueing up abilities
							 	})
							end

							--光法 风行 蓄力
							if a=="keeper_of_the_light_illuminate" or a=="windrunner_powershot" then
								SetMultiCastEnable(u)
								return 3.5 + ai_delay
							else
								SetMultiCastEnable(u)
								return RandomFloat(0.5,2) + ai_delay
							end
						end
					end
				end
			end

			--决定是否要攻击
			if not u.has_assassin_blink == true then
				local attack_result = FindAClosestEnemyAndAttack(u)
				if attack_result ~= nil and attack_result > 0 and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false then
					return attack_result + ai_delay
				end
			end

			--不攻击就走动
			if u:FindModifierByName('modifier_queenofpain_sonic_wave_chaos_debuff') ~= nil or (u.attack_target == nil and u.stop_moving ~= true and u:HasModifier('modifier_oracle_mingyunsheling') == false and u:HasModifier('modifier_br_web_debuff') == false and u:HasAbility('is_ward') == false) then

				local find_ok = nil
				local try_count = 0
				local blink_type = 'run'

				--寻路
				if u.has_assassin_blink == true then
					u.has_assassin_blink = nil
					find_ok = FindFarthestUnluckyDogAvailablePosition(u)
					blink_type = 'jump'

					--背刺跳跃
					InitAssassinJump(u)
				else
					--正常行走
					find_ok = FindNextSkipPosition(u)
					if find_ok ~= nil then
						if u:FindModifierByName('modifier_item_suduzhixue') ~= nil or u:FindModifierByName('modifier_item_aoshuxie') ~= nil or u:FindModifierByName('modifier_item_jingmixie') ~= nil or u:FindModifierByName('modifier_item_yuanxingxie') ~= nil then
							blink_type = 'jump'
						else
							local pos1 = XY2Vector(u.x,u.y,u.at_team_id or u.team_id)
							if (find_ok - pos1):Length2D() > 128*3 then
								find_ok = (find_ok - pos1):Normalized() * 128 * 3 + pos1
							end
						end
						-- if u:FindModifierByName('modifier_is_elf_buff_plus_plus') ~= nil then
						-- 	blink_type = 'elfrun'
						-- end
					end
				end

				if u:FindModifierByName('modifier_queenofpain_sonic_wave_chaos_debuff') ~= nil then
					--混乱，随机走动
					find_ok = FindRandomEmptyGridAtUnit(u,false)
					blink_type = 'run'
				end

				if find_ok ~= nil then
					
					--走！
					local x = Vector2X(find_ok,u.at_team_id or u.team_id)
					local y = Vector2Y(find_ok,u.at_team_id or u.team_id)
					local xx = u.x
					local yy = u.y
					GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][y..'_'..x] = 1
					u:SetForwardVector((find_ok - u:GetAbsOrigin()):Normalized())
					u.is_moving = true
					BlinkChessX({
						p = find_ok,
						caster = u,
						blink_type = blink_type,
					})
					u.y_x = y..'_'..x
					u.y = y
					u.x = x
					GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][yy..'_'..xx] = nil

					return 0.1
				end
				return RandomFloat(0.1,0.2) + ai_delay
			else
				return RandomFloat(0.1,0.2) + ai_delay
			end
			return RandomFloat(0.1,0.2) + ai_delay
		end)
	end
end
--寻找离我最近的能攻击到指定敌人的空格子
function FindClosestEmptyGridToAttackUnluckydog(u,dog)
	local team = u.at_team_id or u.team_id
	local attack_range = u:Script_GetAttackRange() or 210
	local closest_range = 9999
	local closet_position = nil
	local dog_position = XY2Vector(dog.x,dog.y,team)
	for x=1,8 do
		for y=1,8 do
			local pos = XY2Vector(x,y,team)
			if (pos-dog_position):Length2D() < attack_range - dog:GetHullRadius() then 
				--能攻击到dog
				local range = (pos - XY2Vector(u.x,u.y,team)):Length2D()
				if IsEmptyGrid(team,x,y) == true and range < closest_range then 
					--离我最近的空格子
					closest_range = range
					closet_position = pos
				end
			end
		end
	end

	local pos = FindPath(XY2Vector(u.x,u.y,team),closet_position,team)

	return pos
end

--寻找我的下一跳位置
function FindNextSkipPosition(u)
	local team_id = u.at_team_id or u.team_id
	local skip_postion = nil
	local skip_postion_alt = nil
	local skip_postion_new = nil
	local length2d = 99999
	local length2d_alt = 99999
	local pos1 = XY2Vector(u.x,u.y,team_id)
	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			if IsGridCanAttackEnemy(x,y,u) == true then
				local next_skip = IsGridCanReach(x,y,u)
				if next_skip ~= nil and (pos2-pos1):Length2D() < length2d then
					skip_postion = next_skip
					length2d = (pos2-pos1):Length2D()
				end
				if next_skip ~= nil and (pos2-pos1):Length2D() < length2d_alt and math.abs(u.x-x) == math.abs(u.y-y) and pos2 == IsGridCanReach(x,y,u) then
					skip_postion_alt = next_skip
					length2d_alt = (pos2-pos1):Length2D()
				end
			end
		end
	end
	
	if skip_postion_alt ~= nil and (skip_postion_alt-skip_postion):Length2D() < 200 and (skip_postion_alt-pos1):Length2D() > 200 then
		skip_postion_new = skip_postion_alt
	else
		skip_postion_new = skip_postion
	end

	return skip_postion_new
end
function IsGridCanAttackEnemy(x,y,u)
	local team_id = u.at_team_id or u.team_id
	local attack_range = u:Script_GetAttackRange() or 210
	--遍历所有单位
	for _,enemy in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if IsUnitExist(enemy) == true and enemy.team_id ~= u.team_id and enemy:IsInvisible() == false and (XY2Vector(x,y,team_id) - enemy:GetAbsOrigin()):Length2D() < attack_range + enemy:GetHullRadius() + u:GetHullRadius() and enemy:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsBozangWudi(enemy) == false then
			return true
		end
	end
	return false
end
function IsGridCanReach(x,y,u)
	local team_id = u.at_team_id or u.team_id
	local pos1 = XY2Vector(u.x,u.y,team_id)
	local pos2 = XY2Vector(x,y,team_id)
	local pos = FindPath(pos1,pos2,team_id)
	if pos ~= nil then
		return pos
	else
		return nil
	end
end


function IsEmptyGrid(team,x,y)
	if GameRules:GetGameModeEntity().unit[team][y..'_'..x] == nil then
		return true
	else
		return false
	end
end

function FindCurrColFarthestCanAttackPosition(u)
	local team_id = u.at_team_id or u.team_id
	local y = u.y
	local i = u.x
	if u.team_id ~= 4 then
		for j=8,1,-1 do
			if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
				for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
					if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() - unit:GetHullRadius() and j>y then
						return XY2Vector(i,j,team_id)
					end
				end
			end
		end
	else
		for j=1,8 do
			if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
				for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
					if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() - unit:GetHullRadius() and j<y then
						return XY2Vector(i,j,team_id)
					end
				end
			end
		end
	end
end

function FindFarthestUnluckyDogAvailablePosition(u)
	local team_id = u.at_team_id or u.team_id
	if u.team_id ~= 4 then
		if RandomInt(0,100) > 50 then
			for j=8,1,-1 do
				for i=8,1,-1 do
					if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsBozangWudi(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		else
			for j=8,1,-1 do
				for i=1,8 do
					if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsBozangWudi(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		end
	else
		if RandomInt(0,100) > 50 then
			for j=1,8 do
				for i=1,8 do
					if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsBozangWudi(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		else
			for j=1,8 do
				for i=8,1,-1 do
					if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsBozangWudi(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		end
	end
	return nil
end



function FindClosestUnluckyDogAvailablePosition(u)
	local team_id = u.at_team_id or u.team_id
	if u.team_id == 4 then
		for j=8,1,-1 do
			for i=8,1,-1 do
				if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
					for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
						if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < 192 then
							return XY2Vector(i,j,team_id)
						end
					end
				end
			end
		end
	else
		for j=1,8 do
			for i=1,8 do
				if GameRules:GetGameModeEntity().unit[team_id][j..'_'..i] == nil then
					for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
						if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < 192 then
							return XY2Vector(i,j,team_id)
						end
					end
				end
			end
		end
	end

	return nil
end

function FindEmptyGridAtUnit(u, front_flag)
	local team_id = u.at_team_id or u.team_id
	if front_flag == nil then
		front_flag = true
	end

	--优先选取面前的空格子
	local forward_v  = u:GetAbsOrigin() + u:GetForwardVector():Normalized()*128
	local forward_x = Vector2X(forward_v,team_id)
	local forward_y = Vector2Y(forward_v,team_id)
	if IsIn8x8(forward_x,forward_y) == true and IsEmptyGrid(team_id,forward_x,forward_y) == true and front_flag == true then
		return XY2Vector(forward_x,forward_y,team_id)
	end

	--遍历身边的格子
	local random1 = RandomInt(0, 1)
	local random2 = 1
	
	if random1 == 0 then
		random1 = -1
	end
	if u.team_id == 4 then
		random2 = -1
	end
	
	for y = 1*random2,-1*random2,-1*random2 do
		for x = -1*random1,1*random1,random1 do
			if IsIn8x8(u.x+x,u.y+y) == true and IsEmptyGrid(team_id,u.x+x,u.y+y) == true then
				return XY2Vector(u.x+x,u.y+y,team_id)
			end
		end
	end

	for xx = -2,2 do
		for yy = -2,2 do
			if IsIn8x8(u.x+xx,u.y+yy) == true and IsEmptyGrid(team_id,u.x+xx,u.y+yy) == true then
				return XY2Vector(u.x+xx,u.y+yy,team_id)
			end
		end
	end

	return nil
end

function FindRandomEmptyGridAtUnit(u)
	local team_id = u.at_team_id or u.team_id
	local try_count = 0
	local p = nil

	while try_count < 100 and p == nil do
		local x = RandomInt(-1, 1)
		local y = RandomInt(-1, 1)
		if IsIn8x8(u.x+x,u.y+y) == true and IsEmptyGrid(team_id,u.x+x,u.y+y) == true then
			p = XY2Vector(u.x+x,u.y+y,team_id)
		end
		try_count = try_count + 1
	end

	return p
end



--通用方法之寻找一个倒霉蛋
function FindUnluckyDog(u)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 10 do
		local uu = GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and not uu:HasAbility('is_ward') then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end

function FindAllyClosest(u)
	local unluckydog = nil
	local length2d = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local pos = unit:GetAbsOrigin()
		if (my_pos - pos):Length2D() < length2d and unit.team_id == u.team_id and unit:entindex() ~= u:entindex() and unit:IsInvisible() == false and IsUnitExist(unit) then
			unluckydog = unit
			length2d = (my_pos - pos):Length2D() 
		end
	end
	return unluckydog
end
function FindAllyRandom(u)
	local unluckydog = nil
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	local try_count = 0 

	while unluckydog == nil and try_count < 10000 do
		local random = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[team]))
		local unit = GameRules:GetGameModeEntity().to_be_destory_list[team][random]
		if unit ~= nil and unit.y_x and unit:IsNull() == false and unit:IsAlive()==true and unit.team_id == u.team_id and unit:IsInvisible() == false and unit:entindex() ~= u:entindex() then
			if unluckydog == nil then
				unluckydog = unit
			end
		end
		try_count = try_count + 1
	end

	return unluckydog
end

function FindWarlockAlly(u)
	local luckydog = nil
	local min_distance = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)

	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local dd = (unit:GetAbsOrigin() - u:GetAbsOrigin()):Length2D()
		if dd < min_distance and unit.team_id == u.team_id and unit:entindex() ~= u:entindex() and unit:HasModifier('modifier_is_warlock_buff_plus_plus') then
			luckydog = unit
			min_distance = dd
		end
	end
	return luckydog
end

function FindHighLevelUnluckyDog(u, is_force_high_level, is_ignore_nomana)
	local unluckydog = nil
	local max_level = 0
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)

	--第二个参数true==强制最高等级并排除被动技能的棋子
	if RandomInt(1,100)<30 and is_force_high_level ~= true then
		--30%概率随机找敌人
		return FindUnluckyDogRandom(u)
	end

	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local lv = unit:GetLevel()
		if unit:GetMaxMana() <= 0 and is_ignore_nomana ~= true then
			lv = 1
		end
		local a = unit.steal_ability or GameRules:GetGameModeEntity().chess_ability_list[unit:GetUnitName()]
		local beh = GameRules:GetGameModeEntity().ability_behavior_list[a]

		if lv > max_level and unit.team_id ~= u.team_id and unit:FindModifierByName("modifier_doom_bringer_doom") == nil and unit:FindModifierByName("modifier_shadow_shaman_voodoo") == nil and unit:FindModifierByName("modifier_lion_voodoo") == nil and (beh ~= 0 or is_force_high_level == true) and unit:HasAbility('is_ward') == false then
			unluckydog = unit
			max_level = lv
		end
	end
	return unluckydog
end
function FindHighLevelLuckyDog(u)
	local luckydog = nil
	local max_level = 0
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)

	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local lv = unit:GetLevel()
		if lv > max_level and unit.team_id == u.team_id and unit:entindex() ~= u:entindex() then
			luckydog = unit
			max_level = lv
		end
	end
	return luckydog
end
function FindUnluckyDogRandom(u)
	local unluckydog = nil
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	local try_count = 0 

	while unluckydog == nil and try_count < 10000 do
		local random = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[team]))
		local unit = GameRules:GetGameModeEntity().to_be_destory_list[team][random]
		if unit ~= nil and unit.y_x and unit:IsNull() == false and unit:IsAlive()==true and unit.team_id ~= u.team_id and unit:IsInvisible() == false then
			if unluckydog == nil then
				unluckydog = unit
			end
		end
		try_count = try_count + 1
	end

	return unluckydog
end
function FindUnluckyDogClosest(u)
	local unluckydog = nil
	local length2d = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local pos = unit:GetAbsOrigin()
		if (my_pos - pos):Length2D() < length2d and unit.team_id ~= u.team_id and unit:IsInvisible() == false and IsUnitExist(unit) then
			unluckydog = unit
			length2d = (my_pos - pos):Length2D() 
		end
	end
	return unluckydog
end
function FindUnluckyDogFarthest(u)
	local unluckydog = nil
	local length2d = 0
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if (u:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D() > length2d and unit.team_id ~= u.team_id and IsUnitExist(unit) and unit:HasAbility('is_ward') == false then
			unluckydog = unit
			length2d = (u:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D() 
		end
	end
	return unluckydog
end
function FindUnluckyDog190(u)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < 205 + u:GetHullRadius() + uu:GetHullRadius() and uu:HasAbility('is_ward') == false then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindUnluckyDog250(u)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < 205 + u:GetHullRadius() + uu:GetHullRadius() then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindUnluckyDogRandomFriend(u,a,need_has_mana)
	if a == nil then
		a = 'ogre_magi_bloodlust'
	end
	local conf_modifier = 'modifier_'..a 
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id == u.team_id and uu:FindModifierByName(conf_modifier) == nil and (need_has_mana ~= true or uu:GetMaxMana() > 0) then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindBestMulticastFriend(u)
	local conf_modifier = 'modifier_om_multi_cast'
	local best_luckydog = nil
	local best_score = -999
	local try_count = 0

	-- if RandomInt(1,100) <= 30 then
	-- 	return FindUnluckyDogRandomFriend(u,'om_multi_cast',true)
	-- end

	for i,v in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if IsUnitExist(v) and v.team_id == u.team_id and v:HasModifier(conf_modifier) == false and v:HasAbility('om_multi_cast') == false and v:HasModifier('modifier_illusion') == false then
			local score = -999
			if v:GetMaxMana() > 0 then
				score = v:GetLevel() - GetChessAbilityCD(v)
			end
			-- print(v:GetUnitName()..'='..score)
			if score > best_score then
				best_luckydog = v
				best_score = score
			end
		end
	end

	return best_luckydog
end

function FindHighestCostAlly(u)
	local dog = nil
	local cost_max = 0
	local try_count = 0
	for i,v in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local b_name = GetUnitBaseName(v)
		local cost = GameRules:GetGameModeEntity().chess_2_mana[b_name]
		if b_name ~= 'chess_chen' and v.team_id == u.team_id and cost > cost_max and v:FindModifierByName('modifier_chen_fuhuo') == nil then
			dog = v
			cost_max = cost
		end
	end
	return dog
end
function FindNeedShieldFriend(u)
	--寻找最需要护盾的目标，不满血但血量较多的优先
	local unluckydog = u
	local hp_per = 100
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id == u.team_id and unit:HasAbility('is_ward') == false then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100
			
			if per > 50 then
				per = per - 50
			else
				per = 50 - per
			end

			if per < hp_per then
				unluckydog = unit
				hp_per = per
			end
		end
	end
	return unluckydog
end
--为暗牧寻找目标
function FindShallowGraveFriend(u)
	local unluckydog = u
	local hp_per = 101
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id == u.team_id then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100

			if per < hp_per and unit:FindModifierByName('modifier_dazzle_shallow_grave') == nil and unit.is_youhun ~= true and unit:HasModifier("modifier_illusion") == false and unit:HasAbility('is_ward') == false then
				unluckydog = unit
				hp_per = per
			end
		end
	end
	if hp_per > 50 then
		return nil
	else
		return unluckydog
	end
end
function FindShallowGraveFriendInner(u)
	local unluckydog = u
	local hp_per = 101
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id == u.team_id then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100

			if per < hp_per and unit:FindModifierByName('modifier_dazzle_shallow_grave') == nil and unit:HasAbility('is_ward') == false then
				unluckydog = unit
				hp_per = per
			end
		end
	end
	return unluckydog
end
--为全能寻找目标
function FindPurificationFriend(u)
	local unluckydog = nil
	local check_score = 101
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id == u.team_id and unit:HasAbility('is_ward') == false then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100
			local enemy_around = FindUnitsInRadiusByTeam({
				team = unit.team_id,
				role = 2,
				position = unit:GetAbsOrigin(),
				radius = 260,
			})
			local score = per - table.maxn(enemy_around)*30
			if score < check_score then
				unluckydog = unit
				check_score = score
			end
		end
	end
	return unluckydog
end
--为TB换血寻找最佳队友
function FindBestSunderFriend(u)
	local unluckydog = u
	local hp_per_best = 0
	local hp_best = 0
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id == u.team_id and unit:entindex() ~= u:entindex() and unit:HasAbility('is_ward') == false then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100

			if per > hp_per_best then
				unluckydog = unit
				hp_per_best = per
				hp_best = hp
			end
			if per == hp_per_best and hp < hp_best then
				unluckydog = unit
				hp_per_best = per
				hp_best = hp
			end
		end
	end
	return unluckydog
end

--沙王用：寻找一个最远的能打到敌人的离我最远的格子，（戳过去！）
function FindFarthestCanAttackEnemyEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local length2d = 0
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			if IsEmptyGrid(team_id,x,y) and IsGridCanAttackEnemy(x,y,u) == true then
				if (pos2-pos1):Length2D() > length2d then
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end
function FindRandomCanAttackEnemyEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil
	local try_count = 0

	while try_count < 100 do
		x = RandomInt(1,8)
		y = RandomInt(1,8)
		local pos2 = XY2Vector(x,y,team_id)
		if IsEmptyGrid(team_id,x,y) and IsGridCanAttackEnemy(x,y,u) == true then
			skip_postion = pos2
			return skip_postion
		end
		try_count = try_count + 1
	end

	return nil
end

function FindClosestEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local length2d = 9999
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			if IsEmptyGrid(team_id,x,y) == true then
				if (pos2-pos1):Length2D() < length2d then
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end

function FindUnluckyPoint(u)
	local p = nil
	local try_count = 0
	local team_id = u.at_team_id or u.team_id
	local x = nil
	local y = nil
	while p==nil and try_count<100 do
		if RandomInt(0,100)>50 then
			if RandomInt(0,100)>50 then
				x = 1
				y = RandomInt(1,8)
			else
				x = 8
				y = RandomInt(1,8)
			end
		else
			if RandomInt(0,100)>50 then
				y = 1
				x = RandomInt(1,8)
			else
				y = 8
				x = RandomInt(1,8)
			end
		end
		if GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] == nil then
			if (XY2Vector(x,y,team_id) - u:GetAbsOrigin()):Length2D() > 256 then
				p = XY2Vector(x,y,team_id)
			end
		end

		try_count = try_count + 1
	end
	return p
end

function FindRandomEmptyGrid(u)
	local p = nil
	local try_count = 0
	local team_id = u.at_team_id or u.team_id
	local x = nil
	local y = nil
	while p==nil and try_count<100 do
		x = RandomInt(1,8)
		y = RandomInt(1,8)
		if GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] == nil then
			if (XY2Vector(x,y,team_id) - u:GetAbsOrigin()):Length2D() < 200 then
				p = XY2Vector(x,y,team_id)
			end
		end
		try_count = try_count + 1
	end
	return p
end

--通用方法之坐标系转换
function HandIndex2Vector(team_id,index)
	return GameRules:GetGameModeEntity().base_vector[team_id] + Vector((index-1)*128,-2*128,256)
end

function XY2Vector(x,y,team_id)
	return GameRules:GetGameModeEntity().base_vector[team_id] + Vector((x-1)*128,(y-1)*128,256)
end
function Vector2X(v,team_id)
	if v == nil or team_id == nil then
		return nil
	end
	local relative_position = v - GameRules:GetGameModeEntity().base_vector[team_id]
	local x = math.floor((relative_position.x+192)/128)
	-- if x < 1 or x > 8 then
	-- 	x = -1
	-- end
	return x
end
function Vector2Y(v,team_id)
	if GameRules:GetGameModeEntity().base_vector[team_id] == nil then
		return -1
	end
	local relative_position = v - GameRules:GetGameModeEntity().base_vector[team_id]
	local y = math.floor((relative_position.y+192)/128)
	-- if y < 1 or y > 8 then
	-- 	y = -1
	-- end
	return y
end
function CenterVector(team_id)
	return GameRules:GetGameModeEntity().base_vector[team_id] + Vector(3.5*128,2.5*128,0)
end
--通用方法之位置判断
function IsInMap(x,y)
	--格子是否在防守场地
	if x<1 or x>8 or y<1 or y>4 then
		return false
	else
		return true
	end
end
function IsInDefendArea(x,y)
	if x>=1 and x<=8 and y>=1 and y<=4 then
		return true
	else
		return false
	end
end
function IsInAttackArea(x,y)
	--格子是否在进攻场地
	if x>=1 and x<=8 and y>=5 and y<=8 then
		return true
	else
		return false
	end
end
function IsIn8x8(x,y)
	if x>=1 and x<=8 and y>=1 and y<=8 then
		return true
	else
		return false
	end
end
function GetClosestAvailableArea(x,y,team_id)
	local returnx = x
	local returny = y
	if y>4 then
		returny = 4
	elseif y<1 then
		returny = 1
	end
	if x>8 then
		returnx = 8
	elseif x<1 then
		returnx = 1
	end
	return {x = returnx, y =returny}
end
function GetClosestEmptyArea(x,y,team_id)
	for i=-1,1 do
		for j=-1,1 do
			if IsBlocked(x+i,y+j,team_id) == false then
				return {x = x+i, y = y+j}
			end
		end
	end
	return nil
end
function GetClosestEmptyHandIndex(index,team_id)
	local hero = TeamId2Hero(team_id)
	for _,i in pairs({0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7}) do
		if index+i >= 1 and index+i <= 8 and hero.hand_entities[index+i] == nil then
			return index+i
		end
	end
	return nil
end
function IsBlocked(x,y,team_id)
	if IsInMap(x,y) == false then
		return "map"
	end
	if GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] ~= nil then
		return "unit"
	end
	return false
end

--TK：热导飞弹
function RandomMissileStart(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()

	--三连发
	RandomMissileOne({ caster = keys.caster, ability = keys.ability })
	Timers:CreateTimer(0.3,function()
		RandomMissileOne({ caster = keys.caster, ability = keys.ability })
		Timers:CreateTimer(0.3,function()
			RandomMissileOne({ caster = keys.caster, ability = keys.ability })
			if ability_level >= 3 then
				Timers:CreateTimer(0.3,function()
					RandomMissileOne({ caster = keys.caster, ability = keys.ability })
				end)
			end
		end)
	end)
end
function RandomMissileOne(keys)
	--对一个随机的unluckydog发射导弹
	local unlucky_dog = FindUnluckyDog(keys.caster)
	if unlucky_dog ~= nil then
		if (unlucky_dog:GetAbsOrigin() - keys.caster:GetAbsOrigin()):Length2D() < 1500 then
		    ProjectileManager:CreateTrackingProjectile({
		        Target = unlucky_dog,
		        Source = keys.caster,
		        Ability = keys.ability,
		        EffectName = "particles/units/heroes/hero_tinker/tinker_missile.vpcf",
		        bDodgeable = false,
		        iMoveSpeed = 500,
		        bProvidesVision = false,
		        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
		    })
		    EmitSoundOn("Hero_Tinker.Heat-Seeking_Missile",caster)
		end
	end
end
function RandomMissileDamage(keys)
	--导弹伤害
	if keys.target:IsMagicImmune() == false then
	    ApplyDamage({
	    	victim = keys.target,
	    	attacker = keys.caster,
	    	damage_type = DAMAGE_TYPE_MAGICAL,
	    	damage = keys.damage_per_missile
	    })
	end
    EmitSoundOn("Hero_Rattletrap.Rocket_Flare.Explode",keys.target)
    play_particle("particles/units/heroes/hero_gyrocopter/gyro_guided_missile_explosion.vpcf",PATTACH_OVERHEAD_FOLLOW,keys.target,3)
end

--通用方法之添加技能
function AddAbilityAndSetLevel(u,a,l)
	if l == nil then
		l = 1
	end
	if u == nil or u:IsNull() == true then
		return
	end
	if u:FindAbilityByName(a) == nil then
		u:AddAbility(a)
		if u:FindAbilityByName(a) ~= nil then
			u:FindAbilityByName(a):SetLevel(l)
		end
	else
		u:FindAbilityByName(a):SetLevel(l)
	end
end
function RemoveAbilityAndModifier(u,a)
	if u == nil or u:IsNull() == true then
		return
	end
	if u:FindAbilityByName(a) ~= nil then
		u:RemoveAbility(a)
		u:RemoveModifierByName('modifier_'..a)
	end
end
function RemoveFromToBeDestroyList(u)
	if (u.at_team_id or u.team_id) ~= nil and GameRules:GetGameModeEntity().to_be_destory_list[(u.at_team_id or u.team_id)] ~= nil then
		for p,q in pairs(GameRules:GetGameModeEntity().to_be_destory_list[(u.at_team_id or u.team_id)]) do
			if u ~= nil and u:IsNull() == false and q ~= nil and q:IsNull() == false then
				if q:entindex() == u:entindex() then
					table.remove(GameRules:GetGameModeEntity().to_be_destory_list[(u.at_team_id or u.team_id)],p)
				end
			end
		end
	end
end
function prt(t)
	-- GameRules:SendCustomMessage(''..t,0,0)
	CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
		player_id = nil,
		text = ''..t,
		time_stamp = math.floor(GameRules:GetGameTime()),
		type = 'common',
	})
end
function combat(t)
	CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
		type = 'common',
		text = t,
		time_stamp = math.floor(GameRules:GetGameTime()),
	})	
end
function debugg(t)
	if GameRules:GetGameModeEntity().is_debug == true then
		GameRules:SendCustomMessage(''..t,0,0)
	end
end
function unit2text(u)
	local id1 = u.team_id or 'X'
	local id2 = u.at_team_id or 'X'
	return ''..id1..'-'..id2..'的'..u:GetUnitName()
end
function AttackHeal(keys)
	local target = keys.attacker
	local damage = keys.damage
	local per = keys.per
	target:Heal(damage*per, target)
end
function ModMaxHP(keys)
	local caster = keys.caster
	local is_heal = keys.is_heal or false
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		--信使无效，守卫无效
		return
	end

	if not caster.hp_basic then
		caster.hp_basic = caster:GetMaxHealth()
	end

	local per = tonumber(keys.per or 0)
	local const = tonumber(keys.const or 0)
	caster.hp_per = tonumber(caster.hp_per or 0) + per
	caster.hp_const = tonumber(caster.hp_const or 0) + const

	local hp_result_max = math.floor(caster.hp_basic*(100+caster.hp_per)/100 + caster.hp_const)
	

	if is_heal == true then
		local heal = hp_result_max - caster:GetMaxHealth()
		caster:SetBaseMaxHealth(hp_result_max)
		caster:SetMaxHealth(hp_result_max)

		caster:Heal(heal, caster)
	else
		local hp_per_now = caster:GetHealth()/caster:GetMaxHealth()
		caster:SetBaseMaxHealth(hp_result_max)
		caster:SetMaxHealth(hp_result_max)
		local hp_result = hp_result_max * hp_per_now
		caster:SetHealth(hp_result)
	end
	
end
function AddMaxHPPer(keys)
	local caster = keys.caster
	local per = keys.per
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		return
	end

	local hp = caster:GetMaxHealth()
	local hp_final = hp * ((100 + tonumber(per))/100)
	local heal = hp*tonumber(per)/100
	caster:SetBaseMaxHealth(hp_final)
	caster:SetMaxHealth(hp_final)
	-- caster:SetHealth(hp*hp_per)
	caster:Heal(heal, caster)
end
function AddMaxHP(keys)
	local caster = keys.caster
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		return
	end
	local hp = keys.hp
	local hp1 = caster:GetMaxHealth()
	local hp_per = caster:GetHealth()/caster:GetMaxHealth()
	local hp1 = hp1 + tonumber(hp)
	caster:SetBaseMaxHealth(hp1)
	caster:SetMaxHealth(hp1)
	caster:SetHealth(hp1*hp_per)
end
function UnAddMaxHP(keys)
	local caster = keys.caster
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		return
	end
	local hp = keys.hp
	local hp1 = caster:GetMaxHealth()
	local hp_per = caster:GetHealth()/caster:GetMaxHealth()
	local hp1 = hp1 - tonumber(hp)
	caster:SetBaseMaxHealth(hp1)
	caster:SetMaxHealth(hp1)
	caster:SetHealth(hp1*hp_per)
end
function Bump(keys)
	local p = keys.target_points[1]
	local caster = keys.caster
	local team_id = caster.at_team_id or caster.team_id
	local position = p

	GameRules:GetGameModeEntity().unit[team_id][caster.y_x] = nil
	GameRules:GetGameModeEntity().unit[team_id][Vector2Y(position,team_id)..'_'..Vector2X(position,team_id)] = 1
	InvisibleUnitCast({
		caster = caster,
		ability = 'sandking_burrowstrike',
		level = 1,
		unluckydog = nil,
		position = position,
	})

	Timers:CreateTimer(0.3,function()
		caster:SetAbsOrigin(position)
	end)
end
--辅助功能——创建隐藏单位施法
function InvisibleUnitCast(keys)
	local shiban = keys.caster
	local caster_position = keys.caster_position
	local shiban_ability = keys.ability
	local ability_level = keys.level
	local unluckydog = keys.unluckydog
	local position = keys.position
	local team = DOTA_TEAM_NEUTRALS
	if shiban ~= nil then
		team = shiban:GetTeam()
	end

	local uu = CreateUnitByName("invisible_unit", caster_position or shiban:GetAbsOrigin() ,false,nil,nil, team) 
	-- uu:FollowEntity(shiban,true)
	uu.ftd = 2009
	uu:SetOwner(shiban)
	uu.damage_owner = shiban
	uu.ignore_nether_ward = keys.ignore_nether_ward or false -- 获取是否无视啄木鸟图腾，默认为否
	uu.team_id = shiban.team_id
	uu.at_team_id = shiban.at_team_id

	uu:AddAbility(shiban_ability)
	uu:FindAbilityByName(shiban_ability):SetLevel(ability_level)

	Add2InvisibleUnitTable(shiban,uu)
	Timers:CreateTimer(0.05,function()
		if keys.force_unluckydog then
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
		 		TargetIndex = keys.force_unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
			uu.cast_target = keys.force_unluckydog
		elseif uu:FindAbilityByName(shiban_ability):GetBehavior() == DOTA_ABILITY_BEHAVIOR_UNIT_TARGET and unluckydog ~= nil then
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
		 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
			uu.cast_target = unluckydog
		elseif uu:FindAbilityByName(shiban_ability):GetBehavior() == DOTA_ABILITY_BEHAVIOR_NO_TARGET then
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
		 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
		else
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
		 		TargetIndex = nil, --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = position, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
		end
		Timers:CreateTimer(10,function()
			if IsUnitExist(uu) == true then -- 销毁隐藏单位前做一个判断，避免一些报错
				uu:ForceKill(false)
				uu:Destroy()
			end
		end)
	end)

	-- 如果是复制缚魂施法，则添加对主施法者和主目标的状态监听
	-- 之前这一块被放在上一个 Timer 之中，似乎有一些问题，现在就挪出来了
	if keys.origin_unluckydog ~= nil then 
		Timers:CreateTimer(0.5,function()
			-- 针对持续施法技能。监听主人的状态，如果异常了，就中断
			if IsUnitExist(uu) == false then
				return
			end
			-- 判断主施法者是否存在、主施法者是否能够施法、主目标是否存活。若任意为否则终止终止隐藏单位施法。
			if IsUnitExist(shiban) == false or IsUnitAbleToCast(shiban) == false or keys.origin_unluckydog:IsAlive() == false then
				uu:Stop()
				uu:ForceKill(false)
				-- uu:Destroy() -- 之前的代码中有 Destroy。经测试，如果紧跟 Destroy，会造成视觉特效消失但实际控制效果仍在的问题。这里先注释掉了。
				return
			end
			return 0.5
		end)
	end
end

function Add2InvisibleUnitTable(u,i)
	if IsUnitExist(u) == false then
		return
	end
	if u.invisible_unit == nil then
		u.invisible_unit = {}
	end
	table.insert(u.invisible_unit, i)
end
function RemoveInvisibleUnitTable(u)
	if IsUnitExist(u) == false then
		return
	end
	if u.invisible_unit == nil then
		return
	end
	for _,v in pairs(u.invisible_unit) do
		if IsUnitExist(v) == true then
			v:Stop()
			v:ForceKill(false)
			v:Destroy()
		end
	end
	u.invisible_unit = {}
end


function PlayerId2Hero(id)
	return GameRules:GetGameModeEntity().playerid2hero[id]
end
function TeamId2Hero(id)
	if id == nil then
		return nil
	else
		return GameRules:GetGameModeEntity().teamid2hero[id]
	end
end
function GetMaxChessCount(team)
	if TeamId2Hero(team) ~= nil then
		return TeamId2Hero(team):GetLevel()
	else
		return 1
	end
end
function GetStat(id,prop)
	local hero =  PlayerId2Hero(id)
	if hero == nil or hero.steam_id == nil then
		return nil
	end
	return GameRules:GetGameModeEntity().stat_info[hero.steam_id][prop]
end
function SetStat(id,prop,v,need_update_ui)
	if id == nil then 
		return
	end
	local hero =  PlayerId2Hero(id)
	if hero == nil or hero.steam_id == nil then
		return
	end
	GameRules:GetGameModeEntity().stat_info[hero.steam_id][prop] = v
	if need_update_ui ~= false then
		UpdateStatUI()
	end
end
function AddStat(id,prop,amount)
	local hero =  PlayerId2Hero(id)
	if hero == nil or hero.steam_id == nil then
		return
	end
	if amount == nil then
		amount = 1
	end
	GameRules:GetGameModeEntity().stat_info[hero.steam_id][prop] = GameRules:GetGameModeEntity().stat_info[hero.steam_id][prop] + amount
	if prop == 'hero_damage' then
		PlayerResource:IncrementLastHits(id)
	end
	if prop == 'hero_damaged' then
		PlayerResource:IncrementDenies(id)
	end

	if prop == 'win_round' then
		PlayerResource:IncrementKills(id,1)
	end
	if prop == 'lose_round' then
		PlayerResource:IncrementDeaths(id,1)
	end
	if prop == 'draw_round' then
		PlayerResource:IncrementAssists(id,1)
	end

	UpdateStatUI()
end


function StartGame()

	-- Timers:CreateTimer(3,function()
	-- 	print('=====================1111111111==================')
	-- 	DOTA_SpawnMapAtPosition('chessboard/chessboard01', Vector(-2048.2048,0), false,
 --            Dynamic_Wrap(DAC, "OnRoomReadyToSpawn"),
 --            Dynamic_Wrap(DAC, "OnSpawnRoomComplete"), self)
	-- end)
	
	for i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(i,"start_game",{
			key = GetClientKey(i),
			hehe = RandomInt(1,100000),
		})
	end
	Timers:CreateTimer(function()
	    for i=6,13 do
	    	local h1 = TeamId2Hero(i)
	    	if h1 ~= nil and h1:IsNull() == false then
	    		if IsUnitExist(h1) == true then
		    		AddFOWViewer(i, Entities:FindByName(nil,"center"..(i-6)):GetOrigin(), 1000, 3, true)
		    	end
		    	local open_fog = GameRules:GetGameModeEntity().user_setting[h1.steam_id]['is_fog_show']
	    		if open_fog and tonumber(open_fog) ~= 1 then
			    	for j=0,11 do
			    		local hero = TeamId2Hero(j+6)
			    		if hero ~= nil and IsUnitExist(hero) == true then
				    		AddFOWViewer(i, Entities:FindByName(nil,"center"..j):GetOrigin(), 1000, 3, false)
				    	end
				    end
				end
	    	end
		end
		return 2
	end)
	--5秒后开始游戏
	Timers:CreateTimer(5,function()
		if GameRules:GetGameModeEntity().playing_player_count == 1 then
			prt('tips_1_player')
		else
			prt('GAME START!')
		end

		--初始化棋子库
		InitChessPool(GameRules:GetGameModeEntity().playing_player_count)

		EnableBanChess()

    	GameRules:GetGameModeEntity().START_TIME = GameRules:GetGameTime()
		StartAPrepareRound()
    end)
end

function EnableBanChess()
	for team_i=6,13 do
		local hh = TeamId2Hero(team_i)
		if IsUnitExist(hh) and hh:FindAbilityByName('ban_chess') ~= nil then
			hh:FindAbilityByName('ban_chess'):SetHidden(false)
			hh:FindAbilityByName('ban_chess'):SetActivated(true)
		end
	end
end

function GameOver()
	GameRules:GetGameModeEntity().is_game_ended = true
	if GameRules:GetGameModeEntity().ended == false then
		CustomNetTables:SetTableValue( "dac_table", "curtain_tips", { text = "#gameover", hehe = RandomInt(1,1000)})
		CustomNetTables:SetTableValue( "dac_table", "game_over", { text = "#gameover", hehe = RandomInt(1,1000)})

		local win_team = 2
		if GameRules:GetGameModeEntity().good_castle.hp > 0 then
			win_team = 2
		end
		if GameRules:GetGameModeEntity().bad_castle.hp > 0 then
			win_team = 3
		end

		for i,v in pairs(GameRules:GetGameModeEntity().hero) do
			if v.team == win_team then
				v:AddAbility('gameover_win')
				v:FindAbilityByName('gameover_win'):SetLevel(1)
			else
				v:AddAbility('gameover_lose')
				v:FindAbilityByName('gameover_lose'):SetLevel(1)
			end
		end

		GameRules:GetGameModeEntity().ended = true
		-- EmitGlobalSound("Loot_Drop_Stinger_Arcana")

		GameRules:SendCustomMessage('gameover',0,0)

		Timers:CreateTimer(2,function()
			CalScore()
		end)
	end
end


--通过聊天输入执行命令
function DAC:OnPlayerChat(keys)
	
	local player = GameRules:GetGameModeEntity().userid2player[keys.userid]
	local hero = EntIndexToHScript(player):GetAssignedHero()
	if hero == nil then
		return
	end
	local heroindex = hero:GetEntityIndex()
	local team = hero:GetTeam()
	local tokens =  string.split(string.lower(keys.text))

	if (
		tokens[1] == "-lvlup" or
		tokens[1] == "-createhero" or
		tokens[1] == "-item" or
		tokens[1] == "-refresh" or
		tokens[1] == "-startgame" or 
		tokens[1] == "-killcreeps" or
		tokens[1] == "-wtf" or 
		tokens[1] == "-disablecreepspawn" or
		tokens[1] == "-gold" or 
		tokens[1] == "-lvlup" or
		tokens[1] == "-refresh" or
		tokens[1] == "-respawn" or
		tokens[1] == "dota_create_unit" or 
		tokens[1] == "-teleport" or 
		tokens[1] == "-ggsimida"
		) then
		if IsUnitExist(hero) == true then
			KillSelfTeam(team)
		end
		return
	end
	if string.find(keys.text,"^%w%w%w%w%w%p%w%w%w%w%w%p%w%w%w%w%w$") ~= nil then
		local key = string.upper(keys.text)
		local steamid = EntIndexToHScript(heroindex).steam_id
		CustomNetTables:SetTableValue( "dac_table", "cdkey", {
			player_id = player,
			steam_id = steamid,
			text = key,
			hehe = RandomInt(1,10000)
		})
		return
	end
	if tokens[1] == '-tp' then
		local p = Entities:FindByName(nil,'center'..(team-6)):GetAbsOrigin()
		hero:SetAbsOrigin(p)
	end
	if tokens[1] == '-cp' and GameRules:GetGameModeEntity().myself == true then
		CourierCP(hero,hero)
	end

	--测试命令
	if string.find(keys.text,"^e%w%w%w$") ~= nil and GameRules:GetGameModeEntity().myself == true then
		if hero.effect ~= nil then
			hero:RemoveAbility(hero.effect)
			hero:RemoveModifierByName('modifier_texiao_star')
		end
		hero:AddAbility(keys.text)
		hero:FindAbilityByName(keys.text):SetLevel(1)
		hero.effect = keys.text
	end

	if (tokens[1] == '-crab' or tokens[1] == '-chess') and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: +CHESSES')
		if tokens[2] ~= nil and tokens[3] == nil then
			GameRules:GetGameModeEntity().next_crab = 'chess_'..tokens[2]
			prt(GameRules:GetGameModeEntity().next_crab)
			for i=1,3 do
				local x = nil
				local this_chess = nil
				if i == 1 then
					this_chess = GameRules:GetGameModeEntity().next_crab
				elseif i == 2 then
					this_chess = GameRules:GetGameModeEntity().next_crab..'1'
				elseif i == 3 then
					this_chess = GameRules:GetGameModeEntity().next_crab..'11'
				end
				CreateChessInHand(hero,this_chess)
			end
			GameRules:GetGameModeEntity().next_crab = nil
		else
			
			local u_index = 2
			while tokens[u_index] ~= nil and u_index <= 9 do
				prt('chess_'..tokens[u_index])
				CreateChessInHand(hero,'chess_'..tokens[u_index])
				u_index = u_index + 1
			end
			GameRules:GetGameModeEntity().next_crab = nil
		end
	end
	if (tokens[1] == '-drop' or tokens[1] == '-item') and GameRules:GetGameModeEntity().myself == true then
		local u_index = 2
		prt('TEST CODE: +ITEM')
		-- while tokens[u_index] ~= nil and u_index <= 9 do
			local i = 'item_'..tokens[u_index]
			prt(i)
			local newItem = CreateItem( i, hero, hero )
			local drop = CreateItemOnPositionForLaunch(hero:GetAbsOrigin(), newItem )
			local dropRadius = RandomFloat( 50, 200 )
			newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, hero:GetAbsOrigin()+RandomVector(dropRadius))
		-- end
	end
	if (tokens[1] == "-choose" or tokens[1] == '-round') and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: ROUND = '..tokens[2] )
		GameRules:GetGameModeEntity().battle_round = tonumber(tokens[2])
		CustomNetTables:SetTableValue( "game_info", "round_info", { round = GameRules:GetGameModeEntity().battle_round } )
	end
	if (tokens[1] == '-mana' or tokens[1] == '-money') and GameRules:GetGameModeEntity().myself == true then
		local gold = tonumber(tokens[2] or 100) 
		prt('TEST CODE: +'..gold..' GOLD')
		AddMana(hero, gold)
		AddTotalMoneyStat(hero:GetPlayerID(), gold)
	end
	if tokens[1] == '-exp' and GameRules:GetGameModeEntity().myself == true then
		local exp = tonumber(tokens[2] or 9999) 
		prt('TEST CODE: +'..exp..' EXP')
		ExpBook({
			caster = hero,
			xpadd = exp
		})
	end
	
	if tokens[1] == '-ws' and GameRules:GetGameModeEntity().myself == true then
		local win_count = tonumber(tokens[2] or '1')
		prt('TEST CODE: +'..win_count..' WIN STREAK')
		for i=1,win_count do
			AddWinStreak(hero:GetTeam())
		end
	end
	if tokens[1] == "-a" and GameRules:GetGameModeEntity().myself == true then
		local level = tonumber(tokens[3]) or 3
		prt('TEST CODE: +ABILITY '..tokens[2]..', LEVEL = '..level)
		hero:AddAbility(tokens[2])
		hero:FindAbilityByName(tokens[2]):SetLevel(level)
	end
	if tokens[1] == "-n" and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: +ANIMATION '..tokens[2])
		prt('#'..tokens[2])
		hero.animation = tokens[2]
	end
	if tokens[1] == "-effect" and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: +EFFECT '..tokens[2])
		play_particle(tokens[2],PATTACH_ABSORIGIN_FOLLOW,hero,5)
	end
	if tokens[1] == "-hero" and GameRules:GetGameModeEntity().myself == true then
		--装饰信使
		SetCourier(hero, tokens[2], 'e000')

		hero.onduty_hero = tokens[2]
		hero.courier_name = tokens[2]
		prt('TEST CODE: COURIER = '..tokens[2])
		RemoveAbilityAndModifier(hero,'courier_fly')
		if hero.flyup_effect ~= nil then
			ParticleManager:DestroyParticle(hero.flyup_effect,true)
		end
	end
	if tokens[1] == "-size" and GameRules:GetGameModeEntity().myself == true then
		hero.init_model_scale = tokens[2]+0
		hero:SetModelScale(hero.init_model_scale)
		prt('TEST CODE: COURIER SIZE = '..tokens[2])
	end
	if tokens[1] == "-crown" and GameRules:GetGameModeEntity().myself == true then
		local crown_level = tonumber(tokens[2] or 1)
		prt('TEST CODE: CROWN = '..crown_level)
		hero.is_crown = true
		ShowCrown(hero,crown_level)
	end
	if tokens[1] == "-miss" and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: MISS')
		ShowMiss({caster = hero})
	end
	if tokens[1] == "-fish" and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: FISH')
		Fish(hero)
	end
	if tokens[1] == "-roll" and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: ROLL')
		local x = tonumber(tokens[2]) or 0
		local y = tonumber(tokens[3]) or 0
		RollAStone(hero,hero:GetTeam(),x,y,1)
	end

	
	if tokens[1] == "-2p" and GameRules:GetGameModeEntity().myself == true then
		GameRules:GetGameModeEntity().p2_mode = true
		prt('TEST CODE: 2P MODE')
		SetP2Team(6,1)
		SetP2Team(7,1)
		SetP2Team(8,2)
		SetP2Team(9,2)
		SetP2Team(10,3)
		SetP2Team(11,3)
		SetP2Team(12,4)
		SetP2Team(13,4)
	end
	if tokens[1] == "-1p" and GameRules:GetGameModeEntity().myself == true then
		GameRules:GetGameModeEntity().p2_mode = false
		prt('TEST CODE: 1P MODE')
		SetP2Team(6,1)
		SetP2Team(7,1)
		SetP2Team(8,2)
		SetP2Team(9,2)
		SetP2Team(10,3)
		SetP2Team(11,3)
		SetP2Team(12,4)
		SetP2Team(13,4)
	end
	if tokens[1] == '-damage' and GetPlayingPlayerCount() == 1 then
		prt('TEST CODE: SHOW DAMAGE')
		GameRules:GetGameModeEntity().show_damage = true
	end
	if tokens[1] == '-undamage' and GetPlayingPlayerCount() == 1 then
		prt('TEST CODE: HIDE DAMAGE')
		GameRules:GetGameModeEntity().show_damage = false
	end
	if tokens[1] == '-debug' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: DEBUG ON!')
		GameRules:GetGameModeEntity().is_debug = true
	end
	if tokens[1] == '-gaussrandom' and GameRules:GetGameModeEntity().myself == true then
		for i = 1,100 do
			local ran = GaussRandom()
			print(ran)
		end
	end
	if tokens[1] == '-undebug' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: DEBUG OFF!')
		GameRules:GetGameModeEntity().is_debug = false
	end
	if tokens[1] == '-pause' and GameRules:GetGameModeEntity().myself == true then
		PauseGame(not GameRules:IsGamePaused())
	end
	if tokens[1] == '-star' and GameRules:GetGameModeEntity().myself == true then
		ShowStarsOnAllChess(hero:GetTeam())
	end
	if tokens[1] == '-test_end' and GameRules:GetGameModeEntity().myself == true then
		GameRules:GetGameModeEntity().stat_info = json.decode('{"76561198090931971":{"mmr_level":15,"zhugong_model":"models/bilibilitv/model/tv.vmdl","lose_round":0,"hp":0,"win_round":0,"round":1,"hero_level":0,"chess_lineup":"chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_lc11,","player_id":0,"duration":11.233161926269531,"p2team":1,"hero_damage":0,"is_vip":1,"kills":0,"is_author":1,"buff":"is_warrior:1,is_element:1,","zhugong":"h341","deaths":0,"gold":1,"candy":0,"biscuit":1,"zhugong_effect":"e000","draw_round":0,"steamid":"76561198090931971"},"76561198101849234":{"mmr_level":15,"zhugong_model":"models/bilibilitv/model/tv.vmdl","lose_round":0,"hp":0,"win_round":0,"round":1,"hero_level":0,"chess_lineup":"chess_tiny,","player_id":0,"duration":11.233161926269531,"p2team":1,"hero_damage":0,"is_vip":1,"kills":0,"is_author":1,"buff":"is_warrior:1,is_element:1,","zhugong":"h341","deaths":0,"gold":1,"biscuit":0,"candy":12,"zhugong_effect":"e000","draw_round":0,"steamid":"76561198101849234"}}')
		PostGame()
		prt('TEST CODE: END GAME!')

		GameRules:GetGameModeEntity().is_game_ended = true
		prt('GAME OVER')

		Timers:CreateTimer(3,function()
			GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)	
		end)
	end
	if tokens[1] == '-test_dropmoney' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: DROP MONEY x'..( tonumber(tokens[2]) or 1 ))

		DropMoneyBag(hero:GetAbsOrigin(), hero:GetAbsOrigin(), 300, ( tonumber(tokens[2]) or 1 ))
	end
	if tokens[1] == '-test_cheer' and GameRules:GetGameModeEntity().myself == true then
		-- local cheer_index = tonumber(tokens[2]) or FindAvailableCheerIndex(hero:GetTeam())
		-- local courier_name = tokens[3] or RandomACourierFromCourierTable(hero:GetTeam())
		-- if courier_id ~= nil then
		-- 	prt('TEST CODE: CHEER COURIER at '..cheer_index..' --> '..courier_id)
		-- 	SpawnCheerCourier(hero:GetTeam(), cheer_index, courier_name)
		-- else
		-- 	prt('TEST CODE: NO AVAILABLE CHEER COURIER!')
		-- end
		prt('TEST CODE: CHEER COURIER')
		SummonCheerCourier(hero:GetTeam(), tonumber(tokens[2]) or 1)
	end

	if tokens[1] == '-remove_cheer' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: REMOVE CHEER COURIER')
		RemoveCheerCourier(hero:GetTeam(), tonumber(tokens[2]) or nil)
	end

	if tokens[1] == '-test_cheer_bubble' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: CHEER COURIER BUBBLE')
		-- local cheer_courier = GetCheerCourier(hero:GetTeam())
		-- CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
		-- 	unit_index = cheer_courier:entindex(),
		-- 	text = "hahahaha",
		-- })
		SayCheerBubble(hero:GetTeam())
	end

	if tokens[1] == '-show_cheer' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: SHOW COURIER('..table.maxn(hero.courier_table or {})..')')
		print('--------------------------------------')
		print('COURIER('..table.maxn(hero.courier_table or {})..')')
		if hero.courier_table ~= nil then
			for _,v in pairs(hero.courier_table) do
				print(v)
			end
		end
		print('--------------------------------------')
		print('CHEER COURIER')
		if hero.cheer_courier_list ~= nil then
			for i,v in pairs(hero.cheer_courier_list) do
				print('['..i..'] = '..v.courier_name)
			end
		end
		print('--------------------------------------')
	end

	-- if tokens[1] == '-test_guancaiben' and GameRules:GetGameModeEntity().myself == true then
	-- 	local try_count = 0
	-- 	local alive_player_count = GetAlivePlayerCount()
	-- 	local guancai_money = math.floor(hero:GetMana()*(alive_player_count*10)/100)
	-- 	local lucky_team_table = {
	-- 		[6] = 0,
	-- 		[7] = 0,
	-- 		[8] = 0,
	-- 		[9] = 0,
	-- 		[10] = 0,
	-- 		[11] = 0,
	-- 		[12] = 0,
	-- 		[13] = 0,
	-- 	}
	-- 	local money_left = ( tonumber(tokens[2]) or 100 )
	-- 	while try_count < 10000 and money_left > 0 do 
	-- 		local random_team = RandomInt(6,13)
	-- 		local h = TeamId2Hero(random_team)
	-- 		if h ~= nil and h:IsAlive() == true then --and random_team ~= hero:GetTeam() then
	-- 			lucky_team_table[random_team] = lucky_team_table[random_team] + 1
	-- 			money_left = money_left - 1
	-- 		end
	-- 		try_count = try_count + 1
	-- 	end

	-- 	for t,count in pairs(lucky_team_table) do
	-- 		local position_to = CenterVector(t) + Vector(RandomInt(-512,512),RandomInt(-512,512),0)
	-- 		DropMoneyBag(hero:GetAbsOrigin(), position_to, 300, ( count or 1 ))
	-- 	end 
	-- end
	if tokens[1] == '-test_gameover' and GameRules:GetGameModeEntity().myself == true then
		CustomGameEventManager:Send_ServerToTeam(team,"show_gameover",{
			key = GetClientKey(team),
			candy = 10,
			biscuit = 1,
			quest_id = 'q001',
			quest_status = true,
			exp_info = {
				user='76561198090931971',
				courier= 'h239',
				exp_old= 29.5,
				exp_new= 30,
				level_old = 29,
				level_new = 30,
				level_delta = 1,
			},
			hehe = RandomInt(1,100000) 
		})
	end
	if tokens[1] == '-test_legendary' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST LEGENDARY')
		CustomGameEventManager:Send_ServerToAllClients("test_legendary",{
			hehe = RandomInt(1,10000)
		})
	end
	
	if tokens[1] == '-skin' and GameRules:GetGameModeEntity().myself == true then
		hero:SetSkin(tonumber(tokens[2]))
		prt('TEST CODE: COURIER SKIN = '..tokens[2])
	end
	if tokens[1] == '-setting' and GameRules:GetGameModeEntity().myself == true then
		prt(json.encode(GameRules:GetGameModeEntity().user_setting))
	end
	if tokens[1] == '-big_damage' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: BIG DAMAGE x '..tokens[2])
		GameRules:GetGameModeEntity().big_damage = tonumber(tokens[2])
	end
	if tokens[1] == '-popup_box' and GameRules:GetGameModeEntity().myself == true then
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_popup_box",{
			key = GetClientKey(hero:GetTeam()),
			round = GameRules:GetGameModeEntity().battle_round,
		})
	end
	if tokens[1] == '-test_worldpanel' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: TEST WORLDPANEL')
		UpdatePlayerWorldPanel({
			[6] = { steam_id = hero.steam_id, oppo_steam_id = '76561198101849234' },
		})
	end
	if tokens[1] == '-go' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: GO!')
		GameRules:GetGameModeEntity().prepare_timer = 6
	end
	if tokens[1] == '-pj' and GameRules:GetGameModeEntity().myself == true then
		local pj_model = nil
		local pj = nil
		if #tokens[2] == 4 then
			pj_model = GameRules:GetGameModeEntity().projectile_list[tokens[2] or 'p000']
			pj = tokens[2]
			hero.projectile = pj
			prt('TEST PROJECTILE: '..pj..' ('..pj_model..')')
		else
			pj_model = tokens[2]
			prt('TEST PROJECTILE: '..pj_model)
		end
		PreviewProjectile(hero,pj,pj_model)
	end

	if tokens[1] == '-line' and GameRules:GetGameModeEntity().myself == true then
		-- create projectile
		local uu = CreateUnitByName("invisible_unit", Entities:FindByName(nil,"center"..hero:GetPlayerID()):GetAbsOrigin()+Vector(0,128*5,256)+RandomVector(128) ,false,nil,nil, hero:GetTeam()) 

		Timers:CreateTimer(10,function()
			uu:ForceKill(false)
			uu:Destroy()
		end)

		local info = {
			Source = uu,
			Ability = nil,
			EffectName = tokens[2],
			vSpawnOrigin = uu:GetOrigin(),
			fDistance = 1000,
			vVelocity = (hero:GetAbsOrigin()-uu:GetAbsOrigin()):Normalized() * 500,
			fStartRadius = 100,
			fEndRadius = 200,
			iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
			iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_SPELL_IMMUNE_ENEMIES,
			iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
			bReplaceExisting = false,
			bProvidesVision = false,
		}
		ProjectileManager:CreateLinearProjectile( info )
	end

	if tokens[1] == '-pet' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: PET = '..tokens[2])
		RefreshPets(hero,hero["pet1"],tokens[2])
	end

	if tokens[1] == '-round_time' and GameRules:GetGameModeEntity().myself == true then
		prt('TEST CODE: CUSTOM ROUND TIME '..tokens[2])
		GameRules:GetGameModeEntity().custom_round_time = tonumber(tokens[2]) 
		GameRules:GetGameModeEntity().prepare_timer = GameRules:GetGameModeEntity().custom_round_time
	end

	if tokens[1] == "-stub" and GameRules:GetGameModeEntity().myself == true then
		local team_id = hero:GetTeam()
		Timers:CreateTimer(function()
			local grid = GameRules:GetGameModeEntity().unit[team_id]
			for i,iv in pairs(grid) do
				if iv ~= nil then
					local x = string.split(i,'_')[2]
					local y = string.split(i,'_')[1]
					local u = CreateUnitByName("stub",XY2Vector(x,y,team_id),true,nil,nil,DOTA_TEAM_BADGUYS)
					u:SetHullRadius(1)
					u:SetForwardVector(Vector(-1,-1,0))
					AddAbilityAndSetLevel(u,'jiaoxie_wudi')
					Timers:CreateTimer(0.5,function()
						u:Destroy()
					end)
				end
			end
			return 0.5
		end)
	end
	if tokens[1] == '-chesspool' and GameRules:GetGameModeEntity().myself then
		PrintChessPool()
	end

	--发弹幕
	if GameRules:GetGameModeEntity().p2_mode == true and keys.teamonly == 1 then
		--2P模式
		local ally_team = GetP2Ally(hero:GetTeam())
		if ally_team then
			local team_from = hero:GetTeam()
			local player_from = hero:GetPlayerID()
			local team_to = ally_team
			local player_to = TeamId2Hero(team_to):GetPlayerID()
			CustomGameEventManager:Send_ServerToTeam(team_to,"chat_bubble",{
				key = GetClientKey(team_to),
				player_from = player_from,
				player_to = player_to,
				text = keys.text,
				is_vip = hero.is_vip,
			})
			CustomGameEventManager:Send_ServerToTeam(team_from,"chat_bubble",{
				key = GetClientKey(team_from),
				player_from = player_from,
				player_to = player_to,
				text = keys.text,
				is_vip = hero.is_vip,
			})
		else
			--给自己发
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"chat_bubble",{
				key = GetClientKey(hero:GetTeam()),
				player_from = hero:GetPlayerID(),
				player_to = hero:GetPlayerID(),
				text = keys.text,
				is_vip = hero.is_vip,
			})
		end
		
	else
		-- CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"chat_bubble",{
		-- 	key = GetClientKey(hero:GetTeam()),
		-- 	player_from = hero:GetPlayerID(),
		-- 	player_to = hero:GetPlayerID(),
		-- 	text = keys.text,
		-- 	is_vip = hero.is_vip,
		-- })

		--发弹幕
		-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
		-- 	player_id = hero:GetPlayerID(),
		-- 	vip = hero.is_vip,
		-- 	win_streak = hero.win_streak or 0,
		-- 	text = keys.text,
		-- })

		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = keys.text,
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_chat',
		})
		
	end
end
function play_particle(p, pos, u, d)
	-- if u == nil then
	-- 	return
	-- end
	local pp = ParticleManager:CreateParticle(p, pos, u)
	-- Timers:CreateTimer(function()
	-- 	if u:IsNull() ~= false or u:IsAlive() ~= false then
	-- 		ParticleManager:DestroyParticle(pp,true)
	-- 		return
	-- 	end
	-- 	return 1
	-- end)
	Timers:CreateTimer(d,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)
end
function PlayParticleOnUnitUntilDeath(keys)
	local p = keys.p
	local u = keys.caster
	if u == nil then
		return
	end
	local pos = keys.pos or PATTACH_ABSORIGIN_FOLLOW
	local pp = ParticleManager:CreateParticle(p, pos, u)
	ParticleManager:SetParticleControlEnt( pp, 0, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 2, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 3, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 4, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 5, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 6, u, pos, nil, u:GetOrigin(), true );

	Timers:CreateTimer(0.1,function()
		if u == nil or u:IsNull() == true or u:IsAlive() == false then
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
			return
		end
		if pp == nil then
			return
		end
		return 0.1
	end)

	return pp
end

function FindUnitsInRadiusOnTeamGround(keys)
	local team = keys.team
	local at_team = keys.at_team
	local role = keys.role or 1 --1=队友,2=敌人,3=全部
	local radius = keys.radius or 9999
	local position = keys.position or Vector(0,0,0)
	local units = {}

	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team]) do
		if IsUnitExist(v) == true and (v:GetAbsOrigin() - position):Length2D() <= radius then
			if role == 1 and v:GetTeam() == team then
				table.insert(units,v)
			end
			if role == 2 and v:GetTeam() ~= team then
				table.insert(units,v)
			end
			if role == 3 then
				table.insert(units,v)
			end
		end
	end

	return units
end

--高级选取单位，适应所有team
function FindUnitsInRadiusByTeam(keys)
	local team = keys.team
	local role = keys.role or 1 --1=队友,2=敌人,3=全部
	local radius = keys.radius or 500
	local position = keys.position or Vector(0,0,0)
	local units = {}

	local all_units = FindUnitsInRadius(
		DOTA_TEAM_BADGUYS,
		Vector(0,0,0),
		nil,
		9999,
		DOTA_UNIT_TARGET_TEAM_BOTH,  --用BOTH可以选到所有team的单位
		DOTA_UNIT_TARGET_ALL,
		DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES,
		FIND_ANY_ORDER,
		false)

	for u,v in pairs(all_units) do
		if (v:GetAbsOrigin() - position):Length2D() <= radius then
			if role == 1 and v:GetTeam() == team then
				table.insert(units,v)
			end
			if role == 2 and v:GetTeam() ~= team then
				table.insert(units,v)
			end
			if role == 3 then
				table.insert(units,v)
			end
		end
	end

	return units
end

function ApplyDamageInRadius(keys)
	local caster = keys.caster
	local team = keys.team
	local role = keys.role or 2
	local position = keys.position
	local damage = keys.damage or 1
	local damage_per = keys.damage_per
	local radius = keys.radius or 500
	local damage_type = keys.damage_type or DAMAGE_TYPE_MAGICAL
	local delay = keys.delay or 0
	local stun_duration = keys.stun_duration or 0
	local stun_partical = keys.stun_partical
	local knockback = keys.knockback or false

	Timers:CreateTimer(delay,function()
		local unlucky_dogs = FindUnitsInRadiusByTeam({
			team = team,
			role = role,
			position = position,
			radius = radius,
		})
		for _,u in pairs(unlucky_dogs) do
			if u ~= nil and u:IsNull() == false and u:IsAlive() == true then
				if damage_per ~= nil and damage_per > 0 then
					local max_hp = u:GetMaxHealth()
					damage = max_hp / 100 * damage_per
				end

				ApplyDamage({
					victim = u,
					attacker = caster,
					damage_type = damage_type,
					damage = damage,
					ability = caster:FindAbilityByName(keys.ability)
				})
				if stun_duration > 0 then
					u:AddNewModifier(u,nil,"modifier_stunned",{ duration = stun_duration })
				end

				if stun_partical ~= nil then
					play_particle(stun_partical,PATTACH_ABSORIGIN_FOLLOW,u,3)
				end
				if knockback == true then
					HunterKnockBack({
						caster = caster,
						target = u,
					})
				end
			end
		end 
	end)
end

function AddModifierInRadius(keys)
	local caster = keys.caster
	local team = caster:GetTeam()
	local role = keys.role or 2
	local radius = keys.radius or 500
	local modifier = keys.modifier
	local ability = keys.ability
	local unlucky_dogs = FindUnitsInRadiusByTeam({
		team = team,
		role = role,
		position = caster:GetAbsOrigin(),
		radius = radius,
	})
	for _,u in pairs(unlucky_dogs) do
		if u ~= nil and u:IsNull() == false and u:IsAlive() == true then
			u:AddNewModifier(caster,keys.ability,modifier,nil)
		end
	end
end


function ChangeModelScale(keys)
	local u = keys.caster
	local x = keys.x
	local s = u:GetModelScale()
	-- u:SetModelScale(s*x)
	if not u:HasAbility('is_ward') then
		AddModelScalePlus(u, s*x)
		play_particle("effect/big.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,2)
	end
end

function RemoveTableItem(t,item)
	for i,v in pairs (t) do
		if v == item then
			table.remove(t,i)
			return t
		end
	end
end

function ChessAddMana(chess,mana)
	chess:SetMana(chess:GetMana()+mana)
	if chess.tether_target ~= nil and IsUnitExist(chess.tether_target) and chess.tether_target:FindModifierByName('modifier_wisp_tether_haste') ~= nil then

		local mana_add = 0
		if chess.tether_target:FindModifierByName('modifier_wisp_tether_haste'):GetAbility():GetLevel() == 1 then
			mana_add = mana*2.5
		elseif chess.tether_target:FindModifierByName('modifier_wisp_tether_haste'):GetAbility():GetLevel() == 2 then
			mana_add = mana*5
		end
		Timers:CreateTimer(0.2,function()
			if mana_add > 0 then
				chess.tether_target:SetMana(chess.tether_target:GetMana()+mana_add)
				if mana_add >= 40 then
					AMHC:CreateNumberEffect(chess.tether_target,mana_add,2,AMHC.MSG_MISS,{128,128,255},0)
				end
			end
		end)
	end
end

function show_damage(keys)
	local caster = keys.caster
	local attacker = keys.attacker
	local damage = math.floor(keys.DamageTaken)

	if attacker ~= nil then
		attacker = attacker.damage_owner or attacker
	end

	if damage <= 0 then
		return
	end

	if attacker ~= nil and attacker:IsNull() == false and attacker:IsHero() == true then
		return
	end

	--回蓝

	--受到伤害回蓝
	local mana_get = damage/5
	if mana_get > 50 then
		mana_get = 50
	end
	mana_get = RandomInt(mana_get/2,mana_get)
	ChessAddMana(caster,mana_get)
	-- caster:SetMana(caster:GetMana()+mana_get)

	--造成伤害回蓝（可被装备加成）
	if IsUnitExist(attacker) == true then
		if attacker:FindAbilityByName('is_mage') or attacker:FindAbilityByName('is_priest') or attacker:FindAbilityByName('is_warlock') or attacker:FindAbilityByName('is_shaman') or attacker:FindAbilityByName('is_wizard') then
			--法系职业回蓝快
			mana_get = damage/2.5
			if mana_get > 20 then
				mana_get = 20
			end
		else
			if mana_get > 10 then
				mana_get = 10
			end
		end 

		local damage_mana_x_list = {
			modifier_item_wangguan = 100,
			modifier_item_hongzhang_1 = 100,
			modifier_item_hongzhang_2 = 100,
			modifier_item_hongzhang_3 = 100,
			modifier_item_hongzhang_4 = 100,
			modifier_item_hongzhang_5 = 100,
			modifier_item_jixianfaqiu = 100,
			modifier_item_huanyingfu = 100,
			modifier_item_linkenfaqiu = 150,
			modifier_item_bingyan = 200,

			modifier_item_xuwubaoshi = 50,
			modifier_item_shenmifazhang = 50,
			modifier_item_jianrenqiu = 50,
			modifier_item_xiwa = 50,
			modifier_item_kuangzhanfu = 50,
			modifier_item_shuaxinqiu = 100,
			modifier_item_qinglianbaozhu = 50,

			modifier_item_yangdao = 200,
			modifier_item_baojunwangpao = 100,
		}

		local damage_mana_bonus = 0
		for m,b in pairs(damage_mana_x_list) do
			if attacker:FindModifierByName(m) ~= nil then
				damage_mana_bonus = damage_mana_bonus + b
			end
		end
		mana_get = math.floor(mana_get * (100+damage_mana_bonus) / 100)
		
		-- attacker:SetMana(attacker:GetMana()+mana_get)
		ChessAddMana(attacker,mana_get)
	end

	--术士吸血
	if IsUnitExist(attacker) == true and keys.ability ~= 'is_monk_buff' then
		if attacker:FindModifierByName("modifier_is_warlock_buff") ~= nil then
			AttackHeal({
				attacker = attacker,
				damage = damage,
				per = 0.15,
			})
			play_particle("particles/generic_gameplay/generic_lifesteal.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,2)
		end
		if attacker:FindModifierByName("modifier_is_warlock_buff_plus") ~= nil then
			AttackHeal({
				attacker = attacker,
				damage = damage,
				per = 0.15,
			})
		end
	end

	if caster ~= nil then
		caster.last_damage_ability = keys.ability
	end

	--伤害统计
	if IsUnitExist(attacker) == true then
		local attacker_id = attacker:GetEntityIndex()
		local team_id = attacker.team_id
		if team_id == nil or GameRules:GetGameModeEntity().damage_stat[team_id] == nil then
			return
		end
		local curr_damage = GameRules:GetGameModeEntity().damage_stat[team_id][attacker:GetUnitName()]
		if curr_damage == nil then
			curr_damage = 0
		end
		curr_damage = curr_damage + damage
		GameRules:GetGameModeEntity().damage_stat[team_id][attacker:GetUnitName()] = curr_damage

		local g_time = GameRules:GetGameTime()
		if GameRules:GetGameModeEntity()['last_g_time'..team_id] == nil then
			GameRules:GetGameModeEntity()['last_g_time'..team_id] = 0
		end
		local time_this_level = 51 - GameRules:GetGameModeEntity().battle_timer
		if g_time - GameRules:GetGameModeEntity()['last_g_time'..team_id] > 1 then
			GameRules:GetGameModeEntity()['last_g_time'..team_id] = g_time
		end
	end
end
function RenJia(keys)
	local caster = keys.caster
	local attacker = keys.attacker
	local damage = math.floor(keys.damage)
	if damage <= 0 then
		return
	end
	Timers:CreateTimer(0.1,function()
		EmitSoundOn('DOTA_Item.BladeMail.Damage',caster)
		ApplyDamage({
	    	victim=attacker,
	    	attacker=caster,
	    	damage_type=DAMAGE_TYPE_PURE,
	    	damage=damage
	    })
	end)
end

function RenJiaDamaged(keys)
	local caster = keys.caster
	local attacker = keys.attacker
	local damage = math.floor(keys.DamageTaken)
	if damage <= 0 then
		return
	end

	caster.is_renjia_damaged = true
	caster.is_bkb_damaged = true
	--caster.is_xiwa_damaged= true
	caster.is_pipe_damaged = true
	caster.is_hudie_damaged = true
	caster.is_sadan_damaged = true
	caster.is_chihongjia_damaged = true
end

function TuiTuiAttacked(keys)
	local caster = keys.caster
	local attacker = keys.attacker

	if IsUnitExist(attacker) == true and (attacker:GetAbsOrigin() - caster:GetAbsOrigin()):Length2D() <= 205 + attacker:GetHullRadius() + caster:GetHullRadius() then
		caster.is_tuitui_damaged = attacker
	end
end

--电锤技能
function DianChui(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local targets = event.targets
	local damage = event.damage
	local particle = event.particle or "particles/units/heroes/hero_shadowshaman/shadowshaman_ether_shock.vpcf"

	if ability:IsCooldownReady() == false then
		--内置cd
		return
	end
	ability:StartCooldown(1)
	-- Make sure the main target is damaged
	local lightningBolt = ParticleManager:CreateParticle(particleName, PATTACH_WORLDORIGIN, caster)
	ParticleManager:SetParticleControl(lightningBolt,0,Vector(caster:GetAbsOrigin().x,caster:GetAbsOrigin().y,caster:GetAbsOrigin().z + caster:GetBoundingMaxs().z ))	
	ParticleManager:SetParticleControl(lightningBolt,1,Vector(target:GetAbsOrigin().x,target:GetAbsOrigin().y,target:GetAbsOrigin().z + target:GetBoundingMaxs().z ))
	if target:IsMagicImmune() == false then
		ApplyDamage({ 
			victim = target, 
			attacker = caster, 
			damage = damage, 
			damage_type = DAMAGE_TYPE_MAGICAL
		})
	end
	EmitSoundOn("Hero_Zuus.ArcLightning.Cast",caster)

	-- local cone_units = GetEnemiesInCone( caster, start_radius, end_radius, end_distance )
	local range = caster:Script_GetAttackRange()+500 or 500
	if range < 500 then
		range = 500
	end
	local cone_units = FindUnitsInRadiusOnTeamGround({
			team = caster:GetTeam(),
			at_team = caster.at_team_id or caster.team_id,
			role = 2,
			position = caster:GetAbsOrigin(),
			radius = range,
		})
	local targets_shocked = 1 --Is targets=extra targets or total?
	for _,unit in pairs(cone_units) do
		if targets_shocked < targets then
			if unit ~= target then
				if unit.player == nil or unit.player == caster:GetOwner():GetPlayerID() then
					-- Particle
					local origin = unit:GetAbsOrigin()

					local lightningBolt = ParticleManager:CreateParticle(particle, PATTACH_WORLDORIGIN, caster)
					ParticleManager:SetParticleControl(lightningBolt,0,Vector(caster:GetAbsOrigin().x,caster:GetAbsOrigin().y,caster:GetAbsOrigin().z + caster:GetBoundingMaxs().z ))	
					ParticleManager:SetParticleControl(lightningBolt,1,Vector(origin.x,origin.y,origin.z + unit:GetBoundingMaxs().z ))
				
					-- Damage
					if unit:IsMagicImmune() == false then
						ApplyDamage({ 
							victim = unit, 
							attacker = caster, 
							damage = damage, 
							damage_type = DAMAGE_TYPE_MAGICAL
						})
					end

					-- Increment counter
					targets_shocked = targets_shocked + 1
				end
				
			end
		else
			break
		end
	end
end


function string.split(s, sep)
    if sep == nil then
            sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(s, "([^"..sep.."]+)") do
            t[i] = str
            i = i + 1
    end
    return t
end

--主公的技能
function h101_ability(h)
	if h~=nil and h:IsNull() ~= true and h:IsAlive() ~= false and h:GetHealth() < h:GetMaxHealth() then
		Timers:CreateTimer(RandomFloat(0,0.2),function()
			h:SetHealth(h:GetHealth()+1)
			play_particle("particles/items2_fx/tranquil_boots_healing.vpcf",PATTACH_ABSORIGIN_FOLLOW,h,2)
			EmitSoundOn('DOTA_Item.TranquilBoots.Activate',h)
			SyncHP(h)
		end)
	end
end
function h203_addattackdamage(keys)
	local h = keys.caster
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[h:GetTeam()]) do
		if v.team_id == h:GetTeam() then
			AddAbilityAndSetLevel(v,'h203_attack_increased')
			EmitSoundOn('Hero_Beastmaster.Call.Boar',v)
		end
	end
end
function h301_restoreallhealth(keys)
	local h = keys.caster
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[h:GetTeam()]) do
		if v.team_id == h:GetTeam() then
			v:SetHealth(v:GetMaxHealth())
			play_particle("particles/units/heroes/hero_omniknight/omniknight_purification.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
			EmitSoundOn('Hero_Omniknight.Purification',v)
		end
	end
end
function h302_ability(h)
	AddAbilityAndSetLevel(h,'h302_maxmanaplus20')
end
function h401_ability(keys)
	local h = keys.caster
	AMHC:CreateParticle("particles/econ/items/puck/puck_alliance_set/puck_dreamcoil_waves_rope_aproset.vpcf",PATTACH_OVERHEAD_FOLLOW,false,h,5)
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[h:GetTeam()]) do
		if v.team_id ~= h:GetTeam() then
			AddAbilityAndSetLevel(v,'h401_letaojiao')
		end
	end
end
function h402_ability(keys)
	local h = keys.caster
	play_particle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_wings_grow_rope.vpcf",PATTACH_ABSORIGIN_FOLLOW,h,5)
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[h:GetTeam()]) do
		if v.team_id ~= h:GetTeam() then
			local damageTable = {
		    	victim=v,
		    	attacker=h,
		    	damage_type=DAMAGE_TYPE_MAGICAL,
		    	damage=v:GetMaxHealth()/2
		    }
		    ApplyDamage(damageTable)
			play_particle("particles/econ/items/shadow_fiend/sf_fire_arcana/sf_fire_arcana_shadowraze.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
		end
	end
end

function DAC:OnRefreshChess(keys)
	local player_team = GameRules:GetGameModeEntity().playerid2team[keys.PlayerID]
	local hero = GameRules:GetGameModeEntity().teamid2hero[player_team]

	if (player_team ~= keys.team) then
		hero.is_banned = true
		return
	end

	if hero:GetMana() < 2 then
		CustomGameEventManager:Send_ServerToTeam(keys.team,"mima",{
			key = GetClientKey(keys.team),
			text = "text_mima_no_mana"
		})
		return
	else
		hero.chesslock = false
		CostMana(hero,2)
		Draw5ChessAndShow(keys.team, true)
	end
end

--技能：抽
function SummonHero(keys)
	local caster = keys.caster
	local team_id = caster:GetTeam()
	caster.chesslock = false

	AMHC:CreateParticle("particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ribbon_bright.vpcf",PATTACH_ABSORIGIN_FOLLOW,false,caster,5)
	EmitSoundOn('frostivus_ui_select',caster)
	Draw5ChessAndShow(team_id, true)
	AMHC:CreateNumberEffect(caster,2,3,AMHC.MSG_MISS,{80,80,255},3)

	CustomGameEventManager:Send_ServerToTeam(team_id,"show_gold",{
		key = GetClientKey(team_id),
		gold = caster:GetMana(),
		lose_streak = caster.lose_streak or 0,
		win_streak = caster.win_streak or 0,
	})
	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = caster:GetPlayerID(),
		hp = caster:GetHealth(),
		hp_max = caster:GetMaxHealth(),
		mp = caster:GetMana(),
		level = caster:GetLevel(),
		win_streak = caster.win_streak,
	})
end

function ExpBook(keys)
    local caster = keys.caster
    local team_id = caster:GetTeam()
    local xpnow = caster:GetCurrentXP()
    local xpadd = keys.xpadd or 4
    local xpnextlvl = GameRules:GetGameModeEntity().HeroExpTable[caster:GetLevel() + 1]
    local next_lvl_cost = math.ceil((xpnextlvl - xpnow) / 4) * 4
    local cost = 4
    -- 判断是否满足直接升级的条件
    if caster.quick_lvl_up == true and xpnextlvl - xpnow > 4 and caster:GetMana() >= next_lvl_cost - 4 then
        xpadd = next_lvl_cost
        cost = next_lvl_cost - 4
        caster:ReduceMana(cost)
        caster:FindAbilityByName("exp_book"):StartCooldown(2)
    end
    -- 超过10级时去掉经验值零头
    if xpadd + xpnow > GameRules:GetGameModeEntity().HeroExpTable[10] then
        xpadd = GameRules:GetGameModeEntity().HeroExpTable[10] - xpnow
    end
    if xpadd < 0 then
        xpadd = 0
    end
    -- 添加经验值，达到10级则禁用经验按钮
    caster:AddExperience (xpadd,0,false,false)
    if caster:GetLevel() >= 10 then
        caster:FindAbilityByName('exp_book'):SetActivated(false)
    end
    -- 显示特效
    if xpadd > 4 then
    	play_particle_controlIndex("particles/econ/items/keeper_of_the_light/kotl_ti10_immortal/kotl_ti10_blinding_light.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3,1)
    	EmitSoundOn("quick_lvl_up",caster)
    else
    	AMHC:CreateParticle("particles/units/heroes/hero_oracle/oracle_false_promise_cast_enemy.vpcf",PATTACH_ABSORIGIN_FOLLOW,false,caster,3)
    	EmitSoundOn("lvl_up",caster)
    end
    AMHC:CreateNumberEffect(caster,cost,3,AMHC.MSG_MISS,{80,80,255},3)
    Timers:CreateTimer(0.5,function()
        AMHC:CreateNumberEffect(caster,xpadd,3,AMHC.MSG_MISS,{255,255,128},0)
    end)
    -- 添加快速升级标签
    caster.quick_lvl_up = true
    Timers:CreateTimer(0.18,function()
        caster.quick_lvl_up = false
    end)
    -- 同步UI
    CustomGameEventManager:Send_ServerToTeam(team_id,"show_gold",{
        key = GetClientKey(team_id),
        gold = caster:GetMana(),
        lose_streak = caster.lose_streak or 0,
        win_streak = caster.win_streak or 0,
    })
    CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
        player_id = caster:GetPlayerID(),
        hp = caster:GetHealth(),
        hp_max = caster:GetMaxHealth(),
        mp = caster:GetMana(),
        level = caster:GetLevel(),
        win_streak = caster.win_streak,
    })
end

function AddMana(unit, mana, show_number)
	if mana == nil or mana <= 0 then
		return
	end
	if show_number == nil then
		show_number = true
	end

	local mana_result = math.floor(unit:GetMana()+mana+0.5)
	if mana_result < 0 then
		mana_result = 0
	end
	if mana_result > 100 then
		mana_result = 100
	end
	if mana_result >= 100 and GameRules:GetGameModeEntity().egg_quest == 'q007' then
		SetQuest(unit:GetTeam(),true)
	end
	if mana_result > 20 and GameRules:GetGameModeEntity().egg_quest == 'q008' then
		SetQuest(unit:GetTeam(),false)
	end
	unit:SetMana(mana_result)
	
	if mana >= 10 then
		EmitSoundOn("General.CoinsBig",unit)
	else
		EmitSoundOn("General.Coins",unit)
	end

	if show_number == true then
		AMHC:CreateNumberEffect(unit,mana,3,AMHC.MSG_MISS,{255,255,0},0)
		AMHC:CreateParticle("particles/generic_gameplay/rune_bounty_owner.vpcf",PATTACH_OVERHEAD_FOLLOW,false,unit,5)
	end

	CustomGameEventManager:Send_ServerToTeam(unit:GetTeam(),"show_gold",{
		key = GetClientKey(unit:GetTeam()),
		gold = mana_result,
		lose_streak = unit.lose_streak or 0,
		win_streak = unit.win_streak or 0,
	})
	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = unit:GetPlayerID(),
		hp = unit:GetHealth(),
		hp_max = unit:GetMaxHealth(),
		mp = unit:GetMana(),
		level = unit:GetLevel(),
		win_streak = unit.win_streak,
	})
end

function CostMana(unit, mana)
	if mana == nil or mana <= 0 then
		return
	end
	unit:SetMana(unit:GetMana()-mana)
	AMHC:CreateNumberEffect(unit,mana,3,AMHC.MSG_MISS,{80,80,255},3)
	
	CustomGameEventManager:Send_ServerToTeam(unit:GetTeam(),"show_gold",{
		key = GetClientKey(unit:GetTeam()),
		gold = unit:GetMana(),
		lose_streak = unit.lose_streak or 0,
		win_streak = unit.win_streak or 0,
	})
	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = unit:GetPlayerID(),
		hp = unit:GetHealth(),
		hp_max = unit:GetMaxHealth(),
		mp = unit:GetMana(),
		level = unit:GetLevel(),
		win_streak = unit.win_streak,
	})
end

function AddModelScalePlus(unit, scale)
	unit.target_scale = scale
	Timers:CreateTimer(0.01,function()
		if unit == nil or unit:IsNull() == true or unit:IsAlive() == false or unit:GetModelScale() >= unit.target_scale then
			return
		end
		unit:SetModelScale(unit:GetModelScale()+0.01)
		return 0.01
	end)
end

function CmManaAura(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id
	local radius = keys.radius or 800
	local mana = keys.mana or 5

	for _,unit in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id == team_id and unit:GetMaxMana() ~= 0 then
			play_particle('particles/units/heroes/hero_obsidian_destroyer/obsidian_destroyer_matter_manasteal.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,3)
			if unit:GetMana() < 100 then
				AMHC:CreateNumberEffect(unit,mana,2,AMHC.MSG_MISS,{128,128,255},0)
			end
			unit:GiveMana(mana)
		end
	end
end


function PlayChessDialogue(unit,dialogue)
	if unit == nil or unit:IsNull() == true or unit:IsAlive() == false then
		return
	end
	play_particle("particles/speechbubbles/speech_voice.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,3)
	CustomGameEventManager:Send_ServerToTeam(unit:GetTeam(),"play_chess_dialogue",{
		unit_index = unit:GetEntityIndex(),
		unit_name = unit:GetUnitName(),
		dialogue_type = dialogue, --spawn/win/merge
	})
end
function PlayPetDialogue(unit, is_win, language)
	if unit == nil or unit:IsNull() == true or unit:IsAlive() == false then
		return
	end
	local pet_name = unit.pet_name
	local r = 'chat'
	if is_win == true then
		r = 'win'
	end
	if language == 'schinese' or language == 'tchinese' then
		language = 'schinese'
	else
		language = 'english'
	end 
	play_particle("particles/speechbubbles/speech_voice.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,3)
	EmitSoundOn("pet."..pet_name.."."..r.."."..language,unit)
end

function TriggerRefreshOrb(u)
	if u:FindModifierByName("modifier_item_shuaxinqiu") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			local a = nil
			if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
				a = u.steal_ability
			elseif string.find(u:GetUnitName(),'chess_kael') and u.kael_ability ~= nil then
				a = u.kael_ability
			else
				a = GameRules:GetGameModeEntity().chess_ability_list[u:GetUnitName()] or GameRules:GetGameModeEntity().summon_ability_list[u:GetUnitName()]
			end
			if u.ice_or_fire == 'fire' then
				a = 'jakiro_macropyre'
			end
			if u.ice_or_fire == 'ice' then
				a = 'jakiro_ice_path'
			end
			if a ~= nil and name == 'item_shuaxinqiu' and ability:IsCooldownReady() == true and u:FindAbilityByName(a):IsCooldownReady() == false then
				--刷新！！
				ability:StartCooldown(30)
				
				u:FindAbilityByName(a):EndCooldown()

				play_particle("particles/items2_fx/refresher.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn("DOTA_Item.Refresher.Activate",u)

				return 0.5
			end
		end
	end
end

function TriggerSheepStick(u)
	if u:FindModifierByName("modifier_item_yangdao") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_yangdao' and ability:IsCooldownReady() == true then
				-- if u:FindAbilityByName("crab_voodoo") == nil then
				-- 	AddAbilityAndSetLevel(u,'crab_voodoo')
				-- end
				local dog = FindHighLevelUnluckyDog(u,true,true)
				if u:IsNull() ~= true and dog ~= nil and dog:IsNull() ~= true then
					-- local newOrder = {
				 -- 		UnitIndex = u:entindex(), 
				 -- 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
				 -- 		TargetIndex = dog:entindex(), 
				 -- 		AbilityIndex = u:FindAbilityByName("crab_voodoo"):entindex(), 
				 -- 		Position = nil, 
				 -- 		Queue = 0 
				 -- 	}
					-- ExecuteOrderFromTable(newOrder)

					if dog:IsMagicImmune() == true then
						return
					end

					if BlockByLinken(dog) == false then
						dog:AddNewModifier(
							u,
							nil,
							"modifier_shadow_shaman_voodoo",
							{ duration = 8 }
						)
					end
					ability:StartCooldown(15)

					Timers:CreateTimer(0.3,function()
						if dog:HasModifier('modifier_shadow_shaman_voodoo') then
							RemoveAllKnightBuff(dog)
						end
					end)
				end
				return 0.5
			end
		end
	end
end

function TriggerRenjia(u)
	if u:FindModifierByName("modifier_item_renjia") == nil then
		return 
	end
	if u.is_renjia_damaged == nil then 
		return
	end
	u.is_renjia_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_renjia' and ability:IsCooldownReady() == true then
				EmitSoundOn('DOTA_Item.BladeMail.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_renjia_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerHudie(u)
	if u:FindModifierByName("modifier_item_hudie") == nil then
		return 
	end
	if u.is_hudie_damaged == nil then 
		return
	end
	u.is_hudie_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_hudie' and ability:IsCooldownReady() == true then
				-- EmitSoundOn('DOTA_Item.BladeMail.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_hudie_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerSadan(u)
	if u:FindModifierByName("modifier_item_sadan") == nil then
		return 
	end
	if u.is_sadan_damaged == nil then 
		return
	end
	u.is_sadan_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_sadan' and ability:IsCooldownReady() == true then
				-- EmitSoundOn('DOTA_Item.BladeMail.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_sadan_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerXiwa(u)
	if u:FindModifierByName("modifier_item_xiwa") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_xiwa' and ability:IsCooldownReady() == true then
				ItemXiWa({
					caster = u,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerPipe(u)
	if u:FindModifierByName("modifier_item_dongchayandou") == nil then
		return 
	end
	if u.is_pipe_damaged == nil then 
		return
	end
	u.is_pipe_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_dongchayandou' and ability:IsCooldownReady() == true then
				ItemPipe({
					caster = u,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerChihongjia(u)
	if u:FindModifierByName("modifier_item_chihongjia") == nil then
		return 
	end
	if u.is_chihongjia_damaged == nil then 
		return
	end
	u.is_chihongjia_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_chihongjia' and ability:IsCooldownReady() == true then
				ItemChihongjia({
					caster = u,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerFengKuangMianJu(u)
	if u:FindModifierByName("modifier_item_fengkuangmianju") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_fengkuangmianju' and ability:IsCooldownReady() == true then
				EmitSoundOn('DOTA_Item.MaskOfMadness.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_fengkuangmianju_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(20)
				return 0.5
			end
		end
	end
end

function TriggerMiFaXie(u)
	if u:FindModifierByName("modifier_item_aoshuxie") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_aoshuxie' and ability:IsCooldownReady() == true then
				play_particle("particles/items_fx/arcane_boots.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn('DOTA_Item.ArcaneBoots.Activate',u)
				for _,unit in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
					if unit.team_id == u.team_id and unit:GetMaxMana() ~= 0 then
						play_particle('particles/items_fx/arcane_boots_recipient.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,3)
						if unit:GetMana() < 100 then
							AMHC:CreateNumberEffect(unit,20,2,AMHC.MSG_MISS,{128,128,255},0)
						end
						ChessAddMana(unit,20)
					end
				end
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerTuiTui(u)
	if u.is_tuitui_damaged == nil or IsUnitExist(u.is_tuitui_damaged) == false or u.is_tuitui_damaged:IsMagicImmune() == true then 
		return
	end
	local target = u.is_tuitui_damaged

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_yuanlifazhang' and ability:IsCooldownReady() == true then
				ability:StartCooldown(15)
				if BlockByLinken(target) == false then
					local team_id = target.at_team_id or target.team_id
					local v = FindFarthestEmptyGrid(u)

					local yy = target.y
					local xx = target.x

					local y = Vector2Y(v,team_id)
					local x = Vector2X(v,team_id)
					local stun_duration = ((v-target:GetAbsOrigin()):Length2D()/1000)
					target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+1 })

					GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] = 1
					target.is_moving = true
					BlinkChessX({p=v,caster=target,blink_type='tuitui'})
					EmitSoundOn("DOTA_Item.ForceStaff.Activate",target)

					target.y_x = y..'_'..x
					target.y = y
					target.x = x
					GameRules:GetGameModeEntity().unit[team_id][yy..'_'..xx] = nil
				end

				return 0.5
			end
		end
	end
end


function TriggerBKB(u)
	if u:FindModifierByName("modifier_item_bkb") == nil then
		return 
	end
	if u.is_bkb_damaged == nil then 
		return
	end
	u.is_bkb_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_bkb' and ability:IsCooldownReady() == true then
				EmitSoundOn('DOTA_Item.BlackKingBar.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_bkb_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				u:Purge(false, true, false, false, false) --净化
				return 0.5
			end
		end
	end
end

function TriggerTiaodao(u)
	if u:FindModifierByName("modifier_item_tiaodao") == nil then
		return 
	end
	RemoveAbilityAndModifier(u,'jiaoxie_wudi')
	RemoveAbilityAndModifier(u,'jiaoxie')
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_tiaodao' and ability:IsCooldownReady() == true then
				find_ok = FindFarthestCanAttackEnemyEmptyGrid(u)
				if find_ok ~= nil then
					local x = Vector2X(find_ok,u.at_team_id or u.team_id)
					local y = Vector2Y(find_ok,u.at_team_id or u.team_id)
					local xx = u.x
					local yy = u.y
					GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][y..'_'..x] = 1
					u:SetAbsOrigin(find_ok)
					u.y_x = y..'_'..x
					u.y = y
					u.x = x
					GameRules:GetGameModeEntity().unit[u.at_team_id or u.team_id][yy..'_'..xx] = nil

					AMHC:CreateNumberEffect(u,40,2,AMHC.MSG_MISS,{128,128,255},0)
					u:GiveMana(40)
					
					play_particle("particles/items_fx/blink_dagger_end.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,3)
					EmitSoundOn("DOTA_Item.BlinkDagger.Activate",u)

					ability:StartCooldown(20)
				else
					return
				end
				return 0.5
			end
		end
	end
end

--萨满的羊
function TriggerFrogGua(u)
	if u:FindAbilityByName("frog_voodoo") == nil then
		return 
	end
	local dog = FindUnluckyDog(u)
	if dog ~= nil and u:FindAbilityByName("frog_voodoo"):IsCooldownReady() == true then
		local newOrder = {
	 		UnitIndex = u:entindex(), 
	 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
	 		TargetIndex = dog:entindex(), 
	 		AbilityIndex = u:FindAbilityByName("frog_voodoo"):entindex(), 
	 		Position = nil, 
	 		Queue = 0 
	 	}
		ExecuteOrderFromTable(newOrder)

		if dog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
			CopyAbility2FuhunUnit(u,dog,"frog_voodoo")
		end
		if dog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
			CopyAbility2QinglianbaozhuUnit(u,dog,a)
		end

		TriggerHex({
			target = dog
		})
		-- u:FindAbilityByName("frog_voodoo"):StartCooldown(60)
		-- Timers:CreateTimer(2,function()
		-- 	u:RemoveAbility("frog_voodoo")
		-- end)
		return 0.5
	end
end

function TriggerDagon(u)
	if u:FindModifierByName("modifier_item_hongzhang_1") == nil and u:FindModifierByName("modifier_item_hongzhang_2") == nil and u:FindModifierByName("modifier_item_hongzhang_3") == nil and u:FindModifierByName("modifier_item_hongzhang_4") == nil and u:FindModifierByName("modifier_item_hongzhang_5") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			local name_table = string.split(name,'_')
			local dog = FindUnluckyDog(u)
			if dog ~= nil and name_table[2] == 'hongzhang' and ability:IsCooldownReady() == true then
				ability:StartCooldown(18-tonumber(name_table[3])*3)
				EmitSoundOn("DOTA_Item.Dagon.Activate",u)
				local victim = dog
				local info = {
			        Target = victim,
			        Source = u,
			        Ability = nil,
			        EffectName = "particles/econ/events/ti5/dagon_ti5.vpcf",
			        bDodgeable = false,
			        iMoveSpeed = 3000,
			        bProvidesVision = false,
			        iVisionRadius = 0,
			        iVisionTeamNumber = u:GetTeamNumber(),
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    }
				projectile = ProjectileManager:CreateTrackingProjectile(info)
				if victim:IsMagicImmune() == false then
					if BlockByLinken(victim) == false then
						ApplyDamage({
					    	victim=victim,
					    	attacker=u,
					    	damage_type=DAMAGE_TYPE_MAGICAL,
					    	damage=300+100*tonumber(name_table[3])
					    })
					end
				end
				return 0.5
			end
		end
	end
end
function TriggerHuanyingfu(u)
	if u:FindModifierByName("modifier_item_huanyingfu") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			if ability:GetAbilityName() == 'item_huanyingfu' and ability:IsCooldownReady() == true then
				ability:StartCooldown(15)

				EmitSoundOn("DOTA_Item.Manta.Activate",u)
				play_particle("particles/generic_gameplay/illusion_killed.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,3)
				if IsUnitExist(u) == true and u:GetHealth() > 0 then
					local i1 = SummonOneMinion(u,u:GetUnitName())
					i1:SetHealth(u:GetHealth())
					i1:AddNewModifier(i1,nil,"modifier_illusion",{duration = 10})
					i1:SetMaxMana(0)
					FillEmptySlot(i1)
				end
				Timers:CreateTimer(0.2,function()
					if IsUnitExist(u) == true and u:GetHealth() > 0 then
						local i2 = SummonOneMinion(u,u:GetUnitName())
						i2:SetHealth(u:GetHealth())
						i2:AddNewModifier(i2,nil,"modifier_illusion",{duration = 10})
						i2:SetMaxMana(0)
						FillEmptySlot(i2)
					end
				end)
				return 0.5
			end
		end
	end

end
function ChessTechBomb(keys)
	local caster = keys.caster
	local p = keys.target_points[1]
	local explode_time = keys.explode_time or 5
	local damage = keys.damage or 800
	local scale = keys.scale or 1.2
	local range = keys.range or 400
	local at_team = caster.at_team_id or caster.team_id
	local team = caster:GetTeam()

	if p == nil then
		return
	end

	local y = Vector2Y(p,at_team)
	local x = Vector2X(p,at_team)

	if (GameRules:GetGameModeEntity().unit[at_team][y..'_'..x] ~= nil) then
		p = FindEmptyGridAtUnit(caster)
	end

	--创建一个炸弹
	GameRules:GetGameModeEntity().unit[at_team][y..'_'..x] = 1
	local u = CreateUnitByName('enemy_bomb',p,true,nil,nil,team)
	u:SetModelScale(scale)
	if scale > 1.5 then
		u:SetOriginalModel('models/heroes/techies/fx_techies_remotebomb_underhollow.vmdl')
		u:SetModel('models/heroes/techies/fx_techies_remotebomb_underhollow.vmdl')
	end
	EmitSoundOn("dac.tech.plantbomb",u)
	-- play_particle("particles/units/heroes/hero_techies/techies_remote_mine.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,3)
	local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_techies/techies_remote_mine.vpcf", PATTACH_ABSORIGIN_FOLLOW, u)
	ParticleManager:SetParticleControl(pp,0,u:GetAbsOrigin())

	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)

	Timers:CreateTimer(explode_time, function()
		GameRules:GetGameModeEntity().unit[at_team][y..'_'..x] = 0
		--爆炸
		EmitSoundOn("dac.tech.explode",u)
		play_particle("particles/dac/zhayaotong/zhayaotong.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,2)
		--伤害
		ApplyDamageInRadius({
			caster = caster,
			team = team,
			radius = range,
			role = 2,
			position = u:GetAbsOrigin(),
			damage = damage,
			damage_type = DAMAGE_TYPE_PHYSICAL,
			ability = 'chess_tech_bomb',
		})
		u:SetModelScale(0.001)
		Timers:CreateTimer(2,function()
			u:Destroy()
		end)
	end)
end

function LycSummonWolf(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local hp_per = keys.hp_per
	play_particle("particles/units/heroes/hero_lycan/lycan_shapeshift_cast.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)
	EmitSoundOn("Hero_Lycan.Shapeshift.Cast",caster)

	local lyc_model = {
		[1] = "models/items/lycan/ultimate/ambry_true_form/ambry_true_form.vmdl",
		[2] = "models/items/lycan/ultimate/alpha_trueform9/alpha_trueform9.vmdl",
		[3] = "models/items/lycan/ultimate/blood_moon_hunter_shapeshift_form/blood_moon_hunter_shapeshift_form.vmdl",
	}
	local shift_model = lyc_model[level]
	if shift_model ~= nil then
		--拉比克变身去除饰品
		if string.find(caster:GetUnitName(),'chess_rubick') then
			local children = caster:GetChildren()
		    for k,child in pairs(children) do
		       if child:GetClassname() == "dota_item_wearable" then
		           child:RemoveSelf()
		       end
		    end
		end

		caster:SetOriginalModel(shift_model)
		caster:SetModel(shift_model)
		ModMaxHP({
			caster = caster,
			per = hp_per,
			is_heal = true,
		})
		caster.is_shifted = true
	end

	Timers:CreateTimer(0.1,function()
		local w = SummonOneMinion(caster,'lyc_wolf'..level)
		ExtendBeastBuff(w,caster)

		Timers:CreateTimer(0.1,function()
			local w = SummonOneMinion(caster,'lyc_wolf'..level)
			ExtendBeastBuff(w,caster)

			if level == 3 then
				Timers:CreateTimer(0.1,function()
					local w = SummonOneMinion(caster,'lyc_wolf'..level)
					ExtendBeastBuff(w,caster)
				end)
			end
		end)
	end)
end
function VisageSummonBabyDragon(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	-- play_particle("particles/units/heroes/hero_lycan/lycan_shapeshift_cast.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)
	EmitSoundOn("visage.baby",caster)
	local unluckydog_1 = nil
	local min_speed_1 = 999
	local unluckydog_2 = nil
	local min_speed_2 = 999
	-- local unluckydog_3 = nil
	-- local min_speed_3 = 999
	for i1,v1 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.at_team_id or caster.team_id]) do
		if v1:GetAttackSpeed() < min_speed_1 and v1.team_id ~= caster.team_id then
			min_speed_1 = v1:GetAttackSpeed()
			unluckydog_1 = v1
		end
	end
	if unluckydog_1 ~= nil then
		for i2,v2 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.at_team_id or caster.team_id]) do
			if v2:GetAttackSpeed() < min_speed_2 and v2.team_id ~= caster.team_id and v2:entindex() ~= unluckydog_1:entindex() then
				min_speed_2 = v2:GetAttackSpeed()
				unluckydog_2 = v2
			end
		end
	end
	-- if unluckydog_2 ~= nil then
	-- 	for i3,v3 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.at_team_id or caster.team_id]) do
	-- 		if v3:GetAttackSpeed() < min_speed_3 and v3.team_id ~= caster.team_id and v3:entindex() ~= unluckydog_1:entindex() and v3:entindex() ~= unluckydog_2:entindex() then
	-- 			min_speed_3 = v3:GetAttackSpeed()
	-- 			unluckydog_3 = v3
	-- 		end
	-- 	end
	-- end

	Timers:CreateTimer(0.1,function()
		if GameRules:GetGameModeEntity().restore_check == false then 
			local w = SummonOneMinion(caster,'visage_dragon_'..level)
			ExtendBeastBuff(w,caster)
			play_particle('particles/units/heroes/hero_visage/visage_summon_familiars.vpcf',PATTACH_ABSORIGIN_FOLLOW,w,5)
			AddAbilityAndSetLevel(w,'visage_grave_chill',level)
			if level == 3 and GameRules:GetGameModeEntity().restore_check == false then 
				Timers:CreateTimer(0.2,function()
					local w2 = SummonOneMinion(caster,'visage_dragon_'..level)
					ExtendBeastBuff(w2,caster)
					play_particle('particles/units/heroes/hero_visage/visage_summon_familiars.vpcf',PATTACH_ABSORIGIN_FOLLOW,w2,5)
					AddAbilityAndSetLevel(w2,'visage_grave_chill',level)
					-- if level == 3 and GameRules:GetGameModeEntity().restore_check == false then
					-- 	Timers:CreateTimer(0.2,function()
					-- 		local w3 = SummonOneMinion(caster,'visage_dragon_'..level)
					-- 		ExtendBeastBuff(w3,caster)
					-- 		play_particle('particles/units/heroes/hero_visage/visage_summon_familiars.vpcf',PATTACH_ABSORIGIN_FOLLOW,w3,5)
					-- 		AddAbilityAndSetLevel(w3,'visage_grave_chill',level)
					-- 	end)
					-- end
				end)
			end
		end
	end)
end
function TbMohua(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	EmitSoundOn('Hero_Terrorblade.Sunder.Cast',caster)

	play_particle("particles/units/heroes/hero_terrorblade/terrorblade_metamorphosis_transform.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)

	local mohua_model = {
		[1] = "models/heroes/terrorblade/demon.vmdl",
		[2] = "models/items/terrorblade/knight_of_foulfell_demon/knight_of_foulfell_demon.vmdl",
		[3] = "models/items/terrorblade/dotapit_s3_fallen_light_metamorphosis/dotapit_s3_fallen_light_metamorphosis.vmdl",
	}
	local shift_model = mohua_model[level]
	if shift_model ~= nil then
		caster:SetOriginalModel(shift_model)
		caster:SetModel(shift_model)
		--拉比克变身去除饰品
		if string.find(caster:GetUnitName(),'chess_rubick') then
			local children = caster:GetChildren()
		    for k,child in pairs(children) do
		       if child:GetClassname() == "dota_item_wearable" then
		           child:RemoveSelf()
		       end
		    end
		end
	end

	--附加灵魂隔断效果：

	--（1）找一个倒霉蛋队友
	local unluckydog = FindBestSunderFriend(caster)
	if unluckydog ~= nil then
		--（2）交换血量百分比
		local hp1 = caster:GetHealth()
		local hp_max1 = caster:GetMaxHealth()
		local per1 = 1.0*hp1/hp_max1
		local hp2 = unluckydog:GetHealth()
		local hp_max2 = unluckydog:GetMaxHealth()
		local per2 = 1.0*hp2/hp_max2

		if caster ~= nil and caster:IsNull() ~= true and caster:IsAlive() == true then
			local h1 = caster:GetMaxHealth()*per2
			if h1<=1 then
				h1 = 1
			end
			caster:SetHealth(h1)
		end
		if caster ~= nil and caster:IsNull() ~= true and caster:IsAlive() == true then
			local h2 = unluckydog:GetMaxHealth()*per1
			if h2<=1 then
				h2 = 1
			end
			unluckydog:SetHealth(h2)
		end
		
		--（3）播放特效音效 
		local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_terrorblade/terrorblade_sunder.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
		ParticleManager:SetParticleControl(pp,0,caster:GetAbsOrigin())
		ParticleManager:SetParticleControl(pp,1,unluckydog:GetAbsOrigin())
		Timers:CreateTimer(2,function()
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
		end)
		EmitSoundOn("Hero_Terrorblade.Sunder.Cast",caster)
		EmitSoundOn("Hero_Terrorblade.Sunder.Target",unluckydog)
	end
end

function VenoSummonWard(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local p = keys.target_points[1]

	Timers:CreateTimer(0.1,function()
		local w = SummonOneMinion(caster,'veno_ward'..level)
		ExtendBeastBuff(w,caster)
	end)
	if level == 3 then
		Timers:CreateTimer(0.6,function()
			local w = SummonOneMinion(caster,'veno_ward'..level)
			ExtendBeastBuff(w,caster)
		end)
	end
end

function InvokerSpirit(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	Timers:CreateTimer(0.1,function()
		local w = SummonOneMinion(caster,'invoker_spirit'..level)
		ExtendBeastBuff(w,caster)
	end)
	Timers:CreateTimer(0.3,function()
		local w = SummonOneMinion(caster,'invoker_spirit'..level)
		ExtendBeastBuff(w,caster)
	end)
end
--召唤物继承野兽buff
function ExtendBeastBuff(unit,owner)
	if owner:FindAbilityByName('is_beast_buff')~=nil then
		AddAbilityAndSetLevel(unit,'is_beast_buff')
	end
	if owner:FindAbilityByName('is_beast_buff_plus')~=nil then
		AddAbilityAndSetLevel(unit,'is_beast_buff_plus')
	end
	if owner:FindAbilityByName('ursa_fury_swipes')~=nil then
		AddAbilityAndSetLevel(unit,'ursa_fury_swipes')
	end

	if owner:FindModifierByName('modifier_item_zhaohuanshenshi') ~= nil then
		AddAbilityAndSetLevel(unit,'zhaohuanshenshi')
		play_particle('effect/zhaohuanshenshi/fallback_low.vpcf',PATTACH_ABSORIGIN_FOLLOW,unit,3)
	end
end
function FurTree(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local p = keys.target_points[1]

	Timers:CreateTimer(0.1,function()
		local w = SummonOneMinion(caster, 'fur_tree'..level, p)
		play_particle("particles/units/heroes/hero_furion/furion_force_of_nature_cast.vpcf",PATTACH_OVERHEAD_FOLLOW,w,3)
		ExtendBeastBuff(w,caster)
	end)

	if level >= 2 then
		Timers:CreateTimer(0.6,function()
			local p2 = FindUnluckyPoint(caster)
			local w = SummonOneMinion(caster, 'fur_tree'..level, p2)
			play_particle("particles/units/heroes/hero_furion/furion_force_of_nature_cast.vpcf",PATTACH_OVERHEAD_FOLLOW,w,3)
			ExtendBeastBuff(w,caster)
		end)
	end
end
function LdBear(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	Timers:CreateTimer(0.1,function()
		local w = SummonOneMinion(caster,'ld_bear'..level)
		ExtendBeastBuff(w,caster)
	end)
end
function BmBeast(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	Timers:CreateTimer(0.1,function()
		local w = SummonOneMinion(caster,'bm_beast'..level)
		ExtendBeastBuff(w,caster)
		if w:GetUnitName() == 'bm_beast3' then
			--3级熊，嘲讽
			Timers:CreateTimer(0.3,function()
				ExecuteOrderFromTable({
			 		UnitIndex = w:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
			 		TargetIndex = nil, --Optional.  Only used when targeting units
			 		AbilityIndex = w:FindAbilityByName('bm_bear_taunt'):entindex(), --Optional.  Only used when casting abilities
			 		Position = nil, --Optional.  Only used when targeting the ground
			 		Queue = 0 --Optional.  Used for queueing up abilities
			 	})
			end)
		end
	end)
end
function BmBearTaunt(keys)
	local caster = keys.caster
	local position = caster:GetAbsOrigin()
	local team = caster.team_id
	local unlucky_dogs = FindUnitsInRadiusByTeam({
		team = team,
		role = 2,
		position = position,
		radius = 205,
	})

	for _,u in pairs(unlucky_dogs) do 
		ExecuteOrderFromTable({
	 		UnitIndex = u:entindex(), 
	 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
	 		TargetIndex = caster:entindex(), 
	 		Queue = 0
	 	})
	end
end
function FindTauntEnemy(unit)
	local taunt_table = {}
	if (unit.at_team_id or unit.team_id) == nil or GameRules:GetGameModeEntity().to_be_destory_list[unit.at_team_id or unit.team_id] == nil then
		return taunt_table
	end
	for _,u in pairs(GameRules:GetGameModeEntity().to_be_destory_list[unit.at_team_id or unit.team_id]) do
		if IsUnitExist(u) == true and (unit:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() <= u:Script_GetAttackRange() and unit:GetTeam() ~= u:GetTeam() then
			table.insert(taunt_table,u)
		end
	end
	return taunt_table
end
function TauntEnemy(keys)
	local caster = keys.caster
	local unlucky_dogs = FindTauntEnemy(caster)

	for _,u in pairs(unlucky_dogs) do 
		if u:IsChanneling() == false and u:HasModifier('modifier_is_nraqi_buff') == false then
			ExecuteOrderFromTable({
		 		UnitIndex = u:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
		 		TargetIndex = caster:entindex(), 
		 		Queue = 0
		 	})
		 	Taunt(u,caster)
		end
	end
end
--caster嘲讽u
function Taunt(u,caster)
	if u.taunt_particle == nil then
		u.taunt_particle = ParticleManager:CreateParticle('effect/taunt_debuff/1.vpcf', PATTACH_OVERHEAD_FOLLOW, u)
		u.taunt_target = caster
		Timers:CreateTimer(0.5,function()
			if IsUnitExist(u.taunt_target) == false or IsUnitExist(u) == false then
				--caster或者u死亡，嘲讽终止
				ParticleManager:DestroyParticle(u.taunt_particle,true)
				u.taunt_particle = nil
				u.taunt_target = nil
				return
			end
			if (u.taunt_target:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() > u:Script_GetAttackRange() then
				--超出距离，嘲讽终止
				ParticleManager:DestroyParticle(u.taunt_particle,true)
				u.taunt_particle = nil
				u.taunt_target = nil
				return
			end
			return 0.5
		end)
	end
end
function HealAlly(keys)
	local caster = keys.caster
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	for _,unit in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id == team_id and unit:HasAbility('is_ward') == false then
			local hp_base = unit:GetMaxHealth()
			unit:Heal(math.ceil(hp_base/25),unit)
		end
	end
end
function CKillusion(keys)
	local caster = keys.caster
	play_particle("particles/units/heroes/hero_chaos_knight/chaos_knight_phantasm.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)
	EmitSoundOn("Hero_ChaosKnight.Phantasm",caster)
	Timers:CreateTimer(0.1,function()
		local i1 = SummonOneMinion(caster,'chess_ck_ssr_illusion')
		i1:AddNewModifier(i1,nil,"modifier_illusion",{duration=60})
		i1:SetMaxMana(0)
		Timers:CreateTimer(0.2,function()
			local i2 = SummonOneMinion(caster,'chess_ck_ssr_illusion')
			i2:AddNewModifier(i1,nil,"modifier_illusion",{duration=60})
			i2:SetMaxMana(0)
			Timers:CreateTimer(0.3,function()
				local i3 = SummonOneMinion(caster,'chess_ck_ssr_illusion')
				i3:AddNewModifier(i1,nil,"modifier_illusion",{duration=60})
				i3:SetMaxMana(0)
			end)
		end)
	end)
end
function SummonOneMinion(caster, minion, p, chessai)
	if caster == nil then
		return
	end
	if chessai == nil then
		chessai = true
	end
	local v = p or FindEmptyGridAtUnit(caster)
	local teamid = caster.team_id
	local at_teamid = caster.at_team_id or caster.team_id

	if v == nil then
		return
	end
	if teamid == nil then
		return
	end
	if at_teamid == nil then
		return
	end

	--判断英雄是否还活着
	local hero1 = TeamId2Hero(at_teamid)
	if hero1 == nil or hero1:IsNull() or hero1:IsAlive() == false then
		return
	end

	if GameRules:GetGameModeEntity().battle_timer <= 1 then
		return
	end
	
	local x = CreateUnitByName(minion,v,true,nil,nil,teamid)
	x.is_summoned = true

	table.insert(GameRules:GetGameModeEntity().to_be_destory_list[at_teamid],x)
	x:SetForwardVector(caster:GetForwardVector() or Vector(0,1,0))
	AddAbilityAndSetLevel(x,'root_self')
	AddAbilityAndSetLevel(x,'jiaoxie_wudi')
	x.x = Vector2X(v,at_teamid)
	x.y = Vector2Y(v,at_teamid)
	x.y_x = ''..x.y..'_'..x.x
	if caster.at_team_id ~= nil then
		x.at_team_id = caster.at_team_id
	end
	if caster.team_id ~= nil then
		x.team_id = caster.team_id
	end
	GameRules:GetGameModeEntity().unit[at_teamid][x.y..'_'..x.x] = 1
	if chessai == true then
		Timers:CreateTimer(function()
			if x == nil or x:IsNull() == true or x:IsAlive() == false or x.alreadywon == true then
				return
			end
			ChessAI(x)
			return 1
		end)
	end
	return x
end

function FindAClosestEnemyAndAttack(u)
	-- if u:HasAbility('mars_bulwark') then
	-- 	--玛尔斯
	-- 	if u:FindAbilityByName('mars_shield') ~= nil and u:GetAttackTarget() ~= nil and u:FindAbilityByName('mars_shield'):GetCooldownTimeRemaining() < 0.1 then
	-- 		local target = u:GetAttackTarget()
	-- 		-- u:SwapAbilities('mars_bulwark','mars_shield', false, true)
	-- 		Timers:CreateTimer(0.1,function()
	-- 			if u:FindAbilityByName('mars_shield') ~= nil then
	-- 				ExecuteOrderFromTable({
	-- 			 		UnitIndex = u:entindex(), 
	-- 			 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	-- 			 		TargetIndex = nil, --Optional.  Only used when targeting units
	-- 			 		AbilityIndex = u:FindAbilityByName('mars_shield'):entindex(), --Optional.  Only used when casting abilities
	-- 			 		Position = nil, --Optional.  Only used when targeting the ground
	-- 			 		Queue = 0 --Optional.  Used for queueing up abilities
	-- 			 	})
	-- 			end
	-- 		end)
	-- 		return 1.5
	-- 	-- elseif u.taunt_target ~= nil and u.taunt_target:IsNull() == false and u.taunt_target:IsAlive() and (u:GetAbsOrigin() - u.taunt_target:GetAbsOrigin()):Length2D() < 205 then
	-- 	-- 	u:SetForwardVector((u.taunt_target:GetAbsOrigin() - u:GetAbsOrigin()):Normalized())
	-- 	-- 	ExecuteOrderFromTable({
	-- 	-- 		UnitIndex = u:entindex(), 
	-- 	-- 		OrderType = DOTA_UNIT_ORDER_HOLD_POSITION,
	-- 	-- 		Position = u:GetAbsOrigin(),
	-- 	-- 		Queue = 0 
	-- 	-- 	})
	-- 	-- else
	-- 	-- 	ExecuteOrderFromTable({
	-- 	--  		UnitIndex = u:entindex(), 
	-- 	--  		OrderType = DOTA_UNIT_ORDER_MOVE_TO_POSITION,
	-- 	--  		TargetIndex = target:entindex(), 
	-- 	--  		Position = target:GetAbsOrigin(),
	-- 	--  		Queue = 0 
	-- 	--  	})
	-- 	end
	-- 	-- return 1
	-- end
	if u:HasModifier('modifier_mk_ruyibangfa_stack') and u:GetAttackTarget() ~= nil then
		--大圣棒鸡
		local count = u:FindModifierByName('modifier_mk_ruyibangfa_stack'):GetStackCount()
		if count >= 4 and u:IsSilenced() == false and u:IsStunned() == false and u:IsFrozen() == false and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and u:IsHexed() == false and u:IsCommandRestricted() == false and u:HasModifier("modifier_axe_berserkers_call") == false then
			u:RemoveModifierByName('modifier_mk_ruyibangfa_stack')
			if u:FindAbilityByName('monkey_king_boundless_strike') ~= nil then
				ExecuteOrderFromTable({
			 		UnitIndex = u:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
			 		TargetIndex = nil, --Optional.  Only used when targeting units
			 		AbilityIndex = u:FindAbilityByName('monkey_king_boundless_strike'):entindex(), --Optional.  Only used when casting abilities
			 		Position = u:GetAttackTarget():GetAbsOrigin(), --Optional.  Only used when targeting the ground
			 		Queue = 0, --Optional.  Used for queueing up abilities
			 	})
			end
			return 1.5
		end
	end
	
	local team_id = u.at_team_id or u.team_id
	local all_unit = GameRules:GetGameModeEntity().to_be_destory_list[team_id]
	local attack_range = u:Script_GetAttackRange()
	local attack_target_enemy = nil
	local attack_target_enemy_alt = nil

	-- if u:HasAbility('is_dwarf_buff') == false or u:HasAbility('is_dwarf_buff_plus') == false then
	if u:HasModifier('modifier_is_dwarf_buff') == false and u:HasModifier('modifier_is_dwarf_buff_plus') == false then
		--已经有目标
		if u:GetAttackTarget() ~= nil and u:GetAttackTarget() ~= nil and u:GetAttackTarget():IsNull() == false and u:GetAttackTarget():IsInvisible() == false and u:GetAttackTarget():IsAlive() == true and (u:GetAttackTarget():GetAbsOrigin() - u:GetAbsOrigin()):Length2D() < u:Script_GetAttackRange() + u:GetAttackTarget():GetHullRadius() + u:GetHullRadius() then

			local target_at_team_id = u:GetAttackTarget().at_team_id or u:GetAttackTarget().team_id
			if u:GetAttackTarget():FindModifierByName('modifier_winter_wyvern_cold_embrace') == nil and IsBozangWudi(u:GetAttackTarget()) ~= true and IsChessKnight3Wudi(u:GetAttackTarget()) ~= true and team_id == target_at_team_id then
				return 1
			end
		end
		--非矮人，选择一个较近的目标攻击
		local closest_distance = 9999
		local closest_distance_alt = 9999

		for _,v in pairs(all_unit) do
			if v ~= nil and v:IsNull() == false and v:IsAlive() == true then
				if v.team_id ~= u.team_id and v:IsInvisible() == false then
					local d = (v:GetAbsOrigin() - u:GetAbsOrigin()):Length2D()
					if d < closest_distance and d < attack_range + v:GetHullRadius() + u:GetHullRadius() and v:HasModifier("modifier_winter_wyvern_cold_embrace") ~= true and IsBozangWudi(v) ~= true and IsChessKnight3Wudi(v) ~= true then
						attack_target_enemy = v
						closest_distance = d
					end
					if d < closest_distance_alt and d < attack_range + v:GetHullRadius() + u:GetHullRadius() then
						attack_target_enemy_alt = v
						closest_distance_alt = d
					end
				end
			end
		end

		if attack_target_enemy ~= nil then
			RemoveAbilityAndModifier(u,'jiaoxie')
			u.attack_target = attack_target_enemy
			if u:GetAttackTarget() == nil or u:GetAttackTarget():FindModifierByName('modifier_winter_wyvern_cold_embrace') ~= nil or IsBozangWudi(u:GetAttackTarget()) == true or IsChessKnight3Wudi(u:GetAttackTarget()) == true then
				local newOrder = {
			 		UnitIndex = u:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			 		TargetIndex = u.attack_target:entindex(), 
			 		Queue = 0 
			 	}
				ExecuteOrderFromTable(newOrder)
			elseif string.find(u:GetUnitName(), 'pve') ~= nil then
				local newOrder = {
			 		UnitIndex = u:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			 		TargetIndex = u.attack_target:entindex(), 
			 		Queue = 0 
			 	}
				ExecuteOrderFromTable(newOrder)
			end
			return 1
		else
			u.attack_target = nil
			return nil
		end
	else
		--矮人，选择一个血量较低的目标攻击
		local min_hp = 999999
		local min_hp_alt = 999999

		for _,v in pairs(all_unit) do
			if v ~= nil and v:IsNull() == false and v:IsAlive() == true then
				if v.team_id ~= u.team_id and v:IsInvisible() == false then
					local h = v:GetHealth()
					local d = (v:GetAbsOrigin() - u:GetAbsOrigin()):Length2D()
					if h < min_hp and d < attack_range + v:GetHullRadius() + u:GetHullRadius() and v:HasModifier("modifier_winter_wyvern_cold_embrace") ~= true and IsBozangWudi(v) ~= true and IsChessKnight3Wudi(u:GetAttackTarget()) ~= true then
						attack_target_enemy = v
						min_hp = h
					end
					if h < min_hp_alt and d < attack_range + v:GetHullRadius() + u:GetHullRadius() then
						attack_target_enemy_alt = v
						min_hp_alt = h
					end
				end
			end
		end
		if attack_target_enemy ~= nil then
			RemoveAbilityAndModifier(u,'jiaoxie')
			u.attack_target = attack_target_enemy
				local newOrder = {
			 		UnitIndex = u:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			 		TargetIndex = u.attack_target:entindex(), 
			 		Queue = 0 
			 	}
				ExecuteOrderFromTable(newOrder)
			return 1
		else
			u.attack_target = nil
			return nil
		end
	end
end

function AddLoseStreak(team)
	local hero = GameRules:GetGameModeEntity().teamid2hero[team]
	if hero.lose_streak == nil then
		hero.lose_streak = 0
	end
	hero.lose_streak = hero.lose_streak + 1
end
function RemoveLoseStreak(team)
	local hero = GameRules:GetGameModeEntity().teamid2hero[team]
	hero.lose_streak = 0
end
function AddWinStreak(team)
	local hero = GameRules:GetGameModeEntity().teamid2hero[team]
	if hero.win_streak == nil then
		hero.win_streak = 0
	end
	hero.win_streak = hero.win_streak + 1

	--连胜膨胀
	local sca = (hero.init_model_scale or 1)+hero.win_streak*0.1
	if sca >= (hero.init_model_scale or 1) + 1 then
		sca = (hero.init_model_scale or 1) + 1
		--起飞！
		if GameRules:GetGameModeEntity().egg_quest == 'q012' then
			SetQuest(hero.team_id,true)
		end
		play_particle("particles/units/heroes/hero_shadowshaman/shadowshaman_voodoo.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,3)
		local new_m = ChangeFlyingCourierModel(hero.ori_model)
		hero:SetOriginalModel(new_m)
		hero:SetModel(new_m)
		MakeGreevil(hero,true)
		AddAbilityAndSetLevel(hero,'courier_fly')

		ShowCourierEffect(hero,2)
	end
	hero:SetModelScale(sca)
	if hero.win_streak == 5 or hero.win_streak == 8 or hero.win_streak == 10 then
		for i=6,13 do
			CustomGameEventManager:Send_ServerToTeam(i,"win_streak",{
				key = GetClientKey(i),
				player_id = hero:GetPlayerID(),
				streak = hero.win_streak,
				is_vip = hero.is_vip,
			})
		end
		if hero.is_crown == true then
			ShowCrown(hero,2)
		end
	end

	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = hero:GetPlayerID(),
		hp = hero:GetHealth(),
		hp_max = hero:GetMaxHealth(),
		mp = hero:GetMana(),
		level = hero:GetLevel(),
		win_streak = hero.win_streak,
	})
end
function RemoveWinStreak(team, attacker_team)
	local hero = GameRules:GetGameModeEntity().teamid2hero[team]
	local ws = hero.win_streak
	if hero ~= nil and hero.win_streak ~= nil and hero.win_streak >= 5 then
		--扎破
		if attacker_team ~= nil and attacker_team ~= team then
			local attacker = TeamId2Hero(attacker_team)
			if GameRules:GetGameModeEntity().egg_quest == 'q021' then
				SetQuest(attacker_team,true)
			end
			-- AddMana(attacker, ws)
			-- for i=1,ws do
			-- 	DropOneGGItem('item_money',hero,attacker_team,true)
			-- end
			local position_to = CenterVector(attacker_team) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
			DropMoneyBag(Vector(0,0,128), position_to, 100, ( ws or 1 ))

			--扎破者获得奖励
			ShowCombat({
				t = 'terminate',
				player = hero:GetPlayerID(),
				player2 = attacker:GetPlayerID(),
				num = ws,
			})
		end


		EmitSoundOn("DOTA_Item.AbyssalBlade.Activate",hero)
		play_particle("particles/items_fx/abyssal_blade_jugger.vpcf",PATTACH_OVERHEAD_FOLLOW,hero,3)

		hero:SetOriginalModel(hero.ori_model)
		hero:SetModel(hero.ori_model)
		MakeGreevil(hero,false)
		RemoveAbilityAndModifier(hero,'courier_fly')

		ShowCourierEffect(hero,1)
		if hero.is_crown == true then
			ShowCrown(hero,1)
		end

		


	end
	hero.win_streak = 0
	hero:SetModelScale(hero.init_model_scale or 1)

	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = hero:GetPlayerID(),
		hp = hero:GetHealth(),
		hp_max = hero:GetMaxHealth(),
		mp = hero:GetMana(),
		level = hero:GetLevel(),
		win_streak = hero.win_streak,
	})
end


--调用寻路算法
function FindPath(p1,p2,team)
	local map = {
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
	}

	for u,v in pairs(GameRules:GetGameModeEntity().unit[team]) do
		local y = tonumber(string.split(u,'_')[1])
		local x = tonumber(string.split(u,'_')[2])
		if v == 1 then
			map[y][x] = 1
		end
	end

	-- Value for walkable tiles
	local walkable = 0

	-- Library setup
	local Grid = require ("pathfinder/grid") -- The grid class
	local Pathfinder = require ("pathfinder/pathfinder") -- The pathfinder lass

	-- Creates a grid object
	local grid = nil

	grid = Grid(map)
	--grid = Grid(map)

	-- Creates a pathfinder object using Jump Point Search
	local myFinder = nil
	myFinder = Pathfinder(grid, 'JPS', walkable)

	-- Define start and goal locations coordinates
	local startx, starty = Vector2X(p1,team),Vector2Y(p1,team)
	local endx, endy = Vector2X(p2,team), Vector2Y(p2,team)

	map[starty][startx] = 0

	--local startx, starty = 2,2
	--local endx, endy = 9,9

	-- Calculates the path, and its length
	local path, length = myFinder:getPath(startx, starty, endx, endy)

	if path then
		local dx = 0
		local dy = 0
		local lastx = -100
		local lasty = -100
		local lastdx = -100
		local lastdy = -100
		local lastd = -100
		local d = 0
		local pppp = {}

		for node, count in path:iter() do

			dx = node.x-lastx
			dy = node.y-lasty

			if dy==0 then
				d = 999
			else
				d = dx/dy
			end

			local lastindex = table.maxn (pppp)

			if d~=lastd or lastindex<=1 then
				table.insert (pppp, node)
			else
				pppp[lastindex] = node
			end
			lastdx = dx
			lastdy = dy
			lastx = node.x
			lasty = node.y
			lastd = d

		end

		--找到路了
		for _,node in pairs(pppp) do
			if node.x ~= startx or node.y ~= starty then
				
				-- if node.x > startx + 1 then
				-- 	node.x = startx + 1
				-- end
				-- if node.x < startx - 1 then
				-- 	node.x = startx - 1
				-- end
				-- if node.y > starty + 1 then
				-- 	node.y = starty + 1
				-- end
				-- if node.y < starty - 1 then
				-- 	node.y = starty - 1
				-- end

				local p_next = XY2Vector(node.x,node.y,team)

				return p_next
			end
		end

		return nil
	else
		--没找到路
		return nil
	end
end

function InitChessPool()
	local remove_table = RandomLegendary()
	CustomNetTables:SetTableValue( "chess_pool_table", "legendary_info", {banned = remove_table,
		active = GameRules:GetGameModeEntity().chess_list_by_mana[5],hehe = RandomInt(1,1000)})
	local chess_pool_times = GameRules:GetGameModeEntity().CHESS_POOL_SIZE or 6
	for cost,v in pairs(GameRules:GetGameModeEntity().chess_list_by_mana) do
		for _,chess in pairs(v) do
			local chess_count = GameRules:GetGameModeEntity().CHESS_INIT_COUNT[cost]*chess_pool_times
			for i=1,chess_count do
				AddAChessToChessPool(chess)
			end
		end
	end

	CustomNetTables:SetTableValue( "chess_pool_table", "synergy_info", GameRules:GetGameModeEntity().chess_list_by_synergy )

	combat('INIT CHESS POOL OK!')
end

function DrawAChessFromChessPool(cost, table_11chess, table_ban_chess, table_ban_chess2,h)
	--初始化1/2/3/4/5费棋子非气值
	if h.cost_n_table == nil then
		h.cost_n_table = {
			[1] = nil,
			[2] = nil,
			[3] = nil,
			[4] = nil,
			[5] = nil,
		}
	end
	for i=1,5 do
		if h.cost_n_table[i] == nil then
			h.cost_n_table[i] = {}
			for _,chess in pairs(GameRules:GetGameModeEntity().chess_list_by_mana[i]) do
				h.cost_n_table[i][chess] = 0
			end
		end
	end

	--检测非气阈值是否达到
	local all_count = 0
	local all_type = 0
	local chess_n_table = h.cost_n_table[cost]
	for _,chess_count in pairs(chess_n_table) do
		all_count = all_count + chess_count
		all_type = all_type + 1 
	end
	local unluckykey = all_count/all_type
	if unluckykey > (GameRules:GetGameModeEntity().CHESS_AFRICA_VALUE[cost] or 1) then
		local least_chess_count = 999
		local least_chess = nil
		local zerocount = 0
		for chess,count in pairs(chess_n_table) do
			if count == 0 then
				zerocount = zerocount + 1
			end
			if count < least_chess_count then
				least_chess = chess
				least_chess_count = count
			end
		end
		h.cost_n_table[cost][least_chess] = h.cost_n_table[cost][least_chess] + 1
		if zerocount <= 1 then
			for chess,_ in pairs(chess_n_table) do
				h.cost_n_table[cost][chess] = 0
			end
		end
		local chess_exist = FindValueInTable(GameRules:GetGameModeEntity().chess_pool[cost],least_chess)
		local check_available = true
		if FindValueInTable(table_11chess,least_chess) == true or FindValueInTable(table_ban_chess,least_chess) == true or FindValueInTable(table_ban_chess2,least_chess) == true then
			check_available = false
		end
		local ban_available = true
		if h.synergy_banned ~= nil and FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy[h.synergy_banned],least_chess) == true then
			ban_available = false
		end
		if chess_exist == true and check_available == true and ban_available == true then
			RemoveOneKeyInTable(GameRules:GetGameModeEntity().chess_pool[cost],least_chess)
			return least_chess
		end			
	end


	if table_11chess == nil then
		table_11chess = {}
	end
	if table_ban_chess == nil then
		table_ban_chess = {}
	end
	if table_ban_chess2 == nil then
		table_ban_chess2 = {}
	end
	if GameRules:GetGameModeEntity().chess_pool[cost] == nil or table.maxn(GameRules:GetGameModeEntity().chess_pool[cost])<1 then
		--棋库空了
		return nil
	end
	local index = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().chess_pool[cost]))
	local chess_name = GameRules:GetGameModeEntity().chess_pool[cost][index]

	if FindValueInTable(table_11chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess2,chess_name) == true then
		return nil
	end
	if h.synergy_banned ~= nil and FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy[h.synergy_banned],chess_name) == true then
		return nil
	end
	if cost ~= nil and h.cost_n_table[cost] ~= nil and h.cost_n_table[cost][chess_name] ~= nil then
		h.cost_n_table[cost][chess_name] = h.cost_n_table[cost][chess_name] + 1
	end
	table.remove(GameRules:GetGameModeEntity().chess_pool[cost],index)
	return chess_name
end

function DrawAChessFromGoldPool(cost, table_11chess, table_ban_chess, table_ban_chess2, h)
	if table_11chess == nil then
		table_11chess = {}
	end
	if table_ban_chess == nil then
		table_ban_chess = {}
	end
	if table_ban_chess2 == nil then
		table_ban_chess2 = {}
	end

	local index = RandomInt(1,table.maxn(GameRules:GetGameModeEntity().chess_list_by_mana_gold))
	local chess_name = GameRules:GetGameModeEntity().chess_list_by_mana_gold[index]

	if FindValueInTable(table_11chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess2,chess_name) == true then
		return nil
	end
	if h.synergy_banned ~= nil and FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy[h.synergy_banned],chess_name) == true then
		return nil
	end

	return chess_name
end

function AddAChessToChessPool(chess)
	if string.find(chess,'ssr') then
		return
	end
	local maxcount = 1
	if string.find(chess,'11') ~= nil and (string.find(chess,'tp') ~= nil or string.find(chess,'eh') ~= nil or string.find(chess,'ld') ~= nil or string.find(chess,'fur') ~= nil) then
		chess = string.sub(chess,1,-3)
		maxcount = 4
	end
	if string.find(chess,'1') ~= nil and (string.find(chess,'tp') ~= nil or string.find(chess,'eh') ~= nil or string.find(chess,'ld') ~= nil or string.find(chess,'fur') ~= nil) then
		chess = string.sub(chess,1,-2)
		maxcount = 2
	end
	if string.find(chess,'11') ~= nil then
		chess = string.sub(chess,1,-3)
		maxcount = 9
	end
	if string.find(chess,'1') ~= nil then
		chess = string.sub(chess,1,-2)
		maxcount = 3
	end
	local special_piece = {'chess_io','chess_io1','chess_ember','chess_ember1','chess_ember11','chess_storm','chess_storm1','chess_storm11','chess_earth','chess_earth1','chess_earth11'}
	local is_removed_piece = false
	if FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_mana_gold,chess) ~= nil and FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_mana[5],chess) == nil then
		is_removed_piece = true
	end
	for count = 1,maxcount do
		if GameRules:GetGameModeEntity().chess_2_mana[chess] ~= nil and FindValueInTable(GameRules:GetGameModeEntity().chess_list_ssr,chess) == false and FindValueInTable(special_piece,chess) == false and is_removed_piece == false then
			local cost = GameRules:GetGameModeEntity().chess_2_mana[chess]
			table.insert(GameRules:GetGameModeEntity().chess_pool[cost],chess)
		end
	end
end

function PrintChessPool()
	local count = {
		[1] = 0,
		[2] = 0,
		[3] = 0,
		[4] = 0,
		[5] = 0,
	}
	local count_all = 0

	for i=1,5 do
		count[i] = table.maxn(GameRules:GetGameModeEntity().chess_pool[i])
		count_all = count_all + count[i]
	end

	prt('棋库有'..count_all..'个棋子（'..count[1]..'/'..count[2]..'/'..count[3]..'/'..count[4]..'/'..count[5]..'）')
end

function SendHTTP(url, callback, fail_callback)
	local str0 = url
	local str1 = ''
	local str2 = ''
	local str3 = ''
	local usercheck = 0
	local x1 = string.find(str0,'@',1)
	if x1 then
		usercheck = 1
		str1 = string.sub(str0,x1+1,-1)
	else
		str1 = str0
	end
	local x2 = string.find(str1,'@',1)
	if x2 then
		str2 = string.sub(str1,0,x2-1)
	else
		str2 = str1
	end
	local x3 = string.find(str2,'?',1)
	if x3 then
		str3 = string.sub(str2,0,x3-1)
	else
		str3 = str2
	end
	if usercheck == 1 then
		local usertable = string.split(str3,',')
		for _,userid in pairs(usertable) do
			if userid then
				if not string.find(GameRules:GetGameModeEntity().steamidlist,userid,1) and not string.find(GameRules:GetGameModeEntity().steamidlist_heroindex,userid,1) then
					return
				end
			end
		end
	end
	local req = CreateHTTPRequestScriptVM('GET', url)
	req:SetHTTPRequestAbsoluteTimeoutMS(20000)

    req:Send(function(res)
        if res.StatusCode ~= 200 or not res.Body then
            if fail_callback ~= nil then
            	fail_callback(obj)
            end
            return
        end

        local obj = json.decode(res.Body)
        if callback ~= nil then
        	callback(obj)
        end
    end)
end

function StatChess()
	local statinfo = {}
	for i=6,13 do
		for _,chess in pairs(GameRules:GetGameModeEntity().mychess[i]) do
			local find_name = chess.chess
			local chess_count = 1
			if string.find(chess.chess,'11') ~= nil and (string.find(chess.chess,'tp') ~= nil or string.find(chess.chess,'eh') ~= nil) then
				find_name = string.sub(chess.chess,1,-2)
				chess_count = 4
			end
			if string.find(chess.chess,'1') ~= nil and (string.find(chess.chess,'tp') ~= nil or string.find(chess.chess,'eh') ~= nil) then
				find_name = string.sub(chess.chess,1,-2)
				chess_count = 2
			end
			if string.find(chess.chess,'11') then
				chess_count = 9
				find_name = string.sub(chess.chess,1,-3)
			elseif string.find(chess.chess,'1') then
				chess_count = 3
				find_name = string.sub(chess.chess,1,-2)
			end
			if statinfo[find_name] == nil then
				statinfo[find_name] = chess_count
			else
				statinfo[find_name] = statinfo[find_name] + chess_count
			end
		end
	end
	for j=6,13 do
		local hhh = TeamId2Hero(j)
		if hhh ~= nil and hhh.hand_entities ~= nil then
			for _,ent in pairs(hhh.hand_entities) do
				local find_name = ent:GetUnitName()
				local chess_count = 1
				if string.find(ent:GetUnitName(),'11') then
					chess_count = 9
					find_name = string.sub(ent:GetUnitName(),1,-3)
				elseif string.find(ent:GetUnitName(),'1') then
					chess_count = 3
					find_name = string.sub(ent:GetUnitName(),1,-2)
				end
				if statinfo[find_name] == nil then
					statinfo[find_name] = chess_count
				else
					statinfo[find_name] = statinfo[find_name] + chess_count
				end
			end
		end
	end
	CustomNetTables:SetTableValue( "dac_table", "stat_chess", { statinfo = statinfo, hehe = RandomInt(1,1000)})
end

--辅助功能——捕捉一只螃蟹，发回pui
function DAC:OnCatchCrab(keys)
	local player_id = keys.PlayerID
	local urls = {
		ranking_top = 'http://autochess.ppbizon.com/ranking/top',
		refresh_shop = 'http://autochess.ppbizon.com/shop/v4/get',
		buy_courier = 'http://autochess.ppbizon.com/shop/v4/courier',
		buy_effect = 'http://autochess.ppbizon.com/shop/v4/effect',
		buy_projectile = 'http://autochess.ppbizon.com/shop/v4/projectile',
		buy_pet = 'http://autochess.ppbizon.com/shop/v4/pet',
		buy_animation = 'http://autochess.ppbizon.com/shop/v4/animation',
		buy_emotion = 'http://autochess.ppbizon.com/shop/v4/emotion',
		choose_hero = 'http://autochess.ppbizon.com/courier/change',
		lottery_go = 'http://autochess.ppbizon.com/shop/lottery',
		
		activate_cdkey = 'http://autochess.ppbizon.com/cdkey/act',
		jihuan_hero = 'http://autochess.ppbizon.com/shop/v4/collect',
		request_vote_chess = 'http://autochess.ppbizon.com/vip/vote',
		get_season_award = 'http://autochess.ppbizon.com/award/get',
		bet_ti9 = 'http://autochess.ppbizon.com/bet/ti9',
		merge_hero = 'http://autochess.ppbizon.com/courier/merge',

		recycle_hero = 'http://autochess.ppbizon.com/courier/del',
		recycle_effect = 'http://autochess.ppbizon.com/effect/del',
		recycle_projectile = 'http://autochess.ppbizon.com/projectile/del',
		recycle_animation = 'http://autochess.ppbizon.com/animation/del',
		recycle_pet = 'http://autochess.ppbizon.com/pet/del',
	}
	if urls[keys.event] ~= nil then
		local send_url = urls[keys.event]
		--user_specific=1：要带上@id
		if keys.user_specific == 1 then
			send_url = send_url..'/@'..GameRules:GetGameModeEntity().playerid2steamid[keys.PlayerID]
		end
		--这些情况有第二个@
		if keys.event == 'buy_effect' or keys.event == 'choose_hero' or keys.event == 'recycle_hero' or keys.event == 'activate_cdkey' or keys.event == 'jihuan_hero' or keys.event == 'merge_hero' or keys.event == 'buy_projectile' or keys.event == 'buy_animation' or keys.event == 'buy_pet' or keys.event == 'buy_emotion' or keys.event == 'recycle_effect' or keys.event == 'recycle_projectile' or keys.event == 'recycle_pet' or keys.event == 'recycle_animation' or keys.event == 'buy_courier' then
			send_url = send_url..'@'..keys.params['hero']
		end
		send_url = send_url..'?hehe='..RandomInt(1,10000)
		for i,v in pairs(keys.params) do
			send_url = send_url..'&'..i..'='..v
		end

		send_url = send_url..GetSendKey()

		Timers:CreateTimer(RandomFloat(0,1),function()
			-- print(send_url)
			SendHTTP(send_url,function(t)
				-- DeepPrintTable(t)
				if keys.event == 'bet_ti9' then
					GameRules:GetGameModeEntity().user_info[GameRules:GetGameModeEntity().playerid2steamid[keys.PlayerID]]['bet_info'] = t['team']
					CustomNetTables:SetTableValue( "dac_table", "player_info", { info = GameRules:GetGameModeEntity().user_info, hehe = RandomInt(1,1000)})
				end
				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player_id),'send_http_cb',{
					key = GetClientKey(GameRules:GetGameModeEntity().playerid2team[player_id]),
					event = keys.cb,
					data = json.encode(t),
				})
			end)
	    end)
	end
end
function DAC:OnUnlockChess(keys)
	local player_team = GameRules:GetGameModeEntity().playerid2team[keys.PlayerID]
	local hero = TeamId2Hero(player_team)

	if player_team ~= keys.team then
		hero.is_banned = true
		return
	end

	hero.chesslock = false
end
function DAC:OnLockChess(keys)
	local player_team = GameRules:GetGameModeEntity().playerid2team[keys.PlayerID]
	local hero = TeamId2Hero(player_team)

	if player_team ~= keys.team then
		hero.is_banned = true
		return
	end

	hero.chesslock = true
end

function NecSSRScythe(keys)
	local target = keys.target
	local caster = keys.caster
	local damage = 99999

	play_particle_controlIndex("particles/econ/items/necrolyte/necro_sullen_harvest/necro_ti7_immortal_scythe_start.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3,1)
	EmitSoundOn("Hero_Necrolyte.ReapersScythe.Target",target)

	EmitSoundOn("necrolyte_necr_kill_10",target)

	-- --如果目标受伤 就斩杀
	-- if target:GetHealth() < target:GetMaxHealth() then
	-- 	damage = 9999
	-- end

	Timers:CreateTimer(1.5,function()
		local damageTable = {
	    	victim=target,
	    	attacker=caster,
	    	damage_type=DAMAGE_TYPE_PURE,
	    	damage=damage
	    }
	    ApplyDamage(damageTable)
	end)
end

function play_particle_controlIndex(p, pos, u, d, controlIndex)
	local pp = ParticleManager:CreateParticle(p, pos, u)
	ParticleManager:SetParticleControl(pp,1,u:GetAbsOrigin())

	Timers:CreateTimer(d,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)
end

function MakeTiny(x)
	if not IsUnitExist(x) then
		return
	end
	if x:GetUnitName() == 'chess_tiny1' then
		-- x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny_03/glacial/glacial_tiny_03_head.vmdl"})
		-- x.part1:FollowEntity(x,true)
		x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny_03/glacial/glacial_tiny_03_body.vmdl"})
		x.part2:FollowEntity(x,true)
	end
	if x:GetUnitName() == 'chess_tiny11' then
		x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_back/tiny_bad_to_the_bone_back.vmdl"})
		x.part1:FollowEntity(x,true)
		x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_belt/tiny_bad_to_the_bone_belt.vmdl"})
		x.part2:FollowEntity(x,true)
		x.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_neck/tiny_bad_to_the_bone_neck.vmdl"})
		x.part3:FollowEntity(x,true)
		x.part4 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_shoulder/tiny_bad_to_the_bone_shoulder.vmdl"})
		x.part4:FollowEntity(x,true)

		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/tiny3/tiny_bad_to_the_bone_back.vpcf",
		})

		
	end

	-- if x:GetUnitName() == 'chess_mars1' then
	-- 	x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tidehunter/tidehunter_skull_weapon_lod.vmdl"})
	-- 	x.part2:FollowEntity(x,true)
	-- end

	

	-- if x:GetUnitName() == 'pve_roshan' then
	-- 	x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/creeps/roshan_halloween/roshan_halloween_angel.vmdl"})
	-- 	x.part1:FollowEntity(x,true)
	-- end
	-- if x:GetUnitName() == 'chess_tiny1' then
	-- 	x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/scarletquarry_head_t3/scarletquarry_head_t3.vmdl"})
	-- 	x.part1:FollowEntity(x,true)
	-- 	x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/scarletquarry_armor_t2/scarletquarry_armor_t2.vmdl"})
	-- 	x.part2:FollowEntity(x,true)
	-- 	x.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/scarletquarry_arms_t2/scarletquarry_arms_t2.vmdl"})
	-- 	x.part3:FollowEntity(x,true)
	-- 	x.part4 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/scarletquarry_offhand_t2/scarletquarry_offhand_t2.vmdl"})
	-- 	x.part4:FollowEntity(x,true)
	-- end
	-- if x:GetUnitName() == 'chess_mars11' then
	-- 	PlayParticleOnUnitUntilDeath({
	-- 		caster = x,
	-- 		p = "effect/mars/1/e.vpcf",
	-- 	})		
	-- end
	-- if x:GetUnitName() == 'chess_snap1' then
	-- 	PlayParticleOnUnitUntilDeath({
	-- 		caster = x,
	-- 		p = "effect/snap/1.vpcf",
	-- 	})		
	-- end
	-- if x:GetUnitName() == 'chess_snap11' then
	-- 	PlayParticleOnUnitUntilDeath({
	-- 		caster = x,
	-- 		p = "effect/snap/2.vpcf",
	-- 	})		
	-- end

	-- if x:GetUnitName() == 'chess_viper11' then
	-- 	x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/viper/venom_source_machinery_back/venom_source_machinery_back.vmdl"})
	-- 	x.part1:FollowEntity(x,true)
	-- 	x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/viper/venom_source_machinery_head/venom_source_machinery_head.vmdl"})
	-- 	x.part2:FollowEntity(x,true)
	-- 	x.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/viper/venom_source_machinery_tail/venom_source_machinery_tail.vmdl"})
	-- 	x.part3:FollowEntity(x,true)
	-- end

	if x:GetUnitName() == 'chess_luna11' then
		x:SetRangedProjectileName("particles/econ/items/luna/luna_ti9_weapon_gold/luna_ti9_gold_base_attack.vpcf")
	end
	if x:GetUnitName() == 'chess_luna1' then
		x:SetRangedProjectileName("particles/econ/items/luna/luna_ti9_weapon/luna_ti9_base_attack.vpcf")
	end

	if x.bh_bag ~= nil then
		x.bh_bag:Destroy()
	end

	PlaySpawnAnimation(x)

	-- if x:GetUnitName() == 'chess_bh' then
	-- 	if x.track_money_count ~= nil and x.track_money_count >= 4 then
	-- 		x.bh_bag = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/bounty_hunter/ti6_hunters_hoard/mesh/ti6_hunters_hoard_model.vmdl"})
	-- 		x.bh_bag:FollowEntity(x,true)
	-- 	else
	-- 		x.bh_bag = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/bounty_hunter/pack_of_the_blood_stained_sands/pack_of_the_blood_stained_sands.vmdl"})
	-- 		x.bh_bag:FollowEntity(x,true)
	-- 	end
	-- end
	-- if x:GetUnitName() == 'chess_bh1' then
	-- 	if x.track_money_count ~= nil and x.track_money_count >= 10 then
	-- 		x.bh_bag = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/bounty_hunter/ti6_hunters_hoard/mesh/ti6_hunters_hoard_model.vmdl"})
	-- 		x.bh_bag:FollowEntity(x,true)
	-- 	else
	-- 		x.bh_bag = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/bounty_hunter/pack_of_the_blood_stained_sands/pack_of_the_blood_stained_sands.vmdl"})
	-- 		x.bh_bag:FollowEntity(x,true)
	-- 	end
	-- end
	-- if x:GetUnitName() == 'chess_bh11' then
	-- 	if x.track_money_count ~= nil and x.track_money_count >= 50 then
	-- 		x.bh_bag = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/bounty_hunter/ti6_hunters_hoard/mesh/ti6_hunters_hoard_model.vmdl"})
	-- 		x.bh_bag:FollowEntity(x,true)
	-- 	else
	-- 		x.bh_bag = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/bounty_hunter/pack_of_the_blood_stained_sands/pack_of_the_blood_stained_sands.vmdl"})
	-- 		x.bh_bag:FollowEntity(x,true)
	-- 	end
	-- end
end


function TinyTouzhi(keys)
	local p = keys.target_points[1]
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	
	local radius = keys.radius or 200
	local damage = keys.damage or 100
	local stun_duration = keys.stun or 1

	local target = FindUnluckyDog190(caster)
	if target == nil or target.stop_moving == true or target.is_moving == true then
		return
	end

	local team_id = target.at_team_id or target.team_id
	local v = FindFarthestCanAttackEnemyEmptyGrid(caster)
	-- if v == nil or (v-target:GetAbsOrigin()):Length2D() < 400 then
	-- 	v = FindFarthestEmptyGrid(target)
	-- end
	if v == nil or (v-target:GetAbsOrigin()):Length2D() < 400 then
		v = target:GetAbsOrigin()
	end

	local yy = target.y
	local xx = target.x

	local y = Vector2Y(v,team_id)
	local x = Vector2X(v,team_id)
	-- local stun_duration = 1 --((v-target:GetAbsOrigin()):Length2D()/1000)


	Timers:CreateTimer(1+0.1,function()
		ApplyDamageInRadius({
			caster = caster,
			team = caster.team_id,
			radius = radius,
			role = 2,
			position = target:GetAbsOrigin(),
			damage = damage,
			damage_type = DAMAGE_TYPE_PHYSICAL,
			stun_duration = stun_duration,
			stun_partical = "particles/units/heroes/hero_tiny/tiny_toss_impact.vpcf",
			ability = 'tiny_touzhi',
		})
		play_particle("particles/units/heroes/hero_tiny/tiny_toss_impact.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
		EmitSoundOn('Ability.TossImpact',target)
	end)

	target:AddNewModifier(target,nil,"modifier_stunned",{ duration = 1+stun_duration })
	--先清除再添加，投掷原地后格子仍然可以占用
	GameRules:GetGameModeEntity().unit[team_id][yy..'_'..xx] = nil
	GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] = 1

	BlinkChessX({p=v,caster=target,blink_type='toss'})
	target.y_x = y..'_'..x
	target.y = y
	target.x = x
end

function FindFarthestEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local result_postion = nil
	local length2d = 0
	for x=1,8 do
		for y=1,8 do
			local pos = XY2Vector(x,y,team_id)
			if GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] == nil then
				if (u:GetAbsOrigin() - pos):Length2D() > length2d then
					result_postion = pos
					length2d = (u:GetAbsOrigin() - pos):Length2D()
				end
			end
		end
	end
	return result_postion
end

function QiquWaibiao(keys)
	local attacker = keys.attacker
	local caster = keys.caster
	local duration = keys.duration or 2

	if attacker:Script_GetAttackRange() < 250 then  
		--近战
		EmitSoundOn("Hero_Tiny.CraggyExterior",attacker)
		attacker:AddNewModifier(attacker,nil,"modifier_stunned",{ duration = duration })
		attacker:AddNewModifier(attacker,nil,"modifier_medusa_stone_gaze_stone",{ duration = duration })
	end
end

function DemonAttack(keys)
    local caster = keys.caster
    local target = keys.target

	--获取攻击伤害
    local damage = math.floor((keys.attack_damage or 0) / 2)
    local damageTable = {
    	victim=target,
    	attacker=caster,
    	damage_type=DAMAGE_TYPE_PURE,
    	damage=damage
    }
    ApplyDamage(damageTable)
end

function JinghunAttack(keys)
    local caster = keys.caster
    local target = keys.target
    local damage = keys.attack_damage

    if IsUnitExist(target) and (target.is_summoned == true or target.is_shifted == true or target:HasModifier('modifier_dragon_knight_dragon_form') or target:HasModifier('modifier_tb_mohua')) then
		--获取攻击伤害
	    local damage = 50
	    local damageTable = {
	    	victim=target,
	    	attacker=caster,
	    	damage_type=DAMAGE_TYPE_PURE,
	    	damage=damage
	    }
	    ApplyDamage(damageTable)
	    EmitSoundOn('DOTA_Item.DiffusalBlade.Target',target)
		play_particle("particles/items_fx/diffusal_slow.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
	end
end

function ChangeFlyingCourierModel(opp_model)
	local new_m = string.sub(opp_model,1,string.len(opp_model)-5)..'_flying.vmdl'

	if opp_model == "models/courier/mighty_boar/mighty_boar.vmdl" then
		new_m = "models/courier/mighty_boar/mighty_boar_wings.vmdl"
	end
	if opp_model == "models/courier/yak/yak.vmdl" then
		new_m = "models/courier/yak/yak_wings.vmdl"
	end
	if opp_model == "models/props_gameplay/donkey_dire.vmdl" then
		new_m = "models/props_gameplay/donkey_dire_wings.vmdl"
	end
	if opp_model == "models/props_gameplay/donkey.vmdl" then
		new_m = "models/props_gameplay/donkey_wings.vmdl"
	end
	if opp_model == "models/courier/juggernaut_dog/juggernaut_dog.vmdl" then
		new_m = "models/courier/juggernaut_dog/juggernaut_dog_wings.vmdl"
	end
	if opp_model == "models/items/juggernaut/ward/fortunes_tout/fortunes_tout.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant_flower_1.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant/hallowed_horde/hallowed_horde.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant/furion_treant_nelum_red/furion_treant_nelum_red.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant/ravenous_woodfang/ravenous_woodfang.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/shudaixiong/model/shudaixiong/shudaixiong.vmdl" then
		new_m = "models/shudaixiong/model/shudaixiong_flying/shudaixiong_flying.vmdl"
	end 
	if opp_model == "models/rongyanquan/rongyanquan.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/drodo/drodo.vmdl" then
		new_m = opp_model
	end

	return new_m
end

--type = round_pve/round_pvp/combine/battle/say/notice
--text = 要显示的文字
--player = 玩家id
function ShowCombat(keys)
	local combat_type = keys.t
	local combat_text = keys.text
	local combat_num = keys.num
	local combat_gold = keys.gold
	local combat_player = keys.player
	local combat_player2 = keys.player2
	local combat_hero = keys.hero
	local gameEvent = {}

	if GameRules:GetGameModeEntity().egg_quest == 'q009' then
		if combat_type == 'battle_pvp_win' and combat_num >= 10 then
			SetQuest(PlayerId2Hero(combat_player).team_id,true)
		end
		if combat_type == 'battle_pvp_lose' and combat_num >= 10 then
			SetQuest(PlayerId2Hero(combat_player2).team_id,true)
		end
	end

	if combat_player ~= nil then
		gameEvent["player_id"] = combat_player
	end
	if combat_player2 ~= nil then
		gameEvent["player_id2"] = combat_player2
	end
	if combat_text ~= nil then
		gameEvent["locstring_value"] = combat_text
	end
	if combat_num ~= nil then
		gameEvent["int_value"] = combat_num
	end
	if combat_hero ~= nil then
		gameEvent["hero_name"] = combat_hero
		gameEvent["heroname"] = combat_hero
	end
	-- gameEvent["teamnumber"] = -1
	-- gameEvent["message"] = "#text_combat_event_"..combat_type
	-- FireGameEvent( "dota_combat_event_message", gameEvent )

	if combat_type == 'round_pve' or combat_type == 'round_pvp' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'common',
			text = 'ROUND '..combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})	
	end
	if combat_type == 'battle_pve_win' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pve_win',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pve_draw' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pve_draw',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pve_lose' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pve_lose',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'battle_cloud_win' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_cloud_win',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_cloud_draw' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_cloud_draw',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_cloud_lose' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_cloud_lose',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'battle_pvp_win' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pvp_win',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pvp_draw' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pvp_draw',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pvp_lose' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pvp_lose',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'player_dead' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'player_dead',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			gold1 = combat_gold,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'terminate' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'terminate',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'drop_shengjian' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'drop_shengjian',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'player_get_lootbox' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'player_get_lootbox',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	

end

function DAC:OnChangeOndutyHero(keys)
	local player_id = keys.PlayerID
	local onduty_hero_new = keys.onduty_hero_new

	local onduty_hero = string.split(onduty_hero_new,'_')[1]
	local onduty_hero_effect = string.split(onduty_hero_new,'_')[2] or ''
	local onduty_hero_projectile = string.split(onduty_hero_new,'_')[4] or ''
	local onduty_hero_pet = string.split(onduty_hero_new,'_')[5] or ''
	local onduty_hero_animation = string.split(onduty_hero_new,'_')[6] or ''

	local hero = PlayerId2Hero(player_id)
	if keys.player_id ~= keys.PlayerID then
		hero.is_banned = true
		return
	end

	--装饰信使
	SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet, onduty_hero_animation)
	hero.is_changed_hero = true
	
	local steam_id = hero.steam_id
	local onduty_hero_model = GameRules:GetGameModeEntity().sm_hero_list[onduty_hero]

	SetStat(player_id,'zhugong',onduty_hero)
	SetStat(player_id,'zhugong_model',onduty_hero_model)
	SetStat(player_id,'zhugong_effect',onduty_hero_effect)
	GameRules:GetGameModeEntity().user_info[steam_id]['zhugong_model'] = onduty_hero_model
	GameRules:GetGameModeEntity().user_info[steam_id]['zhugong_effect'] = onduty_hero_effect
	GameRules:GetGameModeEntity().user_info[steam_id]['onduty_hero'] = onduty_hero
	GameRules:GetGameModeEntity().user_info[steam_id]['onduty_hero_effect'] = onduty_hero_effect

	CustomNetTables:SetTableValue( "dac_table", "player_info", { info = GameRules:GetGameModeEntity().user_info, hehe = RandomInt(1,1000)})

	RemoveAbilityAndModifier(hero,'courier_fly')
	if hero.flyup_effect ~= nil then
		ParticleManager:DestroyParticle(hero.flyup_effect,true)
	end
end
function DAC:OnPreviewEffect(keys)
	local h = PlayerId2Hero(keys.PlayerID) --   EntIndexToHScript(keys.hero_index)
	if h.is_preview_cd == true then
		return
	end
	h.is_preview_cd = true
	local e = keys.effect

	if string.find(GameRules:GetGameModeEntity().effect_list,e) then
		if h.effect ~= nil then
			h:RemoveAbility(h.effect)
			h:RemoveModifierByName('modifier_texiao_star')
		end
		h:AddAbility(e)
		h:FindAbilityByName(e):SetLevel(1)

		Timers:CreateTimer(5,function()
			h:RemoveAbility(e)
			h:RemoveModifierByName('modifier_texiao_star')
			if h.effect ~= nil then
				h:AddAbility(h.effect)
				h:FindAbilityByName(h.effect):SetLevel(1)
			end
			Timers:CreateTimer(5,function()
				h.is_preview_cd = false
			end)
		end)
	else
		h.is_banned = true
	end
end
function DAC:OnPreviewProjectile(keys)
	local hero = PlayerId2Hero(keys.PlayerID) --   EntIndexToHScript(keys.hero_index)
	if hero.is_preview_cd == true then
		return
	end
	hero.is_preview_cd = true
	local e = keys.projectile
	local pj = GameRules:GetGameModeEntity().projectile_list[e]

	for i=1,3 do
		Timers:CreateTimer(RandomFloat(1,3),function()
			PreviewProjectile(hero,e,pj)
		end)
	end

	Timers:CreateTimer(10,function()
		hero.is_preview_cd = false
	end)
end


function CollectAmazonData(dur,mode)
	local base_data = {
		version = '0.2',
		ticket = GameRules:GetGameModeEntity().dotamind_ticket,
		map_name = GetMapName(),
	    end_time= GameRules:GetGameModeEntity().send_time['end_time'],
	    duration= dur,
	    players = GameRules:GetGameModeEntity().send_info,
	    chess_detail = GameRules:GetGameModeEntity().upload_detail_stat,
	}
	return base_data
end

function SendHTTPPost(url,game_data,header_table)
    local req = CreateHTTPRequestScriptVM("POST",url)
    local json_data = json.encode(game_data)
    req:SetHTTPRequestHeaderValue("Content-Type", "application/json;charset=UTF-8")
    req:SetHTTPRequestRawPostBody("application/json;charset=UTF-8",json_data)
    if header_table ~= nil then
    	for h,t in pairs(header_table) do
    		req:SetHTTPRequestHeaderValue(h,t)
    	end
    end
    req:Send(function(res)
        if res.StatusCode ~= 200 or not res.Body then
            return
        end
        local obj = json.decode(res.Body)
        if obj and type(obj) == 'table' then
        	GameRules:GetGameModeEntity().dotamind_ticket = obj.ticket
        end
    end)
end

function FindRikiAndToggle(chess)
	if chess == nil or chess:GetTeam() == nil then
		return
	end
	local team = chess:GetTeam()

	local hand_riki = false
	if TeamId2Hero(team).hand_entities ~= nil then
		for _,ent in pairs(TeamId2Hero(team).hand_entities) do
			if ent:IsNull() ~= true and ent:FindAbilityByName('is_satyr') ~= nil then
				hand_riki = true
			end
		end
	end
	if hand_riki == true then
		HideBench(team)
		AddAbilityAndSetLevel(thischess,"invisible_to_enemy")
	else
		ShowBench(team)
		RemoveAbilityAndModifier(thischess,'invisible_to_enemy')
	end

	local prepare_riki = false
	if GameRules:GetGameModeEntity().to_be_destory_list[team] ~= nil then
		for _,ent in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team]) do
			if ent:FindAbilityByName('is_satyr') ~= nil then
				prepare_riki = true
			end
		end
	end
	if prepare_riki == true and GameRules:GetGameModeEntity().game_status == 1 then
		HidePrepare(team)
		AddAbilityAndSetLevel(thischess,"invisible_to_enemy")
	else
		ShowPrepare(team)
		RemoveAbilityAndModifier(thischess,'invisible_to_enemy')
	end
end
function HideBench(team)
	if TeamId2Hero(team).hand_entities ~= nil then
		for _,ent in pairs(TeamId2Hero(team).hand_entities) do
			AddAbilityAndSetLevel(ent,'invisible_to_enemy')
		end
	end
end
function ShowBench(team)
	if TeamId2Hero(team).hand_entities ~= nil then
		for _,ent in pairs(TeamId2Hero(team).hand_entities) do
			RemoveAbilityAndModifier(ent,'invisible_to_enemy')
		end
	end
end
function HidePrepare(team)
	if GameRules:GetGameModeEntity().to_be_destory_list[team] ~= nil then
		for _,ent in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team]) do
			AddAbilityAndSetLevel(ent,'invisible_to_enemy')
		end
	end
end
function ShowPrepare(team)
	if GameRules:GetGameModeEntity().to_be_destory_list[team] ~= nil then
		for _,ent in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team]) do
			RemoveAbilityAndModifier(ent,'invisible_to_enemy')
		end
	end
end

function FindARandomDogInAtTeam(team,is_host_dog)
	--在指定场地随便找只狗(场地，找主场狗？)
	local unluckydog = nil
	local try_count = 0
	if GameRules:GetGameModeEntity().to_be_destory_list[team] ~= nil then
		while unluckydog == nil and try_count < 100 do
			local uu = GameRules:GetGameModeEntity().to_be_destory_list[team][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[team]))]
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= 4 and is_host_dog == true then
				unluckydog = uu
			end
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id == 4 and is_host_dog ~= true then
				unluckydog = uu
			end
			try_count = try_count + 1
		end
		return unluckydog
	end
	return nil
end
function FindAHighLevelDogInAtTeam(team,is_host_dog)
	--在指定场地随便找只高等级狗(场地，找主场狗？)
	local unluckydog = nil
	local try_count = 0
	local max_level = 0

	if GameRules:GetGameModeEntity().to_be_destory_list[team] ~= nil then
		while unluckydog == nil and try_count < 100 do
			local uu = GameRules:GetGameModeEntity().to_be_destory_list[team][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[team]))]
			local lv = uu:GetLevel()
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= 4 and is_host_dog == true and lv > max_level then
				unluckydog = uu
				max_level = lv
			end
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id == 4 and is_host_dog ~= true and lv > max_level then
				unluckydog = uu
				max_level = lv
			end
			try_count = try_count + 1
		end
		return unluckydog
	end
	return nil
end


function HitPOMStart(keys)
	local a = keys.ability
	local caster = keys.caster
	a.start = caster:GetAbsOrigin()
end
function HitPOMTarget(keys)
	local caster = keys.caster
	local target = keys.target
	local a = keys.ability
	local start = a.start or caster:GetAbsOrigin() or Vector(0,0,0)
	local distance = (target:GetAbsOrigin() - start):Length2D()
	local min_damage = keys.min_damage
	local min_stun = keys.min_stun
	local max_damage = keys.max_damage
	local max_stun = keys.max_stun
	local max_distance = keys.max_distance

	if target == nil or target:IsNull() == true or target:IsAlive() == false then
		return
	end

	if BlockByLinken(target) == false then
		local stun_duration = min_stun + ((max_stun - min_stun)*(distance / max_distance)) or min_stun
		local damage = min_damage + ((max_damage - min_damage)*(distance / max_distance)) or min_damage

		play_particle("particles/econ/items/mirana/mirana_starstorm_bow/mirana_starstorm_starfall_attack.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
		EmitSoundOn('Ability.Starfall',target)

		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration })

		Timers:CreateTimer(0.5,function()
			if target == nil or target:IsNull() == true or target:IsAlive() == false then
				return
			end
			EmitSoundOn('Ability.StarfallImpact',target)
			if target:IsMagicImmune() == false then
				local damageTable = {
			    	victim=target,
			    	attacker=caster,
			    	damage_type=DAMAGE_TYPE_MAGICAL,
			    	damage=damage
			    }
			    ApplyDamage(damageTable)
			end
		end)
	end
end

function SlarkJump(keys)
	local caster = keys.caster
	local team_id = caster.at_team_id or caster.team_id
	local target = keys.target
	local origin_p = caster:GetAbsOrigin()
	local damage = keys.damage or 200
	local disarm_duration = keys.disarm_duration or 3
	local ability = keys.ability
	local level = ability:GetLevel() or 1

	local position = FindAJumpPosition(caster,target)
	if position ~= nil then
		local x = Vector2X(position,team_id)
		local y = Vector2Y(position,team_id)
		GameRules:GetGameModeEntity().unit[team_id][caster.y..'_'..caster.x] = nil
		GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] = 1
		caster.y_x = y..'_'..x
		caster.y = y
		caster.x = x
		
		BlinkChessX(
		{
			p = position,
			caster = caster,
			sound = "Hero_Slark.Pounce.Impact",
			animation = ACT_DOTA_CAST_ABILITY_2,
		})
		Timers:CreateTimer((position-origin_p):Length2D()/1000+0.2,function()
			if target == nil or target:IsNull() == true or target:IsAlive() == false then
				return
			end
			target:AddNewModifier(target,nil,"modifier_invoker_deafening_blast_disarm",{ duration = disarm_duration })
			local damageTable = {
		    	victim=target,
		    	attacker=caster,
		    	damage_type=DAMAGE_TYPE_PURE,
		    	damage=damage
		    }
		    ApplyDamage(damageTable)
		    EmitSoundOn("Hero_Slark.Pounce.Cast",target)
		    local pounce_effect = {
		    	[1] = "particles/units/heroes/hero_slark/slark_pounce_start.vpcf",
		    	[2] = "particles/econ/items/slark/slark_ti6_blade/slark_ti6_pounce_start.vpcf",
		    	[3] = "particles/econ/items/slark/slark_ti6_blade/slark_ti6_pounce_start_gold.vpcf",
			}
		    play_particle(pounce_effect[level],PATTACH_ABSORIGIN_FOLLOW,target,3)
		end)
	end
end
function FindAJumpPosition(caster,target)
	local team = caster.at_team_id or caster.team_id
	local pc = caster:GetAbsOrigin()
	local pt = target:GetAbsOrigin()
	local d = (pt-pc):Normalized()
	local p = pt+d*128
	local x = Vector2X(p,team)
	local y = Vector2Y(p,team)
	if IsIn8x8(x,y) == true and IsEmptyGrid(team,x,y) == true then
		return p
	else
		return nil
	end
end
function FindSlarkJumpUnluckyDogClosest(u)
	local unluckydog = nil
	local length2d = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		local pos = unit:GetAbsOrigin()
		if (my_pos - pos):Length2D() < length2d and unit.team_id ~= u.team_id and unit:IsInvisible() == false and FindAJumpPosition(u,unit) then
			unluckydog = unit
			length2d = (my_pos - pos):Length2D() 
		end
	end
	return unluckydog
end
function DAC:OnReport(keys)
	local steam_id = GameRules:GetGameModeEntity().playerid2steamid[keys.PlayerID]

	local report_str = keys.cheatuser..'_'..steam_id
	if GameRules:GetGameModeEntity().reportinfo[report_str] == nil and string.find(GameRules:GetGameModeEntity().steamidlist,keys.cheatuser) then
		SendHTTP('https://autochess.ppbizon.com/cheat/report?hehe='..RandomInt(1,10000)..'&cheatuser='..keys.cheatuser..'&reporter='..keys.reporter,function()
			end
		)
	end
end

function SilenceChess(keys)
	if keys.caster:GetUnitName() == 'npc_dota_hero_wisp' then
		keys.caster:RemoveModifierByName("modifier_silence")
	else
		keys.caster:AddNewModifier(keys.caster,nil,"modifier_silence",{})
	end
end

function CleaveAttack( keys )
    local caster = keys.caster
    local target = keys.target
    local damage = keys.damage
    local cleave_per = keys.cleave_per
    local cleave_radius = keys.cleave_radius

    --远程无效
    if caster:Script_GetAttackRange() > 300 then
    	return
    end

    local cleave_units = FindUnitsInRadiusByTeam({
		team = target:GetTeam(),
		role = 1,
		position = target:GetAbsOrigin(),
		radius = cleave_radius,
	})

	for _,unit in pairs(cleave_units) do
		if IsUnitExist(unit) == true and unit:entindex() ~= target:entindex() then
		    local attack_damage = damage*cleave_per/100
		    local damage_table = {
		    	victim = unit,
		    	attacker = caster,
		    	damage_type = DAMAGE_TYPE_PURE,
		    	damage = attack_damage
		    }
		    ApplyDamage(damage_table)
		end
	end
end

function HideCombo(keys)
	local team_id = keys.team_id
	local hero = TeamId2Hero(team_id)
	for _,k in pairs(GameRules:GetGameModeEntity().class_type) do
		hero:RemoveModifierByName('modifier_show_combo_'..k)
	end
end
function ShowCombo(keys)
	local team_id = keys.team_id
	local hero = TeamId2Hero(team_id)
	local combo_table = keys.combo_table

	AddAbilityAndSetLevel(hero,'show_combo')
	local ability = hero:FindAbilityByName('show_combo')

	for _,k in pairs(GameRules:GetGameModeEntity().class_type) do
		hero:RemoveModifierByName('modifier_show_combo_'..k)
	end

	local combo_array = {}
	for m,s in pairs(combo_table) do
		local sc = 0
		for score1,k in pairs(GameRules:GetGameModeEntity().class_type) do
			if k == m then
				sc = score1
			end
		end

		table.insert(combo_array,{
			m = m,
			s = s,
			score = s*10000 + sc
		})

	end

	table.sort(combo_array,function(a,b)
		return a.score > b.score
	end)

	--将种族/职业现在各有几个了的BUFF按顺序显示在信使上
	local combo_buff_str = ''
	for i = 1,table.maxn(combo_array) do
		local modifier_i = combo_array[i]
		combo_buff_str = combo_buff_str..modifier_i.m..':'..modifier_i.s..','
		local modifier_name = 'modifier_show_combo_'..modifier_i.m
		Timers:CreateTimer(i*0.03,function()
			ability:ApplyDataDrivenModifier(hero,hero,modifier_name,{})
			if hero:FindModifierByName(modifier_name) ~= nil then
				hero:FindModifierByName(modifier_name):SetStackCount(modifier_i.s)
			end
		end)
	end

	SetStat(hero:GetPlayerID(),'buff',combo_buff_str,false)
	StatAllPlayerLineup()
end

function StatClassCount(team_id)
	--通用技能
	local combo_chess_table_self = {}
	local combo_count_table_self = {}

	--第一次循环：棋子分组
	for w,vw in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if vw.team_id == team_id then --我的棋子
			for _,k in pairs(GameRules:GetGameModeEntity().class_type) do
				if combo_chess_table_self[k] == nil then
					combo_chess_table_self[k] = {}
				end
				if vw:FindAbilityByName(k) ~= nil then
					table.insert(combo_chess_table_self[k],vw)
				end
			end
		end
	end

	--第二次循环：计数
	for k,vk in pairs(combo_chess_table_self) do
		--统计不同的种类数
		local diff_count = 0
		local diff_string = ''
		for _,chess in pairs(combo_chess_table_self[k]) do
			--去掉等级变量
			local find_name = chess:GetUnitName()
			if string.find(find_name,'11') ~= nil then
				find_name = string.sub(find_name,1,-3)
			end
			if string.find(find_name,'1') ~= nil then
				find_name = string.sub(find_name,1,-2)
			end
			--搜索是否重复了
			if string.find(diff_string,find_name) == nil then
				diff_count = diff_count + 1
				diff_string = diff_string..'-'..find_name
			end
		end
		if diff_count > 0 then
			combo_count_table_self[k] = diff_count
		end
	end
	ShowCombo({
		team_id = team_id,
		combo_table = combo_count_table_self,
	})

	--统计所有buff
	for u,v in pairs(GameRules:GetGameModeEntity().combo_ability_type) do

	end
end

function GetClientKey(team)
	return GameRules:GetGameModeEntity().client_key[team]
end
function GetSendKey()
	return "&key="..GetDedicatedServerKey('drodo').."&key2="..GetDedicatedServerKeyV2('zzwdjs').."&key3="..GetDedicatedServerKeyV2('xgnb').."&key4="..GetDedicatedServerKeyV2('fgnb').."&key5="..GetDedicatedServerKeyV2('bsl,bgbxh')
end

--从某个玩家的手牌中寻找两个chess棋子，返回：有几个，第一个，第二个，第三个
function Find2SameChessInHand(caster,chess)
	if chess == 'chess_io1' or chess == 'chess_io' or chess == 'chess_ck_ssr' or chess == 'chess_nec_ssr' or chess == 'chess_ss_ssr' then
		--2星小精灵不参与合成
		return 0,nil,nil,nil
	end
	local count = 0
	local chess1 = nil
	local chess2 = nil
	local chess3 = nil
	if caster ~= nil and caster.hand_entities ~= nil then
		for _,v in pairs(caster.hand_entities) do
			if IsUnitExist(v) == true and v:GetUnitName() == chess and v:FindAbilityByName('is_druid') == nil then
				count = count + 1
				if count == 1 then
					chess1 = v
				end
				if count == 2 then
					chess2 = v
				end
				if count == 3 then
					chess3 = v
				end
			end
		end
		return count,chess1,chess2,chess3
	else
		return 0,nil,nil,nil
	end
end

function IsUnitExist(u)
	if u ~= nil and u:IsNull() == false and u:IsAlive() == true and u.is_removing ~= true then
		return true
	else
		return false
	end
end

--收集多个棋子的装备
function GetAllItemsInUnits(units)
	--收集棋子的物品
	local items_table = {}
	for _,vv in pairs(units) do
		if vv ~= nil then
			--记录装备情况
			for slot=0,9 do
				if vv:GetItemInSlot(slot)~= nil then
					local item = vv:GetItemInSlot(slot)
					local name = vv:GetItemInSlot(slot):GetAbilityName()
					local charges = vv:GetItemInSlot(slot):GetCurrentCharges()
					-- if item:IsPermanent() == false then
					-- 	--消耗品： 丢出来
					-- 	for i=1,charges do
					-- 		local newItem = CreateItem( name, vv, vv )
					-- 		local drop = CreateItemOnPositionForLaunch(vv:GetAbsOrigin(), newItem )
					-- 		local dropRadius = RandomFloat( 50, 200 )
					-- 		newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, vv:GetAbsOrigin() + RandomVector(dropRadius ))
					-- 	end
					-- else
						local item_name = vv:GetItemInSlot(slot):GetAbilityName()
						if item_name ~= 'item_null' then
							table.insert(items_table,item_name)
						end
					-- end
				end
			end
		end
	end
	return items_table
end
--把装备给棋子
function GiveItems2Unit(items,unit)
	for _,v in pairs(items) do
		-- prt('给'..unit:GetUnitName()..'装备：'..v)
		unit:AddItemByName(v)
	end
end

function DAC:OnSetAutoCombine(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)
	if hero ~= nil then
		hero.is_auto_combine = keys.is_auto_combine
	end
end

function AcidSpray(keys)
	local caster = keys.caster
	local ability_level = keys.ability_level

	InvisibleUnitCast({
		caster = caster,
		ability = 'ability_acid_spray',
		level = ability_level,
		unluckydog = nil,
		position = caster:GetAbsOrigin(),
		ignore_nether_ward = true,
	})
end

function ZeusThunder(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel() or 1
	local damage = keys.damage or 100
	local damage_per = keys.damage_per or 10

	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	EmitSoundOn("Hero_Zuus.GodsWrath",caster)
	local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_zuus/zuus_thundergods_wrath_start.vpcf",PATTACH_ABSORIGIN_FOLLOW, caster)
	ParticleManager:SetParticleControlEnt( pp, 0, u, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, u, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)
	
	local thunder_count = 0
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if v ~= nil and v:IsNull() == false and v:IsAlive() == true then
			if v.team_id ~= caster.team_id and RandomInt(0,100) >= 50 then
				ZeusThunderOne({
					caster = caster,
					victim = v,
					damage = math.floor(v:GetHealth()*damage_per/100 + damage),
				})
				thunder_count = thunder_count + 1
			end
		end
	end

	if thunder_count == 0 then
		local v = FindUnluckyDog(caster)
		if v ~= nil then
			ZeusThunderOne({
				caster = caster,
				victim = v,
				damage = math.floor(v:GetHealth()*damage_per/100 + damage),
			})
		end
	end
end
function ZeusThunderOne(keys)
	local caster = keys.caster
	local victim = keys.victim
	local damage = keys.damage
	EmitSoundOn('Hero_Zuus.GodsWrath.Target',victim)
    local pp = ParticleManager:CreateParticle("particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_strike.vpcf",PATTACH_ABSORIGIN_FOLLOW, victim)
	ParticleManager:SetParticleControlEnt( pp, 0, victim, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, victim, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)

	if victim:IsMagicImmune() == false then
		ApplyDamageDelay({
			caster = caster,
			victim = victim,
			damage = damage,
			damage_type = DAMAGE_TYPE_MAGICAL,
			delay = 0.5,
			p = "particles/units/heroes/hero_stormspirit/stormspirit_overload_discharge.vpcf",
		})
	end
end
function ApplyDamageDelay(keys)
	local caster = keys.caster
	local damage = keys.damage or 1
	local damage_type = keys.damage_type or DAMAGE_TYPE_MAGICAL
	local delay = keys.delay or 0
	local victim = keys.victim
	local ability = keys.ability
	local p = keys.p

	Timers:CreateTimer(delay,function()
		if victim ~= nil and victim:IsNull() == false and victim:IsAlive() == true then
			ApplyDamage({
				victim = victim,
				attacker = caster,
				damage_type = damage_type,
				damage = damage,
				ability = ability,
			})
			if p ~= nil then
				play_particle(p,PATTACH_ABSORIGIN_FOLLOW,victim,3)
			end
		end
	end)
end

function ZeusThunderCourier(zeus,courier,level)
	local caster = zeus
	local target = courier
	local damage_courier_per = 5.0+ 5*level

	local damage = math.floor(target:GetHealth() * damage_courier_per / 100)

	local after_hp = target:GetHealth() - damage
	if after_hp <= 0 then
		after_hp = 0
	end
	
	PlayParticleOnUnitUntilDeath({
		caster = caster,
		p = "particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_bolt_child.vpcf",
	})
	play_particle('particles/units/heroes/hero_stormspirit/stormspirit_overload_discharge.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)

	Timers:CreateTimer(RandomFloat(0.3,0.8),function()
		if target:IsHero() == true and after_hp <= 0 then
			target:ForceKill(false)
			GameRules:GetGameModeEntity().counterpart[target:GetTeam()] = -1
			SyncHP(target)
			target:SetMana(0)
			AMHC:CreateNumberEffect(target,damage_all,2,AMHC.MSG_MISS,"red",9)
			return
		end
		target:SetHealth(after_hp)
		SyncHP(target)
		AMHC:CreateNumberEffect(target,damage,2,AMHC.MSG_MISS,"red",9)
		EmitSoundOn("Frostivus.PointScored.Enemy",damage)
	end)
end

function MarsShieldDamage(keys)
	local caster = keys.caster
	local radius = 200
	local ability = keys.ability
	local attack_damage = keys.damage
	local damage_table = {
		[1] = 200,
		[2] = 250,
		[3] = 350,
	}
	local damage = damage_table[ability:GetLevel()]

	ApplyDamageInRadius({
		delay = 0.4,
		caster = caster,
		team = caster.team_id,
		radius = 225,
		role = 2,
		position = caster:GetAbsOrigin()+caster:GetForwardVector()*175,
		damage = damage,
		damage_type = DAMAGE_TYPE_PHYSICAL,
		ability = 'mars_bulwark',
		knockback = true,
	})
end

function StartMarsShieldCD(caster)
	if caster:HasAbility("mars_bulwark_attack") then
		if caster:HasAbility('is_god_buff_plus') then
			caster:FindAbilityByName("mars_bulwark_attack"):StartCooldown(8*0.25)
		elseif caster:HasAbility('is_god_buff') then
			caster:FindAbilityByName("mars_bulwark_attack"):StartCooldown(8*0.5)
		else
			caster:FindAbilityByName("mars_bulwark_attack"):StartCooldown(8)
		end
	end
end

function ShowCrown(hero,crown_level)
	if crown_level == nil then
		crown_level = 1
	end
	if not IsUnitExist(hero) then
		return
	end
	if hero.crown_p ~= nil then
		ParticleManager:DestroyParticle(hero.crown_p,true)
	end
	if hero.is_crown ~= true then
		return
	end
	-- if crown_level == 1 then
	-- 	hero.crown_p = PlayParticleOnUnitUntilDeath({
	-- 		caster = hero,
	-- 		p = "effect/crown/1.vpcf",
	-- 		pos = PATTACH_ABSORIGIN_FOLLOW,
	-- 	})
	-- end
	-- if crown_level == 2 then
	-- 	hero.crown_p = PlayParticleOnUnitUntilDeath({
	-- 		caster = hero,
	-- 		p = "effect/crown/2.vpcf",
	-- 		pos = PATTACH_OVERHEAD_FOLLOW,
	-- 	})
	-- end
	if crown_level == 1 then
		hero.crown_p = PlayParticleOnUnitUntilDeath({
			caster = hero,
			p = "effect/crown_s3/1.vpcf",
			pos = PATTACH_OVERHEAD_FOLLOW,
		})
	end
	if crown_level == 2 then
		hero.crown_p = PlayParticleOnUnitUntilDeath({
			caster = hero,
			p = "effect/crown_s3/2.vpcf",
			pos = PATTACH_OVERHEAD_FOLLOW,
		})
	end
end

function JoinTableString(t)
	local str = ''
	for _,v in pairs(t) do
		str = str..v..','
	end
	return str
end

function ShowCourierEffect(hero,type)
	if hero.flyup_effect ~= nil then
		ParticleManager:DestroyParticle(hero.flyup_effect,true)
	end
	if hero.ground_effect ~= nil then
		ParticleManager:DestroyParticle(hero.ground_effect,true)
	end
	if type == 1 then
		--陆地特效
		if hero.onduty_hero ~= nil and GameRules:GetGameModeEntity().courier_ground_effect_list[hero.onduty_hero] ~= nil then
			--陆地特效
			local ground_effect = GameRules:GetGameModeEntity().courier_ground_effect_list[hero.onduty_hero]
			hero.ground_effect = PlayParticleOnUnitUntilDeath({
				caster = hero,
				p = ground_effect,
			})
		end
	end
	if type == 2 then
		--飞行特效
		if hero.onduty_hero ~= nil and GameRules:GetGameModeEntity().courier_flyup_effect_list[hero.onduty_hero] ~= nil then
			--飞行特效
			local flyup_effect = GameRules:GetGameModeEntity().courier_flyup_effect_list[hero.onduty_hero]
			hero.flyup_effect = PlayParticleOnUnitUntilDeath({
				caster = hero,
				p = flyup_effect,
			})
		end
	end
end

function DropMoneyBag(from_position, to_position, radius, money)
	local newItem = CreateItem( "item_money", nil, nil )
	newItem:SetPurchaseTime( 0 )
	newItem:SetCurrentCharges( 1)
	newItem.money = money or 1

	local drop = CreateItemOnPositionSync( from_position, newItem )
	newItem:GetContainer():SetModelScale(1.4+( money or 1 )/15)

	local gg_item_dis = (to_position-Vector(0,0,128)):Length2D()
	local gg_item_t = gg_item_dis/800
	newItem:LaunchLoot( true, 600, gg_item_t, to_position )
end

function RandomDropOneGGItem(gg_item_one,gg_item_hero, my_team, is_auto_pick)
	if not is_auto_pick then
		is_auto_pick = false
	end
	local lucky_team = nil
	local try_count = 0
	while lucky_team == nil and try_count < 100 do 
		local random_team = RandomInt(6,13)
		local hero = TeamId2Hero(random_team)
		if hero ~= nil and hero:IsAlive() == true and random_team ~= my_team then
			lucky_team = random_team
		end
		try_count = try_count + 1
	end
	if lucky_team ~= nil then
		local newItem = CreateItem( gg_item_one, gg_item_hero, gg_item_hero )
		CreateItemOnPositionForLaunch(Vector(0,0,128), newItem )
		local gg_item_v = CenterVector(lucky_team) + Vector(RandomInt(-512,512),RandomInt(-512,512),0)
		local gg_item_dis = (gg_item_v-Vector(0,0,128)):Length2D()
		local gg_item_t = gg_item_dis/800
		newItem:LaunchLootInitialHeight( is_auto_pick, 0, 400, gg_item_t, gg_item_v)
	end
	return lucky_team
end
function DropOneGGItem(gg_item_one, gg_item_hero, lucky_team, is_auto_pick)
	if not is_auto_pick then
		is_auto_pick = false
	end

	if lucky_team ~= nil then
		local newItem = CreateItem( gg_item_one, gg_item_hero, gg_item_hero )
		CreateItemOnPositionForLaunch(Vector(0,0,128), newItem )
		local gg_item_v = CenterVector(lucky_team) + Vector(RandomInt(-512,512),RandomInt(-512,512),0)
		local gg_item_dis = (gg_item_v-Vector(0,0,128)):Length2D()
		local gg_item_t = gg_item_dis/1000
		newItem:LaunchLootInitialHeight( is_auto_pick, 0, 400, gg_item_t, gg_item_v)
	end
	return lucky_team
end


function OnKnightBuffCreate(keys)
	local caster = keys.caster
	if IsHexxed(caster) == true then
		RemoveAllKnightBuff(caster)
	end
end

function RemoveAllKnightBuff(u)
	if u:FindModifierByName('modifier_is_knight_buff_2') ~= nil then
		u:RemoveModifierByName('modifier_is_knight_buff_2')
	end
	if u:FindModifierByName('modifier_is_knight_buff_2_plus') ~= nil then
		u:RemoveModifierByName('modifier_is_knight_buff_2_plus')
	end
	if u:FindModifierByName('modifier_is_knight_buff_2_plus_plus') ~= nil then
		u:RemoveModifierByName('modifier_is_knight_buff_2_plus_plus')
	end
end

function TriggerHex(keys)
	local target = keys.target
	if IsUnitExist(target) then
		RemoveAllKnightBuff(target)
	end
end

function IsHexxed(u)
	if IsUnitExist(u) == false then
		return false
	end
	if u:FindModifierByName('modifier_hexxed') ~= nil then
		return true
	end
	if u:FindModifierByName('modifier_shadow_shaman_voodoo') ~= nil then
		return true
	end
	if u:FindModifierByName('modifier_lion_voodoo') ~= nil then
		return true
	end
	return false
end

function DAC:OnSelectDifficulty(keys)
	GameRules:GetGameModeEntity().difficulty = keys.difficulty or 2
end

function string.fromhex(str)
    return (str:gsub('..', function(cc)
        return string.char(tonumber(cc, 16))
    end))
end

function string.tohex(str)
    return (str:gsub('.', function (c)
        return string.format('%02X',string.byte(c))
    end))
end
function string.split(s, sep)
    if sep == nil then
            sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(s, "([^"..sep.."]+)") do
            t[i] = str
            i = i + 1
    end
    return t
end
function sign(key, msg)
	return sha2.hex2bin(sha2.hmac(sha2.sha256,key,msg))
end
function calmd5(str)
	return sha2.md5(str)
end
function getSignatureKey(key, dateStamp, regionName, serviceName)
    kDate = sign('AWS4'..key, dateStamp)
    kRegion = sign(kDate, regionName)
    kService = sign(kRegion, serviceName)
    kSigning = sign(kService, 'aws4_request')
    return kSigning
end
function SendAmazonData(ctx,amzdate,datestamp)
	local data_compressed = LibDeflate:CompressDeflate(json.encode(ctx));
	local data = {
	  StreamName = "report_reciver",
	  Data = base64.encode(data_compressed),
	  PartitionKey = 'AMAZON'..RandomInt(1,1000),
	}
	local body_data = json.encode(data)
	
	local method = 'POST'
	local service = 'kinesis'
	local host = 'kinesis.cn-north-1.amazonaws.com.cn'
	local region = 'cn-north-1'
	local endpoint = 'https://kinesis.cn-north-1.amazonaws.com.cn'
	local request_parameters = ""
	local enc_AWS_ACCESS_KEY_ID = "27715D326D6432E154E7D91D1662D7C14783D4ADE24394565A17BF91B6FD653A"
	local AWS_ACCESS_KEY_ID = aeslua.decrypt(GetDedicatedServerKeyV2('fgnb'),string.fromhex(enc_AWS_ACCESS_KEY_ID))
	local access_key = AWS_ACCESS_KEY_ID
	local enc_AWS_SECRET_ACCESS_KEY = "3C77FACD23AE027A4580075B1C5FC1B70339120A07B5FA37CC78A36B526045D84AA1493432AE6CBB443EFB9604C4AAD2"
	local AWS_SECRET_ACCESS_KEY = aeslua.decrypt(GetDedicatedServerKeyV2('fgnb'),string.fromhex(enc_AWS_SECRET_ACCESS_KEY))
	local secret_key = AWS_SECRET_ACCESS_KEY

	-- local method = 'POST'
	-- local service = 'kinesis'
	-- local host = 'kinesis.us-east-2.amazonaws.com'
	-- local region = 'us-east-2'
	-- local endpoint = 'https://kinesis.us-east-2.amazonaws.com'
	-- local request_parameters = ""
	-- local enc_AWS_ACCESS_KEY_ID = "032B547325EC3CA77B5A41BAA5E8B6E2782DAA707CF787D83F927EA83AF924D3"
	-- local AWS_ACCESS_KEY_ID = aeslua.decrypt(GetDedicatedServerKeyV2('bsl,bgbxh'),string.fromhex(enc_AWS_ACCESS_KEY_ID))
	-- local access_key = AWS_ACCESS_KEY_ID
	-- local enc_AWS_SECRET_ACCESS_KEY = '528D3C17F37D92A89DF81451B99D2ABE458689E62F5B9DD9E1D6AAE6C93B2B077554BF139D2C15ED745A0197D67C9BC8'
	-- local AWS_SECRET_ACCESS_KEY = aeslua.decrypt(GetDedicatedServerKeyV2('bsl,bgbxh'),string.fromhex(enc_AWS_SECRET_ACCESS_KEY))
	-- local secret_key = AWS_SECRET_ACCESS_KEY

	local canonical_uri = '/'
	local canonical_querystring = request_parameters
	local canonical_headers = 'host:'..host..'\n'..'x-amz-date:'..amzdate..'\n'
	local signed_headers = 'host;x-amz-date'
	local payload_hash = sha2.sha256(body_data)
	local canonical_request = method..'\n'..canonical_uri..'\n'..canonical_querystring..'\n'.. canonical_headers..'\n'..signed_headers..'\n'..payload_hash


	local algorithm = 'AWS4-HMAC-SHA256'
	local credential_scope = datestamp..'/'..region..'/'..service..'/'..'aws4_request'
	local string_to_sign = algorithm..'\n'..amzdate..'\n'..credential_scope..'\n'..sha2.sha256(canonical_request)

	local signing_key = getSignatureKey(secret_key, datestamp, region, service)
	local signature = sha2.hmac(sha2.sha256,signing_key,string_to_sign)

	local authorization_header = algorithm..' '..'Credential='..access_key..'/'..credential_scope..', '..'SignedHeaders='..signed_headers..', '..'Signature='..signature

	local request_url = endpoint..'/'

	local req = CreateHTTPRequestScriptVM("POST",request_url)
    req:SetHTTPRequestHeaderValue("x-amz-date", amzdate)
    req:SetHTTPRequestHeaderValue("Content-Type", "application/x-amz-json-1.1")
    req:SetHTTPRequestHeaderValue("X-Amz-Target", "Kinesis_20131202.PutRecord")
    req:SetHTTPRequestHeaderValue("Authorization", authorization_header)
    req:SetHTTPRequestRawPostBody("application/x-amz-json-1.1",body_data)
    req:Send(function(res)
        if res.StatusCode ~= 200 or not res.Body then
            return
        else

        end
    end)
end

function DAC:OnRequestSelectChess(keys)
	local player_id = keys.PlayerID
	local hero = GameRules:GetGameModeEntity().playerid2hero[player_id]
	local unit_index = keys.unit_index
	local unit = EntIndexToHScript(unit_index)

	if hero:FindAbilityByName('pick_chess') ~= nil then
		ExecuteOrderFromTable({
			UnitIndex = hero:entindex(), 
			OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
			TargetIndex = unit_index,
			AbilityIndex = hero:FindAbilityByName('pick_chess'):entindex(),
			Queue = 0
		})
	end
end

function DAC:OnUpdateUserSettings(keys)
	local player_id = keys.PlayerID
	local hero = GameRules:GetGameModeEntity().playerid2hero[player_id]

	if hero == nil then
		return
	end
	local steam_id = hero.steam_id

	if steam_id ~= nil and GameRules:GetGameModeEntity().user_setting[steam_id] ~= nil then
		GameRules:GetGameModeEntity().user_setting[steam_id][keys.key] = keys.value
		CustomNetTables:SetTableValue( "setting_table", "show_settings", GameRules:GetGameModeEntity().user_setting)
	end
end

function DAC:OnPauseGame(keys)
	local player_id = keys.playerid
	local hero = GameRules:GetGameModeEntity().playerid2hero[player_id]

	if IsUnitExist(hero) == false then
		return
	end
	if GameRules:IsGamePaused() then
		PauseGame(false)
		-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
		-- 	player_id = player_id,
		-- 	vip = hero.is_vip,
		-- 	text = '#text_unpause_game'
		-- })
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_unpause",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})
		return
	end

	if GameRules:GetGameModeEntity().START_TIME == nil then
		return
	end

	local pause_time = math.floor(GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME)
	if hero.last_pause_time == nil or GetPlayingPlayerCount() == 1 then
		PauseGame(true)
		-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
		-- 	player_id = player_id,
		-- 	vip = hero.is_vip,
		-- 	text = '#text_pause_game'
		-- })
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_pause",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})
		hero.last_pause_time = pause_time
	else
		if pause_time - hero.last_pause_time > 300 then
			PauseGame(true)
			-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
			-- 	player_id = player_id,
			-- 	vip = hero.is_vip,
			-- 	text = '#text_pause_game'
			-- })
			hero.last_pause_time = pause_time
		else
			return
		end
	end

	

end

function ShowStarsOnAllChess(team)
	for _,u in pairs(GameRules:GetGameModeEntity().to_be_destory_list[team]) do
		u.is_in_battle = true
		ShowStarsOnChess(u,nil,'teleport')
	end
end

function ShowStarsOnChess(unit,duration,gesture)
	Timers:CreateTimer(0.5,function()
		if IsUnitExist(unit) == false then
			return
		end
		local unit_name = unit:GetUnitName()
		if duration == nil then
			duration = 3
		end
		local star = 1
		if string.find(unit_name,'11') ~= nil then
			unit_name = string.sub(unit_name,1,-3)
			star = 3
		end
		if string.find(unit_name,'1') ~= nil then
			unit_name = string.sub(unit_name,1,-2)
			star = 2
		end

		local cost = GameRules:GetGameModeEntity().chess_2_mana[unit_name]

		if cost == nil then
			return
		end
		if cost > 5 then
			play_particle('effect/arrow/ssr/star1.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,duration)
		else
			play_particle('effect/arrow/'..cost..'/star'..star..'.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,duration)
		end

		-- unit:StartGesture(gesture or ACT_DOTA_TELEPORT)

		local m = "modifier_ready"
		if gesture ~= nil then
			m = "modifier_"..gesture
		end
		unit:AddNewModifier(unit,nil,m,{ duration = duration,})
	end)
end

function ShallowGrave(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local duration = ability:GetLevelSpecialValueFor( "duration", level - 1 )

	if IsUnitExist(caster) == false then 
		return
	end
	local u1 = FindShallowGraveFriendInner(caster)
	if u1 ~= nil then
		if u1:FindModifierByName("modifier_dazzle_shallow_grave") == nil then
			u1:AddNewModifier(u1,nil,"modifier_dazzle_shallow_grave",{duration=duration})
			EmitSoundOn("Hero_Dazzle.Shallow_Grave",u1)
		end
		if level >= 2 then
			Timers:CreateTimer(0.5,function()
				if IsUnitExist(caster) == false then 
					return
				end
				local u2 = FindShallowGraveFriendInner(caster)
				if u2 ~= nil then
					if u2:FindModifierByName("modifier_dazzle_shallow_grave") == nil then
						u2:AddNewModifier(u2,nil,"modifier_dazzle_shallow_grave",{duration=duration})
						EmitSoundOn("Hero_Dazzle.Shallow_Grave",u2)
					end
					if level >= 3 then
						Timers:CreateTimer(0.5,function()
							if IsUnitExist(caster) == false then 
								return
							end
							local u3 = FindShallowGraveFriendInner(caster)
							if u3 ~= nil then
								if u3:FindModifierByName("modifier_dazzle_shallow_grave") == nil then
									u3:AddNewModifier(u3,nil,"modifier_dazzle_shallow_grave",{duration=duration})
									EmitSoundOn("Hero_Dazzle.Shallow_Grave",u3)
								end
							end
						end)
					end
				end
			end)
		end
	end
end

function PlayCombineSound(u)
	local level = u:GetLevel()
	if level == nil or level < 3 then
		level = 3
	end
	if level >9 then
		level = 9
	end
	EmitSoundOn("dac.combine."..level,u)
end

function FindUnluckyDogInRange(u, range, dup_debuff)
	if u:GetAttackTarget() ~= nil then
		return u:GetAttackTarget()
	end
    local unluckydog = nil
    local try_count = 0
    while unluckydog == nil and try_count < 100 do
        local uu = GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]))]
        if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < range + u:GetHullRadius() + uu:GetHullRadius() and uu:HasAbility('is_ward') == false then
        	-- if dup_debuff == nil or uu:FindModifierByName(dup_debuff) == nil then
            	unluckydog = uu
            -- end
        end
        try_count = try_count + 1
    end
    return unluckydog
end

function SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet, onduty_hero_animation)
	local onduty_hero_model = GameRules:GetGameModeEntity().sm_hero_list[onduty_hero]
	local onduty_hero_skin = GameRules:GetGameModeEntity().sm_hero_list_skin[onduty_hero] or 0
	hero:SetOriginalModel(onduty_hero_model)
	hero:SetModel(onduty_hero_model)
	hero:SetSkin(onduty_hero_skin)
	hero.init_model_scale = GameRules:GetGameModeEntity().sm_hero_size[onduty_hero] or 1
	hero:SetModelScale(hero.init_model_scale)
	hero.ori_model = onduty_hero_model
	hero.ori_skin = onduty_hero_skin
	hero.onduty_hero = onduty_hero
	hero.projectile = onduty_hero_projectile
	hero.pet = onduty_hero_pet
	hero.animation = onduty_hero_animation
	if GameRules:GetGameModeEntity().egg_quest == 'q024' and (string.find(hero.onduty_hero,'h1') ~= nil or string.find(hero.onduty_hero,'h0') ~= nil) then
		SetQuest(hero:GetTeam(),true)
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q025' and string.find(hero.onduty_hero,'h2') ~= nil then
		SetQuest(hero:GetTeam(),true)
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q026' and string.find(hero.onduty_hero,'h3') ~= nil then
		SetQuest(hero:GetTeam(),true)
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q027' and string.find(hero.onduty_hero,'h4') ~= nil then
		SetQuest(hero:GetTeam(),true)
	end

	hero.courier_name = onduty_hero
	MakeGreevil(hero,false)

	if hero.effect ~= nil then
		hero:RemoveAbility(hero.effect)
		hero:RemoveModifierByName('modifier_texiao_star')
	end
	if onduty_hero_effect ~= nil and onduty_hero_effect ~= '' and onduty_hero_effect ~= 'e000' then
    	if string.find(GameRules:GetGameModeEntity().effect_list,onduty_hero_effect) then
			AddAbilityAndSetLevel(hero,onduty_hero_effect)
			hero.effect = onduty_hero_effect
		end
	else
		hero.effect = nil
    end
    ShowCourierEffect(hero,1)
    hero.onduty_hero = onduty_hero

    BlinkChessX({caster=hero,blink_type="fall"})

    CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
		player_id = hero:GetPlayerID(),
		win_streak = hero.win_streak or 0,
		vip = hero.is_vip,
		onduty_hero = onduty_hero,
		text = "notice_player_select_courier",
		time_stamp = math.floor(GameRules:GetGameTime()),
		type = 'player_courier_event',
	})

    RefreshPets(hero,hero.pet_entity,onduty_hero_pet)


    --获取出场动画
 --    print('----------------')
 --    print(hero.animation)
	-- local animation_info = GetAnimation(hero.animation or 'n000')
	-- DeepPrintTable(animation_info)
	-- hero:SetOrigin(hero:GetOrigin() + Vector(0,0,1000))
	-- --播放起始动画
	-- local ppp = ShowTPEffectAtPosition(hero:GetAbsOrigin(),animation_info.tp_effect)

	-- Timers:CreateTimer(2,function()
	-- 	if ppp ~= nil then
 --            ParticleManager:DestroyParticle(ppp,true)
 --        end
	-- 	--播放后续动画
	-- 	if animation_info.tp_sound ~= nil then
	-- 		EmitSoundOn(animation_info.tp_sound,hero)
	-- 	end
	-- 	if animation_info.animation_modifier ~= nil then
	-- 		BlinkChessX({caster=hero,blink_type=animation_info.animation_modifier})
	-- 	end
	-- 	if animation_info.end_effect ~= nil then
	-- 		play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,hero,3)
	-- 	end
	-- end)
 
end

function LichBingjia(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()

	InvisibleUnitCast({
		caster = caster,
		ability = 'lich_frost_shield',
		level = level,
		unluckydog = target,
	})
	
	InvisibleUnitCast({
		caster = caster,
		ability = 'give_bingjia',
		level = level,
		unluckydog = target,
	})
end


function CastGodsStrength(u)
	local team_id = u.team_id
	local at_team_id = u.at_team_id or u.team_id
	local level = u:FindAbilityByName("sven_gods_strength"):GetLevel()

	--统计有多少个恶魔
	local demon_table = {}
	local demon_count = 0
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id == u.team_id and unit:HasAbility('is_demon_buff') then
			demon_count = demon_count + 1
		end
	end
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id == u.team_id and unit:HasAbility('is_demon') and unit.sven_buffed ~= true then
			unit.sven_buffed = true
			for i=1,demon_count do
				InvisibleUnitCast({
					caster = unit,
					ability = 'give_shenli',
					level = level,
					unluckydog = unit,
					ignore_nether_ward = true,
				})
			end
		end
	end
end

function ItemMoney(keys)
	local caster = keys.caster
	local ability = keys.ability

	if ability.money ~= nil and ability.money > 0 then
		AddMana(caster, ability.money)
		AddTotalMoneyStat(caster:GetPlayerID(),ability.money)
	end
	ability:SpendCharge()
end

function ItemChishu(keys)
	local caster = keys.caster
	local target = keys.target
	target:CutDown(caster:GetTeam())

	local hp = caster:GetHealth()
	local heal = RandomInt(1,8)
	if GameRules:GetGameModeEntity().p2_mode == true then
		heal = RandomInt(1,4)
	end
	hp = hp + heal
	if hp > 100 then
		hp = 100
	end

	if GameRules:GetGameModeEntity().p2_mode == true and GetP2Ally(caster:GetTeam()) ~= nil then
		local hh = TeamId2Hero(GetP2Ally(caster:GetTeam())) 
		if hh ~= nil then
			hh:SetHealth(hp)
			SyncHP(hh)
			AMHC:CreateNumberEffect(hh,heal,3,AMHC.MSG_MISS,{0,128,0},0)
			EmitSoundOn("DOTA_Item.Tango.Activate",hh)
		end
	end
	caster:SetHealth(hp)
	SyncHP(caster)
	AMHC:CreateNumberEffect(caster,heal,3,AMHC.MSG_MISS,{0,128,0},0)
	EmitSoundOn("DOTA_Item.Tango.Activate",caster)
end
function ItemPingguo(keys)
	local caster = keys.caster
	AddAbilityAndSetLevel(caster,'is_priest_buff_plus_plus')
	EmitSoundOn("Hero_Abaddon.AphoticShield.Cast",caster)

	if GetP2Ally(caster:GetTeam()) ~= nil and TeamId2Hero(GetP2Ally(caster:GetTeam())) ~= nil then
		local hh = TeamId2Hero(GetP2Ally(last_hero:GetTeam()))
		if IsUnitExist(hh) == true then
			AddAbilityAndSetLevel(hh,'is_priest_buff_plus_plus')
			EmitSoundOn("Hero_Abaddon.AphoticShield.Cast",hh)
		end
	end
end

function ItemFengwangjiang(keys)
	local caster = keys.caster
	AddAbilityAndSetLevel(caster,'is_priest_buff')
	EmitSoundOn("Hero_Abaddon.AphoticShield.Cast",caster)
end

function ItemMangguo(keys)
	local caster = keys.caster
	local add_mana = RandomInt(1,caster:GetLevel())
	AddMana(caster, add_mana)
	AddTotalMoneyStat(caster:GetPlayerID(),add_mana)
	EmitSoundOn("DOTA_Item.Mango.Activate",caster)
	play_particle('particles/items3_fx/mango_active.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)
	play_particle('particles/generic_gameplay/outpost_reward.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)
	
end

function ItemZhishizhishu(keys)
	local caster = keys.caster
	local team_id = caster:GetTeam()
	local is_gold = keys.is_gold
	local lv = caster:GetLevel()
	local exp_require = GameRules:GetGameModeEntity().HeroExpTable[lv+1] - GameRules:GetGameModeEntity().HeroExpTable[lv]
	local exp = math.floor(exp_require/16)
	if exp == 0 then
		exp = 1
	end
	if exp > 0 then
		caster:AddExperience(exp,0,false,false)
	end
	AMHC:CreateNumberEffect(caster,exp,3,AMHC.MSG_MISS,{255,255,128},0)
	EmitSoundOn("item.exp2",caster)
	--同步ui血量和等级
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = caster:GetPlayerID(),
		hp = caster:GetHealth(),
		hp_max = caster:GetMaxHealth(),
		mp = caster:GetMana(),
		level = caster:GetLevel(),
		win_streak = caster.win_streak,
	})
end
function ItemJixiezhixin(keys)
	local caster = keys.caster
	local team_id = caster:GetTeam()
	local is_gold = keys.is_gold
	caster.chesslock = false

	AMHC:CreateParticle("particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ribbon_bright.vpcf",PATTACH_ABSORIGIN_FOLLOW,false,caster,5)
	EmitSoundOn("ex_machina_open",caster)
	if is_gold ~= nil then
		Draw5ChessAndShow(team_id, true, true)
	else
		Draw5ChessAndShow(team_id, true)
	end
	AMHC:CreateNumberEffect(caster,2,3,AMHC.MSG_MISS,{80,80,255},3)
end

function GsMoji(keys)
	InvisibleUnitCast({
		caster = keys.caster,
		ability = 'grimstroke_dark_artistry',
		level = keys.ability:GetLevel(),
		position = keys.target_points[1],
	})
	keys.ability.stack = 0
end

function GsMojiHit(keys)
	local caster = keys.caster
	local target = keys.target
	local stack = keys.ability.stack or 0
	local count = keys.ability:GetLevelSpecialValueFor( "fuhun_stack_count", keys.ability:GetLevel() - 1)
	if caster:GetTeam() ~= target:GetTeam() and target:FindModifierByName('modifier_gs_give_fuhun') == nil and stack < count then
		keys.ability:ApplyDataDrivenModifier(caster, target, 'modifier_gs_give_fuhun', nil)
		keys.ability.stack = stack + 1
	end
end

function AddFuhunDebuffParticle(keys)
	local u = keys.target
	local pp = ParticleManager:CreateParticle("effect/gs_fuhun/debuffdebuff.vpcf", PATTACH_ABSORIGIN_FOLLOW, u)
	ParticleManager:SetParticleControlEnt( pp, 0, u, PATTACH_ABSORIGIN_FOLLOW, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, u, PATTACH_ABSORIGIN_FOLLOW, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 2, u, PATTACH_ABSORIGIN_FOLLOW, nil, u:GetOrigin(), true );

	u.fuhun_debuff_particle = pp

	u:FindModifierByName("modifier_gs_give_fuhun"):SetStackCount(1)
end
function RemoveFuhunDebuffParticle(keys)
	local target = keys.target
	ParticleManager:DestroyParticle(target.fuhun_debuff_particle,true)
end
function CopyAbility2FuhunUnit(unit,unluckydog,ability)
	if unit:IsSilenced() == true or unit:HasModifier('modifier_silencer_global_silence') then
		return
	end
	if unit == nil or unit:FindAbilityByName(ability) == nil then
		return
	end
	local level = unit:FindAbilityByName(ability):GetLevel()
	for _,u in pairs(GameRules:GetGameModeEntity().to_be_destory_list[unit.at_team_id or unit.team_id]) do
		if IsUnitExist(u) == true and u:GetTeam() ~= unit:GetTeam() and u:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
			local l = u:FindModifierByName("modifier_gs_give_fuhun"):GetStackCount()
			l = l - 1
			if l == 0 then
				u:RemoveModifierByName('modifier_gs_give_fuhun')
			else
				u:FindModifierByName("modifier_gs_give_fuhun"):SetStackCount(l)
			end
			if u:entindex() ~= unluckydog:entindex() then
				Timers:CreateTimer(RandomFloat(0.1,0.5),function()
					if unit:IsSilenced() == true or unit:HasModifier('modifier_silencer_global_silence') then
						return
					end
					InvisibleUnitCast({
						caster = unit,
						ability = ability,
						level = level,
						unluckydog = u,
						force_unluckydog = u,
						origin_unluckydog = unluckydog,
					})
					if u:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
						CopyAbility2QinglianbaozhuUnit(u,unit,ability)
					end
				end)
			end
		end
	end
end
function CopyAbility2QinglianbaozhuUnit(unit,unluckydog,ability)
	local level = unit:FindAbilityByName(ability):GetLevel()
	for slot=0,5 do
		if unluckydog:GetItemInSlot(slot)~= nil then
			local qinglian_ability = unluckydog:GetItemInSlot(slot)
			local name = qinglian_ability:GetAbilityName()
			if name == 'item_qinglianbaozhu' and qinglian_ability:IsCooldownReady() == true then
				qinglian_ability:StartCooldown(3)
				Timers:CreateTimer(0.5,function()
					InvisibleUnitCast({
						caster = unluckydog,
						ability = ability,
						level = level,
						unluckydog = unit,
						force_unluckydog = unit,
					})

					play_particle('particles/items3_fx/lotus_orb_reflect.vpcf',PATTACH_ABSORIGIN_FOLLOW,unluckydog,3)
					EmitSoundOn("item.lianhua",unluckydog)
					if unit:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
						CopyAbility2FuhunUnit(unluckydog,unit,ability)
					end
					if unit:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
						CopyAbility2QinglianbaozhuUnit(unit,unluckydog,ability)
					end
				end)
			end
		end
	end
end
--能看到这行字的代码哥哥，请勿将测试服拆包内容公开和公开讨论，谢谢

--寻找血量与技能伤害量最相近的棋子
function FindUnluckyDogByAbilityDamage(u,ability)
	local unluckydog = nil
	local hp_abs = 999999
	local hp_estimate = u:FindAbilityByName(ability):GetAbilityDamage()
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id ~= u.team_id and unit:IsNull() == false and unit:IsAlive() == true and unit:HasAbility('is_ward') == false then
			--魔法伤害，引入魔抗系数进行计算
			if u:FindAbilityByName(ability):GetAbilityDamageType() == 2 then
				if math.abs(unit:GetHealth() - hp_estimate * (1 - unit:GetMagicalArmorValue())) < hp_abs and unit:GetMagicalArmorValue() < 1 then
					unluckydog = unit
					hp_abs = math.abs(unit:GetHealth() - hp_estimate * (1 - unit:GetMagicalArmorValue()))
				end
			--物理及纯粹伤害
			else
				if math.abs(unit:GetHealth() - hp_estimate) < hp_abs then
					unluckydog = unit
					hp_abs = math.abs(unit:GetHealth() - hp_estimate)
				end
			end
		end
	end
	return unluckydog
end

function InitP2Mode()

	local team1_player_count = 0
	if TeamId2Hero(6) ~= nil then
		team1_player_count = team1_player_count + 1
	end
	if TeamId2Hero(7) ~= nil then
		team1_player_count = team1_player_count + 1
	end
	if team1_player_count ~= 0 and team1_player_count ~= 2 then
		return false
	end

	local team2_player_count = 0
	if TeamId2Hero(8) ~= nil then
		team2_player_count = team2_player_count + 1
	end
	if TeamId2Hero(9) ~= nil then
		team2_player_count = team2_player_count + 1
	end
	if team2_player_count ~= 0 and team2_player_count ~= 2 then
		return false
	end

	local team3_player_count = 0
	if TeamId2Hero(10) ~= nil then
		team3_player_count = team3_player_count + 1
	end
	if TeamId2Hero(11) ~= nil then
		team3_player_count = team3_player_count + 1
	end
	if team3_player_count ~= 0 and team3_player_count ~= 2 then
		return false
	end

	local team4_player_count = 0
	if TeamId2Hero(12) ~= nil then
		team4_player_count = team4_player_count + 1
	end
	if TeamId2Hero(13) ~= nil then
		team4_player_count = team4_player_count + 1
	end
	if team4_player_count ~= 0 and team4_player_count ~= 2 then
		return false
	end

	SetP2Team(6,1)
	SetP2Team(7,1)
	SetP2Team(8,2)
	SetP2Team(9,2)
	SetP2Team(10,3)
	SetP2Team(11,3)
	SetP2Team(12,4)
	SetP2Team(13,4)

	GameRules:GetGameModeEntity().p2_mode = true
	return true
end

function ExtraAttack(keys)
	--实测效果不稳定
	local caster = keys.caster
	local target = keys.target
	caster:PerformAttack(target, true, true, true, false, false, false, true)
end

--获取棋子的不带1和11的名字，如chess_wr
function GetChessTypeName(chess)
	local find_name = chess:GetUnitName()
	if string.find(find_name,'11') ~= nil then
		find_name = string.sub(find_name,1,-3)
	end
	if string.find(find_name,'1') ~= nil then
		find_name = string.sub(find_name,1,-2)
	end
	return find_name
end

--获取棋子是几星的
function GetChessStar(chess)
	if IsUnitExist(chess) == false then
		return 1
	end
	local find_name = chess:GetUnitName()
	if string.find(find_name,'11') ~= nil then
		return 3
	end
	if string.find(find_name,'1') ~= nil then
		return 2
	end
	return 1
end

function GetChessNameStar(chess_name)
	if string.find(chess_name,'11') ~= nil then
		return 3
	end
	if string.find(chess_name,'1') ~= nil then
		return 2
	end
	return 1
end

function IsChessInHand(chess)
	if chess.hand_index ~= nil then
		return true
	else
		return false
	end
end

--进阶的棋子合成
--units是参与合成的棋子列表table，其中每一个棋子可以是unit，也可以是obj
function CombineChessPlus(units, advance_unit_name)
	for i,u in pairs(units) do
		if u.index ~= nil then
			units[i] = EntIndexToHScript(u.index)
		end
		units[i].combining = true
	end
	
	if units == nil or table.maxn(units) <= 1 or units[1] == nil then
		return
	end
	local team_id = units[1].team_id
	local hero = TeamId2Hero(team_id)

	local advance_unit_name = advance_unit_name or (units[1]:GetUnitName()..'1')

	if advance_unit_name == nil or advance_unit_name == 'chess_io11' then
		return
	end
	
	--is_target_in_hand=true：要合在手牌
	--is_target_in_hand=false：合在unit[0]被视为的位置
	local is_target_in_hand = IsChessInHand(units[1]) 
	local hand_index = units[1].hand_index
	local p = units[1]:GetAbsOrigin()
	if units[1].hand_index == nil then
		p = XY2Vector(units[1].x,units[1].y,team_id)
	else
		p = HandIndex2Vector(team_id, units[1].hand_index)
	end
	local y = units[1].y
	local x = units[1].x

	--进阶合成：检查手牌/场上是否有2个advance_unit_name名字的棋子。
	--如果有，将他们也加入配件，并且合成advance_unit_name1
	local u1 = nil
	local u2 = nil

	--手牌
	local have_exist_count,u2,u1 = Find2SameChessInHandOrOnBoard(hero,advance_unit_name)

	local wizard_count = GetWizardCount(team_id)
	local druid_count = GetDruidCount(team_id)
	if wizard_count >= 2 and druid_count >= 3 then
		druid_count = druid_count + 1
	end
	if wizard_count >= 3 and druid_count == 2 then
		druid_count = druid_count + 1
	end

	if u2 ~= nil and u2:HasAbility('is_druid') and string.find(u2:GetUnitName(),'11') == nil and druid_count >= 4 then
		--德鲁伊（4）：两个一样的2星可以合
		table.insert(units,u2)
		advance_unit_name = advance_unit_name..'1'

		if IsChessInHand(u2) == false then
			is_target_in_hand = false
			p = u2:GetAbsOrigin()
			y = u2.y
			x = u2.x
		end
	elseif u1 ~=nil and u2 ~=nil and string.find(u1:GetUnitName(),'11')  == nil then
		--普通情况：三个一样的可以合
		table.insert(units,u1)
		table.insert(units,u2)
		advance_unit_name = advance_unit_name..'1'

		if IsChessInHand(u1) == false then
			is_target_in_hand = false
			p = u1:GetAbsOrigin()
			y = u1.y
			x = u1.x
		elseif IsChessInHand(u2) == false then
			is_target_in_hand = false
			p = u2:GetAbsOrigin()
			y = u2.y
			x = u2.x
		end
	end

	if string.find(advance_unit_name,'11') ~= nil then
		GameRules:GetGameModeEntity().level3pieces[team_id] = GameRules:GetGameModeEntity().level3pieces[team_id] + 1
	end
	local chess_price = 1
	for k1,v1 in pairs(GameRules:GetGameModeEntity().chess_list_by_mana) do
		for k2,v2 in pairs(v1) do
			if string.find(advance_unit_name,v2) ~= nil then
				chess_price = k1
			end
		end
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q003' and string.find(advance_unit_name,'1') ~= nil and chess_price == 5 then
		SetQuest(team_id,true)
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q004' and string.find(advance_unit_name,'11') ~= nil and chess_price == 4 then
		SetQuest(team_id,true)
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q011' and GameRules:GetGameModeEntity().level3pieces[team_id] >= 4 then
		SetQuest(team_id,true)
	end
	--=====================================================
	--至此已经确定了所有配件棋子，以及最终的合成品。可以开始合成了
	
	--收集低级棋子的物品
	local items_table = GetAllItemsInUnits(units)

	--收集低级棋子的press_count
	local total_press_count = 0
	local max_press_count = 0
	for i,u in pairs(units) do
		if IsUnitExist(u) == true then
			local pc = u.press_count
			if pc ~= nil and pc > 0 then
				total_press_count = total_press_count + pc
			end
			-- if pc ~= nil and pc > 0 and pc > max_press_count then
			-- 	max_press_count = pc
			-- end
		end
	end
	--收集低级棋子的track_money_count
	local total_track_money_count = 0
	for i,u in pairs(units) do
		if IsUnitExist(u) == true then
			local pc = u.track_money_count
			if pc ~= nil and pc > 0 then
				total_track_money_count = total_track_money_count + pc
			end
		end
	end

	--移除低级棋子
	for _,u in pairs(units) do
		if u.hand_index ~= nil then
			--在手牌
			GameRules:GetGameModeEntity().hand[team_id][u.hand_index] = 0
			hero.hand_entities[u.hand_index] = nil
		else
			--在棋盘
			GameRules:GetGameModeEntity().mychess[team_id][u.y_x] = nil
			GameRules:GetGameModeEntity().unit[team_id][u.y_x] = nil
			RemoveFromToBeDestroyList(u)
		end
		u:Destroy()
	end

	--创建合成的棋子
	local uu = CreateUnitByName(advance_unit_name, p,false,nil,nil,team_id) 
	-- uu.is_respawning = true
	-- Timers:CreateTimer(1,function()
	-- 	uu.is_respawning = nil
	-- end)
	MakeTiny(uu)

	--狗头人的特殊逻辑
	if IsKobold(advance_unit_name) == true and GetChessNameStar(advance_unit_name) == 3 then
		PlayChessDialogue(uu,'devided.1')
		Timers:CreateTimer(0.5,function()
			--创建狗棋子，播动画
			local cc = CreateChessInHand(TeamId2Hero(team_id),advance_unit_name,nil,'nil')
			if IsUnitExist(cc) == true then
				BlinkChessX({caster=cc,blink_type="breaksoil"})
				--发弹幕：合成棋子
				CustomGameEventManager:Send_ServerToAllClients("bullet",{
					player_id = TeamId2Hero(team_id):GetPlayerID(),
					vip = TeamId2Hero(team_id).is_vip,
					win_streak = TeamId2Hero(team_id).win_streak or 0,
					target = advance_unit_name,
				})
				Timers:CreateTimer(1,function()
					if IsUnitExist(cc) == true then
						PlayChessDialogue(cc,'devided.2')
					end
				end)
			end
		end)
	else
		PlayChessDialogue(uu,'merge')
	end

	uu.press_count = total_press_count
	uu.track_money_count = total_track_money_count

	-- EmitSoundOn("Loot_Drop_Stinger_Rare",uu)
	PlayCombineSound(uu)
	
	--给高级棋子添加棋子技能
	if GameRules:GetGameModeEntity().chess_ability_list[uu:GetUnitName()] ~= nil then
		local a = GameRules:GetGameModeEntity().chess_ability_list[uu:GetUnitName()]
		if uu:FindAbilityByName(a) == nil then
			AddAbilityAndSetLevel(uu,a,0)
		end
		if a == 'lc_qianggong' and uu.press_count ~= nil and uu.press_count > 0 then
			SetPressStack(uu)
		end
		if uu.track_money_count ~= nil and uu.track_money_count > 0 then
			SetTrackMoneyStack(uu)
		end
	end

	--添加星星特效
	ShowStarsOnChess(uu,5,'')

	if is_target_in_hand == false then
		--在棋盘
		table.insert(GameRules:GetGameModeEntity().to_be_destory_list[team_id],uu)
		GameRules:GetGameModeEntity().mychess[team_id][''..y..'_'..x] = {
			index = uu:entindex(),
			chess = uu:GetUnitName(),
			item = items_table,
			x = x,
			y = y,
			press_count = uu.press_count,
			track_money_count = uu.track_money_count,
		}
		GameRules:GetGameModeEntity().unit[team_id][''..y..'_'..x] = 1
		uu.y_x = ''..y..'_'..x
		uu.y = y
		uu.x = x
		uu.vchess_index = ''..y..'_'..x
	else
		--在手牌
		uu.hand_index = hand_index
		hero.hand_entities[hand_index] = uu
		GameRules:GetGameModeEntity().hand[team_id][hand_index] = 1
	end
	uu.team_id = team_id

	FindRikiAndToggle(uu)

	uu:SetForwardVector(Vector(0,1,0))
	--添加装备
	InitChessRemindedItem(uu, items_table)
	GiveItems2Unit(items_table,uu)
	

	AddAbilityAndSetLevel(uu,'root_self')
	AddAbilityAndSetLevel(uu,'jiaoxie_wudi')
	--合成特效
	play_particle("particles/generic_hero_status/hero_levelup.vpcf",PATTACH_ABSORIGIN_FOLLOW,uu,3)
	if string.find(uu:GetUnitName(),'11') then
		play_particle("particles/econ/events/ti9/ti9_drums_musicnotes.vpcf",PATTACH_OVERHEAD_FOLLOW,uu,3)
	else
		play_particle("particles/econ/events/ti9/ti9_drums_musicnotes_b.vpcf",PATTACH_OVERHEAD_FOLLOW,uu,3)
	end

	--重新计算人口
	CheckChess(team_id)

	--同步ui人口
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = GameRules:GetGameModeEntity().population_max[team_id],
		count = GameRules:GetGameModeEntity().population[team_id],
	})

	--发弹幕：合成棋子
	CustomGameEventManager:Send_ServerToAllClients("bullet",{
		player_id = TeamId2Hero(team_id):GetPlayerID(),
		vip = TeamId2Hero(team_id).is_vip,
		win_streak = TeamId2Hero(team_id).win_streak or 0,
		target = advance_unit_name,
	})
end

function Find2SameChessInHandOrOnBoard(caster,chess)
	if chess == 'chess_io1' or chess == 'chess_io' then
		--2星小精灵不参与合成
		return 0,nil,nil,nil
	end
	local count = 0
	local chess1 = nil
	local chess2 = nil
	local chess3 = nil
	if caster ~= nil and caster.hand_entities ~= nil then  -- and GameRules:GetGameModeEntity().is_game_test == false
		if GameRules:GetGameModeEntity().prepare_timer > 5 then  -- 准备回合结束后，不再寻找场上棋子做为合成材料，避免一些未知的BUG。
			for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.team_id]) do
				local kobold_or_druid = false
				if v:FindAbilityByName('is_druid') ~= nil or v:FindAbilityByName('is_kobold') ~= nil then
					kobold_or_druid = true
				end
				if IsUnitExist(v) == true and v:GetUnitName() == chess and (kobold_or_druid == false or (kobold_or_druid == true and GetChessStar(v) == 2)) and v.is_in_battle ~= true and v.is_moving ~= true and v.team_id == caster.team_id then
					count = count + 1
					if count == 1 then
						chess1 = v
					end
					if count == 2 then
						chess2 = v
					end
					if count == 3 then
						chess3 = v
					end
				end
			end
		end
		for _,v in pairs(caster.hand_entities) do
			if IsUnitExist(v) == true and v:GetUnitName() == chess and v:FindAbilityByName('is_druid') == nil and v:FindAbilityByName('is_kobold') == nil and v.is_moving ~= true then
				count = count + 1
				if count == 1 then
					chess1 = v
				end
				if count == 2 then
					chess2 = v
				end
				if count == 3 then
					chess3 = v
				end
			end
		end
		return count,chess1,chess2,chess3
	else
		return 0,nil,nil,nil
	end
end 

function GetWizardCount(team_id)
	if GameRules:GetGameModeEntity().game_status ~= 2 then
		return 0
	end
	local rubick = 0
	local gs = 0
	local lion = 0
	local dw = 0
	for x,y in pairs(GameRules:GetGameModeEntity().mychess[team_id]) do
		if string.find(y.chess,'chess_rubick') ~= nil then
			rubick = 1
		end
		if string.find(y.chess,'chess_gs') ~= nil then
			gs = 1
		end
		if string.find(y.chess,'chess_lion') ~= nil then
			lion = 1
		end
		if string.find(y.chess,'chess_dw') ~= nil then
			dw = 1
		end
	end
	local count = 0
	if rubick == 1 then
		count = count + 1
	end
	if lion == 1 then
		count = count + 1
	end
	if gs == 1 then
		count = count + 1
	end
	if dw == 1 then
		count = count + 1
	end
	return count
end

--设置英雄血量并同步UI 和 判断死亡
function SetHeroHP(hero,hp)
	if hero == nil or hp == nil then
		return
	end
	if hp < 0 then
		hp = 0
	end

	if hp == 0 then
		hero:ForceKill(false)
		GameRules:GetGameModeEntity().counterpart[hero:GetTeam()] = -1
	else
		hero:SetHealth(hp)
	end

	SyncHP(hero)
end
--对指定team的棋手造成伤害
function DamageTeam(team, damage, pj)

	local hh = TeamId2Hero(team) 
	if hh ~= nil then
		SetHeroHP(hh, hh:GetHealth() - damage)
		AMHC:CreateNumberEffect(hh,damage,2,AMHC.MSG_MISS,"red",9)

		local damage_sound = GameRules:GetGameModeEntity().projectile_sound_list[pj] or "pj_hit.tower"
		
		EmitSoundOn(damage_sound,hh)
		-- EmitSoundOn("Frostivus.PointScored.Enemy",hh)
	end
end

function CourierCP(c1,c2)
	local CP_GROUP = {
		h001 = 1, h002 = 1, h309 = 1, h138 = 1, h316 = 1,
		h117 = 2, h242 = 2, 
		h422 = 3, h444 = 3, h445 = 3, h446 = 3,
		h499 = 4, h322 = 4, h346 = 4, h347 = 4, h348 = 4, h349 = 4, h350 = 4, h351 = 4, h353 = 4, h438 = 4, h439 = 4,
		h243 = 5, h120 = 5,
		h405 = 6, h414 = 6,
		h354 = 7, h355 = 7,
		h410 = 8, h411 = 8,
		h408 = 9, h409 = 9,
		h412 = 10, h413 = 10,
		h417 = 11, h418 = 11,
		h419 = 12, h443 = 12,
		h135 = 13, h110 = 13,
		h320 = 14, h321 = 14,
		h436 = 15, h437 = 15,
		h226 = 16, h227 = 16, h228 = 16, h324 = 16, h325 = 16, h326 = 16, h423 = 16, h424 = 16, h425 = 16,
		h399 = 17, h433 = 17,
		h397 = 18, h398 = 18,
		h136 = 19, h137 = 19, h240 = 19, h340 = 19, h434 = 19,
	}
	local h1 = c1.onduty_hero
	local h2 = c2.onduty_hero

	if c1.cp_exp == nil then
		c1.cp_exp = 1
	else
		c1.cp_exp = c1.cp_exp + 1
	end
	if c2.cp_exp == nil then
		c2.cp_exp = 1
	else
		c2.cp_exp = c2.cp_exp + 1
	end
	if GameRules:GetGameModeEntity().egg_quest == 'q018' then
		SetQuest(c1:GetTeam(),true)
		SetQuest(c2:GetTeam(),true)
	end

	if h1 ~= h2 and (CP_GROUP[h1] == nil or CP_GROUP[h2] == nil or CP_GROUP[h1] ~= CP_GROUP[h2]) then
		return
	end
	local e1 = c1.onduty_hero_effect
	local e2 = c2.onduty_hero_effect
	local cp_level = -1

	if (CP_GROUP[h1] == CP_GROUP[h2]) or (h1 == h2) then
		cp_level = cp_level + 1
	end
	if e1 == e2 then
		cp_level = cp_level + 1
	end
	if c1.cp_exp >= 5 or c2.cp_exp >= 5 then
		cp_level = cp_level + 1
	end
	if cp_level >= 0 then
		if GameRules:GetGameModeEntity().egg_quest == 'q019' then
			SetQuest(c1:GetTeam(),true)
			SetQuest(c2:GetTeam(),true)
		end
		EmitSoundOn("dac.cpsound",c1)
		EmitSoundOn("dac.cpsound",c2)
		play_particle("effect/cp_heart/"..cp_level..".vpcf",PATTACH_OVERHEAD_FOLLOW,c1,6)
		play_particle("effect/cp_heart/"..cp_level..".vpcf",PATTACH_OVERHEAD_FOLLOW,c2,6)
	end
end

function ShowBattleInfo()
	local battle_table = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	if GameRules:GetGameModeEntity().battle_boss[GameRules:GetGameModeEntity().battle_round] ~= nil then
		--PVE
		for i=6,13 do
			if IsUnitExist(TeamId2Hero(i)) == true then
				CustomGameEventManager:Send_ServerToTeam(i,"battle_info",{
					key = GetClientKey(i),
					type = "pve",
					text = ''..GameRules:GetGameModeEntity().battle_round,
					round = GameRules:GetGameModeEntity().battle_round,
					history_win = GetHistoryWin(i,4),
	            	history_lose = GetHistoryLose(i,4),
				})
				battle_table[i] = {
					key = GetClientKey(i),
					round = GameRules:GetGameModeEntity().battle_round,
					type = 'pve',
					steam_id = TeamId2Hero(i).steam_id,
					oppo_steam_id = nil,
				}
			end
		end
	else
		--PVP
		if GameRules:GetGameModeEntity().playing_player_count == 1 and GameRules:GetGameModeEntity().cloudlineup[''..GameRules:GetGameModeEntity().battle_round] ~= nil then
			local chesses = nil
			for _,data in pairs(GameRules:GetGameModeEntity().cloudlineup[''..GameRules:GetGameModeEntity().battle_round]) do
				chesses = json.decode(data)
			end
			--打云玩家
			for i=6,13 do
				if IsUnitExist(TeamId2Hero(i)) == true then
					CustomGameEventManager:Send_ServerToTeam(i,"battle_info",{
						key = GetClientKey(i),
						type = "cloud",
						text = chesses.owner,
						round = GameRules:GetGameModeEntity().battle_round,
						history_win = GetHistoryWin(i,5),
	            		history_lose = GetHistoryLose(i,5),
					})
					battle_table[i] = {
						key = GetClientKey(i),
						round = GameRules:GetGameModeEntity().battle_round,
						type = 'cloud',
						steam_id = TeamId2Hero(i).steam_id,
						oppo_steam_id = chesses.owner,
					}
				end
			end
		else
			for i=6,13 do
				if IsUnitExist(TeamId2Hero(i)) == true then
					--打pvp敌人
					--i = 我的teamid
					--v = 我的主场对手的teamid
					--g = 我的客场对手的teamid
					local v = GameRules:GetGameModeEntity().counterpart[i]
					if v ~= nil and v ~= -1 then
						local g = GetMyGuestEnemyTeam(i)
						local enemy_id = TeamId2Hero(v):GetPlayerID()
						local guest_oppo_id = TeamId2Hero(g):GetPlayerID()
						local buffs = nil

						if GameRules:GetGameModeEntity().stat_info[TeamId2Hero(v).steam_id] ~= nil then
							buffs = GetStat(enemy_id,'buff')
						end
						
						
						CustomGameEventManager:Send_ServerToTeam(i,"battle_info",{
							key = GetClientKey(i),
							type = "pvp",
							text = enemy_id,
							host_oppo_id = enemy_id,
							guest_oppo_id = guest_oppo_id,
							round = GameRules:GetGameModeEntity().battle_round,
							history_win = GetHistoryWin(i,v),
	            			history_lose = GetHistoryLose(i,v),
	            			buffs = buffs,
						})

						battle_table[i] = {
							key = GetClientKey(i),
							round = GameRules:GetGameModeEntity().battle_round,
							type = 'pvp',
							steam_id = TeamId2Hero(i).steam_id,
							oppo_steam_id = TeamId2Hero(v).steam_id,
						}
					end
				end
			end
		end
	end

	UpdatePlayerWorldPanel(battle_table)
end

function AddHistoryWin(team1, team2)
	GameRules:GetGameModeEntity().history_win[team1][team2] = GameRules:GetGameModeEntity().history_win[team1][team2] + 1
end
function AddHistoryLose(team1, team2)
	GameRules:GetGameModeEntity().history_lose[team1][team2] = GameRules:GetGameModeEntity().history_lose[team1][team2] + 1
end
function GetHistoryWin(team1, team2)
	return GameRules:GetGameModeEntity().history_win[team1][team2]
end
function GetHistoryLose(team1, team2)
	return GameRules:GetGameModeEntity().history_lose[team1][team2]
end
function IsBozangWudi(unit)
	if unit:FindModifierByName('modifier_dazzle_shallow_grave') ~= nil and unit:GetHealth() < 10 then
		return true
	elseif unit:FindModifierByName('modifier_oracle_mingyunsheling') ~= nil then
		return true
	elseif unit:FindModifierByName('modifier_skeleton_king_reincarnation_scepter_active') ~= nil then
		return true
	elseif unit:IsInvulnerable() == true then
		return true
	else
		return false
	end
end

function ItemXiWa(keys)
	play_particle("particles/econ/events/ti7/shivas_guard_active_ti7.vpcf",PATTACH_ABSORIGIN_FOLLOW,keys.caster,6)
	EmitSoundOn("DOTA_Item.ShivasGuard.Activate",keys.caster)

	local units = FindUnitsInRadiusByTeam({
		team = keys.caster.team_id,
		role = 2,
		radius = 800,
		position = keys.caster:GetAbsOrigin()
	})
	
	for _,unluckydog in pairs(units) do
		local delay = 1.0* (unluckydog:GetAbsOrigin() - keys.caster:GetAbsOrigin()):Length2D() / 350
		ItemXiWaOne(delay,keys.caster,unluckydog)
	end
end
function ItemXiWaOne(delay,caster,unluckydog)
	Timers:CreateTimer(delay,function()
		InvisibleUnitCast({
			caster = caster,
			ability = 'shiva_give_debuff',
			level = 1,
			unluckydog = unluckydog,
			ignore_nether_ward = true,
		})
	end)
end

function ItemPipe(keys)
	local caster = keys.caster
	play_particle("particles/items2_fx/pipe_of_insight_launch.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,6)
	EmitSoundOn("DOTA_Item.Pipe.Activate",caster)

	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 1,
		position = caster:GetAbsOrigin(),
		radius = 9999,
	})
	
	for _,unluckydog in pairs(units) do
		InvisibleUnitCast({
			caster = caster,
			ability = 'give_pipe_buff',
			level = 1,
			unluckydog = unluckydog,
			ignore_nether_ward = true,
		})
	end
end

function ItemChihongjia(keys)
	local caster = keys.caster
	EmitSoundOn("Item.CrimsonGuard.Cast",caster)

	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 1,
		position = caster:GetAbsOrigin(),
		radius = 9999,
	})
	
	for _,unluckydog in pairs(units) do
		InvisibleUnitCast({
			caster = caster,
			ability = 'give_chihongjia_buff',
			level = 1,
			unluckydog = unluckydog,
			ignore_nether_ward = true,
		})
	end
end

function DAC:OnRequestChooseLoot(keys)
	local player_id = keys.PlayerID
	local loot_index = keys.loot_index
	local hero = PlayerId2Hero(player_id)
	if hero.loot_table == nil or hero.loot_table[loot_index] == nil then
		return
	end
	local loot = hero.loot_table[loot_index]
	hero.loot_table = nil

	AddItemPlus(hero,loot)
end

-- 寻找一个技能伤害最多敌人的最远格子
function FindFarthestGridForAbility(u,a)
	local team_id = u.at_team_id or u.team_id
	local length2d = 0
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil
	local target_enemy = nil
	local range = 100
	local target_count = 0

    -- 水人技能宽度
 	if u:FindAbilityByName(a):GetSpecialValueFor('width') > 0 then
 		range = u:FindAbilityByName(a):GetSpecialValueFor('width')
 	-- 沙王技能宽度
 	elseif u:FindAbilityByName(a):GetSpecialValueFor('burrow_width') > 0 then
 		range = u:FindAbilityByName(a):GetSpecialValueFor('burrow_width')
 	-- 光法、蝙蝠技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('radius') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('radius')
	-- 风行技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('arrow_width') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('arrow_width')
	-- 陨石技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('area_of_effect') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('area_of_effect')	
	-- 双头龙冰火技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('path_radius') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('path_radius')	
	end

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			local find_table = TargetCountForMorph(x,y,u,range)
			local count_temp = find_table['count']
			local target = find_table['target']
			if GameRules:GetGameModeEntity().ability_behavior_list[a] == 11 or GameRules:GetGameModeEntity().ability_behavior_list[a] == 19 then
				-- 水人、沙王、蝙蝠等需要占用格子的技能
				if IsEmptyGrid(team_id,x,y) and IsGridCanAttackEnemy(x,y,u) and count_temp > 0 then
					-- 伤害更多单位优先
					if count_temp > target_count then
						target_count = count_temp
						target_enemy = target
						skip_postion = pos2
						length2d = (pos2-pos1):Length2D()
					-- 在伤害单位数相同的情况下，距离更远优先
					elseif count_temp == target_count and (pos2-pos1):Length2D() > length2d and target_count then
						target_enemy = target
						skip_postion = pos2
						length2d = (pos2-pos1):Length2D()
					end
				end
			else
				-- 其他有宽度属性的线性AOE技能
				-- 伤害更多单位优先
				if count_temp > target_count then
					target_count = count_temp
					target_enemy = target
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				-- 在伤害单位数相同的情况下，距离更远优先
				elseif count_temp == target_count and (pos2-pos1):Length2D() > length2d and target_count > 1 then
					target_enemy = target
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
				-- 避免光法波空（光法伤害起始位置在正面前方一段距离）
				if target_count == 1 and target ~= nil then
					skip_postion = target:GetAbsOrigin()
				end
			end
		end
	end

	return {
		skip_postion = skip_postion,
		target_enemy = target_enemy
	}
end	

-- 计算位移到目标格时，能伤害到的单位个数
function TargetCountForMorph(x,y,u,range)
	local team_id = u.at_team_id or u.team_id
	local count = 0
	local ability_distance = (u:GetAbsOrigin() - XY2Vector(x,y,team_id)):Length2D()
	local nearest_distance = 9999
	local nearest_enemy = nil
	local all_enemy = {}
	--遍历所有单位
	for _,enemy in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if IsUnitExist(enemy) == true and enemy.team_id ~= u.team_id and enemy:IsInvisible() == false and IsBozangWudi(enemy) == false then
			local enemy_to_startpoint = (enemy:GetAbsOrigin() - u:GetAbsOrigin()):Length2D()
			local enemy_to_endpoint = (enemy:GetAbsOrigin() - XY2Vector(x,y,team_id)):Length2D()
			local p = (ability_distance + enemy_to_startpoint + enemy_to_endpoint) / 2
			local shortest_distance = 9999
			-- 三个点为钝角三角形，取最短距离
			if math.pow(enemy_to_startpoint, 2) >= math.pow(ability_distance, 2) + math.pow(enemy_to_endpoint, 2) then
		    	shortest_distance = enemy_to_endpoint
		    elseif math.pow(enemy_to_endpoint, 2) >= math.pow(ability_distance, 2) + math.pow(enemy_to_startpoint, 2) then
		    	shortest_distance = enemy_to_startpoint
		    -- 利用海伦公式计算敌方单位到施法路径间的最短距离
		    else
			    shortest_distance = math.sqrt(p * math.abs(p - ability_distance) * math.abs(p - enemy_to_startpoint) * math.abs(p - enemy_to_endpoint)) * 2 / ability_distance
			end
			-- 此处距离判断没有加上施法单位的半径，因为从沙王的实测来看位移技能用下面的公式更合理
		    if shortest_distance <= range + enemy:GetHullRadius() then
		    	table.insert(all_enemy,enemy)
		    	count = count + 1
		    	--比较记录最近的敌人
				if enemy_to_startpoint + shortest_distance * 3 < nearest_distance and shortest_distance <= range then
					nearest_distance = enemy_to_startpoint + shortest_distance * 3
					nearest_enemy = enemy
				end
		    end

		end
	end
	return {
		count = count,
		target = nearest_enemy,
		all_enemy = all_enemy,
	}
end 

function ItemBaoxiang(keys)
	local caster = keys.caster
	local lv = keys.lv

	if caster.loot_table ~= nil then
		Timers:CreateTimer(1,function()
			ItemBaoxiang(keys)
		end)
		return
	end

	play_particle("effect/loot_box/econ/events/ti9/shovel_revealed_loot_variant_0.vpcf",PATTACH_OVERHEAD_FOLLOW,caster,8)

	caster.loot_table = {}
	while table.maxn(caster.loot_table)<3 do
		local loot = RandomALoot(lv)
		if FindValueInTable(caster.loot_table,loot) ~= true then
			table.insert(caster.loot_table,loot)
		end
	end

	local loot_str = ''
	for _,v in pairs(caster.loot_table) do
		loot_str = loot_str..v..','
	end

	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_loot_box",{
		key = GetClientKey(caster:GetTeam()),
		loot_list = loot_str,
	})
end

function RandomALoot(level)
	local ran = RandomInt(1,100)
	local item_level = 0
	local curr_per = 0
	if GameRules:GetGameModeEntity().drop_loot_gailv[level] ~= nil then
		for per,lv in pairs(GameRules:GetGameModeEntity().drop_loot_gailv[level]) do
			if ran >= per and curr_per<=per then
				curr_per = per
				item_level = lv
			end
		end
	end

	local i = GameRules:GetGameModeEntity().DROP_ITEM_LIST[item_level][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().DROP_ITEM_LIST[item_level]))]

	return i
end 

function GiveALootBox(hero)
	local item_name = GameRules:GetGameModeEntity().wave_2_lootbox[GameRules:GetGameModeEntity().battle_round - 1]
	if item_name == nil then
		return
	end

	AddItemPlus(hero,item_name,0.8)

	ShowCombat({
		t = 'player_get_lootbox',
		player = hero:GetPlayerID(),
	})
	EmitSoundOn("dac.loot.drop",hero)
end

function AddItemPlus(hero,item_name,delay)
	if delay == nil then
		delay = 0
	end
	
	Timers:CreateTimer(delay,function()
		local has_enemy_slot = false
		for slot=0,8 do
			if hero:GetItemInSlot(slot) == nil or (hero:GetItemInSlot(slot):GetAbilityName() == item_name and hero:GetItemInSlot(slot):IsStackable()) then
				has_enemy_slot = true
			end
		end
		if has_enemy_slot == true then
			hero:AddItemByName(item_name)
		else
			DropItemAppointed(hero,hero,item_name)
		end
	end)
end

function SlarkNengliangzhuanyi(keys)
	local ability = keys.ability
	local level = ability:GetLevel()
	local caster = keys.caster
	local target = keys.target
	local max_stack_count = keys.max_stack_count

	local pervious_buff_count = 0
	local pervious_debuff_count = 0
	if caster:HasModifier("modifier_slark_nengliangzhuanyi_buff_counter") == true then
		pervious_buff_count = caster:GetModifierStackCount("modifier_slark_nengliangzhuanyi_buff_counter", caster)
	end
	if target:HasModifier("modifier_slark_nengliangzhuanyi_debuff_counter") == true then
		pervious_debuff_count = target:GetModifierStackCount("modifier_slark_nengliangzhuanyi_debuff_counter", caster)
	end

	if pervious_buff_count == 0 then
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_slark_nengliangzhuanyi_buff_counter", nil)
		caster:SetModifierStackCount("modifier_slark_nengliangzhuanyi_buff_counter", caster, 1)
	end
	if pervious_debuff_count == 0 then
		ability:ApplyDataDrivenModifier(caster, target, "modifier_slark_nengliangzhuanyi_debuff_counter", nil)
		target:SetModifierStackCount("modifier_slark_nengliangzhuanyi_buff_counter", caster, 1)
	end

	if pervious_buff_count < max_stack_count and pervious_debuff_count < max_stack_count then
		caster:FindModifierByName("modifier_slark_nengliangzhuanyi_buff_counter"):IncrementStackCount()
		if target ~= nil and target:FindModifierByName("modifier_slark_nengliangzhuanyi_debuff_counter") ~= nil then
			target:FindModifierByName("modifier_slark_nengliangzhuanyi_debuff_counter"):IncrementStackCount()
		end
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_slark_nengliangzhuanyi_buff", nil)
		ability:ApplyDataDrivenModifier(caster, target, "modifier_slark_nengliangzhuanyi_debuff", nil)

		local effect_list = {
			[1] = 'particles/econ/items/slark/slark_ti6_blade/slark_ti6_blade_essence_shift_gold_swipe_dark.vpcf',
			[2] = 'particles/econ/items/slark/slark_ti6_blade/slark_ti6_blade_essence_shift_swipe.vpcf',
			[3] = 'particles/econ/items/slark/slark_ti6_blade/slark_ti6_blade_essence_shift_gold.vpcf',
		}
		play_particle(effect_list[level],PATTACH_ABSORIGIN_FOLLOW,target,2)
	end
end
function TrollRexuezhanhun(keys)
	local ability = keys.ability
	local caster = keys.caster
	local max_stack_count = keys.max_stack_count

	local pervious_buff_count = 0
	if caster:HasModifier("modifier_troll_rexuezhanhun_counter") == true then
		pervious_buff_count = caster:GetModifierStackCount("modifier_troll_rexuezhanhun_counter", caster)
	end
	if pervious_buff_count == 0 then
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_troll_rexuezhanhun_counter", nil)
		caster:SetModifierStackCount("modifier_troll_rexuezhanhun_counter", caster, 1)
	end

	if pervious_buff_count < max_stack_count then
		caster:FindModifierByName("modifier_troll_rexuezhanhun_counter"):IncrementStackCount()
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_troll_rexuezhanhun_buff", nil)
	end
end

--显示caster头顶的miss，默认是红色
function ShowMiss(keys)
	local u = keys.caster
	local color = keys.color or Vector(255, 32, 32)
	if u == nil then
		return
	end
	if u.miss_particle ~= nil then
		ParticleManager:DestroyParticle(u.miss_particle,true)
		u.miss_particle = nil
		u.miss_particle_id = nil
	end
	local pos = PATTACH_ABSORIGIN_FOLLOW
	local pp = ParticleManager:CreateParticle('effect/miss/1.vpcf', pos, u)

	ParticleManager:SetParticleControl(pp, 0, u:GetOrigin())
    ParticleManager:SetParticleControl(pp, 3, color)
    ParticleManager:SetParticleControl(pp, 4, Vector(5, 0, 0))

    local id = RandomFloat(1,10000)
    u.miss_particle = pp
    u.miss_particle_id = id

	Timers:CreateTimer(5,function()
		if u.miss_particle ~= nil and u.miss_particle_id == id then
			ParticleManager:DestroyParticle(u.miss_particle,true)
			u.miss_particle = nil
    		u.miss_particle_id = nil
		end
	end)

	--9精灵：闪避幻象
	local target = u:GetAttackTarget()
	if IsUnitExist(target) == true and target:GetHealth() > 0 and (target.elf_illusion == nil or IsUnitExist(target.elf_illusion) == false ) then
		if target:FindModifierByName('modifier_is_elf_buff_plus_plus') ~= nil and target:FindAbilityByName('is_elf_buff_plus_plus') ~= nil and target:FindAbilityByName('is_elf_buff_plus_plus'):IsCooldownReady() == true then
			target.elf_illusion = target
			play_particle("particles/units/heroes/hero_mirana/mirana_moonlight_ray.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,2)
			EmitSoundOn("Hero_Dark_Seer.Ion_Shield_end",target)
			target:FindAbilityByName('is_elf_buff_plus_plus'):StartCooldown(3)
			Timers:CreateTimer(0.1,function()
				if IsUnitExist(target) == true and target:GetHealth() > 0 then
					local i1 = SummonOneMinion(target,target:GetUnitName())
					i1:SetHealth(target:GetHealth())
					i1:AddNewModifier(i1,nil,"modifier_illusion",{duration = 10})
					i1:SetMaxMana(0)
					target.elf_illusion = i1
					FillEmptySlot(i1)
				end
			end)
		end
	end
end

function AllocateABattleRoundV3()
	local finished = false
	local trytime = 0

	GameRules:GetGameModeEntity().last_3rd_round = GameRules:GetGameModeEntity().last_2nd_round
	GameRules:GetGameModeEntity().last_2nd_round = GameRules:GetGameModeEntity().last_round
	GameRules:GetGameModeEntity().last_round = GameRules:GetGameModeEntity().current_round

	while trytime < 10000 and finished == false do
		trytime = trytime + 1
		GameRules:GetGameModeEntity().current_round = {}
		
		local alive_player_count = 0
		--统计玩家死活
		for u,v in pairs(GameRules:GetGameModeEntity().counterpart) do
			if TeamId2Hero(u) ~= nil and TeamId2Hero(u):IsNull() == false and TeamId2Hero(u):IsAlive() == true then
				--活玩家
				GameRules:GetGameModeEntity().counterpart[u] = u
				alive_player_count = alive_player_count + 1
			else
				--死玩家
				GameRules:GetGameModeEntity().counterpart[u] = -1
			end
		end

		local rann = 0
		if alive_player_count <= 1 then
			rann = 0
		elseif alive_player_count == 2 then
			rann = 1
		else
			rann = RandomInt(1,alive_player_count-1)
		end
		--给活玩家分配一个随机对手
		for rotate_count = 1,rann do
			for i,j in pairs(GameRules:GetGameModeEntity().counterpart) do
				if j ~= -1 then
					local aliveteam = j

					local try_count = 0
					while (aliveteam == j or GameRules:GetGameModeEntity().counterpart[aliveteam] == nil or GameRules:GetGameModeEntity().counterpart[aliveteam] == -1) and try_count<10000 do
						aliveteam = aliveteam + 1
						if aliveteam > 13 then
							aliveteam = 6
						end
						try_count = try_count + 1
					end
					GameRules:GetGameModeEntity().counterpart[i] = aliveteam
				end
			end
		end

		for ii,jj in pairs(GameRules:GetGameModeEntity().counterpart) do
			if jj ~= -1 then
				table.insert(GameRules:GetGameModeEntity().current_round, ii * 100 + jj)
			end
		end
		
		finished = true
		for i, v in pairs(GameRules:GetGameModeEntity().current_round) do
			if alive_player_count >= 7 then
				if IsValueInTable(v, GameRules:GetGameModeEntity().last_round) == true or IsValueInTable(v, GameRules:GetGameModeEntity().last_2nd_round) == true or IsValueInTable(v, GameRules:GetGameModeEntity().last_3rd_round) == true then
					finished = false
				end
			elseif alive_player_count >= 5 then 
				if IsValueInTable(v, GameRules:GetGameModeEntity().last_round) == true or IsValueInTable(v, GameRules:GetGameModeEntity().last_2nd_round) == true then
					finished = false
				end
			elseif alive_player_count >= 3 then 
				if IsValueInTable(v, GameRules:GetGameModeEntity().last_round) == true then
					finished = false
				end
			elseif alive_player_count >= 1 then 
				finished = true
			else
				return
			end
		end
	end
end

function IsValueInTable(value, table)
	for k,v in pairs(table) do
	  if v == value then
	  	return true
	  end
	end
	return false
end

function IsChessKnight3Wudi( chess )
	return false
	-- if IsUnitExist(chess) == false then
	-- 	return false
	-- end
	-- if chess:FindModifierByName('modifier_is_knight_buff_2') ~= nil and chess:FindModifierByName('modifier_is_knight_buff_2_plus') ~= nil and chess:FindModifierByName('modifier_is_knight_buff_2_plus_plus') ~= nil then
	-- 	return false
	-- end
end

function ChangeUnitPosition(unit, new_position, is_immediately)
	local team_id = unit.at_team_id or unit.team_id
	local old_position = unit:GetAbsOrigin()
	local old_y = unit.y
	local old_x = unit.x
	local old_y_x = unit.y_x
	local new_y = Vector2Y(new_position,team_id)
	local new_x = Vector2X(new_position,team_id)
	local new_y_x = new_y..'_'..new_x

	GameRules:GetGameModeEntity().unit[team_id][old_y_x] = nil
	GameRules:GetGameModeEntity().unit[team_id][new_y_x] = 1
	unit.y_x = new_y_x
	unit.y = new_y
	unit.x = new_x

	if is_immediately == true then
		if unit:HasModifier("modifier_jump") or unit:HasModifier("modifier_run") or unit:HasModifier("modifier_tuitui") or unit:HasModifier("modifier_elfrun") then
			unit:RemoveModifierByName("modifier_jump")
			unit:RemoveModifierByName("modifier_run")
			unit:RemoveModifierByName("modifier_elfrun")
			unit:RemoveModifierByName("modifier_tuitui")
		end
		unit:SetAbsOrigin(new_position)
	end
end

function FingerOfDeathDamage(keys)
	local caster = keys.caster
	local target = keys.target
	
end

function LionManaDrainStart(keys)
	local caster = keys.caster
	local target = keys.target
end

function LionManaDrainEnd(keys)
	local caster = keys.caster
	local target = keys.target
	local ability_level = keys.ability:GetLevel()
	-- local cd_reduce = caster:FindAbilityByName('lion_mana_drain_datadriven'):GetSpecialValueFor('cd_reduce')

	if IsUnitExist(caster) == true and caster:GetMana() >= 0 and caster.is_comboing ~= true then
		caster.is_comboing = true
		caster:SwapAbilities('lion_mana_drain_datadriven','keeper_of_the_light_chakra_magic', false, true)
		Timers:CreateTimer(1.5,function()
			if IsUnitExist(caster) == true then
		 		caster:SwapAbilities('keeper_of_the_light_chakra_magic','lion_mana_drain_datadriven', false, true)
				caster.is_comboing = nil
			end
	 	end)
		Timers:CreateTimer(0.1,function()
			if caster:FindAbilityByName('keeper_of_the_light_chakra_magic') ~= nil then
				--找三个队友
				local luckydog_1 = nil
				local level_1 = -999
				local luckydog_2 = nil
				local level_2 = -999
				local luckydog_3 = nil
				local level_3 = -999
				for i1,v1 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.at_team_id or caster.team_id]) do
					if v1:GetMaxMana() > 0 and v1:GetMana() < 100 and v1:GetLevel() - GetChessAbilityCD(v1) > level_1 and v1.team_id == caster.team_id and v1:entindex() ~= caster:entindex() then
						level_1 = v1:GetLevel() - GetChessAbilityCD(v1)
						luckydog_1 = v1
					end
				end
				if luckydog_1 ~= nil and ability_level >= 2 then
					for i2,v2 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.at_team_id or caster.team_id]) do
						if v2:GetMaxMana() > 0 and v2:GetMana() < 100 and v2:GetLevel() - GetChessAbilityCD(v2) > level_2 and v2.team_id == caster.team_id and v2:entindex() ~= luckydog_1:entindex() and v2:entindex() ~= caster:entindex() then
							level_2 = v2:GetLevel() - GetChessAbilityCD(v2)
							luckydog_2 = v2
						end
					end
				end
				if luckydog_1 ~= nil and luckydog_2 ~= nil and ability_level >= 3 then
					for i3,v3 in pairs(GameRules:GetGameModeEntity().to_be_destory_list[caster.at_team_id or caster.team_id]) do
						if v3:GetMaxMana() > 0 and v3:GetMana() < 100 and v3:GetLevel() - GetChessAbilityCD(v3) > level_3 and v3.team_id == caster.team_id and v3:entindex() ~= luckydog_2:entindex() and v3:entindex() ~= luckydog_1:entindex() and v3:entindex() ~= caster:entindex() then
							level_3 = v3:GetLevel() - GetChessAbilityCD(v3)
							luckydog_3 = v3
						end
					end
				end

				if luckydog_1 == nil then
					return
				end

				ExecuteOrderFromTable({
			 		UnitIndex = caster:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
			 		TargetIndex = luckydog_1:entindex(), --Optional.  Only used when targeting units
			 		AbilityIndex = caster:FindAbilityByName('keeper_of_the_light_chakra_magic'):entindex(), --Optional.  Only used when casting abilities
			 		Position = nil, --Optional.  Only used when targeting the ground
			 		Queue = 0 --Optional.  Used for queueing up abilities
			 	})
			 	Timers:CreateTimer(0.3,function()
					local give_mana = caster:GetMana()
					caster:SetMana(0)

					if IsUnitExist(luckydog_1) == true then
						luckydog_1:GiveMana(give_mana)
						-- ReduceChessAbilityCD(luckydog_1,cd_reduce)
						AMHC:CreateNumberEffect(luckydog_1,give_mana,2,AMHC.MSG_MISS,{128,128,255},0)
					end
					if IsUnitExist(luckydog_2) == true then
						local pp2 = ParticleManager:CreateParticle('particles/units/heroes/hero_keeper_of_the_light/keeper_of_the_light_chakra_magic.vpcf', PATTACH_ABSORIGIN_FOLLOW, luckydog_2)
						ParticleManager:SetParticleControlEnt( pp2, 0, luckydog_2, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_2:GetOrigin(), true );
						ParticleManager:SetParticleControlEnt( pp2, 1, luckydog_2, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_2:GetOrigin(), true );
						Timers:CreateTimer(3,function()
							if pp2 ~= nil then
								ParticleManager:DestroyParticle(pp2,true)
							end
						end)

						luckydog_2:GiveMana(give_mana)
						-- ReduceChessAbilityCD(luckydog_2,cd_reduce)
						AMHC:CreateNumberEffect(luckydog_2,give_mana,2,AMHC.MSG_MISS,{128,128,255},0)
					end
					if IsUnitExist(luckydog_3) == true then
						local pp3 = ParticleManager:CreateParticle('particles/units/heroes/hero_keeper_of_the_light/keeper_of_the_light_chakra_magic.vpcf', PATTACH_ABSORIGIN_FOLLOW, luckydog_3)
						ParticleManager:SetParticleControlEnt( pp3, 0, luckydog_3, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_3:GetOrigin(), true );
						ParticleManager:SetParticleControlEnt( pp3, 1, luckydog_3, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_3:GetOrigin(), true );
						Timers:CreateTimer(3,function()
							if pp3 ~= nil then
								ParticleManager:DestroyParticle(pp3,true)
							end
						end)

						luckydog_3:GiveMana(give_mana)
						-- ReduceChessAbilityCD(luckydog_3,cd_reduce)
						AMHC:CreateNumberEffect(luckydog_3,give_mana,2,AMHC.MSG_MISS,{128,128,255},0)
					end
			 	end)
			 	
			end
		end)
	end
end

function GetChessAbilityCD(u)
	local cd = 9999
	if IsUnitExist(u) == false then
		return cd
	end
	local ability_name = GetChessAbility(u)
	if ability_name ~= nil then
		cd = math.floor(u:FindAbilityByName(ability_name):GetCooldownTimeRemaining())
	end
	return cd
end

function GetChessAbility(u)
	local a = nil
	if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
		a = u.steal_ability
	elseif string.find(u:GetUnitName(),'chess_kael') and u.kael_ability ~= nil then
		a = u.kael_ability	
	else
		a = GameRules:GetGameModeEntity().chess_ability_list[u:GetUnitName()] or GameRules:GetGameModeEntity().summon_ability_list[u:GetUnitName()]
	end
	if u.ice_or_fire == 'fire' then
		a = 'jakiro_macropyre'
	end
	if u.ice_or_fire == 'ice' then
		a = 'jakiro_ice_path'
	end
	return a
end

function ReduceChessAbilityCD(u,sec)
	if IsUnitExist(u) == false then
		return
	end
	if sec == nil then
		return
	end
	local ability_name = GameRules:GetGameModeEntity().chess_ability_list[u:GetUnitName()]
	local ability = u:FindAbilityByName(ability_name)
	if GetChessTypeName(u) == 'chess_rubick' and u.steal_ability ~= nil then
		ability = u:FindAbilityByName(u.steal_ability)
	end
	local cd = ability:GetCooldownTimeRemaining()
	local cd_new = cd - sec
	if cd_new < 0 then
		cd_new = 0
	end
	if cd_new <= 0 then
		ability:EndCooldown()
	else
		ability:EndCooldown()
		ability:StartCooldown(cd_new)
	end
end

function FindMaxManaUnluckydog(u)
	local unluckydog = nil
	local max_mana = -1
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit:GetMana() > max_mana and unit.team_id ~= u.team_id and unit:FindModifierByName('modifier_mana_drain_datadriven') == nil then
			unluckydog = unit
			max_mana = unit:GetMana()
		end
	end
	return unluckydog
end

function UpdatePlayerWorldPanel(battle_table)
	if battle_table == nil then
		battle_table = {
			[6] = {},
			[7] = {},
			[8] = {},
			[9] = {},
			[10] = {},
			[11] = {},
			[12] = {},
			[13] = {},
		}
		for i=6,13 do
			if TeamId2Hero(i) ~= nil and TeamId2Hero(i).steam_id ~= nil then
				battle_table[i] = {
					steam_id = TeamId2Hero(i).steam_id
				}
			end
		end
	end
	if GameRules:GetGameModeEntity().battle_boss[GameRules:GetGameModeEntity().battle_round] ~= nil then
		battle_table['pve_round'] = GameRules:GetGameModeEntity().battle_round
	end
	for i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(i,"update_player_worldpanel",battle_table)
	end
	CustomGameEventManager:Send_ServerToTeam(1,"update_player_worldpanel",battle_table)
end
function ShowQuest()
	CustomNetTables:SetTableValue( "quest_table", "show_quest", {
		quest = GameRules:GetGameModeEntity().egg_quest,
		status = GameRules:GetGameModeEntity().quest_status, 
		hehe = RandomFloat(0,10000),
	})
end
function SetQuest(team,tf)
	if GameRules:GetGameModeEntity().quest_status[team] ~= -1 then
		GameRules:GetGameModeEntity().quest_status[team] = tf
	end
	
	ShowQuest()
end

function TeamId2PlayerName(team)
	local hero = TeamId2Hero(team)
	local steam_id = hero.steam_id
	local player_name = GameRules:GetGameModeEntity().steamid2name[steam_id] or '未知玩家'
	return player_name
end

--向table中添加一个内容（去重,后面的11和1会被去掉）
function SAdd(t, v)
	if string.find(v,'11') ~= nil then
		v = string.sub(v,1,-3)
	end
	if string.find(v,'1') ~= nil then
		v = string.sub(v,1,-2)
	end
	if FindValueInTable(t, v) == true then
		return table.maxn(t)
	else
		table.insert(t, v)
		-- DeepPrintTable(t)
		return table.maxn(t)
	end
end

--统计本局中一共有多少正在游戏的玩家（观战的不算）
function GetPlayingPlayerCount()
	if GameRules:GetGameModeEntity().playing_player_count > 0 then
		return GameRules:GetGameModeEntity().playing_player_count
	else
		local playing_player_count = 0
		local obing_player_count = 0
		for player_id,_ in pairs(GameRules:GetGameModeEntity().playerid2steamid) do
			if PlayerResource:GetTeam(player_id) >= 6 and PlayerResource:GetTeam(player_id) <= 13 then
				playing_player_count = playing_player_count + 1
			end
			if PlayerResource:GetTeam(player_id) == 1 then
				obing_player_count = obing_player_count + 1
			end
		end
		GameRules:GetGameModeEntity().playing_player_count = playing_player_count
		GameRules:GetGameModeEntity().obing_player_count = obing_player_count
		combat('PLAYER COUNT: '..GameRules:GetGameModeEntity().playing_player_count)
		if GameRules:GetGameModeEntity().obing_player_count > 0 then
			combat('OB COUNT: '..GameRules:GetGameModeEntity().obing_player_count)
			CustomGameEventManager:Send_ServerToAllClients("show_ob_count",{
				count = GameRules:GetGameModeEntity().obing_player_count
			})
		end
		return GameRules:GetGameModeEntity().playing_player_count
	end
end

function InitPlayerIDTable()
	for i=0,11 do
		local hero = PlayerId2Hero(i)
		if hero ~= nil then
			local team_id = hero:GetTeam()
			local player_index = team_id - 6
			local hero_index = hero:entindex()

			CustomNetTables:SetTableValue( "player_id_table", 'player_'..i, {
				player_id = i,
				team_id = team_id,
				player_index = player_index,
				hero_index = hero_index,
			})
		end
	end
end

function DAC:OnChooseBadge(keys)
	local player_id = keys.PlayerID
	local badge = keys.badge

	CustomNetTables:SetTableValue( "player_id_table", 'badge_'..player_id, {badge=badge})
end

function DAC:OnShowGameNotice(keys)
	local player_id = keys.PlayerID
	if player_id ~= 0 then
		return
	end
	local text = keys.text
	-- prt(text)
end

function DAC:OnPlayerLanguage(keys)
	local player_id = keys.PlayerID
	local language = keys.language
	local hero = PlayerId2Hero(player_id)
	if hero ~= nil then
		-- prt('player_id='..player_id..'--->language='..language)
		hero.language = language
	end
end

function InitChessMana(chess)
	if chess:FindModifierByName('modifier_item_nengliangqiu') ~= nil or chess:FindModifierByName('modifier_item_wangyuanjing') ~= nil or chess:FindModifierByName('modifier_item_aoshuxie') ~= nil or chess:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
		chess:SetMana(40)
		AMHC:CreateNumberEffect(chess,40,2,AMHC.MSG_MISS,{128,128,255},0)
	else
		chess:SetMana(0)
	end
end

function AnMieProjectile(keys)
	local caster = keys.caster
	caster:SetRangedProjectileName("particles/items_fx/desolator_projectile.vpcf")
end

--其实命运敕令第三个字应该都chi，但是语死早的代码里有很多mingyunsheling，懒得改了...囧
function OracleMingyunSheling(keys)
	local caster = keys.caster
	local u1 = keys.target
	local level = keys.ability:GetLevel() or 1
	if IsUnitExist(caster) == false or IsUnitExist(u1) == false then 
		return
	end
	local sub_ability_name = 'oracle_mingyunsheling_one'

	local u0 = FindMingyunShelingTarget(u1)
	if u0 == nil then
		return
	end

	if u1 ~= nil then
		u1.has_mingyun_sheling = true
		InvisibleUnitCast({
			caster = caster,
			ability = sub_ability_name,
			level = level,
			unluckydog = u1,
		})

		if level >= 2 then
			Timers:CreateTimer(0.1,function()
				if IsUnitExist(caster) == false then 
					return
				end
				local u2 = FindMingyunShelingTarget(u1)
				if u2 ~= nil then
					u2.has_mingyun_sheling = true
					InvisibleUnitCast({
						caster = caster,
						ability = sub_ability_name,
						level = level,
						unluckydog = u2,
						ignore_nether_ward = true,
					})
					if level >= 3 then
						Timers:CreateTimer(0.1,function()
							if IsUnitExist(caster) == false then 
								return
							end
							local u3 = FindMingyunShelingTarget(u2)
							if u3 ~= nil then
								u3.has_mingyun_sheling = true
								InvisibleUnitCast({
									caster = caster,
									ability = sub_ability_name,
									level = level,
									unluckydog = u3,
									ignore_nether_ward = true,
								})
							end
						end)
					end
				end
			end)
		end
	end
end

function FindMingyunShelingTarget(u)
	local unluckydog = u
	local hp_per = 0
	local un_chiling_enemy_count = 0
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id == u.team_id then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100
			local level = unit:GetLevel()

			if unit.has_mingyun_sheling == nil then
				un_chiling_enemy_count = un_chiling_enemy_count + 1
			end

			if per+level > hp_per and unit.has_mingyun_sheling == nil then
				unluckydog = unit
				hp_per = per+level
			end
		end
	end
	if un_chiling_enemy_count <= 1 then
		unluckydog = nil
	end
	return unluckydog
end

function AddMingyunShelingDebuff(keys)
	local target = keys.target
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local jingu_duration = ability:GetLevelSpecialValueFor( "jingu_duration", level - 1 )	

	if BlockByLinken(target) == false then
		ability:ApplyDataDrivenModifier(target,target,'modifier_oracle_mingyunsheling',{ duration = jingu_duration})
	end
end

function RemoveMingyunSheling(keys)
	local target = keys.target
	target.has_mingyun_sheling = nil
end

function FillEmptySlot(x)
	--用空物品塞满剩下的格子，避免物品放进来丢失
	local slot_count = 9
	for slot=0,8 do
		if x:GetItemInSlot(slot)~= nil then
			slot_count = slot_count - 1
		end
	end
	if slot_count > 0 then
		for i=1,slot_count do
			x:AddItemByName('item_null')
		end
	end
end
function SummonAChess(teamid,position,chessname,at_teamid,health_percent,mana,items,is_tuihua)
	--生成一个退化的棋子
	if position == nil then
		return
	end
	if teamid == nil then
		return
	end
	if at_teamid == nil then
		return
	end
	--判断英雄是否还活着
	local hero1 = TeamId2Hero(at_teamid)
	if hero1:IsNull() or hero1:IsAlive() == false or hero1.is_battle_completed == true then
		return
	end
	if GameRules:GetGameModeEntity().battle_timer <= 1 then
		return
	end
	
	local x = CreateUnitByName(chessname,position,true,nil,nil,teamid)

	table.insert(GameRules:GetGameModeEntity().to_be_destory_list[at_teamid],x)
	AddAbilityAndSetLevel(x,'root_self')
	AddAbilityAndSetLevel(x,'jiaoxie_wudi')
	x.x = Vector2X(position,at_teamid)
	x.y = Vector2Y(position,at_teamid)
	x.y_x = ''..x.y..'_'..x.x
	x.at_team_id = at_teamid
	x.team_id = teamid
	x.is_tuihuaed = true
	x:SetHealth(x:GetMaxHealth()*health_percent)
	x:SetMana(mana or 0)

	if items ~= nil then
		GiveItems2Unit(items,x)
	end
	FillEmptySlot(x)

	GameRules:GetGameModeEntity().unit[at_teamid][x.y..'_'..x.x] = 1

	if x:GetTeam() == 4 then
		x:SetForwardVector(Vector(0,-1,0))
	else
		x:SetForwardVector(Vector(0,1,0))
	end

	-- if is_tuihua then
	-- 	Timers:CreateTimer(0.1,function()
	-- 		x:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(x,x,'modifier_transfer_debuff',{ duration = 2})
	-- 	end)
	-- else
	-- 	Timers:CreateTimer(0.1,function()
	-- 		local transfer_duration = x:GetLevel()/2
	-- 		x:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(x,x,'modifier_transfer_buff',{ duration = transfer_duration})
	-- 	end)
	-- end

	--添加战斗技能和棋子AI
	Timers:CreateTimer(0.1,function()
		x.is_in_battle = true
		if GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()] ~= nil then
			local a = GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()]
			local a_level = 1
			if string.find(x:GetUnitName(),'1') then
				a_level = 2
			end
			if string.find(x:GetUnitName(),'11') then
				a_level = 3
			end
			if x:FindAbilityByName(a) == nil then
				AddAbilityAndSetLevel(x,a,a_level)
			else
				x:FindAbilityByName(a):SetLevel(a_level)
			end
			x:RemoveAbility('jiaoxie_wudi')
			x:RemoveModifierByName('modifier_jiaoxie_wudi')
		end
		Timers:CreateTimer(0.5,function()
			if x == nil or x:IsNull() == true or x:IsAlive() == false or x.alreadywon == true then
				return
			end
			ChessAI(x)
			return 1
		end)
	end)

	return x
end
function HunterKnockBack(keys)
	local caster = keys.caster
	local target = keys.target
	local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
	local deltax = math.floor(vec.x+0.5)
	local deltay = math.floor(vec.y+0.5)

	local team_id = target.at_team_id or target.team_id

	local y = target.y
	local x = target.x
	if IsIn8x8(x+deltax,y+deltay) == true and IsEmptyGrid(team_id,x+deltax,y+deltay) == true and not target:HasModifier('modifier_tuitui') and target:HasMovementCapability() == true then
		local target_pos = XY2Vector(x+deltax,y+deltay,team_id)
		local stun_duration = ((target_pos-target:GetAbsOrigin()):Length2D()/1000)
		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+0.1})

		GameRules:GetGameModeEntity().unit[team_id][(y+deltay)..'_'..(x+deltax)] = 1
		target.is_moving = true
		BlinkChessX({p=target_pos,caster=target,blink_type='tuitui'})
		target.y_x = (y+deltay)..'_'..(x+deltax)
		target.y = y+deltay
		target.x = x+deltax
		GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] = nil
	end
end
--亡语
function DeathRattle(u,attacker)
	--6亡灵亡语：幽魂形态（如成功则return，不触发后面的）
	if attacker:HasModifier('modifier_is_undead_buff_plus_plus') == true and u.is_youhun ~= true and ((u.at_team_id or u.team_id) == (attacker.at_team_id or attacker.team_id)) and u:HasAbility('is_ward') == false then
		local items = GetAllItemsInUnits({[1] = u})
		local i1 = SummonOneMinion(u,u:GetUnitName(),u:GetAbsOrigin())
		if items ~= nil then
			GiveItems2Unit(items,i1)
		end
		i1.is_youhun = true
		FillEmptySlot(i1)
		ExtendBeastBuff(i1,u)
		i1:AddNewModifier(i1,nil,"modifier_skeleton_king_reincarnation_scepter_active",{duration = 5})
		i1:SetMaxMana(0)
		Timers:CreateTimer(5,function()
			if IsUnitExist(i1) == true then
				i1:ForceKill(false)
			end
		end)
		return
	end
	--6术士灵魂榨取亡语：最近的术士吸取（优先级最高，不影响其他）
	local Warlock6_enemy = FindClosestWarlock6Enemy(u)
	if IsUnitExist(Warlock6_enemy) == true and u:HasModifier('modifier_illusion') == false and u.last_damage_ability ~= 'is_monk_buff' then
		local hh = u:GetMaxHealth()
		local mm = u:GetMana()
		play_particle("particles/units/heroes/hero_dark_seer/dark_seer_surge.vpcf",PATTACH_ABSORIGIN_FOLLOW,Warlock6_enemy,3)
		ModMaxHP({
			caster = Warlock6_enemy,
			const = hh,
			is_heal = true,
		})
		ChessAddMana(Warlock6_enemy,mm)
		EmitSoundOn('warlock.brainsap',Warlock6_enemy)
		Warlock6_enemy:SetRenderColor(255-(Warlock6_enemy:GetMaxHealth()/100), 255, 255-(Warlock6_enemy:GetMaxHealth()/100))
	end

	--4萨满亡语：退化攻击者（不影响其他）
	-- if u:HasModifier('modifier_is_shaman_buff_plus') and u.is_youhun ~= true then
	-- 	if IsUnitExist(attacker) == true and string.find(attacker:GetUnitName(),'chess_') ~= nil and attacker.alreadywon ~= true then

	-- 		local aposition = attacker:GetAbsOrigin()
	-- 		local teamid = attacker.team_id
	-- 		local at_teamid = attacker.at_team_id or attacker.team_id
	-- 		local star = GetChessNameStar(attacker:GetUnitName())
	-- 		local cost = GameRules:GetGameModeEntity().chess_2_mana[GetUnitBaseName(attacker)]
	-- 		local c = cost---1
	-- 		if c == nil or c < 1 then
	-- 			c = 1
	-- 		end
	-- 		local health_percent = attacker:GetHealth()/attacker:GetMaxHealth()
	-- 		local mana = attacker:GetMana()

	-- 		local items = GetAllItemsInUnits({[1] = attacker})

	-- 		--销毁攻击者
	-- 		if IsUnitExist(attacker) == true and attacker.tuihua ~= true then
	-- 			attacker.tuihua = true
	-- 			--生成新的攻击者
	-- 			local t = GameRules:GetGameModeEntity().chess_list_by_mana[c]
	-- 			local uname = t[RandomInt(1,table.maxn(t))]
	-- 			local name_suffix = ''
	-- 			if star == 2 then
	-- 				name_suffix = '1'
	-- 			elseif star == 3 then
	-- 				name_suffix = '11'
	-- 			end
	-- 			local unitname = uname..name_suffix

	-- 			local x = SummonAChess(teamid,aposition,unitname,at_teamid,health_percent,mana, items, true)

	-- 			RemoveFromToBeDestroyList(attacker)
	-- 			AddAbilityAndSetLevel(attacker,'no_selectable')

	-- 			Timers:CreateTimer(0.1,function()
	-- 				if IsUnitExist(attacker) == true then
	-- 					if attacker.team_id ~= 4 then
	-- 						SaveItem(attacker.team_id,attacker:entindex(),function()
	-- 							attacker:Destroy()
	-- 						end)
	-- 					else
	-- 						attacker:Destroy()
	-- 					end
	-- 				end
	-- 			end)
	-- 		end
	-- 	end
	-- end

	--近战棋子亡语：所有食人魔变胖（不影响其他）
	if u:IsRangedAttacker() == false then
		for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
			if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and v:HasModifier('modifier_is_ogre_buff') == true then
				if v.ogre_buff_count == nil or (v.ogre_buff_count ~= nil and v.ogre_buff_count < 10) then
					ModMaxHP({
						caster = v,
						per = 20,
					})
					ChangeModelScale({
						caster = v,
						x = 1.1, 
					})
					if v:FindModifierByName("modifier_ogre_25_attack_damage") == nil then
						AddAbilityAndSetLevel(v,"ogre_25_attack_damage",1)
						EmitSoundOn('ogre.fat',v)
						v.ogre_buff_count = 1
					else
						v:FindAbilityByName("ogre_25_attack_damage"):ApplyDataDrivenModifier(v,v,'modifier_ogre_25_attack_damage',{})
						EmitSoundOn('ogre.fat',v)
						v.ogre_buff_count = v.ogre_buff_count + 1
					end
				end
			end
		end
	end

	--亚基虫族亡语：生虫（如成功则return，不触发后面的）
	if u:HasModifier('modifier_is_aqir_buff') == true then
		
		local AQIR_CHESS_LIST = {
			[1] = { 'chess_sk', 'chess_veno' },
			[2] = { 'chess_sk', 'chess_veno' },
			[3] = { 'chess_sk', 'chess_veno' },
			[4] = { 'chess_na', 'chess_br', },
			[5] = { 'chess_sk1','chess_veno1', },
			[6] = { 'chess_na1', 'chess_br1', },
			[7] = { 'chess_sk11','chess_veno11',},
			[8] = { 'chess_na11', 'chess_br11', },
			[9] = { 'chess_na11', 'chess_br11', },
		}
		local max_level,max_level_chess = GetSameNameFriendChessMaxLevel(u)

		-- local dead_level = u:GetLevel()

		if max_level > 0 then
			if u:HasAbility('is_aqir') == true then
				if RandomInt(1,100) < 10 then
					max_level = max_level + 2
				elseif RandomInt(1,100) > 75 then
					max_level = max_level + 1
				end
			else
				if RandomInt(1,100) <= 20 then
					max_level = max_level + 1
				end
			end
			if max_level > 9 then
				max_level = 9
			end

			local random_pool = AQIR_CHESS_LIST[max_level]
			local random_aqir = random_pool[RandomInt(1,table.maxn(random_pool))]
			local aqir_level = GetChessNameStar(random_aqir)

			if aqir_level == 1 then
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_emerge_clean_low.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn('Hero_LifeStealer.Infest',u)
				local x = SummonOneMinion(u,random_aqir,u:GetAbsOrigin())
				x:SetMana(0)
				FillEmptySlot(x)
				ExtendBeastBuff(x,u)
				AddChessAbility(x,aqir_level)
				AddAbilityAndSetLevel(x,'jiaoxie_wudi')
				if max_level_chess ~= nil then
					LinkEffect(x,max_level_chess)
				end
				return
			elseif aqir_level == 2 then
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_emerge_clean_low.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn('Hero_LifeStealer.Infest',u)
				local x = SummonOneMinion(u,random_aqir,u:GetAbsOrigin())
				x:SetMana(0)
				FillEmptySlot(x)
				ExtendBeastBuff(x,u)
				AddChessAbility(x,aqir_level)
				AddAbilityAndSetLevel(x,'jiaoxie_wudi')
				if max_level_chess ~= nil then
					LinkEffect(x,max_level_chess)
				end
				return
			elseif aqir_level >= 3 then
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_emerge_bloody.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn('Hero_LifeStealer.Infest',u)
				local x = SummonOneMinion(u,random_aqir,u:GetAbsOrigin())
				x:SetMana(0)
				FillEmptySlot(x)
				ExtendBeastBuff(x,u)
				AddChessAbility(x,aqir_level)
				AddAbilityAndSetLevel(x,'jiaoxie_wudi')
				if max_level_chess ~= nil then
					LinkEffect(x,max_level_chess)
				end
				return
			else
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_cast.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn('Hero_LifeStealer.Infest',u)
			end
		else
			play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_cast.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
			EmitSoundOn('Hero_LifeStealer.Infest',u)
		end
	end
	
	--在蛛网中死亡：诞生小蜘蛛（如成功则return，不触发后面的）
	if u:HasModifier('modifier_br_web_debuff') == true then
		
		if u:FindModifierByName('modifier_br_web_debuff') == nil or u:FindModifierByName('modifier_br_web_debuff'):GetAbility() == nil then
			return
		end
		local level = u:FindModifierByName('modifier_br_web_debuff'):GetAbility():GetLevel() or 1
		local spider_name = 'br_spider'..level
		-- prt(spider_name)
		play_particle('particles/units/heroes/hero_broodmother/broodmother_spiderlings_spawn.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
		EmitSoundOn('Hero_LifeStealer.Infest',u)
		if attacker:entindex() ~= u:entindex() then
			local x = SummonOneMinion(attacker,spider_name,u:GetAbsOrigin())
			x:SetMana(0)
			FillEmptySlot(x)
			ExtendBeastBuff(x,attacker)
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
		end
		return
	end
end

--获取场上存活的同名友方棋子数量
function GetSameNameFriendChessCount(u)
	local same_count = 0
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) then
			same_count = same_count + 1
		end
	end

	return same_count
end
--获取场上存活的同名友方棋子星级之和
function GetSameNameFriendChessTotalStars(u)
	local stars = 0
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) then
			stars = stars + GetChessStar(v)
		end
	end

	return stars
end

function FindClosestWarlock6Enemy(u)
	local closest_enemy = nil
	local closest_distance = 9999
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if IsUnitExist(v) == true and v.team_id ~= u.team_id and v:HasModifier('modifier_is_warlock_buff_plus_plus') == true then
			local distance = (v:GetAbsOrigin()-u:GetAbsOrigin()):Length2D()
			if distance < closest_distance then
				closest_distance = distance
				closest_enemy = v
			end
		end
	end
	return closest_enemy
end

function GetSameNameFriendChessMaxLevel(u)
	local max_level = 0
	local max_level_chess = nil
	local is_aqir = false
	if IsHexxed(u) == true then
		return 0
	end
	
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) and v:GetLevel() > max_level and IsHexxed(v) == false then
			max_level = v:GetLevel()
			max_level_chess = v
		end
	end

	if max_level < 0 then
		max_level = 0
	end
	if max_level > 9 then
		max_level = 9
	end

	return max_level,max_level_chess
end

function HasSameNameFriendChess(u)
	if IsHexxed(u) == true then
		return false
	end
	
	for _,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) and IsHexxed(v) == false then
			return true
		end
	end

	return false
end

--获得棋子名字的基础部分（去掉1和11）
function GetUnitBaseName(u)
	local unit_name = u:GetUnitName() 
	if string.find(unit_name,'chess_') ~= nil then
		if string.find(unit_name,'11') ~= nil then
			unit_name = string.sub(unit_name,1,-3)
		end
		if string.find(unit_name,'1') ~= nil then
			unit_name = string.sub(unit_name,1,-2)
		end
	end
	return unit_name
end

--添加棋子战斗技能
function AddChessAbility(x,level)
	if GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()] ~= nil then
		local a = GameRules:GetGameModeEntity().chess_ability_list[x:GetUnitName()]
		if x:FindAbilityByName(a) == nil then
			AddAbilityAndSetLevel(x,a,(level or 0))
		end
	end
end

function OmMultiCast(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local target = keys.target

	local u1 = target
	if IsUnitExist(u1) ~= true then
		u1 = FindBestMulticastFriend(caster)
	end
	if u1 ~= nil then
		ability:ApplyDataDrivenModifier(u1,u1,'modifier_om_multi_cast',{ duration = 60 })
		EmitSoundOn('om.multi_cast',u1)
		PlayParticleOnUnitUntilDeath({
			caster = u1,
			p = 'effect/pray/blue_pray.vpcf',
		})
	end

	if level >= 2 then
		Timers:CreateTimer(0.1,function()
			u2 = FindBestMulticastFriend(caster)
			if u2 ~= nil then
				ability:ApplyDataDrivenModifier(u2,u2,'modifier_om_multi_cast',{ duration = 60 })
				EmitSoundOn('om.multi_cast',u2)
				PlayParticleOnUnitUntilDeath({
					caster = u2,
					p = 'effect/pray/blue_pray.vpcf',
				})

				if level >= 3 then
					Timers:CreateTimer(0.1,function()
						u3 = FindBestMulticastFriend(caster)
						if u3 ~= nil then
							ability:ApplyDataDrivenModifier(u3,u3,'modifier_om_multi_cast',{ duration = 60 })
							EmitSoundOn('om.multi_cast',u3)
							PlayParticleOnUnitUntilDeath({
								caster = u3,
								p = 'effect/pray/blue_pray.vpcf',
							})
						end

						-- Timers:CreateTimer(0.1,function()
						-- 	u4 = FindBestMulticastFriend(caster)
						-- 	if u4 ~= nil then
						-- 		ability:ApplyDataDrivenModifier(u4,u4,'modifier_om_multi_cast',{ duration = 60 })
						-- 		EmitSoundOn('om.multi_cast',u4)
						-- 		PlayParticleOnUnitUntilDeath({
						-- 			caster = u4,
						-- 			p = 'effect/pray/blue_pray.vpcf',
						-- 		})
						-- 	end
						-- end)
					end)
				end
			end
		end)
	end
end

function MultiCast(u)
	if u:HasModifier('modifier_om_multi_cast') == true and u.is_multi_cast_enable == true then
		local a = nil
		if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
			a = u.steal_ability
		elseif string.find(u:GetUnitName(),'chess_kael') and u.kael_ability ~= nil then
			a = u.kael_ability	
		else
			a = GameRules:GetGameModeEntity().chess_ability_list[u:GetUnitName()] or GameRules:GetGameModeEntity().summon_ability_list[u:GetUnitName()]
		end
		if u.ice_or_fire == 'fire' then
			a = 'jakiro_macropyre'
		end
		if u.ice_or_fire == 'ice' then
			a = 'jakiro_ice_path'
		end
		if a ~= nil and u:FindAbilityByName(a):IsCooldownReady() == false then
			
			PlayMultiCastParticle({
				p = 'effect/multicast/1.vpcf',
				caster = u,
			})

			u:FindAbilityByName(a):EndCooldown()
			EmitSoundOn("om.multi_cast2",u)
			u:RemoveModifierByName('modifier_om_multi_cast')
			u:SetMana(u:FindAbilityByName(a):GetManaCost(u:FindAbilityByName(a):GetLevel()))
			u.is_multi_cast_enable = false
		else
			return
		end
		return 0.1
	else
		return
	end
end

function SetMultiCastEnable(u)
	if u:HasModifier('modifier_om_multi_cast') == true then
		u.is_multi_cast_enable = true
	end
end

function PlayMultiCastParticle(keys)
	local p = keys.p
	local u = keys.caster
	local multi = keys.multi or 2
	if u == nil then
		return
	end
	local pos = keys.pos or PATTACH_OVERHEAD_FOLLOW
	local pp = ParticleManager:CreateParticle(p, pos, u)
	-- ParticleManager:SetParticleControlEnt( pp, 0, u, pos, nil, Vector(multi,1,1), true )
	-- ParticleManager:SetParticleControlEnt( pp, 1, u, pos, nil, Vector(multi,1,1), true )

	Timers:CreateTimer(0.1,function()
		if u == nil or u:IsNull() == true or u:IsAlive() == false then
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
			return
		end
		if pp == nil then
			return
		end
		return 0.1
	end)

	return pp
end

function AdjustHuskarBuff(keys)
	local caster = keys.caster
	local ability = keys.ability
	local ability_level = ability:GetLevel()

	if IsUnitExist(caster) == false then
		return
	end

	local hp_per = 1.0 * caster:GetHealth() / caster:GetMaxHealth()
	local hp_lose_per = (1-hp_per)*100
	local hp_lose_level = math.floor(hp_lose_per / 10)

	AddAbilityAndSetLevel(caster,'huskar_buff'..ability_level,hp_lose_level)
	-- prt('huskar_buff'..ability_level..'-->'..hp_lose_level)

end

function BsDelaySilenceEnemy(u,level)
	--血魔的原版血祭客场对敌人没有沉默特效，只能出此下策，补上沉默
	local team_id = u.team_id
	local p = u:GetAbsOrigin()
	local radius = 250
	local duration = 2.5
	if level == 2 then
		radius = 350
		duration = 3
	elseif level == 3 then
		radius = 500
		duration = 4
	end
	Timers:CreateTimer(3,function()
		local unlucky_dogs = FindUnitsInRadiusByTeam({
			team = team_id,
			role = 2,
			position = p,
			radius = radius,
		})
		for _,v in pairs(unlucky_dogs) do
			if IsUnitExist(v) then
				if duration > 0 then
					-- prt('slience-->'..v:GetUnitName())
					-- v:AddNewModifier(v,nil,"modifier_silence",{ duration = duration })
					
					play_particle("particles/generic_gameplay/generic_silence.vpcf",PATTACH_OVERHEAD_FOLLOW,v,duration)
				end
			end
		end 
	end)
end

function SsSSrWards(keys)
	local caster = keys.caster
	local target = keys.target
	EmitSoundOn("chess_ss_ssr.wards",caster)
	for i=1,8 do
		SummonOneSnakeWard(i,caster,target)
	end
end
function SummonOneSnakeWard(index,caster,target)
	Timers:CreateTimer(0.2*index,function()
		local p = FindRandomEmptyGridAtUnit(target)
		if p ~= nil then
			local w = SummonOneMinion(caster,'ss_ssr_ward',p)
			ExtendBeastBuff(w,caster)
			Timers:CreateTimer(0.1,function()
				if IsUnitExist(target) == true then
					w.attack_target = target
					local newOrder = {
				 		UnitIndex = w:entindex(), 
				 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
				 		TargetIndex = w.attack_target:entindex(), 
				 		Queue = 0 
				 	}
					ExecuteOrderFromTable(newOrder)
				end
			end)
		end
	end)
end
function FindAnEmptyGridByIteration(team_id,at_team_id,direction,direction_x)
	--1是从边缘向中间，-1是中间向边缘
	local search_table = {4,5,3,6,2,7,1,8}
	if team_id ~= at_team_id and direction_x ~= nil then
		--客场，反过来
		direction_x = -direction_x
	end

	if direction_x == 1 then
		search_table = {1,2,3,4,5,6,7,8}
	elseif direction_x == -1 then
		search_table = {8,7,6,5,4,3,2,1}
	end
	if team_id == at_team_id and direction == 1 then
		for y = 1,4 do
			for _,x in pairs(search_table) do
				if GameRules:GetGameModeEntity().unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
	if team_id == at_team_id and direction == -1 then
		for y = 4,1,-1 do
			for _,x in pairs(search_table) do
				if GameRules:GetGameModeEntity().unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
	if team_id ~= at_team_id and direction == 1 then
		for y = 8,5,-1 do
			for _,x in pairs(search_table) do
				if GameRules:GetGameModeEntity().unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
	if team_id ~= at_team_id and direction == -1 then
		for y = 5,8 do
			for _,x in pairs(search_table) do
				if GameRules:GetGameModeEntity().unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
end

function SetWard(w)
	if w:HasAbility('is_ward') == false then
		return
	end
	
	local all_enemy_chess = GetAllEnemyChess(w)
	local enemy_chess_count = table.maxn(all_enemy_chess)
	local size = enemy_chess_count
	if w:GetUnitName() == 'taunt_ward' then
		size = size * 3
	end
	if size <= 0 then
		size = 1
	end
	w:SetBaseMaxHealth(size)
	w:SetMaxHealth(size)
	w:SetHealth(size)
	local size_base = {
		disarm_ward = 1.0,
		taunt_ward = 1.4,
		nether_ward = 1.1,
	}
	w:SetModelScale(size_base[w:GetUnitName()]+enemy_chess_count/20.0)

	EmitSoundOn("chess_es.taunt_ward",w)
	Timers:CreateTimer(1,function()
		if IsUnitExist(w) == true then
			w:StartGesture(ACT_DOTA_IDLE)
		end
	end)
end

function SummonTaurenWard(caster,level)
	local at_team_id = caster.at_team_id or caster.team_id
	local p = {}
	local ward = {}
	--嘲讽图腾
	if level == 1 then
		local p = FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,-1)
		Timers:CreateTimer(RandomFloat(0.1,0.2),function()
			local w = SummonOneMinion(caster,'taunt_ward',p)
			SetWard(w)
		end)
		return
	end
	if level == 2 then
		Timers:CreateTimer(RandomFloat(0.1,0.15),function()
			local w1 = SummonOneMinion(caster,'taunt_ward',FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,-1))
			SetWard(w1)
		end)
		Timers:CreateTimer(RandomFloat(0.2,0.25),function()
			local w2 = SummonOneMinion(caster,'nether_ward',FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,1,1))
			SetWard(w2)
		end)
		Timers:CreateTimer(RandomFloat(0.3,0.35),function()
			local w3 = SummonOneMinion(caster,'disarm_ward',FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,1,-1))
			SetWard(w3)
		end)
		return
	end
end
function RefreshPets(hero_new,old_pet,new_pet_name, name_suffix)
	if name_suffix == nil then
		name_suffix = 1
	end
	if old_pet ~= nil and old_pet:IsNull() ~= true then
		old_pet:Destroy()
	end
	--生成宠物
	local pet = nil
	if new_pet_name ~= nil then
		pet = new_pet_name
	end
	if pet ~= nil and GameRules:GetGameModeEntity().pet_list[pet] ~= nil then
		local ran1 = RandomInt(50,200)
		local ran11 = RandomInt(0,1)
		if ran11 == 0 then 
			ran1 = -ran1
		end
		local ran2 = RandomInt(50,200)
		local ran22 = RandomInt(0,1)
		if ran22 == 0 then 
			ran2 = -ran2
		end

		if name_suffix == 2 then
			ran1 = 100
			ran2 = -50
		end
		local my_pet = CreateUnitByName("gemtd_pet", hero_new:GetAbsOrigin()+Vector(ran1,ran2,0),true,nil,nil, DOTA_TEAM_GOODGUYS)
		my_pet.ftd = 2009
		my_pet:SetOwner(hero_new)
		hero_new.pet_entity = my_pet
		my_pet.pet_name = pet
		AddAbilityAndSetLevel(my_pet,'no_collision')

		if pet == 't305' then
			PlayParticleOnUnitUntilDeath({
				caster = my_pet,
				p = "effect/bose_hand/bose.vpcf",
			})
		end

		local onduty_pet_model = GameRules:GetGameModeEntity().pet_list[pet]
		local onduty_pet_skin = 0 --GameRules:GetGameModeEntity().sm_hero_list_skin[pet] or 0
		my_pet:SetOriginalModel(onduty_pet_model)
		my_pet:SetModel(onduty_pet_model)
		my_pet:SetSkin(onduty_pet_skin)
		my_pet:SetModelScale(GameRules:GetGameModeEntity().pet_size_list[pet] or 1)

		-- BlinkChessX({caster=my_pet,blink_type="fall"})

		hero_new['pet'..name_suffix] = my_pet
		hero_new['pet_name'..name_suffix] = pet
		my_pet.owner = hero_new

		if name_suffix ~= 2 then
			PlayPetDialogue(my_pet,false,hero_new.language)
		end

		Timers:CreateTimer(1,function()
			if my_pet == nil or my_pet.owner == nil or my_pet:IsNull() == true or my_pet:IsAlive() == false then
				return
			end
			if my_pet.owner == nil or my_pet.owner:IsNull() == true or my_pet.owner:IsAlive() == false then
				my_pet:Destroy()
				return
			end
			
			if (my_pet:GetAbsOrigin() - my_pet.owner:GetAbsOrigin()):Length2D() >200 then
				local ran1 = RandomInt(50,200)
				local ran11 = RandomInt(0,1)
				if ran11 == 0 then 
					ran1 = -ran1
				end
				local ran2 = RandomInt(50,200)
				local ran22 = RandomInt(0,1)
				if ran22 == 0 then 
					ran2 = -ran2
				end
				FindClearSpaceForUnit(my_pet, my_pet:GetAbsOrigin(), true)
				my_pet:MoveToPosition(my_pet.owner:GetAbsOrigin()+Vector(ran1,ran2,0))
				return 1
			else
				return 1
			end
		end)

		return my_pet
	else
		hero_new['pet'..name_suffix] = nil
		hero_new['pet_name'..name_suffix] = nil
	end

end

function LinkEffect(u1,u2)
	local p = ParticleManager:CreateParticle("particles/units/heroes/hero_warlock/warlock_fatal_bonds_base.vpcf",PATTACH_CUSTOMORIGIN,u1)
    ParticleManager:SetParticleControlEnt(p,0,u1,5,"attach_hitloc",u1:GetOrigin(),true)
    ParticleManager:SetParticleControlEnt(p,1,u2,5,"attach_hitloc",u2:GetOrigin(),true)
    Timers:CreateTimer(0.5,function()
        ParticleManager:DestroyParticle(p,true)
    end)
end

function PreviewProjectile(hero, pj, pj_model)
	local uu = CreateUnitByName("invisible_unit", Entities:FindByName(nil,"center"..(hero:GetTeam()-6)):GetAbsOrigin()+Vector(0,128*5,256)+RandomVector(128) ,false,nil,nil, hero:GetTeam()) 

	Timers:CreateTimer(10,function()
		uu:ForceKill(false)
		uu:Destroy()
	end)

	local info =
    {
        Target = hero,
        Source = uu,
        Ability = nil,
        EffectName = pj_model,
        bDodgeable = false,
        iMoveSpeed = 1000,
        bProvidesVision = false,
        iVisionRadius = 0,
        iVisionTeamNumber = hero:GetTeam(),
        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
    }
	projectile = ProjectileManager:CreateTrackingProjectile(info)

	local delay_time = (hero:GetAbsOrigin() - uu:GetAbsOrigin()):Length2D() / 1000
	Timers:CreateTimer(delay_time, function()
		local damage_sound = GameRules:GetGameModeEntity().projectile_sound_list[pj]
		-- prt(damage_sound)
		EmitSoundOn(damage_sound,hero)
	end)
	
end

function DecreaseMana(keys)
	local caster = keys.caster
	local target = keys.target
	local mana = keys.mana
	if mana == nil or mana <= 0 then
		return
	end

	-- if caster:IsRangedAttacker() == true then
	-- 	mana = mana / 2
	-- end

	local mana_result = math.floor(target:GetMana()-mana)

	if mana_result < 0 then
		mana_result = 0
	end
	
	if mana_result < target:GetMana() then
		EmitSoundOn('DOTA_Item.DiffusalBlade.Target',target)
		play_particle("particles/items_fx/diffusal_slow.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
	end

	target:SetMana(mana_result)
end

function BingYanProjectile(keys)
	local caster = keys.caster
	caster:SetRangedProjectileName("particles/items2_fx/skadi_projectile.vpcf")
end

function HuiyaoTang(keys)
	local caster = keys.caster
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id
	local radius = keys.radius or 400
	local damage = keys.damage or 30
	local p = caster:GetAbsOrigin()
	local ability = keys.ability

	if caster:IsHero() == true then
		return
	end

	for _,unit in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id ~= team_id and (unit:GetAbsOrigin() - p):Length2D() < radius then
			-- prt('烫:'..unit:GetUnitName())
			ApplyDamage({
		    	victim=unit,
		    	attacker=caster,
		    	damage_type=DAMAGE_TYPE_PURE,
		    	damage=damage
		    })
		    ability:ApplyDataDrivenModifier(unit,unit,'modifier_item_huiyao_debuff',{ duration = 2, })
		    ShowHuiyaoEffect({
		    	caster = caster,
		    	target = unit,
		    })
		end
	end
end


function ShowHuiyaoEffect(keys)
	local unit = keys.target
	local huiyao_unit = keys.caster
	local e = ParticleManager:CreateParticle('effect/huiyao/2.vpcf', PATTACH_ABSORIGIN_FOLLOW, unit)

	ParticleManager:SetParticleControl(e, 0, unit:GetOrigin())
	ParticleManager:SetParticleControl(e, 1, huiyao_unit:GetOrigin())
	Timers:CreateTimer(1.9,function()
		ParticleManager:DestroyParticle(e,true)
	end)
end


function DAC:DamageFilter(keys)
	if keys.entindex_victim_const == nil then
		return false
	end
	local v = EntIndexToHScript(keys.entindex_victim_const)
	local a = EntIndexToHScript(keys.entindex_attacker_const or keys.entindex_victim_const)
	local t = keys.damagetype_const

	--仅限同棋盘伤害
	local attacker_at_team_id = a.at_team_id or a.team_id
	local victim_at_teamid = v.at_team_id or v.team_id
	if attacker_at_team_id ~= victim_at_teamid then
		keys.damage = 0
	    return false
	end

	--锁定伤害类型
	if a:HasAbility('attack_magical') and t == DAMAGE_TYPE_PHYSICAL then
	    keys.damage = 0
	    return false
	end
	if a:HasAbility('attack_pure') and t ~= DAMAGE_TYPE_PURE then
	    keys.damage = 0
	    return false
	end
	--图腾
	if v:HasAbility('is_ward') == true and keys.damage > 0 then
		if IsUnitExist(a) == true and (v:GetAbsOrigin() - a:GetAbsOrigin()):Length2D() > 200 then
			keys.damage = 2
		else
			keys.damage = 1
		end
	end

	if t == DAMAGE_TYPE_PHYSICAL then
		if v:HasModifier('modifier_oracle_mingyunsheling') == true then
			keys.damage = 0
		end
		if v:HasAbility("mars_bulwark_attack") == true then
			--玛尔斯，计算角度，决定是否抵挡部分伤害
			local ability = v:FindAbilityByName("mars_bulwark_attack")
			local level = ability:GetLevel()
			local v1 = v:GetForwardVector():Normalized()
			local v2 = (a:GetAbsOrigin() - v:GetAbsOrigin()):Normalized()
			-- local cross_product = v1.x * v2.x + v1.y * v2.y
			local angle1 = VectorToAngles(v1)
			local angle2 = VectorToAngles(v2)
			local p = "particles/units/heroes/hero_mars/mars_shield_of_mars_small.vpcf"
			if level >= 3 then
				p = "particles/units/heroes/hero_mars/mars_shield_of_mars.vpcf"
			end

			if math.abs(angle1.y - angle2.y) < 45 or (360-math.abs(angle1.y - angle2.y)) < 45 then
				--90度范围内
				local damage_reduce_per = ability:GetLevelSpecialValueFor( "physical_damage_reduction", level - 1 )
				keys.damage = keys.damage/100.0*(100-damage_reduce_per)
				play_particle(p,PATTACH_ABSORIGIN_FOLLOW,v,2)
			elseif math.abs(angle1.y - angle2.y) < 90 or (360-math.abs(angle1.y - angle2.y)) < 90 then
				--180度范围内
				local damage_reduce_per = ability:GetLevelSpecialValueFor( "physical_damage_reduction_side", level - 1 )
				keys.damage = keys.damage/100.0*(100-damage_reduce_per)
				play_particle(p,PATTACH_ABSORIGIN_FOLLOW,v,2)
			end
		end
		if keys.entindex_inflictor_const == nil and a:HasModifier('modifier_is_dwarf_buff_plus') then
			--2矮人
			local distance = (a:GetAbsOrigin() - v:GetAbsOrigin()):Length2D()
			local damage_bouns_per = distance/128.0*5
			keys.damage = keys.damage * (100 + damage_bouns_per) / 100
		end
	end

	if t == DAMAGE_TYPE_MAGICAL then
		--魔法伤害
		local damage_magical_x_list = {
			modifier_item_fashichangpao = 10,
			modifier_item_molifazhang = 20,
			modifier_item_shenmifazhang = 20,
			modifier_item_huiguang = 50,
			modifier_item_hongzhang_1 = 20,
			modifier_item_hongzhang_2 = 40,
			modifier_item_hongzhang_3 = 60,
			modifier_item_hongzhang_4 = 80,
			modifier_item_hongzhang_5 = 100,
			modifier_item_jinghunzhiren = 10,
			modifier_item_yangdao = 20,
			modifier_item_yuanlifazhang = 20,
			modifier_item_baojunwangpao = 10,
		}

		local damage_magical_bonus = 0
		for m,b in pairs(damage_magical_x_list) do
			if a:FindModifierByName(m) ~= nil then
				damage_magical_bonus = damage_magical_bonus + b
			end
		end
		keys.damage = math.floor(keys.damage * (100+damage_magical_bonus) / 100)



		if keys.entindex_inflictor_const ~= nil then
			-- 火女，叠炽魂
			local ability = EntIndexToHScript(keys.entindex_inflictor_const)
			if ability ~= nil and ability:GetAbilityName() == 'lina_laguna_blade' and a:FindAbilityByName('lina_laguna_blade') ~= nil then
				-- prt('叠炽魂')
				local level = a:FindAbilityByName('lina_laguna_blade'):GetLevel()
				InvisibleUnitCast({
					caster = a,
					ability = 'give_fiery_soul',
					level = level,
					unluckydog = a,
					ignore_nether_ward = true,
				})
			end
		end
	end
	-- --武僧
	-- if v:HasModifier('modifier_is_monk_buff') then
	-- 	local ally = FindAllyRandom(v)
	-- 	if ally ~= nil and keys.damage >= 10 then
	-- 		Timers:CreateTimer(0.5,function()
	-- 			ally:Heal(keys.damage, ally)
	-- 			if keys.damage > 10 then
	-- 				play_particle("effect/monk/1.vpcf",PATTACH_ABSORIGIN_FOLLOW,ally,2)
	-- 			end
	-- 		end)
	-- 	end
	-- end
	--格挡
	if t == DAMAGE_TYPE_PHYSICAL then
		local gedang = 0
		local gedang_per = 0
		local gedang_all = 0
		if v:FindModifierByName('modifier_item_yuandun') ~= nil then
			gedang = 10
			gedang_per = 100
			if gedang > 0 and RandomInt(1,100) < gedang_per then
				gedang_all = gedang_all + gedang
			end
		end
		if v:FindModifierByName('modifier_item_qiongguidun') ~= nil then
			gedang = 25
			gedang_per = 100
			if gedang > 0 and RandomInt(1,100) < gedang_per then
				gedang_all = gedang_all + gedang
			end
		end
		if v:FindModifierByName('modifier_item_xianfengdun') ~= nil then
			gedang_per = 50
			if v:IsRangedAttacker() == true then
				gedang = 40
			else
				gedang = 80
			end
			if gedang > 0 and RandomInt(1,100) < gedang_per then
				gedang_all = gedang_all + gedang
			end
		end
		if v:FindModifierByName('modifier_item_chihongjia') ~= nil then
			gedang_per = 50
			if v:IsRangedAttacker() == true then
				gedang = 40
			else
				gedang = 80
			end
			if gedang > 0 and RandomInt(1,100) < gedang_per then
				gedang_all = gedang_all + gedang
			end
		end
		if v:FindModifierByName("modifier_chihongjia_buff") ~= nil then
			gedang_per = 50
			gedang = 80
			if gedang > 0 and RandomInt(1,100) < gedang_per then
				gedang_all = gedang_all + gedang
			end
		end
		
		if v:HasModifier('modifier_is_monk_buff') then
			gedang_per = 50
			gedang = keys.damage * 0.75
			if gedang > 0 and RandomInt(1,100) < gedang_per then
				gedang_all = gedang_all + gedang
			end
		end
		if gedang_all > 0 then
			keys.damage = math.floor(keys.damage-gedang_all)
			if keys.damage < 0 then
				keys.damage = 0
			end
			--武僧
			if v:HasModifier('modifier_is_monk_buff') then
				play_particle("effect/monk/1.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
				local units = FindUnitsInRadiusOnTeamGround({
					team = v:GetTeam(),
					at_team = v.at_team_id or v.team_id,
					role = 3,
					position = v:GetAbsOrigin(),
					radius = 205,
				})
				if table.maxn(units) > 0 and gedang_all >= 10 then
					for i,u in pairs(units) do
						if IsUnitExist(u) and u.team_id == v.team_id then
							u:Heal(gedang_all,u)
						end
						if IsUnitExist(u) and u.team_id ~= v.team_id then
							ApplyDamage({
						    	victim=u,
						    	attacker=v,
						    	damage_type=DAMAGE_TYPE_PURE,
						    	damage= gedang_all
						    })
						end
					end
				end
			end
		end
	end

	--醉酒的miss
	if t == DAMAGE_TYPE_PHYSICAL then
		if keys.entindex_inflictor_const == nil and a:HasModifier('modifier_brewmaster_cinder_brew') and a:IsUnableToMiss() == false then
			-- print('IsUnableToMiss=false,u='..a:GetUnitName())
			local cinder_brew_miss_table = {
				[1] = 30,
				[2] = 40,
				[3] = 50,
			}
			local cinder_brew_ability = a:FindModifierByName('modifier_brewmaster_cinder_brew'):GetAbility()
			if cinder_brew_ability ~= nil then
				local cinder_brew_ability_level = cinder_brew_ability:GetLevel() or 1
				if RandomInt(1,100) <= cinder_brew_miss_table[cinder_brew_ability_level] then
					keys.damage = 0

					ShowMiss({caster = a})
					return false
				end
			end
		end

		--移除概率必中的buff
		local per_cannot_miss_buff_table = {
			"modifier_is_hunter_buff_jingzhun",
			"modifier_is_hunter_buff_jingzhun_plus",
			"modifier_is_hunter_buff_jingzhun_plus_plus",
			"modifier_bizhong",
		}
		for _,m in pairs(per_cannot_miss_buff_table) do
			if a:HasModifier(m) then
				a:RemoveModifierByName(m)
			end
		end
	end

	--伤害显示
	if (GameRules:GetGameModeEntity().show_damage == true or keys.damage > 1000) and a:GetTeam() ~= 4  then
		if t == DAMAGE_TYPE_MAGICAL then
			AMHC:CreateNumberEffect(v,keys.damage,3,AMHC.MSG_DAMAGE,{64,64,255},9)
		elseif t == DAMAGE_TYPE_PHYSICAL then
			AMHC:CreateNumberEffect(v,keys.damage,3,AMHC.MSG_DAMAGE,{255,64,64},9)
		elseif t == DAMAGE_TYPE_PURE then
			AMHC:CreateNumberEffect(v,keys.damage,3,AMHC.MSG_DAMAGE,{255,255,255},9)
		end
	end

	--9战士反伤
	if t ~= DAMAGE_TYPE_PURE and v:HasModifier("modifier_is_warrior_buff_plus_plus") then
		Timers:CreateTimer(0.1,function()
			ApplyDamage({
		    	victim=a,
		    	attacker=v,
		    	damage_type=DAMAGE_TYPE_PURE,
		    	damage= v:GetPhysicalArmorValue(false)
		    })
		end)
	end

	--9法师冻结
	if t == DAMAGE_TYPE_MAGICAL and v:HasModifier("modifier_is_mage_buff_plus_plus") and a:entindex() ~= v:entindex() then
		local dd = keys.damage/400
		local aa = v:FindModifierByName("modifier_is_mage_buff_plus_plus"):GetAbility()
		aa:ApplyDataDrivenModifier(v,v,'modifier_is_mage_frozen_debuff',{duration = dd})
	end

	return true
end

function DAC:HealingFilter(keys)
	local t = EntIndexToHScript(keys.entindex_target_const)
	local h = keys.heal

	local heal_bonus = 0

	if t:HasAbility('is_ward') then
		return false
	end

	if t:HasModifier('modifier_dazzle_shallow_grave') then
		heal_bonus = heal_bonus + 50
	end

	h = h * (100+heal_bonus)/100

	-- --武僧
	-- if t:HasModifier('modifier_is_monk_buff') then
	-- 	local enemy = FindUnluckyDogRandom(t)
	-- 	if enemy ~= nil and h >= 10 then
	-- 		Timers:CreateTimer(0.5,function()
	-- 			ApplyDamage({
	-- 		    	victim = enemy,
	-- 		    	attacker = t,
	-- 		    	damage_type = DAMAGE_TYPE_PURE,
	-- 		    	damage = h,
	-- 		    	ability = 'is_monk_buff'
	-- 		    })
	-- 		    -- if h > 100 then
	-- 		    	play_particle("effect/monk/2.vpcf",PATTACH_ABSORIGIN_FOLLOW,enemy,2)
	-- 		    -- end
	-- 		end)
	-- 	end
	-- end

	if GameRules:GetGameModeEntity().show_damage == true then
		if t ~= nil and h > 10 then
			AMHC:CreateNumberEffect(t,h,2,AMHC.MSG_MISS,{0,255,0},0)
		end
	end

	keys.heal = h

	return true
end

function DAC:ExecuteOrderFilter(keys)
	return true
end

function DAC:ItemAddedToInventoryFilter(keys)
	local item_entindex_const = keys.item_entindex_const
	local inventory_parent_entindex_const = keys.inventory_parent_entindex_const
	local item_parent_entindex_const = keys.item_parent_entindex_const

	local item = EntIndexToHScript(item_entindex_const)
	local inventory_parent = EntIndexToHScript(inventory_parent_entindex_const)
	local item_parent = EntIndexToHScript(item_parent_entindex_const)

	if item ~= nil and inventory_parent ~= nil and inventory_parent:HasItemInInventory('item_null') ~= true and inventory_parent.evolve_result == nil and inventory_parent.devolve_result == nil and inventory_parent.is_clearing == nil then
		item:SetPurchaser(inventory_parent)
	end

	return true
end

function DAC:ModifierGainedFilter(keys)
	local victim = EntIndexToHScript(keys.entindex_parent_const)
	local modifier = keys.name_const
	RemindItem(victim, modifier)

	if modifier == 'modifier_winter_wyvern_cold_embrace' then
		for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[victim.at_team_id or victim.team_id]) do
			if IsUnitExist(unit) and unit.team_id ~= victim.team_id and IsUnitExist(unit:GetAttackTarget()) and  unit:GetAttackTarget():entindex() == victim:entindex() then
				local ww = victim:FindModifierByName(modifier):GetAbility():GetOwner()
				if IsUnitExist(ww) then
					ww:FindAbilityByName('ww_frost'):ApplyDataDrivenModifier(ww,unit,'modifier_ww_frost',{
					duration = 5})
				end
			end
		end
	end
	if victim:HasModifier('modifier_is_nraqi_buff') and victim:FindModifierByName(modifier) ~= nil and (victim:FindModifierByName(modifier):IsDebuff() or modifier == "modifier_pangolier_luckyshot_disarm") and IsModifierInNraqiWhiteList(modifier) ~= true then
		--无面者，抵消debuff
		if victim.nraqi_animation ~= true then
			victim.nraqi_animation = true
			play_particle("particles/units/heroes/hero_faceless_void/faceless_void_backtrack.vpcf",PATTACH_ABSORIGIN_FOLLOW,victim,2)
			Timers:CreateTimer(2,function()
				victim.nraqi_animation = nil
			end)
		end
		return false
	end
	return true
end

function GainNraqiEffect(keys)
	--无面者：获得变黑buff
	play_particle('particles/units/heroes/hero_void_spirit/astral_step/void_spirit_astral_step_dmg_burst.vpcf',PATTACH_ABSORIGIN_FOLLOW,keys.target,5)
	EmitSoundOn("Hero_Bane.BrainSap",keys.target)
	AddAbilityAndSetLevel(keys.target,'faceless_void_time_lock')

	--驱散一下debuff
	for _,m in pairs(keys.target:FindAllModifiers()) do
		if m:IsDebuff() and IsModifierInNraqiWhiteList(m:GetName()) ~= true then
			keys.target:RemoveModifierByName(m:GetName())
		end
	end
end

function IsModifierInNraqiWhiteList(modifier)
	local nraqi_debuff_whitelist = {
		"modifier_is_mage_buff",
		"modifier_is_mage_buff_plus",
		"modifier_is_mage_buff_plus_plus",
		"modifier_is_undead_buff",
		"modifier_is_undead_buff_plus",
		"modifier_is_undead_buff_plus_plus",
	}
	return FindValueInTable(nraqi_debuff_whitelist,modifier)
end

function RemindItem(caster, modifier_name) 
	Timers:CreateTimer(0.1,function()
		if IsUnitExist(caster) == false or caster.is_fuhuo == true or caster.is_tuihuaed == true or caster.is_youhun == true or caster.team_id == 4 or caster:IsHero() == true then
			--这些情况不做特殊处理
			return
		end
		local modifier = caster:FindModifierByName(modifier_name)
		if modifier == nil then
			return
		end
		local item = modifier:GetAbility()
		
		if item == nil then
			return
		end
		local item_name = item:GetAbilityName()
		if modifier_name ~= ('modifier_'..item_name) or string.find(item_name,'item_') == nil then
			return
		end

		if FindChessRemindedItem(caster,item_name) == false then
			AddChessRemindedItem(caster,item_name)
			local item_level = IsCombinedItem(item_name)
			if item_level ~= nil and item_level > 0 then
				--说谢谢
				if RandomInt(1,50) < (item_level*10) then
					PlayChessDialogue(caster,'thanks')
				end
				--发弹幕：获得物品
				local team_id = caster.team_id
				local hero = TeamId2Hero(team_id)
				if hero ~= nil then
					CustomGameEventManager:Send_ServerToAllClients("bullet",{
						player_id = hero:GetPlayerID(),
						win_streak = hero.win_streak or 0,
						vip = hero.is_vip,
						target = caster:GetUnitName(),
						item = item_name,
						item_level = item_level,
					})
					if item_level == 5 and GameRules:GetGameModeEntity().egg_quest == 'q022' then
						SetQuest(hero.team_id,true)
					end
					if item_level == 4 and GameRules:GetGameModeEntity().egg_quest == 'q032' then
						SetQuest(hero.team_id,true)
					end
				end
			end
		end
	end)
end

--棋子装备提醒
function InitChessRemindedItem(chess, items)
	if items == nil then
		items = {}
	end
	chess.reminded_item = items
end
function AddChessRemindedItem(chess, item)
	if chess.reminded_item == nil then
		chess.reminded_item = {}
	end
	table.insert(chess.reminded_item, item)
end
function FindChessRemindedItem(chess, item)
	if chess.reminded_item == nil then
		return false
	end
	return FindValueInTable(chess.reminded_item, item)
end

function EnigmaCastPoint(keys)
	local p = keys.target_points[1]
	keys.ability.p = p
end

function EnigmaPulseDamage(keys)

	if keys.ability == nil or keys.ability.p == nil then
		return
	end

	local p = keys.ability.p
	local caster = keys.caster
	local radius = keys.radius or 450

	local level = keys.ability:GetLevel()
	local damage_per_tick = 3
	if level == 2 then
		damage_per_tick = 4
	end
	if level == 3 then
		damage_per_tick = 6
	end

	ApplyDamageInRadius({
		caster = caster,
		team = caster.team_id,
		radius = radius,
		role = 2,
		position = p,
		damage = damage_per_tick,
		damage_per = damage_per_tick,
		damage_type = DAMAGE_TYPE_PURE,
		ability = "midnight_pulse_datadriven",
	})
end

function GaussRandom()
	local ranbase = 9999
	while (ranbase > 4 or ranbase < -4) do
		local u = RandomInt(1,10000)/10000
		local v = RandomInt(1,10000)/10000
		ranbase = math.sqrt((-2)*math.log(u))*math.cos(2*math.pi*v)
	end
	local ranresult = math.ceil(ranbase*128+512)
	return ranresult
end

function BrWeb(keys)
	local r = keys.radius
	local p = keys.target_points[1]
	local caster = keys.caster
	local ability = keys.ability

	if ability == nil then
		return
	end

	if caster == nil and ability.team == nil then
		return
	end
	local team = ability.team or caster:GetTeam()
	if team == nil then
		return
	end
	ability.team = team

	local unlucky_dogs = FindUnitsInRadiusByTeam({
		team = team,
		role = 2,
		position = p,
		radius = r,
	})

	for _,u in pairs(unlucky_dogs) do 
		-- if u:FindModifierByName('modifier_br_web_debuff') == nil then
			ability:ApplyDataDrivenModifier(u,u,'modifier_br_web_debuff',{
				duration = 1,
			})
		-- end
	end
end



--强攻
function AddPressCount(u)
	if u:GetTeam() == 4 then
		return
	end
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local press_count = v_chess['press_count']
	if press_count == nil then
		v_chess['press_count'] = 0
		press_count = 0
	end

	local press_level = u:FindAbilityByName('lc_qianggong'):GetLevel()
	if press_level == nil or press_level == 0 then
		return
	end
	local add_count = 1 --press_level

	if GetChessStar(u) >= 3 then
		add_count = 2
		PlayParticleOnUnitUntilDeath({
			caster = u,
			p = "particles/econ/items/legion/legion_fallen/legion_fallen_press.vpcf",
		})
	else
		PlayParticleOnUnitUntilDeath({
			caster = u,
			p = "particles/units/heroes/hero_legion_commander/legion_commander_press.vpcf",
		})
	end

	v_chess['press_count'] = v_chess['press_count'] + add_count
end
function GetPressCount(u)
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local press_count = v_chess['press_count']
	if press_count == nil then
		v_chess['press_count'] = 0
		press_count = 0
	end

	return press_count
end
function Unit2VChess(u)
	local team_id = u:GetTeam()
	if team_id == nil or u.vchess_index == nil then
		return nil
	end
	if GameRules:GetGameModeEntity().mychess[team_id] == nil then
		return nil
	end
	return GameRules:GetGameModeEntity().mychess[team_id][u.vchess_index]
end

function SetPressStack(x)
	Timers:CreateTimer(0.5,function()
		if x:FindAbilityByName('lc_qianggong') == nil or x.press_count == nil or x.press_count <= 0 then
			return
		end
		if x:FindModifierByName("modifier_lc_qianggong_count") ~= nil then
			return
		end
		for ii=1,x.press_count do
			x:FindAbilityByName('lc_qianggong'):ApplyDataDrivenModifier(x,x,'modifier_lc_qianggong',{ })
		end
		x:FindAbilityByName('lc_qianggong'):ApplyDataDrivenModifier(x,x,'modifier_lc_qianggong_count',{ })
		x:FindModifierByName("modifier_lc_qianggong_count"):SetStackCount(x.press_count)
	end)
end

--赏金猎人：追踪术
function BhTrack(keys)
	local caster = keys.caster
	local target = keys.target
	
	if caster.damage_owner ~= nil then
		target.tracker = caster.damage_owner
	else
		target.tracker = caster
	end
end
function BhTrackDeath(keys)
	local attacker = keys.attacker
	if IsUnitExist(attacker) == false then
		return
	end
	if attacker:HasModifier('modifier_item_dianjinshou') == true then
		AddTrackMoneyCount(attacker,1)
	end

end

function AddTrackMoneyCount(u,money)
	if u:GetTeam() == 4 or (not u:HasModifier('modifier_item_dianjinshou')) then
		return
	end
	local track_level = 1
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local track_money_count = v_chess['track_money_count']
	if track_money_count == nil then
		v_chess['track_money_count'] = 0
		track_money_count = 0
	end

	track_money_count = track_money_count + money
	local track_money_count_limit = u:GetLevel()*2

	if track_money_count > track_money_count_limit then
		track_money_count = track_money_count_limit
	else
		play_particle("particles/generic_gameplay/rune_bounty_owner.vpcf",PATTACH_OVERHEAD_FOLLOW,u,5)
		EmitSoundOn("General.Coins",u)
		AMHC:CreateNumberEffect(u,money,3,AMHC.MSG_MISS,{255,255,0},0)
	end
	v_chess['track_money_count'] = track_money_count
	
	u.track_money_count = track_money_count
	SetTrackMoneyStack(u)
end
function GetTrackMoneyCount(u)
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local track_money_count = v_chess['track_money_count']
	if track_money_count == nil then
		v_chess['track_money_count'] = 0
		track_money_count = 0
	end

	return track_money_count
end
function SetTrackMoneyStack(x)

	if not x:HasAbility('bh_zhuizongshu') then
		AddAbilityAndSetLevel(x,'bh_zhuizongshu')
	end
	Timers:CreateTimer(0.5,function()
		if x.track_money_count == nil or x.track_money_count <= 0 then
			return
		end

		if x:HasModifier("modifier_bh_zhuizongshu_shangjin_count") then
			x:RemoveModifierByName("modifier_bh_zhuizongshu_shangjin_count")
		end

		x:FindAbilityByName("bh_zhuizongshu"):ApplyDataDrivenModifier(x,x,'modifier_bh_zhuizongshu_shangjin_count',{ })
		x:FindModifierByName("modifier_bh_zhuizongshu_shangjin_count"):SetStackCount(x.track_money_count)
	end)
end

--坟场管理
function ResetAllDeadChessList()
	GameRules:GetGameModeEntity().dead_chess_list = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
end
function AddChess2DeadChessList(keys)
	local at_team_id = keys.at_team_id --必填
	local chess_base_name = keys.chess_base_name --必填
	if at_team_id == nil or chess_base_name == nil then
		return
	end
	local level = keys.level or 0
	if string.find(chess_base_name,'chess_') ~= nil then
		level = GameRules:GetGameModeEntity().chess_2_mana[chess_base_name]
	end
	local items = keys.items or {}
	local index = table.maxn(GameRules:GetGameModeEntity().dead_chess_list[at_team_id]) + 1
	table.insert(GameRules:GetGameModeEntity().dead_chess_list[at_team_id],{
		index = index,
		chess_base_name = chess_base_name,
		items = items,
		level = level,
	})
end
function GetMaxLevelChessFromDeadChessList(keys)
	local at_team_id = keys.at_team_id --必填
	if at_team_id == nil then
		return
	end
	local is_remove = keys.is_remove or false

	local max_level = 0
	local max_level_chess = nil
	local max_level_index = nil
	for i,v in pairs(GameRules:GetGameModeEntity().dead_chess_list[at_team_id]) do
		if v.level ~= nil and v.level > max_level then 
			max_level = v.level
			max_level_chess = v
			max_level_index = i
		end
	end
	if is_remove == true and max_level_index ~= nil then
		table.remove(GameRules:GetGameModeEntity().dead_chess_list[at_team_id],max_level_index)
	end
	return max_level_chess
end

--上帝之陈：复活
function ChenFuhuo(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()

	local fuhuo_unit = GetMaxLevelChessFromDeadChessList({
		at_team_id = caster.at_team_id or caster.team_id,
		is_remove = true,
	})

	if fuhuo_unit ~= nil then
		--复活！
		local unit_name = fuhuo_unit.chess_base_name
		if string.find(unit_name,'chess_') ~= nil then
			if level == 2 then
				unit_name = unit_name..'1'
			elseif level >= 3 then
				unit_name = unit_name..'11'
			end
		end
		local p = FindRandomEmptyGridAtUnit(caster)
		local w = SummonAChess(caster.team_id,p,unit_name,caster.at_team_id or caster.team_id,100,100, nil, false)
		if w ~= nil then
			ExtendBeastBuff(w,caster)
			w.is_fuhuo = true
			play_particle("particles/units/heroes/hero_chen/chen_holy_persuasion.vpcf",PATTACH_ABSORIGIN_FOLLOW,w,3)
			SetWard(w)
		end
		EmitSoundOn("chess_chen.fuhuo",caster)
	end
end

--食人魔之帽
function AddOgre(keys)
	local caster = keys.caster
	if caster:IsHero() ~= true then
		AddAbilityAndSetLevel(caster,'is_ogre',1)
	end
end
function RemoveOgre(keys)
	local caster = keys.caster
	if FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy['is_ogre'],GetUnitBaseName(caster)) ~= true then
 		RemoveAbilityAndModifier(caster,'is_ogre')
 	end
end

function AddDwarf(keys)
	local caster = keys.caster
	if caster:IsHero() ~= true and caster:Script_GetAttackRange() > 205 then
		AddAbilityAndSetLevel(caster,'is_dwarf',1)
	end
end
function RemoveDwarf(keys)
	local caster = keys.caster
	if FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy['is_dwarf'],GetUnitBaseName(caster)) ~= true then
		RemoveAbilityAndModifier(caster,'is_dwarf')
	end
end

function ShowAbility(keys)
	local target = keys.target
	if target == nil then
		return
	end
	prt(target:GetUnitName())
	for i=0,23 do
		if target:GetAbilityByIndex(i) ~= nil then
			print(i..'-->'..target:GetAbilityByIndex(i):GetAbilityName()..'-->'..target:GetAbilityByIndex(i):GetLevel())
		end
	end

	local all_modifier = target:FindAllModifiers()
	for _,m in pairs(all_modifier) do
		print(m:GetName())
	end

	-- DropChessItem({
	-- 	target = target
	-- })

	--用api
	
	-- target:StartGesture(ACT_DOTA_TAUNT)

	--用Animation库
	-- StartAnimation(target, {duration=2, activity=ACT_DOTA_TAUNT, rate=1, translate="good_day_sir"})

	-- BlinkChessX({caster=target,blink_type="walk"})
end

function DisarmChess(keys)
	local target = keys.target
	local caster = keys.caster
	local team_id = target.team_id

	if string.find(target:GetUnitName(),'chess_') == nil then
		return
	end
	if team_id == nil or team_id == 4 or team_id ~= caster:GetTeam() then
		return
	end

	if target.is_removing == true then
		return
	end	
	local extra_time = 0
	if GetMapName() == 'casual_2x4_ob' or GetMapName() == 'casual_2x4' or GetMapName() == 'ranked_2x4' then
		extra_time = 5
	end
	if (GameRules:GetGameModeEntity().game_status == 2 and target.hand_index == nil) or (GameRules:GetGameModeEntity().game_status == 1 and target.hand_index == nil and (GameRules:GetGameModeEntity().prepare_timer > 33 + extra_time or GameRules:GetGameModeEntity().prepare_timer < 2)) then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_delete_battle_chess"
		})
		EmitSoundOn("General.CastFail_NoMana",caster)
		return
	end

	--清空物品table
	-- for _,c in pairs (GameRules:GetGameModeEntity().mychess[team_id]) do
	-- 	if c.index == target:entindex() then
	-- 		c.item = {}
	-- 	end
	-- end
	local item_count = DropChessItem({
		target = target
	})

	--恢复原始弹道
	local units_kv = LoadKeyValues("scripts/npc/npc_units_custom.txt")
	if units_kv[target:GetUnitName()] ~= nil then
		local ori_proj = units_kv[target:GetUnitName()]["ProjectileModel"]
		if ori_proj ~= nil then
			target:SetRangedProjectileName(ori_proj)
		end
	end

	if item_count > 0 then
		target:StartGesture(ACT_DOTA_SPAWN)
		EmitSoundOn("dac.disarm_chess",target)
		caster:FindAbilityByName('disarm_chess'):SetActivated(false)
	else
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_no_item_to_disarm"
		})
		EmitSoundOn("General.CastFail_NoMana",caster)
	end
end

function DropChessItem(keys)
	local target = keys.target
	local item_count = 0
	if target == nil or IsUnitExist(target) == false then
		return
	end
	for slot=0,8 do
		if target:GetItemInSlot(slot)~= nil then
			local item = target:GetItemInSlot(slot)
			local item_name = item:GetAbilityName()
			if item:IsPermanent() == true then
				--永久物品，丢出来
				local newItem = CreateItem( item_name, target, target )
				local drop = CreateItemOnPositionForLaunch(target:GetAbsOrigin(), newItem )
				local dropRadius = RandomFloat( 50, 200 )
				newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, target:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
				target:RemoveItem(target:GetItemInSlot(slot))
				item_count = item_count + 1
			else
				--消耗品，按charges丢出来
				local charges = item:GetCurrentCharges()
				for i=1,charges do
					local newItem = CreateItem( item_name, target, target )
					local drop = CreateItemOnPositionForLaunch(target:GetAbsOrigin(), newItem )
					local dropRadius = RandomFloat( 50, 200 )
					newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, target:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
				end
				target:RemoveItem(target:GetItemInSlot(slot))
				item_count = item_count + 1
			end
		end
	end

	return item_count
end


function DAC:_GoldDropConsoleCommand( cmdName, goldToDrop )
	local newItem = CreateItem( "item_bag_of_gold", nil, nil )
	newItem:SetPurchaseTime( 0 )
	if goldToDrop == nil then goldToDrop = 100 end
	newItem:SetCurrentCharges( goldToDrop )
	local spawnPoint = Vector( 0, 0, 0 )
	local heroEnt = PlayerResource:GetSelectedHeroEntity( 0 )
	if heroEnt ~= nil then
		spawnPoint = heroEnt:GetAbsOrigin()
	end
	local drop = CreateItemOnPositionSync( spawnPoint, newItem )
	newItem:LaunchLoot( true, 300, 0.75, spawnPoint + RandomVector( RandomFloat( 50, 350 ) ) )
end




function EquipPingguo(keys)
	-- prt('EquipPingguo')

	-- for i,_ in pairs(keys) do
	-- 	print(i)
	-- end
end

--在6格物品栏中找到指定的一个物品，返回item对象
function FindItemInInventory(unit, item_name)
	for i = 0,5 do
		local item = unit:GetItemInSlot(i)
		if item and item:GetAbilityName() == item_name then
			return item
		end
	end
end

function DisableItemBagCD(hero)
	if not hero.item_fixer_timer then
		hero.item_fixer_timer = Timers:CreateTimer(0,function()
			for i = 0,5 do
				local item = hero:GetItemInSlot(i)
				if item and item:GetItemState() ~= 1 then
					item:SetItemState(1)
				end
			end
			return 0.03
		end)
	end
end

-- 为AOE技能寻找最佳释放位置
function FindBestGridForCircleAOE(u,a)
	local team_id = u.at_team_id or u.team_id
	local range = 200
	local enemy_count = 0
	local enemy = nil
	local possible_postion = {}
	local target_position = nil

	if RandomInt(1,100)<30 then
		--30%概率随机找敌人
		local unluckydog = FindUnluckyDogRandom(u)
		if unluckydog then
			return unluckydog:GetAbsOrigin()
		else
			return nil
		end
	end

    -- 干扰者、谜团、飞机技能半径
 	if u:FindAbilityByName(a):GetSpecialValueFor('radius') > 0 then
 		range = u:FindAbilityByName(a):GetSpecialValueFor('radius')
	end

	for x=1,8 do
		for y=1,8 do
			local tt = TargetCountForCircleAOE(x,y,u,range)
			local count_temp = tt['count']
			if count_temp > enemy_count then
				enemy_count = count_temp
				possible_postion = {}
				table.insert(possible_postion, XY2Vector(x,y,team_id))
			elseif count_temp == enemy_count and count_temp > 1 then
				table.insert(possible_postion, XY2Vector(x,y,team_id))
			end
			if count_temp == 1 then
				enemy = tt['target']
			end
		end
	end
	
	if enemy_count == 1 and enemy ~= nil then
	-- 当仅能伤害一个敌人时，以该敌人位置为目标
		target_position = enemy:GetAbsOrigin()
	else
	-- 当有多个等效位置时，选择离萨尔最近的位置释放
		-- target_position = possible_postion[RandomInt(1,table.maxn(possible_postion))]
		local min_length2d = 9999
		for _,p in pairs(possible_postion) do
			if (p-u:GetAbsOrigin()):Length2D() < min_length2d then
				min_length2d = (p-u:GetAbsOrigin()):Length2D()
				target_position = p
			end
		end
	end

	return target_position
end

--获取所有能被武僧分担的友军棋子
function GetAllFriendlyChess(u)
	local unit_table = {}
	local team_id = u.at_team_id or u.team_id
	--遍历所有单位
	for _,v in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and IsBozangWudi(v) == false and u:entindex() ~= v:entindex() and v.is_youhun ~= true and v:IsInvulnerable() == false and v:HasAbility('is_ward') == false then
			table.insert(unit_table,v)
		end
	end
	return unit_table
end
function GetAllEnemyChess(u)
	local unit_table = {}
	local team_id = u.at_team_id or u.team_id
	--遍历所有单位
	for _,v in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if IsUnitExist(v) == true and v:GetTeam() ~= u:GetTeam() and v:HasAbility('is_ward') == false then
			table.insert(unit_table,v)
		end
	end
	return unit_table
end
function FindFriendlyChessesBySynergy(u,s)
	local unit_table = {}
	local team_id = u.at_team_id or u.team_id
	--遍历所有单位
	for _,v in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and IsBozangWudi(v) == false and u:entindex() ~= v:entindex() and v:HasAbility(s) == true then
			table.insert(unit_table,v)
		end
	end
	return unit_table
end
function FindRandomChessByTeamAndSynergy(t,s)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GameRules:GetGameModeEntity().to_be_destory_list[t][RandomInt(1,table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[t]))]
		if IsUnitExist(uu) == true and uu.team_id == t and uu:HasAbility(s) then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end

-- 计算在目标格释放AOE时，能伤害到的单位个数
function TargetCountForCircleAOE(x,y,u,range)
	local team_id = u.at_team_id or u.team_id
	local count = 0
	local target = nil
	--遍历所有单位
	for _,enemy in pairs (GameRules:GetGameModeEntity().to_be_destory_list[team_id]) do
		if enemy.team_id ~= u.team_id and enemy:IsInvisible() == false and IsBozangWudi(enemy) == false then
			local enemy_to_centerpoint = (enemy:GetAbsOrigin() - XY2Vector(x,y,team_id)):Length2D()
			if enemy_to_centerpoint <= range then
				count = count + 1
				if count == 1 then
					target = enemy
				else
					target = nil
				end
			end
		end
	end
	return {
		count = count,
		target = target,
	}
end 

function InitAssassinJump(u)
	local ran = RandomInt(1,100)
	if u:HasAbility('is_assassin_buff_plus_plus') == true then
		--9刺客
		if ran > 75 then
			u:FindAbilityByName('is_assassin_buff_plus_plus'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x7',{})
		elseif ran > 50 then
			u:FindAbilityByName('is_assassin_buff_plus_plus'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x5',{})
		else
			u:FindAbilityByName('is_assassin_buff_plus_plus'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x3',{})
		end
	elseif u:HasAbility('is_assassin_buff_plus') == true then
		--6刺客
		if ran > 50 then
			u:FindAbilityByName('is_assassin_buff_plus'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x3',{})
		else
			u:FindAbilityByName('is_assassin_buff_plus'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x5',{})
		end
	elseif u:HasAbility('is_assassin_buff') == true then
		--3刺客
		u:FindAbilityByName('is_assassin_buff'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x3',{})
	end
end

function RequestBanChess(keys)
	local caster = keys.caster
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_ban_choose",{
		key = GetClientKey(caster:GetTeam()),
		player_id = caster:GetPlayerID(),
		chess_pool = GameRules:GetGameModeEntity().chess_list_by_synergy,
		curr_money = caster:GetMana(),
	})
end
function DAC:OnBanChess(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)
	if hero.synergy_banned ~= nil then
		return
	end
	local synergy = keys.synergy
	local price = table.maxn(GameRules:GetGameModeEntity().chess_list_by_synergy[synergy]) * 2

	if price <= 0 then
		return
	end

	if hero:GetMana() < price then
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"mima",{
			key = GetClientKey(hero:GetTeam()),
			text = "text_mima_no_mana"
		})
		EmitSoundOn("General.CastFail_NoMana",hero)
		return
	else
		-- EmitSoundOn("dac.popup",hero)
		EmitSoundOn("ui.npe_objective_given",hero)
		CostMana(hero,price)
		hero.synergy_banned = synergy
		hero:RemoveAbility('ban_chess')
		SetStat(hero:GetPlayerID(),'ban_synergy',synergy)
		AddAbilityAndSetLevel(hero,synergy..'_banned')
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"ban_chess",{
			key = GetClientKey(hero:GetTeam()),
			synergy = synergy,
		})
		CustomNetTables:SetTableValue( "chess_pool_table", "ban_info_"..hero:GetPlayerID(), { banned_synergy = synergy } )
		--弹幕：ban chess
		CustomGameEventManager:Send_ServerToAllClients("bullet",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			ban = synergy,
		})
		GameRules:GetGameModeEntity().bans = GameRules:GetGameModeEntity().bans..synergy..','
		if GameRules:GetGameModeEntity().egg_quest == 'q028' and price >= 15 then
			SetQuest(hero:GetTeam(),true)
		end
	end
end

function UnbanSynergy(keys)
	local caster = keys.caster
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_confirm_unban_synergy",{
		key = GetClientKey(caster:GetTeam()),
		player_id = caster:GetPlayerID(),
	})
	
end

function DAC:OnUnBanSynergy(keys)
	local player_id = keys.PlayerID
	local caster = PlayerId2Hero(player_id)
	local synergy = caster.synergy_banned

	caster.synergy_banned = nil
	caster:RemoveAbility(synergy..'_banned')
	EmitSoundOn("card.flip",caster)
	AddAbilityAndSetLevel(caster,'ban_chess')
	SetStat(caster:GetPlayerID(),'ban_synergy',nil)	
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"unban_chess",{
		key = GetClientKey(caster:GetTeam()),
	})
	CustomNetTables:SetTableValue( "chess_pool_table", "ban_info_"..caster:GetPlayerID(), { banned_synergy = nil } )
end

function AddTotalMoneyStat(player_id, money)
	if IsUnitExist(PlayerId2Hero(player_id)) == false then
		return
	end
	local total_money1 = GetStat(player_id,'total_money')
	AddStat(player_id,'total_money',money)
	local total_money2 = GetStat(player_id,'total_money')
	if GameRules:GetGameModeEntity().egg_quest == 'q023' and total_money2 >= 400 then
		SetQuest(PlayerId2Hero(player_id):GetTeam(),true)
	end
end

function UpdateStatUI()
	CustomNetTables:SetTableValue( "player_info_table", "player_info", { data = GameRules:GetGameModeEntity().stat_info, hehe = RandomInt(1,100000)})
end

function GetChessCostByName(c)
	for cost,chess_list in pairs(GameRules:GetGameModeEntity().chess_list_by_mana) do
		for _,chess_name in pairs(chess_list) do
			if chess_name == c then
				return cost
			end
		end
	end
	return nil
end

function IsCombinedItem(item_name)
	if item_name == nil then
		return nil
	end
	for cost,item_cost_table in pairs(GameRules:GetGameModeEntity().COMBINED_ITEM_LIST) do
		for _,item in pairs(item_cost_table) do
			if item == item_name then
				return cost
			end
		end
	end
end

function KillSelfTeam(team,is_false_kill)
	local hero = TeamId2Hero(team)
	if is_false_kill == nil then
		is_false_kill = false
	end
	if is_false_kill ~= true and (IsUnitExist(hero) == false or hero.is_banned == true) then
		return
	end
	if is_false_kill ~= true then
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_killself",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
			emoji = 175,
		})
		if GameRules:GetGameModeEntity().game_status == 2 then
			--战斗回合，延时死亡（避免因为自杀而改变战斗奖励）
			hero.is_banned = true;
			return
		end
	end

	if GameRules:GetGameModeEntity().battle_round < 3 then
		DAC:OnSuggestLiuju({player_id = hero:GetPlayerID()})
	end
	local dur = GameRules:GetGameTime() - GameRules:GetGameModeEntity().START_TIME
	SetStat(hero:GetPlayerID(), 'duration', dur)
	SetStat(hero:GetPlayerID(), 'round', GameRules:GetGameModeEntity().battle_round)
	hero.last_damaged_by_team = nil
	Timers:CreateTimer(0.5,function()
		-- GameRules:GetGameModeEntity().battle_count = GameRules:GetGameModeEntity().battle_count - 1
		SetBattleTable(team,false)
		-- prt('battle_count:'..GetBattleCount())
		DamageTeam(team, 999, 'p002')
		--雷击特效和音效
		EmitSoundOn('Hero_Zuus.GodsWrath.Target',hero)
		PlayParticleOnUnitUntilDeath({
			caster = hero,
			p = "particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_bolt_parent.vpcf",
		})
		if GameRules:GetGameModeEntity().p2_mode == true and GetP2Ally(team) ~= nil then
			--2P模式，队友分担伤害
			SetStat(TeamId2Hero(GetP2Ally(team)):GetPlayerID(), 'duration', dur)
			SetStat(TeamId2Hero(GetP2Ally(team)):GetPlayerID(), 'round', GameRules:GetGameModeEntity().battle_round)
			-- GameRules:GetGameModeEntity().battle_count = GameRules:GetGameModeEntity().battle_count - 1
			SetBattleTable(GetP2Ally(team),false)
			DamageTeam(GetP2Ally(team), 999, 'p002')
		end
	end)
end

function MkAttack(keys)
	local caster = keys.caster
	-- StartAnimation(caster, {duration=1, activity=ACT_DOTA_ATTACK, rate=1, translate="attack_normal_range"})
	caster:AddActivityModifier('attack_normal_range')
	caster:StartGestureWithPlaybackRate(ACT_DOTA_ATTACK,caster:GetAttacksPerSecond()*1.2)
end

function MarsAttack(keys)
	local caster = keys.caster
	if caster:HasAbility("mars_bulwark_attack") and caster:FindAbilityByName("mars_bulwark_attack"):GetCooldownTimeRemaining() == 0 and caster:IsSilenced() == false and caster:IsStunned() == false and caster:IsFrozen() == false and caster:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and caster:IsHexed() == false and caster:IsCommandRestricted() == false and caster:HasModifier("modifier_axe_berserkers_call") == false and caster.is_moving ~= true then
		caster:Stop()
		StartMarsShieldCD(caster)
		caster:StartGesture(ACT_DOTA_CAST_ABILITY_4)
		
		MarsShieldDamage({
			caster = caster,
			ability = caster:FindAbilityByName("mars_bulwark_attack"),
		})
		local p = "particles/units/heroes/hero_mars/mars_shield_bash.vpcf"
		if caster:FindAbilityByName("mars_bulwark_attack"):GetLevel() >= 3 then
			p = "particles/econ/items/mars/mars_fall20_immortal_shield/mars_fall20_immortal_shield_bash.vpcf"
		end
		
		Timers:CreateTimer(0.4,function()
			play_particle(p,PATTACH_ABSORIGIN_FOLLOW,caster,3)
			EmitSoundOn("Hero_Mars.Shield.Cast",caster)
		end)
	else
		--普通攻击
		caster:AddActivityModifier('attack_close_range')
		caster:AddActivityModifier('faster')
		caster:StartGestureWithPlaybackRate(ACT_DOTA_ATTACK,caster:GetAttacksPerSecond()*3)
	end
end

function QopAttack(keys)
	local caster = keys.caster
	-- StartAnimation(caster, {duration=1, activity=ACT_DOTA_ATTACK, rate=1, translate="attack_normal_range"})
	caster:AddActivityModifier('close')
	caster:StartGestureWithPlaybackRate(ACT_DOTA_ATTACK,caster:GetAttacksPerSecond()*1.2)
end

function Bangjidadi(keys)
	local caster = keys.caster
	local target = keys.target
	if caster:FindModifierByName('modifier_mk_ruyibangfa_stack') ~= nil then
		local count = caster:FindModifierByName('modifier_mk_ruyibangfa_stack'):GetStackCount()
		caster:FindModifierByName('modifier_mk_ruyibangfa_stack'):SetStackCount(count+1)
	else
		caster:FindAbilityByName('mk_ruyibangfa'):ApplyDataDrivenModifier(caster,caster,'modifier_mk_ruyibangfa_stack',{})
		caster:FindModifierByName('modifier_mk_ruyibangfa_stack'):SetStackCount(1)
	end
end

--土猫：巨石翻滚
function EarthStartRockRoll(keys)
	local caster = keys.caster
	if IsUnitExist(caster) == false then
		return
	end
	local team_id = caster:GetTeam()
	local at_team_id = caster.at_team_id or team_id
	local ability = keys.ability
	if ability == nil then
		return
	end
	local level = ability:GetLevel() or 1
	local roll_count = ability:GetLevelSpecialValueFor( "roll_count", level - 1 )

	Timers:CreateTimer(0.5,function()
		if roll_count > 0 and caster:HasModifier('modifier_earth_rock_roll') then
			local x = 0
			local y = 0
			if RandomInt(1,100) < 50 then
				x = GetRandomXHasEnemy(team_id, at_team_id)
			else
				y = GetRandomYHasEnemy(team_id, at_team_id)
			end
			if RandomInt(1,100) < 50 then
				x = -x
				y = -y
			end
			RollAStone(caster,at_team_id,x,y,level)
			roll_count = roll_count - 1
			return 1
		else
			return
		end
	end)
end

function GetRandomXHasEnemy(team_id, at_team_id)
	local lucky_x = 0
	local try_count = 0
	while try_count < 100 and lucky_x == 0 do
		local random_x = RandomInt(1,8)
		for _,enemy in pairs (GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
			if IsUnitExist(enemy) == true and enemy.team_id ~= team_id and enemy.x == random_x then
				lucky_x = random_x
			end
		end
		try_count = try_count + 1
	end
	return lucky_x
end
function GetRandomYHasEnemy(team_id, at_team_id)
	local lucky_y = 0
	local try_count = 0
	while try_count < 100 and lucky_y == 0 do
		local random_y = RandomInt(1,8)
		for _,enemy in pairs (GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
			if IsUnitExist(enemy) == true and enemy.team_id ~= team_id and enemy.y == random_y then
				lucky_y = random_y
			end
		end
		try_count = try_count + 1
	end
	return lucky_y
end

--土猫：滚一个石头
function RollAStone(owner,at_team_id,x,y,level)
	if owner == nil then
		return 
	end
	local team_id = owner:GetTeam()
	if x == nil then
		x = 0 
	end
	if y == nil then
		y = 0 
	end
	if x ~= 0 then
		y = 0
	end
	if y ~= 0 then
		x = 0
	end
	if x == 0 and y == 0 then
		x = RandomInt(1,8)
	end

	if at_team_id == nil then
		at_team_id = team_id
	end
	if level == nil then
		level = 1
	end
	if level > 3 then
		level = 3
	end

	local stone_particle = 'effect/earth/roll/1.vpcf'
	if level == 3 then
		stone_particle = 'particles/econ/items/earth_spirit/earth_spirit_ti6_boulder/espirit_ti6_rollingboulder.vpcf'
	end

	local start_position = nil
	local end_position = nil
	if y == 0 and x > 0 then
		start_position = XY2Vector(x,0,at_team_id)
		end_position = XY2Vector(x,9,at_team_id)
	end
	if y == 0 and x < 0 then
		start_position = XY2Vector(-x,9,at_team_id)
		end_position = XY2Vector(-x,0,at_team_id)
	end
	if x == 0 and y > 0 then
		start_position = XY2Vector(0,y,at_team_id)
		end_position = XY2Vector(9,y,at_team_id)
	end
	if x == 0 and y < 0 then
		start_position = XY2Vector(9,-y,at_team_id)
		end_position = XY2Vector(0,-y,at_team_id)
	end

	if start_position ~= nil and end_position ~= nil then
		local invisible_unit = CreateUnitByName("invisible_unit", start_position ,false,nil,nil, team_id) 
		invisible_unit:SetForwardVector(end_position - start_position)
		invisible_unit:SetOwner(owner)
		invisible_unit.damage_owner = owner
		local pp = ParticleManager:CreateParticle(stone_particle, PATTACH_ABSORIGIN_FOLLOW, invisible_unit)
		ParticleManager:SetParticleControlEnt( pp, 10, invisible_unit, PATTACH_ABSORIGIN_FOLLOW, nil, Vector(0,1,0), true )
		invisible_unit.roll_particle = pp
		EmitSoundOn('Hero_EarthSpirit.RollingBoulder.Loop',invisible_unit)
		Timers:CreateTimer(0.5,function()
			--开始滚
			invisible_unit:AddNewModifier(invisible_unit,nil,"modifier_run",
			{
				vx = end_position.x,
				vy = end_position.y,
				speed = 800,
			})

			Timers:CreateTimer(0.2,function()
				if IsUnitExist(invisible_unit) == false then
					StopSoundEvent( 'Hero_EarthSpirit.RollingBoulder.Loop', invisible_unit )
					return
				end

				--判断砸中敌人
				if GameRules:GetGameModeEntity().to_be_destory_list[at_team_id] ~= nil and table.maxn(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) > 0 then
					for _,enemy in pairs (GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
						if IsUnitExist(enemy) == true and enemy.team_id ~= team_id and (invisible_unit:GetAbsOrigin() - enemy:GetAbsOrigin()):Length2D() < 100 then
							--砸中enemy
							if enemy:HasModifier('modifier_earth_rock_one_debuff') and (enemy.earth_rock_one_debuff_index == nil or enemy.earth_rock_one_debuff_index == invisible_unit:entindex()) then
								--重复砸中的，啥也不做
							elseif enemy:IsMagicImmune() == true then
								--魔法免疫的，啥也不做
							else
								--击晕+物理伤害
								local earth = invisible_unit.damage_owner
								enemy.earth_rock_one_debuff_index = invisible_unit:entindex()
								local ability = earth:FindAbilityByName('earth_rock_roll')
								local level = ability:GetLevel()
								local stun_duration = ability:GetLevelSpecialValueFor( "stun_duration", level - 1 )
								local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
								ability:ApplyDataDrivenModifier(invisible_unit,enemy,'modifier_earth_rock_one_debuff',{duration = stun_duration})
								ApplyDamage({
							    	victim = enemy,
							    	attacker = earth,
							    	damage_type = DAMAGE_TYPE_PHYSICAL,
							    	damage = damage,
							    	ability = ability,
							    })
							    EmitSoundOn('Hero_EarthSpirit.RollingBoulder.Target', enemy)
							end
						end
					end
				end

				--判断到达
				if (invisible_unit:GetAbsOrigin() - end_position):Length2D() < 50 then
					if pp ~= nil and IsUnitExist(invisible_unit) == true then
						ParticleManager:DestroyParticle(pp,false)
					end
					Timers:CreateTimer(3,function()
						if IsUnitExist(invisible_unit) == true then
							invisible_unit:ForceKill(false)
							invisible_unit:Destroy()
						end
					end)
					if IsUnitExist(invisible_unit) == true then
						EmitSoundOn('Hero_EarthSpirit.RollingBoulder.Destroy', invisible_unit)
						StopSoundEvent( 'Hero_EarthSpirit.RollingBoulder.Loop', invisible_unit)
					end
					return
				end
				return 0.2
			end)
		end)
	end

	
end

function AddDrShooterAura(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	for _,unit in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id == team_id and unit:Script_GetAttackRange() > 205 then --and unit:entindex() ~= caster:entindex()
			if unit:HasModifier('modifier_shooter_buff') == false then
				--没有射手光环，直接添加
				keys.ability:ApplyDataDrivenModifier(caster,unit,'modifier_shooter_buff',{ })
			else
				--已有射手光环
				local m = unit:FindModifierByName('modifier_shooter_buff')
				if m ~= nil then
					if m:GetAbility():GetLevel() < ability_level then
						unit:RemoveModifierByName('modifier_shooter_buff')
						keys.ability:ApplyDataDrivenModifier(caster,unit,'modifier_shooter_buff',{ })
					end
				end
			end
		end
	end
end

function RemoveDrShooterAura(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	for _,unit in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if unit.team_id == team_id and unit:FindModifierByNameAndCaster('modifier_shooter_buff',caster) ~= nil then
			unit:RemoveModifierByNameAndCaster('modifier_shooter_buff',caster)
		end
	end
end

function BrewSSR3Pandas(keys)
	local caster = keys.caster
	local items = GetAllItemsInUnits({[1] = caster})

	if IsUnitExist(caster) == true and caster.tuihua ~= true then
		caster.tuihua = true
		--生成三只熊猫
		Timers:CreateTimer(0,function()
			local x = SummonOneMinion(caster,'chess_earth11')
			x:SetMana(0)
			FillEmptySlot(x)
			ExtendBeastBuff(x,caster)
			AddChessAbility(x,3)
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			Timers:CreateTimer(0.1,function()
				local x = SummonOneMinion(caster,'chess_ember11')
				x:SetMana(0)
				FillEmptySlot(x)
				ExtendBeastBuff(x,caster)
				AddChessAbility(x,3)
				AddAbilityAndSetLevel(x,'jiaoxie_wudi')
				Timers:CreateTimer(0.2,function()
					local x = SummonOneMinion(caster,'chess_storm11')
					x:SetMana(0)
					FillEmptySlot(x)
					ExtendBeastBuff(x,caster)
					AddChessAbility(x,3)
					AddAbilityAndSetLevel(x,'jiaoxie_wudi')
				end)
			end)
		end)

		--销毁酒仙
		RemoveFromToBeDestroyList(caster)
		AddAbilityAndSetLevel(caster,'no_selectable')

		Timers:CreateTimer(1,function()
			if IsUnitExist(caster) == true then
				if caster.team_id ~= 4 then
					SaveItem(caster.team_id,caster:entindex(),function()
						caster:Destroy()
					end)
				else
					caster:Destroy()
				end
			end
		end)
	end
end

function QOPSonicWave(keys)
	local caster = keys.caster
	local p = keys.target_points[1]
	local ability = keys.ability
	local level = ability:GetLevel()
	local speed = ability:GetLevelSpecialValueFor( "speed", level - 1 )
	local forwardVec = p - caster:GetAbsOrigin()


	local speed = ability:GetLevelSpecialValueFor( "speed", level - 1 )
	local starting_aoe = ability:GetLevelSpecialValueFor( "starting_aoe", level - 1 )
	local final_aoe = ability:GetLevelSpecialValueFor( "final_aoe", level - 1 )

	local effect_name = 'particles/units/heroes/hero_queenofpain/queen_sonic_wave.vpcf'
	if level >= 3 then
		effect_name = 'particles/econ/items/queen_of_pain/qop_arcana/qop_arcana_sonic_wave.vpcf'
	end

	local projectileTable =
	{
		Source = caster,
		Ability = ability,
		EffectName = effect_name,
		vSpawnOrigin = caster:GetOrigin(),
		fDistance = 900,
		vVelocity = (p-caster:GetAbsOrigin()):Normalized() * 1100,
		fStartRadius = starting_aoe,
		fEndRadius = final_aoe,
		iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
		iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_SPELL_IMMUNE_ENEMIES,
		iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
		bReplaceExisting = false,
		bProvidesVision = false,
	}
	local projectileID = ProjectileManager:CreateLinearProjectile( projectileTable )
end

function KunkkaShip(keys)
	local caster = keys.caster
	local p = keys.target_points[1]
	local damage = keys.damage
	local ghostship_speed = keys.ghostship_speed
	local stun_duration = keys.stun_duration
	local ghostship_width = keys.ghostship_width
	local ghostship_distance = keys.ghostship_distance or 2000
	local ability = keys.ability
	local level = ability:GetLevel()

	local ship_particle = "particles/units/heroes/hero_kunkka/kunkka_ghost_ship.vpcf"
	local marker_particle = "particles/units/heroes/hero_kunkka/kunkka_ghostship_marker.vpcf"
	if level >= 3 then
		ship_particle = "particles/econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship.vpcf"
		marker_particle = "particles/econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship_marker.vpcf"
	end
	if caster:GetUnitName() == 'chess_rubick' or caster:GetUnitName() == 'chess_rubick1' or caster:GetUnitName() == 'chess_rubick11' then
		ship_particle = "particles/econ/items/rubick/rubick_arcana/rbck_arc_kunkka_ghost_ship.vpcf"
	end

	if level >= 3 then
		EmitSoundOn("chess_kunkka.ship_bell_shark",caster)
		EmitSoundOn("chess_kunkka.ship_run",caster)
	else
		EmitSoundOn("chess_kunkka.ship_bell",caster)
		EmitSoundOn("chess_kunkka.ship_run",caster)
	end

	local start_point = p + ((caster:GetOrigin()-p):Normalized() * ghostship_distance)
	ProjectileManager:CreateLinearProjectile( {
		Source = caster,
		Ability = nil,
		EffectName = ship_particle,
		vSpawnOrigin = start_point,
		fDistance = ghostship_distance,
		vVelocity = (p-caster:GetOrigin()):Normalized() * ghostship_speed,
		fStartRadius = ghostship_width,
		fEndRadius = ghostship_width,
		iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
		iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_SPELL_IMMUNE_ENEMIES,
		iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
		bReplaceExisting = false,
		bProvidesVision = false,
	} )

	local ppp = ParticleManager:CreateParticle(marker_particle, PATTACH_WORLDORIGIN ,nil)
    ParticleManager:SetParticleControl(ppp, 0, p)


	local duration = 1.0*ghostship_distance/ghostship_speed
	Timers:CreateTimer(duration, function()
		if level >= 3 then
			EmitSoundOn("chess_kunkka.ship_crash_shark",caster)
		else
			EmitSoundOn("chess_kunkka.ship_crash",caster)
		end
		if ppp ~= nil then
            ParticleManager:DestroyParticle(ppp,true)
        end
	end)
	
	ApplyDamageInRadius({
		delay = duration,
		caster = caster,
		team = caster.team_id,
		radius = ghostship_width,
		role = 2,
		position = p,
		damage = damage,
		damage_type = DAMAGE_TYPE_MAGICAL,
		stun_duration = stun_duration,
		ability = "kunkka_ship",
	})
end

function AddLinKen(keys)
	local caster = keys.caster
	if IsUnitExist(caster) == true and caster:IsHero() == false and caster:HasModifier("modifier_item_sphere_target") == false then
		caster:AddNewModifier(caster,nil,"modifier_item_sphere_target",{})
	end
end
function RemoveLinKen(keys)
	local caster = keys.caster
	if caster:HasModifier("modifier_item_sphere_target") == true then
		caster:RemoveModifierByName("modifier_item_sphere_target")
	end
end
function ThinkLinKen(keys)
	local caster = keys.caster
	local ability = keys.ability
	if IsUnitExist(caster) == true and caster:IsHero() == false and caster:HasModifier("modifier_item_sphere_target") == false then
		if ability.cd == nil then
			ability.cd = true
			ability:StartCooldown(5)
		else
			if ability:IsCooldownReady() == true then
				--冷却好了，加上buff
				ability.cd = nil
				caster:AddNewModifier(caster,nil,"modifier_item_sphere_target",{})
			else
				return
			end
		end
	end
end


function FindChessInGrid(teamid,x,y)
	local chess = nil
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[teamid]) do
		if v.x == x and v.y == y then
			chess = v
		end
	end
	return chess
end
function FindEnemyInGrid(teamid,x,y,at_team_id)
	local chess = nil
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if IsUnitExist(v) == true and v.x == x and v.y == y and v:GetTeam() ~= teamid then
			chess = v
		end
	end
	return chess
end
function FindGouheDirection(es)
	local at_team_id = es.at_team_id or es.team_id
	local position = es:GetAbsOrigin()
	local directions = {
		[1] = {x=1,y=0},
		[2] = {x=1,y=1},
		[3] = {x=1,y=-1},
		[4] = {x=-1,y=0},
		[5] = {x=-1,y=1},
		[6] = {x=-1,y=-1},
		[7] = {x=0,y=-1},
		[8] = {x=0,y=1},
	}
	local x = Vector2X(position,at_team_id)
	local y = Vector2Y(position,at_team_id)
	local return_direction = nil
	local max_enemy = 0
	for i,v in pairs(directions) do
		local direction_length = 1
		local x0 = x + v.x
		local y0 = y + v.y
		local count_enemy = 0
		while IsIn8x8(x0,y0) == true do
			if FindEnemyInGrid(es:GetTeam(),x0,y0,at_team_id) ~= nil then
				count_enemy = count_enemy + 1
			end
			x0 = x0 + v.x
			y0 = y0 + v.y
			direction_length = direction_length + 1
		end
		if count_enemy > 0 and max_enemy < count_enemy + (direction_length*0.1) then
			max_enemy = count_enemy + (direction_length*0.1)
			return_direction = v
		end
	end
	return return_direction
end
function TpSeedThink(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	if ability == nil then
		return
	end
	local level = ability:GetLevel()
	local radius = ability:GetLevelSpecialValueFor( "radius", level - 1 )
	local damage = ability:GetLevelSpecialValueFor( "damage_heal", level - 1 )

	if IsUnitExist(target) == false or ability == nil then
		return
	end
	ApplyDamage({
    	victim = target,
    	attacker = caster,
    	damage_type = DAMAGE_TYPE_MAGICAL,
    	damage = damage,
    })

	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[target.at_team_id or target.team_id]) do
		local dd = (target:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D()
		if dd < radius and unit.team_id ~= target.team_id then
			TpSeedHeal(target,unit,ability)
		end
	end
end

function TpSeedCast(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()

	if BlockByLinken(target) == false then
		local pp = ParticleManager:CreateParticle('particles/units/heroes/hero_treant/treant_leech_seed.vpcf', PATTACH_ABSORIGIN_FOLLOW, caster)
		ParticleManager:SetParticleControlEnt( pp, 0, caster, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true )
		ParticleManager:SetParticleControlEnt( pp, 1, target, PATTACH_ABSORIGIN_FOLLOW, nil, target:GetOrigin(), true )
		Timers:CreateTimer(2,function()
			if pp ~= nil then
		        ParticleManager:DestroyParticle(pp,true)
		    end
	    end)
	else
		--被林肯挡了
		if target:HasModifier('modifier_tp_seed_debuff') then
			target:RemoveModifierByName('modifier_tp_seed_debuff')
		end
	end
end

function TpSeedHeal(from,to,ability)
	ProjectileManager:CreateTrackingProjectile({
        Target = to,
        Source = from,
        Ability = ability,
        EffectName = 'particles/units/heroes/hero_treant/treant_leech_seed_projectile.vpcf',
        bDodgeable = false,
        iMoveSpeed = 450,
        bProvidesVision = false,
        iVisionRadius = 0,
        iVisionTeamNumber = to:GetTeamNumber(),
        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
    })
    local level = ability:GetLevel()
    local heal = ability:GetLevelSpecialValueFor( "damage_heal", level - 1 )
    local duration = (from:GetAbsOrigin() - to:GetAbsOrigin()):Length2D() / 450.0
    Timers:CreateTimer(duration, function()
    	to:Heal(heal, to)
    	-- AMHC:CreateNumberEffect(to,heal,2,AMHC.MSG_MISS,{0,255,0},0)
    end)
end

function BlockByLinken(target)
	for slot=0,5 do
		if target:GetItemInSlot(slot)~= nil then
			local ability = target:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_linkenfaqiu' and ability:IsCooldownReady() == true then
				target:RemoveModifierByName("modifier_item_sphere_target")
				ability.cd = true
				ability:StartCooldown(5)
				
				play_particle("particles/items_fx/immunity_sphere_2.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
				EmitSoundOn("item.linken",target)
				return true
			end
		end
	end

	return false
end

function RefreshAssassinJump(keys)
	local caster = keys.caster

	--9刺客，重置背刺跳跃
	if IsUnitExist(caster) and  caster:HasModifier('modifier_is_assassin_buff_plus_plus') == true then
		caster.has_assassin_blink = true
		caster.attack_target = nil
		AddAbilityAndSetLevel(caster,'jiaoxie')
	end
end

function SbBash(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local stun = ability:GetLevelSpecialValueFor( "stun", level - 1 )

	local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
	local deltax = math.floor(vec.x+0.5)
	local deltay = math.floor(vec.y+0.5)

	local team_id = target.at_team_id or target.team_id

	local y = target.y
	local x = target.x

	if IsIn8x8(x+deltax,y+deltay) == true and IsEmptyGrid(team_id,x+deltax,y+deltay) == true and not target:HasModifier('modifier_tuitui') and target:HasMovementCapability() == true then
		local target_pos = XY2Vector(x+deltax,y+deltay,team_id)
		local stun_duration = ((target_pos-target:GetAbsOrigin()):Length2D()/1000)
		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+stun})

		GameRules:GetGameModeEntity().unit[team_id][(y+deltay)..'_'..(x+deltax)] = 1
		target.is_moving = true
		BlinkChessX({p=target_pos,caster=target,blink_type='tuitui'})
		target.y_x = (y+deltay)..'_'..(x+deltax)
		target.y = y+deltay
		target.x = x+deltax
		GameRules:GetGameModeEntity().unit[team_id][y..'_'..x] = nil
	else
		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun})
	end

	Timers:CreateTimer(0.1,function()
		ApplyDamage({
	    	victim = target,
	    	attacker = caster,
	    	damage_type = DAMAGE_TYPE_PHYSICAL,
	    	damage = damage,
	    })
	end)
end

function GetAnimation(n)
	local animation_list = require("data").dac_animation_list
	if animation_list ~= nil and animation_list[n] ~= nil then
		return animation_list[n]
	else
		return animation_list['n000']
	end
end

function FindFriendlyChessesByName(caster,chessname)
	local t = {}
	local teamid = caster.team_id
	local atteamid = caster.at_team_id or caster.team_id
	for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[atteamid]) do
		if string.find(v:GetUnitName(),chessname) ~= nil and teamid == v.team_id then
			table.insert(t,v)
		end
	end
	return t
end

function FindEnemyChessesByName(caster,chessname)
	local t = {}
	local teamid = caster.team_id
	local atteamid = caster.at_team_id or caster.team_id
	if GameRules:GetGameModeEntity().to_be_destory_list[atteamid] ~= nil then 
		for i,v in pairs(GameRules:GetGameModeEntity().to_be_destory_list[atteamid]) do
			if IsUnitExist(v) == true and string.find(v:GetUnitName(),chessname) ~= nil and teamid ~= v.team_id then
				table.insert(t,v)
			end
		end
	end
	return t
end

function MeepoPoofOuter(keys)
	local c = keys.caster
	local a = keys.ability
	local t = keys.target
	local level = a:GetLevel()
	local meepos = FindFriendlyChessesByName(c,'chess_meepo')
	if table.maxn(meepos) > 0 then
		for _,m in pairs(meepos) do
			if m:HasModifier('modifier_axe_berserkers_call') == false and m:FindModifierByName('modifier_doom_bringer_doom') == nil and IsHexxed(m) == false and m:FindModifierByName('modifier_medusa_stone_gaze_stone') == nil and m:IsSilenced() == false and m:IsStunned() == false then
				m.stop_moving = true
				MeepoPoofOne(c,m,t,a)
			end
		end
	end
end

function MeepoPoofOne(c,m,t,a)
	Timers:CreateTimer(RandomFloat(0.1,0.8),function()
		local p = FindClosestEmptyGrid(t)
		ChangeUnitPosition(m, p, true)
		m.stop_moving = nil

		-- local x = Vector2X(p,m.at_team_id or m.team_id)
		-- local y = Vector2Y(p,m.at_team_id or m.team_id)
		-- local xx = m.x
		-- local yy = m.y
		-- GameRules:GetGameModeEntity().unit[m.at_team_id or m.team_id][y..'_'..x] = 1
		-- m:SetAbsOrigin(p)
		-- m.y_x = y..'_'..x
		-- m.y = y
		-- m.x = x
		-- GameRules:GetGameModeEntity().unit[m.at_team_id or m.team_id][yy..'_'..xx] = nil
 
		local level = a:GetLevel()
		local damage = a:GetLevelSpecialValueFor( "pure_damage", level - 1 )

		ApplyDamageInRadius({
			caster = m,
			team = m.team_id,
			radius = 205,
			role = 2,
			position = p,
			damage = damage,
			damage_type = DAMAGE_TYPE_PURE,
			ability = "poof",
		})
		play_particle("particles/units/heroes/hero_meepo/meepo_poof_end.vpcf",PATTACH_ABSORIGIN_FOLLOW,m,3)
		
	end)
end

function UpdateTimer()
	CustomNetTables:SetTableValue( "game_info", "timer", { 
		game_status = GameRules:GetGameModeEntity().game_status,
		prepare_timer = GameRules:GetGameModeEntity().prepare_timer,
		battle_timer = GameRules:GetGameModeEntity().battle_timer,
	})
end

function AttackAbilityMagical(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local damage = caster:GetAttackDamage()
	local damage_bonus = caster:GetAverageTrueAttackDamage(target) - ( caster:GetBaseDamageMax() + caster:GetBaseDamageMin() ) / 2

	local team_id = target.at_team_id or target.team_id
	ApplyDamage({
		victim = target, 
		attacker = caster, 
		damage = damage + damage_bonus, 
		damage_type = DAMAGE_TYPE_MAGICAL, 
		damage_flags = DOTA_DAMAGE_FLAG_NONE, 
		ability = {}
	})
end

function AttackAbilityPure(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local damage = caster:GetAttackDamage()
	local damage_bonus = caster:GetAverageTrueAttackDamage(target) - ( caster:GetBaseDamageMax() + caster:GetBaseDamageMin() ) / 2

	local team_id = target.at_team_id or target.team_id
	ApplyDamage({
		victim = target, 
		attacker = caster, 
		damage = damage + damage_bonus, 
		damage_type = DAMAGE_TYPE_PURE, 
		damage_flags = DOTA_DAMAGE_FLAG_NONE, 
		ability = {}
	})
end

function IsKobold(unit_name)
	local base_name = GetChessBaseName(unit_name)
	return FindValueInTable(GameRules:GetGameModeEntity().chess_list_by_synergy['is_kobold'],base_name)
end
function GetChessBaseName(name)
	if string.find(name,'11') ~= nil then
		name = string.sub(name,1,-2)
	end
	if string.find(name,'1') ~= nil then
		name = string.sub(name,1,-2)
	end
	return name
end
function WardDisarm(keys)
	local c = keys.caster
	local w = FindEnemyChessesByName(c,'disarm_ward')
	if table.maxn(w) > 0 and IsUnitExist(w[1]) == true and RandomInt(1,100) > 90 then
		if w[1]:FindAbilityByName('ward_disarm') ~= nil and w[1]:FindAbilityByName('ward_disarm'):IsCooldownReady() == true then
			if c:IsMagicImmune() == false then
				w[1]:FindAbilityByName('ward_disarm'):StartCooldown(0.5)
				c:AddNewModifier(c,nil,"modifier_pangolier_luckyshot_disarm",{duration = 2})
			    ApplyDamage({
			    	victim = c,
			    	attacker = w[1],
			    	damage_type = DAMAGE_TYPE_PHYSICAL,
			    	damage = 200
			    })
			    --特效、音效
				local effect_name = "particles/econ/items/tinker/tinker_ti10_immortal_laser/tinker_ti10_immortal_laser.vpcf"-- "particles/units/heroes/hero_tinker/tinker_laser.vpcf"
				ProjectileManager:CreateTrackingProjectile({
			        Target = c,
			        Source = w[1],
			        Ability = nil,
			        EffectName = effect_name,
			        bDodgeable = false,
			        iMoveSpeed = 1200,
			        bProvidesVision = false,
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    })
			    EmitSoundOn("tauren.ward.laser",w[1])
			    w[1]:SetForwardVector(c:GetAbsOrigin()-w[1]:GetAbsOrigin())
			end
		end
	end
end
function WardNether(keys)
	local c = keys.caster
	if c:GetUnitName() == 'invisible_unit' then
		--隐藏施法单位，寻找它的真正施法者
		if c.damage_owner ~= nil and IsUnitExist(c.damage_owner) == true and c.ignore_nether_ward ~= true then -- 增加对 ignore_nether_ward  的判断
			c = c.damage_owner
		else
			--找不到的话，就算了！
			return
		end
	end
	local w = FindEnemyChessesByName(c,'nether_ward')

	if table.maxn(w) > 0 and IsUnitExist(w[1]) == true and RandomInt(1,100) > 50 then
		if w[1]:FindAbilityByName('ward_nether') ~= nil and w[1]:FindAbilityByName('ward_nether'):IsCooldownReady() == true then
			if c:IsMagicImmune() == false then
				w[1]:FindAbilityByName('ward_nether'):StartCooldown(0.5)
				ApplyDamage({
			    	victim = c,
			    	attacker = w[1],
			    	damage_type = DAMAGE_TYPE_MAGICAL,
			    	damage = 500
			    })
				c:AddNewModifier(c,nil,"modifier_silencer_global_silence",{duration = 5})
				--特效、音效
				local effect_name = "particles/econ/items/pugna/pugna_ward_ti5/pugna_ward_attack_heavy_ti_5.vpcf"
				ProjectileManager:CreateTrackingProjectile({
			        Target = c,
			        Source = w[1],
			        Ability = nil,
			        EffectName = effect_name,
			        bDodgeable = false,
			        iMoveSpeed = 1200,
			        bProvidesVision = false,
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    })
			    EmitSoundOn("tauren.ward.nether",w[1])
			    w[1]:SetForwardVector(c:GetAbsOrigin()-w[1]:GetAbsOrigin())
			end
		end
	end
end

function ESGouhe(keys)
	local es = keys.caster
	local team = es.at_team_id or es.team_id
	local point = keys.target_points[1]
	local ability = keys.ability
	local level = ability:GetLevel()
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local duration = ability:GetLevelSpecialValueFor( "duration", level - 1 )
	local stun = ability:GetLevelSpecialValueFor( "stun", level - 1 )

	EmitSoundOn('Hero_EarthShaker.Fissure',es)
	local pp = "particles/units/heroes/hero_earthshaker/earthshaker_fissure.vpcf"
	if level == 3 then
		pp = "particles/econ/items/earthshaker/earthshaker_ti9/earthshaker_fissure_ti9.vpcf"
	end
	local direction = point - es:GetAbsOrigin()
	local gouhe_table = {}
	local endpoint = point
	while IsIn8x8(Vector2X(endpoint,team),Vector2Y(endpoint,team)) == true do
		table.insert(gouhe_table,{x=Vector2X(endpoint,team),y=Vector2Y(endpoint,team)})
		endpoint = endpoint + direction
	end
	local particle = ParticleManager:CreateParticle(pp, PATTACH_ABSORIGIN, es)
	ParticleManager:SetParticleControl(particle, 0, point)
	ParticleManager:SetParticleControl(particle, 1, endpoint-direction)
	ParticleManager:SetParticleControl(particle, 2, Vector(duration,0,0))
	for i,v in pairs(gouhe_table) do
		local c = FindChessInGrid(team,v.x,v.y)
		if c ~= nil and c:HasMovementCapability() == true then
			local pp = FindClosestEmptyGrid(c)
			local stun_duration = ((pp-c:GetAbsOrigin()):Length2D()/1000)
			if IsUnitExist(c) and (c:GetTeam() == es:GetTeam() or c:IsMagicImmune() == true) then
				c:AddNewModifier(c,nil,"modifier_stunned",{ duration = stun_duration})
			else
				c:AddNewModifier(c,nil,"modifier_stunned",{ duration = stun_duration+stun})
				ApplyDamage({
			    	victim = c,
			    	attacker = es,
			    	damage_type = DAMAGE_TYPE_PHYSICAL,
			    	damage = damage,
			    	ability = es:FindAbilityByName('gouhe')
			    })
			end
			if IsUnitExist(c) then
				c.is_moving = true
				BlinkChessX({p=pp,caster=c,blink_type='tuitui'})
				c.x = Vector2X(pp,team)
				c.y = Vector2Y(pp,team)
				c.y_x = Vector2Y(pp,team)..'_'..Vector2X(pp,team)
				GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] = nil
				GameRules:GetGameModeEntity().unit[team][Vector2Y(pp,team)..'_'..Vector2X(pp,team)] = 1
			end
		end
		if GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] == nil then
			GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] = 1
		else
			GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] = GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] + 1
		end
		Timers:CreateTimer(duration,function()
			if GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] ~= nil and FindChessInGrid(team,v.x,v.y) == nil then
				if GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] <= 1 then
					GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] = nil
				else
					GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] = GameRules:GetGameModeEntity().unit[team][v.y..'_'..v.x] - 1
				end
			end
		end)
	end
end

--上古巨神-裂地沟壑
function EarthSplitter(keys)
	local et = keys.caster
	local team = et.at_team_id or et.team_id or et:GetTeam()
	local point = keys.target_points[1]
	local ability = keys.ability
	local level = ability:GetLevel()
	local duration = ability:GetLevelSpecialValueFor( "duration", level - 1 )
	local damage_base = ability:GetLevelSpecialValueFor( "damage_base", level - 1 )
	local damage_per = ability:GetLevelSpecialValueFor( "damage_per", level - 1 )
	local radius = ability:GetLevelSpecialValueFor( "radius", level - 1 )

	EmitSoundOn('Hero_ElderTitan.EarthSplitter.Projectile',et)
	local pp = "particles/units/heroes/hero_elder_titan/elder_titan_earth_splitter.vpcf"

	local direction = point - et:GetAbsOrigin()
	local gouhe_table = {}
	local endpoint = point
	while IsIn8x8(Vector2X(endpoint,team),Vector2Y(endpoint,team)) == true do
		table.insert(gouhe_table, Vector2X(endpoint,team)..'_'..Vector2Y(endpoint,team))
		endpoint = endpoint + direction
	end
	local particle = ParticleManager:CreateParticle(pp, PATTACH_ABSORIGIN, et)
	ParticleManager:SetParticleControl(particle, 0, point)
	ParticleManager:SetParticleControl(particle, 1, endpoint+direction)
	ParticleManager:SetParticleControl(particle, 3, Vector(0,3.5,0))

	local gouhe_table_expand = {}
	for i,v in pairs(gouhe_table) do
		table.insert(gouhe_table_expand,v)
	end

	--扩大一圈范围
	for i,v in pairs(gouhe_table) do
		local x = tonumber(string.split(v,'_')[1])
		local y = tonumber(string.split(v,'_')[2])

		local delta = {
			[1] = {x=1,y=0},
			[2] = {x=-1,y=0},
			[3] = {x=0,y=1},
			[4] = {x=0,y=-1},
		}
		for _,d in pairs(delta) do
			if IsIn8x8(x+d.x,y+d.y) == true and FindValueInTable(gouhe_table_expand,''..(x+d.x)..'_'..(y+d.y)) == false then
				table.insert(gouhe_table_expand,''..(x+d.x)..'_'..(y+d.y))
			end
		end
	end

	Timers:CreateTimer(3,function()
		EmitSoundOn("et.earth_splitter.end",et)
		--遍历每一个格子，拉最近的棋子
		for i,v in pairs(gouhe_table_expand) do
			local x = tonumber(string.split(v,'_')[1])
			local y = tonumber(string.split(v,'_')[2])
			local p = XY2Vector(x,y,team)

			if IsEmptyGrid(team,x,y) == true then
				local enemy_chess = FindClosestEarthSplitterEnemyByGrid(team, x, y, radius, et, gouhe_table, gouhe_table_expand)
				if IsUnitExist(enemy_chess) == true then
					GameRules:GetGameModeEntity().unit[team][enemy_chess.y..'_'..enemy_chess.x] = nil
					enemy_chess.is_moving = true
					BlinkChessX({p=p,caster=enemy_chess,blink_type='tuitui'})
					enemy_chess.x = x
					enemy_chess.y = y
					enemy_chess.y_x = y..'_'..x
					GameRules:GetGameModeEntity().unit[team][y..'_'..x] = 1
					SplitterDamageAndStun(et, ability, enemy_chess, damage_base, damage_per, duration)
				end
			else
				local enemy_chess = FindChessInGrid(team,x,y)
				if IsUnitExist(enemy_chess) == true and et:GetTeam() ~= enemy_chess:GetTeam() then
					SplitterDamageAndStun(et, ability, enemy_chess, damage_base, damage_per, duration)
				end
			end
		end
	end)
end

function SplitterDamageAndStun(et, ability, enemy_chess, damage_base, damage_per, duration)
	ability:ApplyDataDrivenModifier(et,enemy_chess,'modifier_et_earth_splitter_stunned_debuff',{duration = duration})
	local damage = (damage_base + enemy_chess:GetMaxHealth() / 100.0 * damage_per) * 0.5
	ApplyDamageDelay({
		caster = et,
		victim = enemy_chess,
		damage = damage,
		damage_type = DAMAGE_TYPE_MAGICAL,
		delay = 0.5,
		ability = ability,
	})
	ApplyDamageDelay({
		caster = et,
		victim = enemy_chess,
		damage = damage,
		damage_type = DAMAGE_TYPE_PHYSICAL,
		delay = 0.5,
		ability = ability,
	})
end

function FindClosestEarthSplitterEnemyByGrid(at_team_id, x, y, radius, caster, g_table, g_table_expand)
	local enemy = nil
	local min_distance = 9999
	for _,chess in pairs(GameRules:GetGameModeEntity().to_be_destory_list[at_team_id]) do
		if IsUnitExist(chess) == true and caster:GetTeam() ~= chess:GetTeam() and chess:HasMovementCapability() == true then
			local la = true
			if FindValueInTable(g_table, chess.x..'_'..chess.y) == true then
				la = false
			else
				if FindValueInTable(g_table, x..'_'..y) == false and FindValueInTable(g_table_expand, chess.x..'_'..chess.y) == true then
					la = false
				end
			end
			if la then 
				local d = (chess:GetAbsOrigin() - XY2Vector(x,y,at_team_id)):Length2D()
				if d< radius and d < min_distance then
					enemy = chess
					min_distance = d
				end
			end
		end
	end
	return enemy
end

function DAC:ResetFOW(keys)
	local local_player_team = keys.local_player_team
	local target_player_team = keys.target_player_team
	local hero = TeamId2Hero(local_player_team)
	if hero == nil or Entities:FindByName(nil,"center"..(target_player_team-6)) == nil then
		return
	end
	--先删除之前的视野
	if hero.ob_viewer_id ~= nil then
		RemoveFOWViewer(local_player_team, hero.ob_viewer_id)
	end
	--添加新的玩家对应棋盘视野
	hero.ob_viewer_id = AddFOWViewer(local_player_team, Entities:FindByName(nil,"center"..(target_player_team-6)):GetOrigin(), 1000, 9999, false)
end

function BhShuriken(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local ministun = ability:GetLevelSpecialValueFor( "ministun", level - 1 )
	local skip_count = ability:GetLevelSpecialValueFor( "skip_count", level - 1 )

	--伤害和眩晕
	target:AddNewModifier(target,nil,"modifier_stunned",{ duration = ministun})
	ApplyDamage({
    	victim = target,
    	attacker = caster.damage_owner or caster,
    	damage_type = DAMAGE_TYPE_MAGICAL,
    	damage = damage,
    	ability = ability
    })

    if level >= 2 then
    	--弹跳下一个飞镖
    	if caster.damage_owner ~= nil then
    		caster = caster.damage_owner
    	end
    	local next_enemy = FindMinHPEnemy(caster,target)
    	InvisibleUnitCast({
			caster = caster,
			ability = "bh_shuriken",
			level = level - 1,
			unluckydog = next_enemy,
			force_unluckydog = next_enemy,
			caster_position = target:GetAbsOrigin(),
			ignore_nether_ward = true,
		})
    end
end

function FindMinHPEnemy(u,last_target)
	local unluckydog = nil
	local min_hp = 999999
	local last_index = -1
	if last_target ~= nil then
		last_index = last_target:entindex()
	end
	local team = u.at_team_id or u.team_id
	for _,unit in pairs (GameRules:GetGameModeEntity().to_be_destory_list[u.at_team_id or u.team_id]) do
		if unit.team_id ~= u.team_id and IsUnitExist(unit) and unit:entindex() ~= last_index and unit:GetHealth() < min_hp then
			unluckydog = unit
			min_hp = unit:GetHealth()
		end
	end
	return unluckydog
end

function FvZhao(keys)
	local caster = keys.caster
	local ability = keys.ability
	local point = keys.target_points[1]
	local duration = ability:GetLevelSpecialValueFor( "duration", ability:GetLevel() - 1 )
	local radius = ability:GetLevelSpecialValueFor( "radius", ability:GetLevel() - 1 )

	--播放特效和音效
	local particle = ParticleManager:CreateParticle('particles/units/heroes/hero_faceless_void/faceless_void_chronosphere.vpcf', PATTACH_ABSORIGIN, caster)
	ParticleManager:SetParticleControl(particle, 0, point)
	ParticleManager:SetParticleControl(particle, 1, Vector(radius-50,radius-50,radius-50))
	Timers:CreateTimer(duration,function()
		if particle ~= nil then
	        ParticleManager:DestroyParticle(particle,true)
	    end
    end)
    EmitSoundOn("Hero_FacelessVoid.Chronosphere",caster)

    --计时器，每interval秒判断罩子内部的敌人，给interval秒的冻结debuff
    local interval = 0.1
    local count_down = duration or 5
    Timers:CreateTimer(interval,function()
    	count_down = count_down - interval
    	if count_down <= 0 then
    		return
    	end
    	GiveFvDebuffAndBuff(caster,point,radius,ability,"modifier_faceless_void_chronosphere_freeze",nil,interval)

    	return interval
    end)
end

function GiveFvDebuffAndBuff(caster,point,radius,ability,debuff,buff,duration)
	if caster == nil or caster:IsNull() == true then
		return
	end
	if debuff ~= nil then
		--给罩子内全部棋子debuff
		local unlucky_dogs = FindUnitsInRadiusByTeam({
			team = caster:GetTeam(),
			role = 3,
			position = point,
			radius = radius,
		})
		for i,v in pairs(unlucky_dogs) do
			if IsUnitExist(v) == true and v:HasAbility('fv_zhao') == false and v.is_moving ~= true then
				v:AddNewModifier(v,nil,debuff,{duration = duration})
			end
		end
	end
	if buff ~= nil then
		--未来可能添加的buff
	end
end





function PlaySpawnAnimation(x)
	x:StartGesture(ACT_DOTA_SPAWN)
	if string.find(x:GetUnitName(),'sniper') ~= nil then
		x:StartGesture(ACT_DOTA_IDLE)
	end
end

function ClearEmotionCooldown(h)
	h.is_emotion_cooldown = true
end
function SetEmotionCooldown(h)
	h.is_emotion_cooldown = nil
end
function IsEmotionCooldown(h)
	if h.is_emotion_cooldown == true then
		return true
	else
		return false
	end
end
function DAC:RequestShowEmotionBubble(keys)
	local player_id = keys.playerID or keys.player_id
	local h = PlayerId2Hero(player_id)
	local emotion_index = keys.emotion_index

	if IsUnitExist(h) == false then
		return
	end

	if IsEmotionCooldown(h) == true then
		return
	end

	local mirror_chesser_entindex
	if h.my_away_mirror_chesser ~= nil and IsUnitExist(h.my_away_mirror_chesser) == true then
		mirror_chesser_entindex = h.my_away_mirror_chesser:entindex()
	end

	CustomGameEventManager:Send_ServerToAllClients("drodo_emotion",{
		id = keys.PlayerID,
		player_from = player_id,
		player_to = player_id,
		mirror_chesser_entindex = mirror_chesser_entindex,
		emotion_index = emotion_index,
		hehe = RandomFloat(1,10000),
	})
	SetEmotionCooldown(h)

	if RandomInt(1,100) <= 50 then
    	SayCheerBubble(h:GetTeam(), nil, 'emotion', 0, emotion_index)
    end
end

function IsUnitAbleToCast(u)
	if u:IsSilenced() == false and u:IsStunned() == false and u:IsFrozen() == false and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and u:IsHexed() == false and u:IsCommandRestricted() == false and u:HasModifier("modifier_axe_berserkers_call") == false then
		return true
	else
		return false
	end
end

function PangolierSwashbuckleStart(keys)
	--滚滚
	local p = keys.target_points[1]
	local caster = keys.caster
	local chessboard_id = caster.at_team_id or caster.team_id
	local ability = keys.ability
	local level = ability:GetLevel() or 1
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local attack_interval = ability:GetLevelSpecialValueFor( "attack_interval", level - 1 )
	local end_radius = ability:GetLevelSpecialValueFor( "end_radius", level - 1 )
	local strikes = ability:GetLevelSpecialValueFor( "strikes", level - 1 )

	if caster.stop_moving == true or caster:HasModifier('modifier_gungun') == true then
		return
	end

	-- 跳跃
	local target_x = Vector2X(p,chessboard_id)
	local target_y = Vector2Y(p,chessboard_id)
	local xx = caster.x
	local yy = caster.y
	caster.y_x = target_y..'_'..target_x
	caster.y = target_y
	caster.x = target_x
	GameRules:GetGameModeEntity().unit[chessboard_id][yy..'_'..xx] = nil
	GameRules:GetGameModeEntity().unit[chessboard_id][target_y..'_'..target_x] = 1
	caster.is_moving = true

	--冲刺到目标地点
	local blink_duration = BlinkChessX({
		caster = caster,
		p = p,
		blink_type = 'gungun',
	})
	if blink_duration > 0 then
		Timers:CreateTimer(blink_duration+0.1,function()
			--选一个方向，刺刺刺刺
			local di = FindGouheDirection(caster)
			if di == nil then
				local directions = {
					[1] = {x=1,y=0},
					[2] = {x=1,y=1},
					[3] = {x=1,y=-1},
					[4] = {x=-1,y=0},
					[5] = {x=-1,y=1},
					[6] = {x=-1,y=-1},
					[7] = {x=0,y=-1},
					[8] = {x=0,y=1},
				}
				local trytime = 0
				local di_random = nil
				while trytime < 100 and di == nil do
					di_random = directions[RandomInt(1,8)]
					local target_point_x = Vector2X(caster:GetAbsOrigin(),chessboard_id)
					local target_point_y = Vector2Y(caster:GetAbsOrigin(),chessboard_id)
					while IsIn8x8(target_point_x + di_random.x, target_point_y + di_random.y) == true do
						target_point_x = target_point_x + di_random.x
						target_point_y = target_point_y + di_random.y
					end
					local find_enemy = TargetCountForMorph(
						target_point_x,
						target_point_y,
						caster,
						end_radius)
					if find_enemy.count > 0 then
						di = di_random
					end
					trytime = trytime + 1
				end
			end
			if di ~= nil then
				local direction = Vector(di.x*128,di.y*128,0)
				-- 	caster:SetForwardVector(direction)
				ability.direction = direction
				ability.attack_count = 0
				ability:ApplyDataDrivenModifier(caster,caster,'modifier_pangolier_swashbuckle_attack',{ duration = 5 })
			end
		end)
	end
end

function PangolierSwashbuckleAttack(keys)
	local caster = keys.caster
	local chessboard_id = caster.at_team_id or caster.team_id
	local ability = keys.ability
	local direction = ability.direction
	local level = ability:GetLevel() or 1
	local attack_interval = ability:GetLevelSpecialValueFor( "attack_interval", level - 1 )
	local end_radius = ability:GetLevelSpecialValueFor( "end_radius", level - 1 ) or 125
	local strikes = ability:GetLevelSpecialValueFor( "strikes", level - 1 ) or 4
	local particle_cast = "particles/units/heroes/hero_pangolier/pangolier_swashbuckler.vpcf"
	local sound_cast = "Hero_Pangolier.Swashbuckle.Attack"

	local effect_cast = ParticleManager:CreateParticle( particle_cast, PATTACH_ABSORIGIN_FOLLOW, caster )
	ParticleManager:SetParticleControl( effect_cast, 1, direction*7 )
	EmitSoundOn( sound_cast, caster )
	local duration = 0.5
	-- if level >= 3 then
	-- 	duration = 3
	-- end

	Timers:CreateTimer(duration,function()
		if effect_cast ~= nil then
			ParticleManager:DestroyParticle(effect_cast,true)
		end
	end)

	local target_point = caster:GetAbsOrigin()
	while IsIn8x8(Vector2X(target_point+ direction,chessboard_id),Vector2Y(target_point+ direction,chessboard_id)) == true do
		target_point = target_point + direction
	end
	local find_enemy = TargetCountForMorph(
		Vector2X(target_point,chessboard_id),
		Vector2Y(target_point,chessboard_id),
		caster,
		end_radius)
	if find_enemy ~= nil then
		local enemies = find_enemy.all_enemy
		for _,enemy in pairs(enemies) do
			-- Attack
			caster:PerformAttack( enemy, true, true, true, false, false, false, true )

			-- play sound
			local sound_target = "Hero_Pangolier.Swashbuckle.Damage"
			EmitSoundOn( sound_target, enemy )
		end
	end

	--攻击计数，到达次数就终止
	ability.attack_count = (ability.attack_count or 0) + 1
	if ability.attack_count >= strikes then
		caster:RemoveModifierByName('modifier_pangolier_swashbuckle_attack')
	end
end



--非当前信使观战
function RandomSummonCheerCourier(team_id)
	SpawnCheerCourier(
		team_id, 
		FindAvailableCheerIndex(team_id), 
		RandomACourierFromCourierTable(team_id)
	)
end
function SummonCheerCourier(team_id, count)
	Timers:CreateTimer(0.5,function()
		if count == nil or count == 0 then
			return
		end
		RandomSummonCheerCourier(team_id)
		count = count - 1
		return 0.5
	end)
end
			


function RemoveAllCheerCourier(team_id)
	RemoveCheerCourier(team_id, nil)
end
function RemoveOndutyCourierFromCheerCourier(team_id)
	if team_id == nil or courier_name == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end

end
function SayCheerBubble(team_id, unit_index, text, delay, emotion_index)
	if team_id == nil then
		return false
	end
	if GetCheerCourierCount(team_id) < 3 and RandomInt(1,100) < 50 then
		--人数较少的观战，说话概率降为一半
		return false
	end
	Timers:CreateTimer((delay or 0), function()
		local unit = nil
		if unit_index == nil then
			unit = GetCheerCourier(team_id)
			if unit ~= nil then
				unit_index = unit:entindex()
			end
		end
		if unit_index ~= nil then
			CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
				unit_index = unit_index,
				text = 'text_cheer_'..text..'_'..RandomInt(1,10),
				player_name = TeamId2Hero(team_id).player_name,
				emotion_index = emotion_index,
			})
		end
	end)
end

function GetCheerPosition(team_id, cheer_index)
	if not cheer_index then
		cheer_index = 0
	end
	if cheer_index < 1 then
		cheer_index = 1
	end
	if cheer_index > 8 then
		cheer_index = 8
	end
	local center_vector = CenterVector(team_id)
	if cheer_index < 5 then
		--棋盘左边
		local left_line_vector = center_vector + Vector(128*(-4.5),0,0) 
		local left_index = cheer_index
		return left_line_vector + Vector(0, -128*3+left_index*128,200)
	else
		--棋盘右边
		local right_line_vector = center_vector + Vector(128*(4.5),0,0) 
		local right_index = cheer_index - 4
		return right_line_vector + Vector(0, -128*3+right_index*128,200)
	end
end

function GetCheerPetPosition(team_id, cheer_index)
	local cheer_position = GetCheerPosition(team_id, cheer_index)
	if cheer_index < 5 then
		return cheer_position + Vector(64,64,0)
	else
		return cheer_position + Vector(-64,-64,0)
	end
end

function SpawnCheerCourier(team_id, cheer_index, courier_name)
	if team_id == nil or courier_name == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end
	if cheer_index == nil or cheer_index <= 0 then
		cheer_index = FindAvailableCheerIndex(team_id)
		if cheer_index == nil or cheer_index <= 0 then
			return false
		end
	end
	local cheer_courier = CreateUnitByName("cheer_courier",GetCheerPosition(team_id, cheer_index),true,nil,nil,DOTA_TEAM_NEUTRALS)
	--设置朝向
	if cheer_index < 5 then
		cheer_courier:SetForwardVector(Vector(1,0,0))
	else
		cheer_courier:SetForwardVector(Vector(-1,0,0))
	end
	--设置模型
	local courier_id = string.split(courier_name,'_')[1]
	local courier_effect = string.split(courier_name,'_')[2] or ''
	local courier_projectile = string.split(courier_name,'_')[4] or ''
	local courier_pet = string.split(courier_name,'_')[5]
	local courier_animation = string.split(courier_name,'_')[6] or ''

	local courier_model = GameRules:GetGameModeEntity().sm_hero_list[courier_id] or 'models/props_gameplay/donkey_wings.vmdl'
	courier_model = ChangeFlyingCourierModel(courier_model)
	local courier_skin = GameRules:GetGameModeEntity().sm_hero_list_skin[courier_id] or 0
	local courier_scale = GameRules:GetGameModeEntity().sm_hero_size[courier_id] or 1
	cheer_courier:SetOriginalModel(courier_model)
	cheer_courier:SetModel(courier_model)
	cheer_courier:SetSkin(courier_skin)
	cheer_courier:SetModelScale(courier_scale*0.8)
	cheer_courier.courier_name = courier_id
	MakeGreevil(cheer_courier,true)
	
	if cheer_courier.effect ~= nil then
		cheer_courier:RemoveAbility(cheer_courier.effect)
		cheer_courier:RemoveModifierByName('modifier_texiao_star')
	end
	if courier_effect ~= nil and courier_effect ~= '' and courier_effect ~= 'e000' then
    	if string.find(GameRules:GetGameModeEntity().effect_list,courier_effect) then
			AddAbilityAndSetLevel(cheer_courier,courier_effect)
			cheer_courier.effect = courier_effect
		end
	else
		cheer_courier.courier_effect = nil
    end
    -- cheer_courier.courier_name = courier_id
    -- cheer_courier.onduty_hero = courier_id
    -- ShowCourierEffect(cheer_courier,2)

    SetCheerCourier(team_id, cheer_index, cheer_courier)
    FindClearSpaceForUnit(cheer_courier, cheer_courier:GetAbsOrigin(), true)
    -- BlinkChessX({caster=cheer_courier,blink_type="fall"})
    cheer_courier:AddNewModifier(cheer_courier,nil,"modifier_fall",{})
    if courier_pet ~= nil and courier_pet ~= '' and courier_pet ~= 'p000' then
    	Timers:CreateTimer(0.5,function()
    		SpawnCheerCourierPet(team_id, cheer_index, courier_pet, cheer_courier)
    	end)
    end

    if RandomInt(1,100) < 50 then
    	SayCheerBubble(team_id, cheer_courier:entindex(), 'hello', 1)
    end
    return cheer_index
end

function SpawnCheerCourierPet(team_id, cheer_index, pet_id, cheer_courier)
	if team_id == nil or cheer_courier == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end
	if cheer_index == nil or cheer_index <= 0 then
		return false
	end

	if pet_id ~= nil and GameRules:GetGameModeEntity().pet_list[pet_id] ~= nil then
		local my_pet = CreateUnitByName("gemtd_pet", GetCheerPetPosition(team_id, cheer_index),true,nil,nil, DOTA_TEAM_GOODGUYS)
		cheer_courier.pet_entity = my_pet
		my_pet.pet_name = pet
		AddAbilityAndSetLevel(my_pet,'no_collision')
		AddAbilityAndSetLevel(my_pet,'cheer_pet_fly')

		if pet_id == 't305' then
			PlayParticleOnUnitUntilDeath({
				caster = my_pet,
				p = "effect/bose_hand/bose.vpcf",
			})
		end

		--设置朝向
		if cheer_index < 5 then
			my_pet:SetForwardVector(Vector(1,0,0))
		else
			my_pet:SetForwardVector(Vector(-1,0,0))
		end

		--设置模型
		local onduty_pet_model = GameRules:GetGameModeEntity().pet_list[pet_id]
		local onduty_pet_skin = 0
		my_pet:SetOriginalModel(onduty_pet_model)
		my_pet:SetModel(onduty_pet_model)
		my_pet:SetSkin(onduty_pet_skin)
		my_pet:SetModelScale((GameRules:GetGameModeEntity().pet_size_list[pet_id] or 1)*0.8)
		my_pet.owner = cheer_courier
		my_pet:AddNewModifier(my_pet,nil,"modifier_fall",{})
	end
end

function InitCheerCourier(team_id)
	if team_id == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end
	hero.cheer_courier_list = {
		[1] = nil,[2] = nil,[3] = nil,[4] = nil,[5] = nil,
		[6] = nil,[7] = nil,[8] = nil,
	}
end
function SetCheerCourier(team_id, index, courier)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return
	end
	if hero.cheer_courier_list == nil then
		InitCheerCourier(team_id)
	end

	if index ~= nil and index >= 1 and index <= 8 then
		hero.cheer_courier_list[index] = courier
	else
		local available_index = FindAvailableCheerIndex(team_id)
		if available_index ~= nil and available_index > 0 then
			hero.cheer_courier_list[available_index] = courier
		else
			print('[SetCheerCourier] No available_index! team_id='..team_id)
		end
	end
end
function FindAvailableCheerIndex(team_id)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return
	end

	if hero.cheer_courier_list == nil then
		InitCheerCourier(team_id)
	end

	local try_count = 0
	local available_index = 0
	while try_count < 100 and available_index == 0 do
		local random_index = RandomInt(1,8)
		if GetCheerCourier(team_id, random_index) == nil then
			available_index = random_index
		end
		try_count = try_count + 1
	end
	return available_index
end
function GetCheerCourier(team_id, index)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.cheer_courier_list == nil then
		return
	end
	if index ~= nil and index >= 1 and index <= 8 then
		return hero.cheer_courier_list[index]
	else
		--随机一个
		local try_count = 0
		local available_index = 0
		while try_count < 100 and available_index == 0 do
			local random_index = RandomInt(1,8)
			if GetCheerCourier(team_id, random_index) ~= nil then
				available_index = random_index
			end
			try_count = try_count + 1
		end
		if available_index > 0 then
			return hero.cheer_courier_list[available_index]
		else
			return nil
		end
	end
end
function GetCheerCourierCount(team_id)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.cheer_courier_list == nil then
		return 0
	end

	local count = 0
	for i=1,8 do
		if hero.cheer_courier_list[index] ~= nil then
			count = count + 1
		end
	end
	return count
end
function RemoveCheerCourier(team_id, index)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return
	end
	if index ~= nil and index > 0 then
		--移除指定index的
		local courier = GetCheerCourier(team_id, index)
		if courier ~= nil then
			if courier.pet_entity ~= nil then
				courier.pet_entity:Destroy()
				courier.pet_entity = nil
			end
			courier:ForceKill(false)
			hero.cheer_courier_list[index] = nil
		end
	else
		--全部移除
		for i=1,10 do
			local courier = GetCheerCourier(team_id, i)
			if courier ~= nil then
				if courier.pet_entity ~= nil then
					courier.pet_entity:Destroy()
					courier.pet_entity = nil
				end
				courier:ForceKill(false)
				hero.cheer_courier_list[i] = nil
			end
		end
	end
end

function DAC:SetCourierTable(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)

	if hero == nil then
		return
	end

	if hero.courier_table == nil then
		--设置信使池，不覆盖
		hero.courier_table = string.split(keys.courier_list or '',',')
	end
	local team_id = hero:GetTeam()

	--移除当前信使
	local cheer_courier_list = hero.cheer_courier_list or {}
	for index,v in pairs(cheer_courier_list) do
		if v.courier_name == keys.onduty_courier then
			RemoveCheerCourier(team_id, index)
		end
	end
	if hero.courier_table ~= nil then
		for index,v in pairs(hero.courier_table) do
			if v == keys.onduty_courier then
				RemoveOneKeyInTable(hero.courier_table, keys.onduty_courier)
			end
		end
	end
end

function RandomACourierFromCourierTable(team_id)
	if team_id == nil then
		return nil
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.courier_table == nil or table.maxn(hero.courier_table) <= 0 then
		return nil
	end
	
	local index = RandomInt(1,table.maxn(hero.courier_table))
	local courier_name = hero.courier_table[index]
	RemoveOneKeyInTable(hero.courier_table, courier_name)
	return courier_name
end
function RemoveACourierFromCourierTable(team_id, courier_id)
	if team_id == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.courier_table == nil or table.maxn(hero.courier_table) <= 0 then
		return false
	end

	RemoveOneKeyInTable(hero.courier_table, courier_id)
	return true
end

function DAC:SetPlayerShowBuffList(keys)
	local player_id = keys.PlayerID
	SetStat(player_id,'show_buff',keys.show_buff_list,false)
end