--          啊 如此良辰美景 赋词一首
--          
--          古古咕古古古咕                                                                ........ . .......               
--          故咕咕                                                                       ....:?++?+??+.....               
--          古古咕                                                                   .  ...++++++???+??7.....             
--          古古古古                                                                 ....++?++???=:=IIII7Z.               
--          古故故咕咕                                                               ...???????I=7$D+7II77Z . .           
--          古故古咕古故故                                                          ...I+++??I7+~ZZ$+$77777Z...           
--          古古故                                                                 ..+?+????IIII+I7777I?,:,~+..          
--          故咕咕                                                                . .?????IIIII777777777III$$++.          
--          古古咕古古古咕                                                      ....I???III7I7$$$$$$$$$$ZZ?I$?7I....      
--          故咕咕                                                             ...IIIIIII777$7$$$$ZZ+.........?=...      
--          古古咕                                                             ..?I7$I777777ZZ$$ZOZ........ .......      
--          古古古古                                                           .,7$7II7777I$7$$ZO8.                      
--          古故故咕咕                                                           .$7$7I777$77$$ZZZ8O .                     
--          古故古咕古故故                                                      $7$777I77II$77$OO8...                     
--          古古故                                                         ...,777$77I777$7$$$Z88 .                      
--          估孤 故咕咕                                                     . =$7$$7$777Z$7ZZZZ888                        
--                                                                        ...7ZOZ$7777$77Z$O$ZOO$                        
--                                                                         .7$$7$7$7III$IZOOOZO87                        
--                                                                      . .$Z$$$$7$II$I$Z$ZZOO88D                        
--                                                                    . ..ZZ77I$IZ?$7ZI7$$ZOOOO8D                        
--                                                                    ...7II777$7I7I$$77$ZZOZOO8D                        
--                                                                    ..?II7III77I7II$77Z$ZZO888D                        
--                                                                .   .=?77?I??II?II777$ZZZOOO88D                        
--                                                                ....?=?==+??I7I7I77$ZZ$ZZOOO888                        
--                                                                ...====~~==+??III77$$Z$ZOOOOOO8                        
--                                                           .. ...=~~~~~~~~~~=++III$$$ZZOOOOOO88                        
--                                                           ....,~::::::~~~~~~~~:~+I7$Z$ZZOOOO88                        
--                                                           ..::::,::::::::::::~~:~~=7$ZZZZOOOO8 .                      
--                                                  .  ... .,:::::::::::::::::~~~~~====~+ZOZZOOOO..                      
--                                                       ..:,::::,:::::::::~~~~~~~~=======??ZOOOO:.                      
--                                                  .. .,::,:::::::::::::~~~~~~~=========+=+?$ZZO$.                      
--                                                 ...,,,::::::::::::::::~~~~~~~=========+=??7OZZO....                   
--                                               ...,:,,::::::::::::::::~~~~~~~~==+=======+?I7ZZZZ....                   
--                                             ...:.,,:::::::::,::::::~~~~~~===~==~~=====++?I7ZZZZ....                   
--                                         ..  .=..::,:::::,,,:::::::~~~~~~=~~====~=====++?II7OZZZ...                    
--                                       . ....:+:??,:=++:,,,::::::~~~~~~~~~~=~==~====++??II7$OZZO..                     
--                                ..   ......77IIII$,:==~?,:::::::~~~~~~~~~~~~~~====++++?I77$8ZZZZ..                     
--                                ......:=.,III~7777~~::=+,:::::::::~~~~~~~~=~~~=+=+++??II77OZ$$O~                       
--                               ....$++=,I7777:,$7777:::::::::::~~~::~:~~~~~~==+=+++??II7$OO$ZZI                        
--                      .      ..7Z7I++=~:7777?:~:77777$=:::::~:::::~~~~~~~========++??I7$ZZZ$ZO.                        
--                   .......$ZZZZ7I?++=$7II777:,,,:=$7$$$I~::::::~~~~~~=~~===++++++???I7OZ$$$ZZ..                        
--                   ..$88ZZZZ$$++?II?,,,,77$$$+::::::7Z$$$7=~~~::~~~~~~~====+=++???IIOZ$$$$$7 ..                        
--           ......O8888OZI7II7II7$I7~:::::I$Z$ZZ~:::::::7Z$Z$?~~~~~~=~====+==+?+??IZZ$$$7$$~                            
--            .O88888ZI77II7I7I777$77$~:::::7ZOZZZ=~::~~~:~$ZZ$$ZZ+======++++??IIIZZ$7$$$$$..                            
--            8OOZ7I7$777I7I77$77?I77$I=:::::ZZO$OZ~=~~~~~~~+ZZZZZOOZZI++??7II77Z$7$$7$$Z....                            
--     .......?777I$7II7III7I7I77$$IIIII7$I+===?I7$7I?=~~~~~~~==ZOOZZOI???I$$$77777$$$Z.                                 
--     ....$$$$$$77$77777I777III777777$777777777$ZZZ$$7+======+=++??I77??II?III7$$Z$?..,                                 
--     .,7$$Z$7$$$$7$7$77777I??I?7I7I777IIIII7IIIII??+??I??+++?II++?++????III77$$Z ..                                    
--  ..II7ZZZZZ$7??+?I7+~==I77$$$$7$ZZ77IZ7$Z7777$$$77II???++==~~=+==++???II77ZO.                                         
-- ...?ZZZ$ZZ$$Z=............................7$7IIII??++=+====~~==++++??I7$O:  .                                         
--  ......... ....................   .        . $I??+++?========+++???I7Z. ..                                            
--                                                . :II?+~=+=++++?+?7Z .                                                 
--                                                  .....+===++++II?..                                                   
--                                                  .....:~~~==+I$.. .                                                   
--                                                    . .~~~==+I$$O.. .....                                              
--                                                      ..~~==+7$ZO8...   ..                                             
--                                                      ...:~~=$$$$OOZ7ZOD8~  . .                                        
--                                                      ....~~=~7I77OZ$Z8~..........                                     
--                                                      ..$,~+?+?Z$ZII$DZ8Z7II+?$Z..                                     
--                                                       ...+==I+$=.7II??7..........                                     
--                                                       ....=+++ZI......I=      ...                                     
--                                                      ..?~=~~+:=~$,..?II~                                              
--                                                        . ...I=~=??+$$O~..........                                     
--                                                           ....+~+?I?+,:++:==.....                                     
--                                                           ......+:~=~.~+IIII+....                                     
--                                                                   .=:+..                                              
--                                                                  ..+~...                                              

if DAC == nil then
	DAC = class({})
end

if __debug_trace_back_original__ == nil then
	__debug_trace_back_original__ = debug.traceback 
end
debug.traceback = function(thread, message, level)
	local trace
	if thread == nil and message == nil and level == nil then
		trace = __debug_trace_back_original__()
	else
		trace = __debug_trace_back_original__(thread, message, level)
	end
	if thread ~= nil then
		local e = tostring(thread)
		print(e)
		local err_encode = require('libs/base64').encode(e)

		if _G.error_trace[err_encode] == nil then
			_G.error_trace[err_encode] = e
			local url = "http://autochess.ppbizon.com/error/catch?&err="..err_encode..'&game=autochess&round='..(_G.battle_round or 0)..GetSendKey()
			CreateHTTPRequestScriptVM("GET", url):Send(function (result) end)
		end
	end

	return trace
end

require('libs/amhc_library/amhc')
require('libs/Timers')
require('libs/Physics')
require('libs/util')
require('libs/barebones')
require('libs/wearable')
require('pathfinder/core/heuristics')
require('pathfinder/core/node')
require('pathfinder/core/path')
require('pathfinder/grid')
require('pathfinder/pathfinder')
require('pathfinder/core/bheap')
require('pathfinder/search/astar')
require('pathfinder/search/bfs')
require('pathfinder/search/dfs')
require('pathfinder/search/dijkstra')
require('pathfinder/search/jps')
require("libs/animations")
require('libs/aeslua')
local base64 = require('libs/base64')
local sha2 = require('libs/sha2')
local LibDeflate = require("libs/LibDeflate")
local Grid = require ("pathfinder/grid") -- The grid class
local Pathfinder = require ("pathfinder/pathfinder") -- The pathfinder lass
require("libraries/animations")

LinkLuaModifier("modifier_jump", "lua_modifier/jump.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_run", "lua_modifier/run.lua", LUA_MODIFIER_MOTION_HORIZONTAL)
LinkLuaModifier("modifier_elfrun", "lua_modifier/elfrun.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_windwalk", "lua_modifier/windwalk.lua", LUA_MODIFIER_MOTION_HORIZONTAL)
LinkLuaModifier("modifier_walk", "lua_modifier/walk.lua", LUA_MODIFIER_MOTION_HORIZONTAL)
LinkLuaModifier("modifier_tuitui", "lua_modifier/tuitui.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_toss", "lua_modifier/toss.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_fall", "lua_modifier/fall.lua", LUA_MODIFIER_MOTION_VERTICAL)
LinkLuaModifier("modifier_breaksoil", "lua_modifier/breaksoil.lua", LUA_MODIFIER_MOTION_VERTICAL)
LinkLuaModifier("modifier_teleport", "lua_modifier/teleport.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_spawn", "lua_modifier/spawn.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_ready", "lua_modifier/ready.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_torrent", "lua_modifier/torrent.lua", LUA_MODIFIER_MOTION_BOTH)
LinkLuaModifier("modifier_gungun", "lua_modifier/gungun.lua", LUA_MODIFIER_MOTION_HORIZONTAL)
LinkLuaModifier("modifier_hook", "lua_modifier/hook.lua", LUA_MODIFIER_MOTION_BOTH)

function Precache( context )
    print("Precache...")
    local precache_list = require("precache")
	for _, precache_item in pairs(precache_list) do
		--预载precache.lua里的资源
		if string.find(precache_item, ".vpcf") then
			-- print('[precache]'..precache_item)
			PrecacheResource( "particle",  precache_item, context)
		end
		if string.find(precache_item, ".vmdl") then 	
			-- print('[precache]'..precache_item)
			PrecacheResource( "model",  precache_item, context)
		end
		if string.find(precache_item, ".vsndevts") then
			-- print('[precache]'..precache_item)
			PrecacheResource( "soundfile",  precache_item, context)
		end
		if string.find(precache_item, ".v") == false then
			-- print('[precache]'..precache_item)
			PrecacheResource( "particle_folder",  precache_item, context)
		end
    end
    --预载入
    local chess_mana_1 = {'chess_luna','chess_cm','chess_tusk','chess_axe','chess_eh','chess_clock','chess_ss','chess_bh','chess_dr','chess_tk','chess_am','chess_tiny','chess_mars','chess_ww','chess_wd','chess_sb','chess_dw','chess_oracle','chess_vs','chess_dazzle','chess_ember','chess_storm','chess_earth','chess_void','chess_io'} --,,"chess_pb",'chess_db','chess_ts'
    for k,v in pairs(chess_mana_1) do
    	if v ~= nil then
    		PrecacheUnitByNameSync(v, context)
    	end
    end

	--预载入物品
	-- local items_kv = LoadKeyValues("scripts/npc/npc_items_custom.txt")
	-- for k, v in pairs(items_kv) do
	-- 	if k ~= "Version" then
	-- 		PrecacheItemByNameSync(k, context)
	-- 	end
	-- end
	--预载入技能里的precache
	-- local abilities_kv = LoadKeyValues("scripts/npc/npc_abilities_custom.txt")
	-- for k, v in pairs(KeyValues.AbilitiesKv) do
	-- 	if k ~= "Version" then
	-- 		if v.precache then
	-- 			for sPrecacheMode, sResource in pairs(v.precache) do
	-- 				PrecacheResource(sPrecacheMode, sResource, context)
	-- 			end
	-- 		end
	-- 	end
	-- end

    print("Precache OK")
end

function Activate()
	_G.AddonTemplate = DAC()
	_G.AddonTemplate:InitGameMode()
end

--【游戏流程】
--1、初始化变量和监听
function DAC:InitGameMode()
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_GOODGUYS, 0 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_BADGUYS, 0 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_1, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_2, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_3, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_4, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_5, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_6, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_7, 1 )
	GameRules:SetCustomGameTeamMaxPlayers( DOTA_TEAM_CUSTOM_8, 1 )
	if GetCurrMapInfo().has_ob == true then
		GameRules:SetCustomGameTeamMaxPlayers( 1, 5) --OB位
	end
	GameRules:SetTreeRegrowTime(60)
	GameRules:GetGameModeEntity():SetCustomBackpackSwapCooldown(0)
	GameRules:GetGameModeEntity():SetPauseEnabled(false)
    GameRules:GetGameModeEntity():SetFogOfWarDisabled(false)
    GameRules:GetGameModeEntity():SetUnseenFogOfWarEnabled(false)
    GameRules:GetGameModeEntity():SetBuybackEnabled(false)
	GameRules:GetGameModeEntity():SetDamageFilter(Dynamic_Wrap(DAC, "DamageFilter"), DAC)
	GameRules:GetGameModeEntity():SetHealingFilter(Dynamic_Wrap(DAC, "HealingFilter"), DAC)
	GameRules:GetGameModeEntity():SetExecuteOrderFilter(Dynamic_Wrap(DAC, 'ExecuteOrderFilter'), DAC )
	GameRules:GetGameModeEntity():SetItemAddedToInventoryFilter( Dynamic_Wrap( DAC, "ItemAddedToInventoryFilter" ), DAC )
	GameRules:GetGameModeEntity():SetModifierGainedFilter( Dynamic_Wrap( DAC, "ModifierGainedFilter" ), DAC )
	GameRules:GetGameModeEntity():SetUseCustomHeroLevels(true)
	GameRules:GetGameModeEntity():SetCustomHeroMaxLevel(16)
	GameRules:GetGameModeEntity():DisableHudFlip(true)
	GameRules:GetGameModeEntity():SetSendToStashEnabled(false)
	
	SetTeamCustomHealthbarColor(DOTA_TEAM_NEUTRALS, 255,0,0)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_1, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_2, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_3, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_4, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_5, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_6, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_7, 128,255,128)
	SetTeamCustomHealthbarColor(DOTA_TEAM_CUSTOM_8, 128,255,128)

	ListenToGameEvent("player_connect_full", Dynamic_Wrap(DAC,"OnPlayerConnectFull" ),self)

	-- ListenToGameEvent("dota_player_spawned", Dynamic_Wrap(DAC,"OnPlayerConnectFull" ),self)
    ListenToGameEvent("player_disconnect", Dynamic_Wrap(DAC, "OnPlayerDisconnect"), self)
	ListenToGameEvent("player_reconnected", Dynamic_Wrap(DAC, "OnPlayerReconnected"), self)
    ListenToGameEvent("player_chat",Dynamic_Wrap(DAC,"OnPlayerChat"),self)
    ListenToGameEvent("dota_player_pick_hero",Dynamic_Wrap(DAC,"OnPlayerPickHero"),self)
    ListenToGameEvent("entity_killed", Dynamic_Wrap(DAC, "OnEntityKilled"), self)
    ListenToGameEvent("dota_player_gained_level", Dynamic_Wrap(DAC,"OnPlayerGainedLevel"), self)

    CustomGameEventManager:RegisterListener("request_buy_chess", Dynamic_Wrap(DAC, "OnRequestBuyChess") )
    CustomGameEventManager:RegisterListener("pick_chess_position", Dynamic_Wrap(DAC, "OnPickChessPosition") )
    CustomGameEventManager:RegisterListener("cancel_pick_chess_position", Dynamic_Wrap(DAC, "OnCancelPickChessPosition") )
    CustomGameEventManager:RegisterListener("dac_refresh_chess", Dynamic_Wrap(DAC, "OnRefreshChess") )
    CustomGameEventManager:RegisterListener("dac_report", Dynamic_Wrap(DAC, "OnReport") )
    CustomGameEventManager:RegisterListener("catch_crab", Dynamic_Wrap(DAC, "OnCatchCrab") )
    CustomGameEventManager:RegisterListener("unlock_chess", Dynamic_Wrap(DAC, "OnUnlockChess") )
    CustomGameEventManager:RegisterListener("lock_chess", Dynamic_Wrap(DAC, "OnLockChess") )
    CustomGameEventManager:RegisterListener("change_onduty_hero", Dynamic_Wrap(DAC, "OnChangeOndutyHero") )
    CustomGameEventManager:RegisterListener("preview_effect", Dynamic_Wrap(DAC, "OnPreviewEffect") )
    CustomGameEventManager:RegisterListener("preview_projectile", Dynamic_Wrap(DAC, "OnPreviewProjectile") )
    CustomGameEventManager:RegisterListener("suggest_liuju", Dynamic_Wrap(DAC, "OnSuggestLiuju") )
    CustomGameEventManager:RegisterListener("set_auto_combine", Dynamic_Wrap(DAC, "OnSetAutoCombine") )
    CustomGameEventManager:RegisterListener("select_difficulty", Dynamic_Wrap(DAC, "OnSelectDifficulty") )
    CustomGameEventManager:RegisterListener("request_pause_game", Dynamic_Wrap(DAC, "OnPauseGame") )
    CustomGameEventManager:RegisterListener("request_select_chess", Dynamic_Wrap(DAC, "OnRequestSelectChess") )
    CustomGameEventManager:RegisterListener("user_settings_update", Dynamic_Wrap(DAC, "OnUpdateUserSettings") )
    CustomGameEventManager:RegisterListener("request_choose_loot", Dynamic_Wrap(DAC, "OnRequestChooseLoot") )
    CustomGameEventManager:RegisterListener("choose_badge", Dynamic_Wrap(DAC, "OnChooseBadge") )
    CustomGameEventManager:RegisterListener("choose_chessboard", Dynamic_Wrap(DAC, "OnChooseChessboard") )
    CustomGameEventManager:RegisterListener("choose_courier", Dynamic_Wrap(DAC, "OnChooseCourier") )
    CustomGameEventManager:RegisterListener("update_mmr_level", Dynamic_Wrap(DAC, "OnUpdateMMRLevel") )
    CustomGameEventManager:RegisterListener("show_game_notice", Dynamic_Wrap(DAC, "OnShowGameNotice") )
    CustomGameEventManager:RegisterListener("player_language", Dynamic_Wrap(DAC, "OnPlayerLanguage") )
    CustomGameEventManager:RegisterListener("request_ban_chess", Dynamic_Wrap(DAC, "OnBanChess") )
    CustomGameEventManager:RegisterListener("request_unban_chess", Dynamic_Wrap(DAC, "OnUnBanSynergy") )
    CustomGameEventManager:RegisterListener("reset_fow", Dynamic_Wrap(DAC, "ResetFOW") )
    CustomGameEventManager:RegisterListener("request_show_emotion_bubble", Dynamic_Wrap(DAC, "RequestShowEmotionBubble") )
    CustomGameEventManager:RegisterListener("set_courier_table", Dynamic_Wrap(DAC, "SetCourierTable") )
    CustomGameEventManager:RegisterListener("set_player_show_buff_list", Dynamic_Wrap(DAC, "SetPlayerShowBuffList") )
    CustomGameEventManager:RegisterListener("request_find_combinable_item", Dynamic_Wrap(DAC, "RequestFindCombinableItem") )
    CustomGameEventManager:RegisterListener("request_combine_item", Dynamic_Wrap(DAC, "RequestCombineItem") )
	CustomGameEventManager:RegisterListener("gg_simida", Dynamic_Wrap(DAC, "GGSimida") )
	CustomGameEventManager:RegisterListener("courier_tp", Dynamic_Wrap(DAC, "OnCourierTP") )
	CustomGameEventManager:RegisterListener("request_update_user_info", Dynamic_Wrap(DAC, "GetAllPlayerInfoFromServer") )
	CustomGameEventManager:RegisterListener("request_show_config", Dynamic_Wrap(DAC, "RequestShowConfig") )
	CustomGameEventManager:RegisterListener("request_export_lineup", Dynamic_Wrap(DAC, "RequestExportLineup") )
	CustomGameEventManager:RegisterListener("request_import_lineup", Dynamic_Wrap(DAC, "RequestImportLineup") )
	CustomGameEventManager:RegisterListener("tester_box_start_battle", Dynamic_Wrap(DAC, "OnTesterBoxStartBattle") )
	CustomGameEventManager:RegisterListener("tester_box_choose_round", Dynamic_Wrap(DAC, "OnTesterBoxChooseRound") )
	CustomGameEventManager:RegisterListener("tester_box_give_money", Dynamic_Wrap(DAC, "OnTesterBoxGiveMoney") )
	CustomGameEventManager:RegisterListener("tester_box_give_exp", Dynamic_Wrap(DAC, "OnTesterBoxGiveExp") )
	CustomGameEventManager:RegisterListener("tester_box_show_damage", Dynamic_Wrap(DAC, "OnTesterBoxShowDamage") )
	CustomGameEventManager:RegisterListener("tester_box_show_grid", Dynamic_Wrap(DAC, "OnTesterBoxShowGrid") )
	CustomGameEventManager:RegisterListener("tester_box_give_chess", Dynamic_Wrap(DAC, "OnTesterBoxGiveChess") )
	CustomGameEventManager:RegisterListener("tester_box_give_item", Dynamic_Wrap(DAC, "OnTesterBoxGiveItem") )
	CustomGameEventManager:RegisterListener("request_select_handchess", Dynamic_Wrap(DAC, "OnRequestSelectHandChess") )

	_G.error_trace = {}
	_G.dotamind_ticket = ''
	_G.playing_player_count = 0
	_G.obing_player_count = 0
	_G.bans = ''
	_G.relics = ''
	_G.restore_check = false
	_G.p2_win_sent = false
	_G.p2_win_settle = false
	_G.p2_death_table = {}
	_G.p2_mode = false
	_G.user_md5_table = {}
	_G.lastrandomn_team = nil
	_G.lastalive_team = nil
	if IsInToolsMode() == true then
		_G.custom_round_time = 999
	end
	_G.request_all_user_info_from_server = false
	_G.is_tester_mode = false
	-- _G.center_index = ''..Entities:FindByName(nil,"center0"):entindex()..','..Entities:FindByName(nil,"center1"):entindex()..','..Entities:FindByName(nil,"center2"):entindex()..','..Entities:FindByName(nil,"center3"):entindex()..','..Entities:FindByName(nil,"center4"):entindex()..','..Entities:FindByName(nil,"center5"):entindex()..','..Entities:FindByName(nil,"center6"):entindex()..','..Entities:FindByName(nil,"center7"):entindex()
	_G.quest_init = {
		q001 = false,--rank_1x8
		q002 = false,--rank_2x4
		q003 = false,--$5 level2
		q004 = false,--$4 level3
		q005 = false,--rampage
		q006 = false,--round 35
		q007 = false,--100 gold
		q008 = true,--<=20 gold
		q009 = false,--win >=10 chess
		q010 = true,--hp 100 15 round
		q011 = false,--$1 level3 x4
		q012 = false,--win streak 10
		q013 = false,--10 pieces
		q014 = false,--a >=6 synergy
		q015 = false,-->=3 synergies
		q016 = false,--d>10000
		q017 = true,--defeat neutrals
		q018 = false,--transfer >=5 pieces
		q019 = false,--love effect
		q020 = false,--150 damage
		q021 = false,--terminate 10x strike
		q022 = false,--t5 items
		q023 = false,--400 gold
		q024 = false,--h1xx
		q025 = false,--h2xx
		q026 = false,--h3xx
		q027 = false,--h4xx
		q028 = false,--ban >=15 gold
		q029 = false,--3x$5
		q030 = false,--apple
		q031 = false,--$5 interest
		q032 = false,--t4 items
		-- relic quest
		q033 = false,
		q034 = false,
		q035 = false,
		q036 = false,
		q037 = false,
		q038 = false,
		q039 = false,
		q040 = false,
		q041 = false,
		q042 = false,
		q043 = false,
		q044 = false,
		q045 = false,
		q046 = false,
		q047 = false,
	}
	_G.player_id_table = {}
	_G.level3pieces = {
		[6] = 0,
		[7] = 0,
		[8] = 0,
		[9] = 0,
		[10] = 0,
		[11] = 0,
		[12] = 0,
		[13] = 0,
	}
	_G.quest_status = {
		[6] = -1,
		[7] = -1,
		[8] = -1,
		[9] = -1,
		[10] = -1,
		[11] = -1,
		[12] = -1,
		[13] = -1,
	}
	_G.quest_14_buff_list = {
		is_troll = 6,
		is_elf = 9,
		is_human = 6,
		is_undead = 6,
		is_goblin = 6,
		is_warrior = 9,
		is_mage = 9,
		is_warlock = 6,
		is_mech = 6,
		is_assassin = 9,
		is_hunter = 9,
		is_knight = 6,
		is_beast = 6,
		is_orc = 6,
	}
	_G.p2_match = {
		[2] = {
			{1,-1},
		},
		[3] = {
			{1,1,-2},
			{2,-1,-1},
		},
		[4] = {
			{1,-1,1,-1},
			{1,1,1,-3},
			{1,2,-2,-1},
			{2,-1,1,-2},
			{2,2,-2,-2},
			{2,2,-1,-3},
			{3,-1,-1,-1},
			{3,1,-2,-2},
			{3,1,-1,-3},
		},
	}
	_G.p2_battle = {
		[1] = -1,
		[2] = -1,
		[3] = -1,
		[4] = -1,
	}
	_G.p2_player = {
		[1] = {},
		[2] = {},
		[3] = {},
		[4] = {},
	}
	_G.team_color = {
		[4] = {r=255,g=0,b=0},
		[6] = {r=0,g=46,b=197},
		[7] = {r=128,g=128,b=128},
		[8] = {r=255,g=255,b=192},
		[9] = {r=255,g=192,b=64},
		[10] = {r=17,g=232,b=234},
		[11] = {r=255,g=100,b=200},
		[12] = {r=255,g=156,b=156},
		[13] = {r=255,g=0,b=255},
	}
	_G.setwin = nil
	_G.big_damage = 1
	_G.alive_player_table = {}
	_G.current_round = {}
	_G.last_round = {}
	_G.last_2nd_round = {}
	_G.last_3rd_round = {}
	_G.battle_round_type = 'pve'
    _G.battle_round = 1
    _G.pilao_round = 50
    _G.difficulty = 2
    _G.steamidlist = ''
    _G.steamidlist_heroindex = ''
    _G.steamid2playerid = {}
    _G.teamid2playerid = {}
    _G.playerid2steamid = {}
    _G.steamid2name = {}
    _G.stat_info = {}
    _G.send_info = {}
    _G.send_status = {}
    _G.show_damage = false
    _G.upload_lineup = {}
    _G.upload_detail_stat = {}
	_G.is_show_grid = {
		[6] = -1,
		[7] = -1,
		[8] = -1,
		[9] = -1,
		[10] = -1,
		[11] = -1,
		[12] = -1,
		[13] = -1,
	}
    _G.connect_state = {
	    [0] = false,
	    [1] = false,
	    [2] = false,
	    [3] = false,
	    [4] = false,
	    [5] = false,
	    [6] = false,
	    [7] = false,
	}
    _G.battle_boss = {
	    [1] = {  --天辉卫士
	    	[1] = {x=4,y=8,enemy='pve_melee_good'}, 
	    	[2] = {x=5,y=8,enemy='pve_melee_good'},
		},
		[2] = {  --天辉中军
	    	[1] = {x=4,y=6,enemy='pve_melee_good_mega'},
	    	[2] = {x=5,y=8,enemy='pve_ranged_good'},
	    	[3] = {x=3,y=8,enemy='pve_ranged_good'},
		},
		[3] = {  --天辉统帅
	    	[1] = {x=4,y=6,enemy='pve_melee_good_mega'},
	    	[2] = {x=5,y=6,enemy='pve_melee_good_mega'},
	    	[3] = {x=4,y=8,enemy='pve_ranged_good'},
	    	[4] = {x=5,y=8,enemy='pve_ranged_good'},
	    	[5] = {x=3,y=7,enemy='pve_melee_good'},
	    	[6] = {x=6,y=7,enemy='pve_melee_good'},
		},
		-- [1] = {  --夜魇卫士
	 --    	[1] = {x=4,y=8,enemy='pve_melee_bad_diretide'}, 
	 --    	[2] = {x=5,y=8,enemy='pve_melee_bad_diretide'},
		-- },
		-- [2] = {  --夜魇中军
	 --    	[1] = {x=4,y=6,enemy='pve_melee_bad_mega_diretide'},
	 --    	[2] = {x=5,y=8,enemy='pve_ranged_bad_diretide'},
	 --    	[3] = {x=3,y=8,enemy='pve_ranged_bad_diretide'},
		-- },
		-- [3] = {  --夜魇统帅
	 --    	[1] = {x=4,y=6,enemy='pve_melee_bad_mega_diretide'},
	 --    	[2] = {x=5,y=6,enemy='pve_melee_bad_mega_diretide'},
	 --    	[3] = {x=4,y=8,enemy='pve_ranged_bad_diretide'},
	 --    	[4] = {x=5,y=8,enemy='pve_ranged_bad_diretide'},
	 --    	[5] = {x=3,y=7,enemy='pve_melee_bad_diretide'},
	 --    	[6] = {x=6,y=7,enemy='pve_melee_bad_diretide'},
		-- },
		[10] = {  --岩石傀儡
			[1] = {x=4,y=6,enemy='pve_stone_a'},
	    	[2] = {x=2,y=7,enemy='pve_stone_b'},
	    	[3] = {x=6,y=7,enemy='pve_stone_b'},
		},
		[15] = {  --群狼
			[1] = {x=4,y=6,enemy='pve_wolf_big'},
			[2] = {x=5,y=8,enemy='pve_wolf_small_a'},
	    	[3] = {x=3,y=8,enemy='pve_wolf_small_a'},
	    	[4] = {x=2,y=7,enemy='pve_wolf_small_b'},
	    	[5] = {x=6,y=7,enemy='pve_wolf_small_b'},
		},
		[20] = {  --夺命双熊
			[1] = {x=4,y=6,enemy='pve_bear_a'},
	    	[2] = {x=2,y=7,enemy='pve_bear_b'},
		},
		[25] = {  --愤怒的枭兽
			[1] = {x=2,y=7,enemy='pve_vulture_a'},
			[2] = {x=7,y=7,enemy='pve_vulture_b'},
		},
		-- [30] = {  --雷隐兽
		-- 	[1] = {x=4,y=6,enemy='pve_leishou_a'},
		-- 	[2] = {x=3,y=7,enemy='pve_leishou_b'},
		-- 	[3] = {x=5,y=7,enemy='pve_leishou_b'},
		-- },
		[30] = {  --松果
			[1] = {x=4,y=6,enemy='pve_pine_cone'},
			[2] = {x=3,y=7,enemy='pve_pine_cone'},
			[3] = {x=5,y=7,enemy='pve_pine_cone'},
		},

		-- [35] = {  --黑龙王
		-- 	[1] = {x=4,y=5,enemy='pve_black_dragon'},
		-- },
		-- [35] = {  --千娇魔女
		-- 	[1] = {x=4,y=5,enemy='pve_qianjiaomonv'},
		-- },
		[35] = {  --黑龙王
			[1] = {x=4,y=5,enemy='pve_black_dragon'},
		},
		-- [35] = {  --千娇魔女
		-- 	[1] = {x=4,y=5,enemy='pve_qianjiaomonv'},
		-- },
		[40] = {  --巨魔部落
			[1] = {x=3,y=6,enemy='pve_troll_dark_a'},
			[2] = {x=4,y=6,enemy='pve_troll_dark_a'},
			[3] = {x=5,y=6,enemy='pve_troll_dark_a'},
			[4] = {x=6,y=6,enemy='pve_troll_dark_a'},
			[5] = {x=3,y=8,enemy='pve_troll_dark_b'},
			[6] = {x=6,y=8,enemy='pve_troll_dark_c'},
		},
		[45] = {  --年兽
			[1] = {x=4,y=7,enemy='pve_nian'},
		},
		-- [50] = {  --肉山大魔王
		-- 	[1] = {x=4,y=7,enemy='pve_tangyimaowang'},
		-- },
		[50] = {  --肉山大魔王
			[1] = {x=4,y=7,enemy='pve_roshan'},
		},
		[100] = {  --for test
			[1] = {x=1,y=6,enemy='dummy'},
			[2] = {x=2,y=6,enemy='dummy'},
			[3] = {x=3,y=6,enemy='dummy'},
			[4] = {x=4,y=6,enemy='dummy'},
			[5] = {x=5,y=6,enemy='dummy'},
			[6] = {x=6,y=6,enemy='dummy'},
			[7] = {x=7,y=6,enemy='dummy'},
			[8] = {x=8,y=6,enemy='dummy'},
		},
		[101] = {  --for test
		},
		[555] = {  --for test
			[1] = {x=1,y=5,enemy='chess_dr1'},
			[2] = {x=2,y=5,enemy='chess_dr1'},
			[3] = {x=3,y=5,enemy='chess_dr1'},
			[4] = {x=4,y=5,enemy='chess_dr1'},
			[5] = {x=5,y=5,enemy='chess_dr1'},
			[6] = {x=6,y=5,enemy='chess_dr1'},
			[7] = {x=7,y=5,enemy='chess_dr1'},
			[8] = {x=8,y=5,enemy='chess_dr1'},
			[9] = {x=1,y=6,enemy='chess_dr1'},
			[10] = {x=2,y=6,enemy='chess_dr1'},
			[11] = {x=3,y=6,enemy='chess_dr1'},
			[12] = {x=4,y=6,enemy='chess_dr1'},
			[13] = {x=5,y=6,enemy='chess_dr1'},
			[14] = {x=6,y=6,enemy='chess_dr1'},
			[15] = {x=7,y=6,enemy='chess_dr1'},
			[16] = {x=8,y=6,enemy='chess_dr1'},
			[17] = {x=1,y=7,enemy='chess_dr1'},
			[18] = {x=2,y=7,enemy='chess_dr1'},
			[19] = {x=3,y=7,enemy='chess_dr1'},
			[20] = {x=4,y=7,enemy='chess_dr1'},
			[21] = {x=5,y=7,enemy='chess_dr1'},
			[22] = {x=6,y=7,enemy='chess_dr1'},
			[23] = {x=7,y=7,enemy='chess_dr1'},
			[24] = {x=8,y=7,enemy='chess_dr1'},
			[25] = {x=1,y=8,enemy='chess_dr1'},
			[26] = {x=2,y=8,enemy='chess_dr1'},
			[27] = {x=3,y=8,enemy='chess_dr1'},
			[28] = {x=4,y=8,enemy='chess_dr1'},
			[29] = {x=5,y=8,enemy='chess_dr1'},
			[30] = {x=6,y=8,enemy='chess_dr1'},
			[31] = {x=7,y=8,enemy='chess_dr1'},
			[32] = {x=8,y=8,enemy='chess_dr1'},
		},
		[556] = {  --for test
			[1] = {x=1,y=5,enemy='chess_mars'},
			[2] = {x=2,y=5,enemy='chess_mars'},
			[3] = {x=3,y=5,enemy='chess_mars'},
			[4] = {x=4,y=5,enemy='chess_mars'},
			[5] = {x=5,y=5,enemy='chess_mars'},
			[6] = {x=6,y=5,enemy='chess_mars'},
			[7] = {x=7,y=5,enemy='chess_mars'},
			[8] = {x=8,y=5,enemy='chess_mars'},
			[9] = {x=1,y=6,enemy='chess_mars'},
			[10] = {x=2,y=6,enemy='chess_mars'},
			[11] = {x=3,y=6,enemy='chess_mars'},
			[12] = {x=4,y=6,enemy='chess_mars'},
			[13] = {x=5,y=6,enemy='chess_mars'},
			[14] = {x=6,y=6,enemy='chess_mars'},
			[15] = {x=7,y=6,enemy='chess_mars'},
			[16] = {x=8,y=6,enemy='chess_mars'},
			[17] = {x=1,y=7,enemy='chess_mars'},
			[18] = {x=2,y=7,enemy='chess_mars'},
			[19] = {x=3,y=7,enemy='chess_mars'},
			[20] = {x=4,y=7,enemy='chess_mars'},
			[21] = {x=5,y=7,enemy='chess_mars'},
			[22] = {x=6,y=7,enemy='chess_mars'},
			[23] = {x=7,y=7,enemy='chess_mars'},
			[24] = {x=8,y=7,enemy='chess_mars'},
			[25] = {x=1,y=8,enemy='chess_mars'},
			[26] = {x=2,y=8,enemy='chess_mars'},
			[27] = {x=3,y=8,enemy='chess_mars'},
			[28] = {x=4,y=8,enemy='chess_mars'},
			[29] = {x=5,y=8,enemy='chess_mars'},
			[30] = {x=6,y=8,enemy='chess_mars'},
			[31] = {x=7,y=8,enemy='chess_mars'},
			[32] = {x=8,y=8,enemy='chess_mars'},
		},
		[558] = {  --for test
			[1] = {x=1,y=5,enemy='veno_ward3'},
			[2] = {x=2,y=5,enemy='veno_ward3'},
			[3] = {x=3,y=5,enemy='veno_ward3'},
			[4] = {x=4,y=5,enemy='veno_ward3'},
			[5] = {x=5,y=5,enemy='veno_ward3'},
			[6] = {x=6,y=5,enemy='veno_ward3'},
			[7] = {x=7,y=5,enemy='veno_ward3'},
			[8] = {x=8,y=5,enemy='veno_ward3'},
			[9] = {x=1,y=6,enemy='veno_ward3'},
			[10] = {x=2,y=6,enemy='veno_ward3'},
			[11] = {x=3,y=6,enemy='veno_ward3'},
			[12] = {x=4,y=6,enemy='veno_ward3'},
			[13] = {x=5,y=6,enemy='veno_ward3'},
			[14] = {x=6,y=6,enemy='veno_ward3'},
			[15] = {x=7,y=6,enemy='veno_ward3'},
			[16] = {x=8,y=6,enemy='veno_ward3'},
			[17] = {x=1,y=7,enemy='veno_ward3'},
			[18] = {x=2,y=7,enemy='veno_ward3'},
			[19] = {x=3,y=7,enemy='veno_ward3'},
			[20] = {x=4,y=7,enemy='veno_ward3'},
			[21] = {x=5,y=7,enemy='veno_ward3'},
			[22] = {x=6,y=7,enemy='veno_ward3'},
			[23] = {x=7,y=7,enemy='veno_ward3'},
			[24] = {x=8,y=7,enemy='veno_ward3'},
			[25] = {x=1,y=8,enemy='veno_ward3'},
			[26] = {x=2,y=8,enemy='veno_ward3'},
			[27] = {x=3,y=8,enemy='veno_ward3'},
			[28] = {x=4,y=8,enemy='veno_ward3'},
			[29] = {x=5,y=8,enemy='veno_ward3'},
			[30] = {x=6,y=8,enemy='veno_ward3'},
			[31] = {x=7,y=8,enemy='veno_ward3'},
			[32] = {x=8,y=8,enemy='veno_ward3'},
		},
		[557] = {  --for test
			[1] = {x=1,y=5,enemy='pve_leishou_a'},
			[2] = {x=2,y=5,enemy='pve_leishou_a'},
			[3] = {x=3,y=5,enemy='pve_leishou_a'},
			[4] = {x=4,y=5,enemy='pve_leishou_a'},
			[5] = {x=5,y=5,enemy='pve_leishou_a'},
			[6] = {x=6,y=5,enemy='pve_leishou_a'},
			[7] = {x=7,y=5,enemy='pve_leishou_a'},
			[8] = {x=8,y=5,enemy='pve_leishou_a'},
			[9] = {x=1,y=6,enemy='pve_leishou_b'},
			[10] = {x=2,y=6,enemy='pve_leishou_b'},
			[11] = {x=3,y=6,enemy='pve_leishou_b'},
			[12] = {x=4,y=6,enemy='pve_leishou_b'},
			[13] = {x=5,y=6,enemy='pve_leishou_b'},
			[14] = {x=6,y=6,enemy='pve_leishou_b'},
			[15] = {x=7,y=6,enemy='pve_leishou_b'},
			[16] = {x=8,y=6,enemy='pve_leishou_b'},
			[17] = {x=1,y=7,enemy='pve_leishou_b'},
			[18] = {x=2,y=7,enemy='pve_leishou_b'},
			[19] = {x=3,y=7,enemy='pve_leishou_b'},
			[20] = {x=4,y=7,enemy='pve_leishou_b'},
			[21] = {x=5,y=7,enemy='pve_leishou_b'},
			[22] = {x=6,y=7,enemy='pve_leishou_b'},
			[23] = {x=7,y=7,enemy='pve_leishou_b'},
			[24] = {x=8,y=7,enemy='pve_leishou_b'},
			[25] = {x=1,y=8,enemy='pve_leishou_b'},
			[26] = {x=2,y=8,enemy='pve_leishou_b'},
			[27] = {x=3,y=8,enemy='pve_leishou_b'},
			[28] = {x=4,y=8,enemy='pve_leishou_b'},
			[29] = {x=5,y=8,enemy='pve_leishou_b'},
			[30] = {x=6,y=8,enemy='pve_leishou_b'},
			[31] = {x=7,y=8,enemy='pve_leishou_b'},
			[32] = {x=8,y=8,enemy='pve_leishou_b'},
		},
		[111] = {  --for test
			[1] = {x=1,y=1,enemy='chess_ww1'},
			[2] = {x=1,y=6,enemy='chess_ww1'},
			[3] = {x=4,y=7,enemy='chess_dr1'},
			[4] = {x=4,y=8,enemy='chess_na1'},
			[5] = {x=5,y=5,enemy='chess_visage1'},
			[6] = {x=5,y=6,enemy='chess_abaddon1'},
		},
	}
	_G.DROP_ITEM_LIST = {
		[1] = {
			[1] = 'item_huifuzhihuan',
			[2] = 'item_xuwubaoshi',
			[3] = 'item_gongjizhizhua',
			[4] = 'item_duangun',
			[5] = 'item_molifazhang',
			[6] = 'item_yuandun',
			[7] = 'item_kangmodoupeng',
			[8] = 'item_xixuemianju',
			[9] = 'item_kuweishi',
			[10] = 'item_huoliqiu',
			[11] = 'item_nengliangqiu',
			[12] = 'item_suduzhixue',
		},
		[2] = {	
			[1] = 'item_miyinchui',
			[2] = 'item_biaoqiang',
			[3] = 'item_zhiliaozhihuan',
			[4] = 'item_wangguan',
			[5] = 'item_shanbihufu',
			[6] = 'item_xiaofu',
			[7] = 'item_tiaodao',
			[8] = 'item_kuojian',
			[9] = 'item_suozijia',
		},
		[3] = {
			[1] = 'item_shengzheyiwu',
			[2] = 'item_zhenfenbaoshi',
			[3] = 'item_dafu',
			[4] = 'item_shenmifazhang',
			[5] = 'item_emodaofeng',
			[6] = 'item_banjia',
		}
	}
	_G.COMBINED_ITEM_LIST = {
		[2] = {'item_qiongguidun','item_jianrenqiu','item_zhenhunshi','item_shuijingjian','item_yuanlifazhang','item_atuosi','item_fengkuangmianju','item_zhaohuanshenshi','item_jingmixie','item_aoshuxie'},
		[3] = {'item_yingjiaogong','item_jixianfaqiu','item_xuanwo','item_renjia','item_xianfengdun','item_tiaozhantoujin','item_bkb','item_meiken','item_jurenzhijie','item_wangyuanjing','item_hongzhang_1','item_hongzhang_2','item_hongzhang_3','item_hongzhang_4','item_hongzhang_5','item_silingshu','item_silingshu_2','item_silingshu_3','item_wangchongtui'},
		[4] = {'item_yinyuezhijing','item_anmie','item_kuangzhanfu','item_huanyingfu','item_bingyan','item_linkenfaqiu','item_shuaxinqiu','item_xuejingshi','item_xiwa','item_dongchayandou','item_chihongjia','item_weishijingjia','item_fulingsuo','item_minglingshu','item_sanchaji','item_xueji','item_yonghengzhipan'},
		[5] = {'item_shengjian','item_huiyao','item_jingubang','item_hudie','item_dapao','item_dadianchui','item_longxin','item_sadan','item_qiangxi','item_yangdao','item_baojunwangpao','item_shirenmozhimao','item_shenjingdun'},
	}
	_G.ITEM_FOOD_LIST = {
		[1] = 'item_huifuzhihuan',
		[2] = 'item_xuwubaoshi',
		[3] = 'item_gongjizhizhua',
		[4] = 'item_duangun',
		[5] = 'item_molifazhang',
		[6] = 'item_yuandun',
		[7] = 'item_kangmodoupeng',
		[8] = 'item_xixuemianju',
		[9] = 'item_kuweishi',
		[10] = 'item_huoliqiu',
		[11] = 'item_nengliangqiu',
		[12] = 'item_suduzhixue',
		[13] = 'item_kuojian',
	}
	_G.DROP_RELIC_LIST = {
		[1] = "item_double_lootbox",
		[2] = "item_upgrade_lootbox",
		[3] = "item_more_interest",
		[4] = "item_more_reward",
		[5] = "item_upgrade_roll",
		[6] = "item_double_io",
		[7] = "item_destroy_piece",
		[8] = "item_shrink_meister",
		[9] = "item_conceal_prepare",
		[10] = "item_streak_plus",
		[11] = "item_free_ban",
		[12] = "item_vampiric_embrace",
		[13] = "item_second_chance",
		[14] = "item_mangotree",
		[15] = "item_more_creep",
		[16] = "item_friends_discount",
		[17] = "item_bench_contract",
		[18] = "item_black_gear",
		[19] = "item_egg",
		[20] = "item_steal_chess",
	}
    _G.heroindex2steamid = {}
    _G.cloudlineup = nil
    _G.steamid2heroindex = {}

    -- _G.userid2player = {}
	_G.team2playerid = {}
	_G.playerid2team = {}

	_G.START_TIME = 0
    _G.player_levels = {}
	_G.HeroExpTable = {
			[1] = 0,--+1
			[2] = 1,--+1
			[3] = 2,--+2-->+4(1)(0)(1)
			[4] = 6,--+4-->+8(1)(0)(1)
			[5] = 14,--+8-->+16(1)(1)(1)
			[6] = 30,--+16-->+32(2)(2)(2)
			[7] = 62,--+24-->+48(3)(3)(2)
			[8] = 110,--+32-->+56(4)(3)(3)
			[9] = 166,--+40-->+64(4)(4)(3)

			[10] = 230,--+48-->+64
			[11] = 294,--+56-->+64
			[12] = 358,--+64-->+64
			[13] = 422,--+72-->+64
			[14] = 486,--+80-->+64
			[15] = 550,--+88-->+64
			[16] = 614,
		}
    GameRules:GetGameModeEntity():SetCustomXPRequiredToReachNextLevel(_G.HeroExpTable)
	_G.client_key = {
		[1] = RandomInt(1,1000000),
	    [6] = RandomInt(1,1000000),
		[7] = RandomInt(1,1000000),
		[8] = RandomInt(1,1000000),
		[9] = RandomInt(1,1000000),
		[10] = RandomInt(1,1000000),
		[11] = RandomInt(1,1000000),
		[12] = RandomInt(1,1000000),
		[13] = RandomInt(1,1000000),
    }
    _G.history_win = {
    	[6] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[7] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[8] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[9] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[10] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[11] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[12] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[13] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
	}
	_G.history_lose = {
    	[6] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[7] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[8] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[9] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[10] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[11] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[12] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
		[13] = {
    		[4] = 0,
			[5] = 0,
    		[6] = 0,
			[7] = 0,
			[8] = 0,
			[9] = 0,
			[10] = 0,
			[11] = 0,
			[12] = 0,
			[13] = 0,
    	},
	}
    _G.unit = {
	    [6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
    }
    _G.mychess = {
    	[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	_G.yourchess = {
    	[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	_G.to_be_destory_list = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	_G.game_status = 0
	_G.prepare_timer = 40
	_G.prepare_timer_ingame = _G.prepare_timer
	_G.battle_timer = 50
    _G.myself = false
	_G.is_stop = false
	_G.isConnected = {}
	_G.is_game_started =false
	_G.is_game_ended =false
	--默认卡池参数
	_G.CHESS_POOL_SIZE = 5
	_G.CHESS_INIT_COUNT = {
		[1] = 4,
		[2] = 4,
		[3] = 3,
		[4] = 3,
		[5] = 2,
	}
	_G.CHESS_AFRICA_VALUE = {
		[1] = 1,
		[2] = 1,
		[3] = 1,
		[4] = 1,
		[5] = 1,
	}
    _G.hero = {}
    _G.battleid = nil
    _G.ended = false
    _G.playerid2hero = {}
	_G.teamid2hero = {}
	_G.reportinfo = {}
	_G.base_vector = {
		[6] = Vector(-2496,1728,128),
		[7] = Vector(-448,1728,128),
		[8] = Vector(1600,1728,128),
		[9] = Vector(1600,-320,128),
		[10] = Vector(1600,-2368,128),
		[11] = Vector(-448,-2368,128),
		[12] = Vector(-2496,-2368,128),
		[13] = Vector(-2496,-320,128),
	}
	_G.hand = {
		[6] = {0,0,0,0,0,0,0,0},
		[7] = {0,0,0,0,0,0,0,0},
		[8] = {0,0,0,0,0,0,0,0},
		[9] = {0,0,0,0,0,0,0,0},
		[10] = {0,0,0,0,0,0,0,0},
		[11] = {0,0,0,0,0,0,0,0},
		[12] = {0,0,0,0,0,0,0,0},
		[13] = {0,0,0,0,0,0,0,0},
	}
	_G.counterpart = {}
	_G.lastrandomn = 0
	_G.population = {
		[6] = 0,
		[7] = 0,
		[8] = 0,
		[9] = 0,
		[10] = 0,
		[11] = 0,
		[12] = 0,
		[13] = 0,
	}
	_G.population_max = {
		[6] = 1,
		[7] = 1,
		[8] = 1,
		[9] = 1,
		[10] = 1,
		[11] = 1,
		[12] = 1,
		[13] = 1,
	}
	--给第i个人提供第j个场地的视野
	_G.lights = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	_G.damage_stat = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	--按费用抽卡的棋子列表（受本局橙卡池影响）
	_G.chess_list_by_mana = {
		[1] = {'chess_dazzle','chess_cm','chess_axe','chess_eh','chess_clock','chess_ss','chess_dr','chess_tk','chess_am','chess_tiny','chess_mars','chess_wd','chess_sb','chess_luna','chess_oracle','chess_ww','chess_hw'},
		[2] = {'chess_fv','chess_bm','chess_jugg','chess_shredder','chess_ck','chess_fur','chess_morph','chess_slark','chess_bat','chess_om','chess_pom','chess_gs','chess_sniper','chess_abaddon','chess_brew','chess_puck','chess_naga'}, --,'chess_db'
		[3] = {'chess_riki','chess_razor','chess_viper','chess_lina','chess_tp','chess_veno','chess_sk','chess_rubick','chess_lc','chess_slardar','chess_sf','chess_meepo','chess_huskar','chess_pudge','chess_tb','chess_marci'}, 
		[4] = {'chess_dk','chess_doom','chess_nec','chess_medusa','chess_ga','chess_light','chess_ld','chess_chen','chess_wr','chess_br','chess_kunkka','chess_pangolier','chess_es','chess_snap','chess_mk'}, --,,'chess_ts'
		[5] = {'chess_ta','chess_gyro','chess_thd','chess_tech','chess_enigma','chess_zeus','chess_et','chess_qop','chess_wl','chess_troll','chess_aw','chess_disruptor','chess_kael','chess_spe','chess_th','chess_pb'}, --
	}
	--金色机械核心可以开出的橙卡棋子（不受本局橙卡池影响）
	_G.chess_list_by_mana_gold = {
		'chess_disruptor','chess_kael','chess_ta','chess_gyro','chess_thd','chess_tech','chess_enigma','chess_zeus','chess_et','chess_wl','chess_qop','chess_troll','chess_aw','chess_spe','chess_dp','chess_sven','chess_th','chess_pb'
	}
	--黑暗机械核心可以开出的小黑屋棋子（不受本局橙卡池影响）
	_G.chess_list_by_mana_black = {
		[1] = {'chess_vs','chess_tusk','chess_dw','chess_bh',},
		[2] = {'chess_bs','chess_lion','chess_visage'},
		[3] = {'chess_pa','chess_ok','chess_lyc'}, 
		[4] = {'chess_lich','chess_na'},
		[5] = {'chess_dp','chess_sven'},
	}
	_G.pandaman_list = {'chess_ember','chess_brew','chess_storm','chess_earth','chess_void'}
	_G.chess_list_ssr = {'chess_nec_ssr','chess_ck_ssr','chess_ss_ssr','chess_brew_ssr','chess_om_ssr'} 
	--德鲁伊棋子列表（不受本局橙卡池影响）
	_G.chess_list_by_druid = {
		'chess_eh','chess_fur','chess_tp','chess_ld','chess_ts','chess_et'
	}
	--按种族/职业索引的棋子列表（受本局橙卡池影响）
	_G.chess_list_by_synergy = {
		is_aqir = {},
		is_beast = {},
		is_demon = {},
		is_dragon = {},
		is_dwarf = {},
		is_element = {},
		is_elf = {},
		is_goblin = {},
		is_god = {},
		is_human = {},
		is_naga = {},
		is_ogre = {},
		is_orc = {},
		is_pandaman = {},
		is_troll = {},
		is_undead = {},
		is_tauren = {},
		is_kobold = {},
		is_nraqi = {},
		is_satyr = {},
		is_draenei = {},

		is_assassin = {},
		is_demonhunter = {}, 
		is_druid = {},
		is_hunter = {},
		is_knight = {},
		is_mage = {},
		is_mech = {},
		is_monk = {},
		is_priest = {},
		is_shaman = {},
		is_warlock = {},
		is_warrior = {},
		is_wizard = {},
	}
	_G.chess_list_by_synergy_black_and_pandaman = {
		is_aqir = {},
		is_beast = {},
		is_demon = {},
		is_dragon = {},
		is_dwarf = {},
		is_element = {},
		is_elf = {},
		is_goblin = {},
		is_god = {},
		is_human = {},
		is_naga = {},
		is_ogre = {},
		is_orc = {},
		is_pandaman = {},
		is_troll = {},
		is_undead = {},
		is_tauren = {},
		is_kobold = {},
		is_nraqi = {},
		is_satyr = {},
		is_draenei = {},

		is_assassin = {},
		is_demonhunter = {},
		is_druid = {},
		is_hunter = {},
		is_knight = {},
		is_mage = {},
		is_mech = {},
		is_monk = {},
		is_priest = {},
		is_shaman = {},
		is_warlock = {},
		is_warrior = {},
		is_wizard = {},
	}
	_G.chess_list_by_synergy_ban_unavailable = {
		is_aqir = {},
		is_beast = {},
		is_demon = {},
		is_dragon = {},
		is_dwarf = {},
		is_element = {},
		is_elf = {},
		is_goblin = {},
		is_god = {},
		is_human = {},
		is_naga = {},
		is_ogre = {},
		is_orc = {},
		is_pandaman = {},
		is_troll = {},
		is_undead = {},
		is_tauren = {},
		is_kobold = {},
		is_nraqi = {},
		is_satyr = {},
		is_draenei = {},

		is_assassin = {},
		is_demonhunter = {},
		is_druid = {},
		is_hunter = {},
		is_knight = {},
		is_mage = {},
		is_mech = {},
		is_monk = {},
		is_priest = {},
		is_shaman = {},
		is_warlock = {},
		is_warrior = {},
		is_wizard = {},
	}
	_G.chess_2_mana = {
		chess_tusk = 1,
		chess_axe = 1,
		chess_eh = 1,
		chess_om = 2,
		chess_clock = 1,
		chess_ss = 1,
		chess_bh = 1,
		chess_bat = 2,
		chess_dr = 1,
		chess_tk = 1,
		chess_bm = 2,
		chess_jugg = 2,
		chess_shredder = 2,
		chess_puck = 2,
		chess_ck = 2,
		chess_slardar = 3,
		chess_luna = 1,
		chess_tp = 3,
		chess_qop = 5,
		chess_snap = 4,
		chess_huskar = 3,
		chess_bs = 2,
		chess_am = 1,
		chess_wd = 1,
		chess_cm = 1,
		chess_light = 4,
		chess_ok = 3,
		chess_razor = 3,
		chess_wr = 4,
		chess_sk = 3,
		chess_abaddon = 2,
		chess_slark = 2,
		chess_sniper = 2,
		chess_sf = 3,
		chess_viper = 3,
		chess_lyc = 3,
		chess_pa = 3,
		chess_kunkka = 4,
		chess_doom = 4,
		chess_lina = 3,
		chess_troll = 5,
		chess_veno = 3,
		chess_nec = 4,
		chess_ta = 5,
		chess_medusa = 4,
		chess_disruptor = 5,
		chess_ga = 4,
		chess_dk = 4,
		chess_gyro = 5,
		chess_lich = 4,
		chess_th = 5,
		chess_enigma = 5,
		chess_tech = 5,
		chess_fur = 2,
		chess_ld = 4,
		--
		chess_tiny = 1,
		chess_tb = 3,
		chess_morph = 2,

		chess_kael = 5,
		chess_sven = 5,

		chess_riki = 3,
		chess_pom = 2,
		chess_dp = 5,
		chess_fv = 2,

		chess_zeus = 5,
		chess_mars = 1,

		chess_ss_ssr = 10,
		chess_brew_ssr = 10,
		chess_nec_ssr = 10,
		chess_ck_ssr = 10,
		chess_om_ssr = 10,

		chess_dazzle = 1,
		chess_io = 5,
		chess_ww = 1,
		chess_rubick = 3,
		chess_gs = 2,

		chess_pudge = 3,
		chess_visage = 2,
		chess_lion = 2,
		chess_na = 4,
		chess_oracle = 1,
		chess_br = 4,
		chess_lc = 3,
		chess_chen = 4,
		chess_thd = 5,
		chess_dw = 1,

		chess_brew = 2,
		chess_ember = 3,
		chess_storm = 3,
		chess_earth = 3,
		chess_mk = 4,
		chess_es = 4,
		chess_sb = 1,
		chess_et = 5,
		chess_meepo = 3,
		chess_pangolier = 4,
		chess_vs = 1,
		chess_wl = 5,
		chess_hw = 1,
		chess_aw = 5,
		chess_spe = 5,
		chess_marci = 3,
		chess_naga = 2,
		chess_void = 3,
		chess_pb = 5,
		chess_ts = 4,
		chess_db = 2,
	}
	_G.chess_list_by_level = {}
	_G.chess_transform_list = {
		chess_tb_mohua1 = 'chess_tb',
		chess_tb_mohua2 = 'chess_tb1',
		chess_tb_mohua3 = 'chess_tb11',
		chess_dk_dragon = 'chess_dk',
		chess_dk1_dragon = 'chess_dk1',
		chess_dk11_dragon = 'chess_dk11',
		chess_lyc_wolf = 'chess_lyc',
		chess_lyc1_wolf = 'chess_lyc1',
		chess_lyc11_wolf = 'chess_lyc11',
	}
	_G.chess_pool = {
		[1] = {},
		[2] = {},
		[3] = {},
		[4] = {},
		[5] = {},
	}
	_G.COLOR_GROUP = {
		h346 = 0, h347 = 0, h348 = 0, h349 = 0, h350 = 0, h351 = 0, h353 = 0, h356 = 0, h428 = 0, h434 = 0, h436 = 0, h438 = 0, h439 = 0, h448 = 0, h452 = 0, h456 = 0, h459 = 0, h460 = 0, h465 = 0, h466 = 0, h468 = 0, h499 = 0, --金色
	}
	_G.CP_GROUP = {
		h001 = 1, h002 = 1, h309 = 1, h138 = 1, h316 = 1,--驴子
		h104 = 24, h241 = 24, h352 = 24, h442 = 24, --蝾螈
		h110 = 2, h135 = 2,--翠花
		h112 = 3, h141 = 3, h253 = 3, h361 = 3, h451 = 3, --乌龟
		h117 = 4, h242 = 4, --小红毛
		h120 = 5, h243 = 5, --小仙鹤
		h126 = 6, h233 = 6, h333 = 6, h334 = 6, h427 = 6, h441 = 6, --小恶魔
		h128 = 7, h224 = 7, h322 = 7, h456 = 7, h421 = 7, --碧林·
		h130 = 8, h229 = 8, h310 = 8, h327 = 8, --小法师
		h133 = 9, h232 = 9, h330 = 9, h331 = 9, h346 = 9, h439 = 9,--箱子
		h134 = 10, h234 = 10, h335 = 10, h428 = 10,--矿车鼠
		h136 = 11, h137 = 11, h240 = 11, h340 = 11, h434 = 11, --金龟子
		h139 = 12, h246 = 12, h247 = 12, h248 = 12, h249 = 12, h250 = 12, h251 = 12, h358 = 12, h359 = 12, h429 = 12 , h448 = 12, --贪魔
		h140 = 13, h252 = 13, h360 = 13, h450 = 13, --断头猫
		h142 = 14, h143 = 14, h144 = 14, h145 = 14, h199 = 14, h255 = 14, h256 = 14, h257 = 14, h362 = 14, h363 = 14, h453 = 14, h454 = 14, h455 = 14, --字
		h146 = 15, h147 = 15, h258 = 15, h259 = 15, h364 = 15, h365 = 15, h457 = 15, h458 = 15, --晴儿
		h148 = 16, h260 = 16, h366 = 16, h366 = 16, h460 = 16,--奇异蛋
		h149 = 17, h263 = 17, h371 = 17, h466 = 17,--方死神
		h150 = 18, h235 = 18, h367 = 18, --陆行鸟
		h216 = 19, h345 = 19, h438 = 19,--小冰龙
		h226 = 20, h227 = 20, h228 = 20, h267 = 20, h324 = 20, h325 = 20, h326 = 20, h423 = 20, h424 = 20, h425 = 20, --蟹小窝
		h239 = 21, h356 = 21, --虎鲸
		h268 = 22, h269 = 22, h373 = 22, h468 = 22,--雪狐
		h270 = 23, h271 = 23, h374 = 23, h469 = 23, --破龙

		h272 = 39, h273 = 39, h375 = 39, h470 = 39, h471 = 39, --学者
		
		h318 = 25, h342 = 25, h343 = 25, h344 = 25, h354 = 25, h355 = 25, h399 = 25, h433 = 25,h436 = 25, h437 = 25, h461 = 25, h462 = 25, --roshan
		h320 = 26, h321 = 26, --变色龙蝶
		h323 = 27, h465 = 27, --招财猫
		h368 = 28, h369 = 28, --考拉,
		h397 = 29, h398 = 29, --鸽子

		h405 = 30, h414 = 30, --小飞狐
		h408 = 31, h409 = 31, --黑白石头人
		h410 = 32, h411 = 32, --火星车
		h412 = 33, h413 = 33, --天使恶魔
		h417 = 34, h418 = 34, --金银狐灵
		h419 = 35, h443 = 35, --风神飞镰
		h422 = 36, h444 = 36, h445 = 36, h446 = 36, --小飞侠
		h213 = 37, h440 = 37, --不屈战犬
		h463 = 38, h467 = 38, --海龙
	}
	--招募棋子（抽卡）概率
	_G.chess_gailv = {
		[1] = { [101] = 2 },
		[2] = { [70] = 2 },
		[3] = { [60] = 2, [95] = 3 },
		[4] = { [50] = 2, [85] = 3 },
		[5] = { [40] = 2, [75] = 3, [98] = 4 },
		[6] = { [33] = 2, [63] = 3, [93] = 4 },
		[7] = { [30] = 2, [60] = 3, [90] = 4 },
		[8] = { [24] = 2, [54] = 3, [82] = 4, [99] = 5 },
		[9] = { [22] = 2, [47] = 3, [72] = 4, [97] = 5 },
		[10] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
		[11] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
		[12] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
		[13] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
		[14] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
		[15] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
		[16] = { [20] = 2, [42] = 3, [67] = 4, [95] = 5 },
	}
	--野怪掉装备概率
	_G.drop_item_gailv = {
		[1] = { [101] = 1},
		[2] = { [101] = 1},
		[3] = { [101] = 1},
		[4] = { [75] = 1},
		[5] = { [50] = 1, [80] = 2},
		[6] = { [40] = 1, [70] = 2},
		[7] = { [30] = 1, [60] = 2},
		[8] = { [20] = 1, [50] = 2},
		[9] = { [0] = 1, [30] = 2},
	}
	--战利品宝箱开装备概率
	_G.drop_loot_gailv = {
		[1] = { [0] = 1},
		[2] = { [0] = 1, [75] = 2},
		[3] = { [0] = 1, [50] = 2},
		[4] = { [0] = 1, [25] = 2, [75] = 3},
		[5] = { [0] = 2, [50] = 3},
		[6] = { [0] = 2, [25] = 3},
	}
	_G.wave_2_lootbox = {
		[1] = 'item_lootbox_lv1',
		[2] = 'item_lootbox_lv1',
		[3] = 'item_lootbox_lv2',
		[5] = 'item_lootbox_lv2',--为了绿皮船长的容错
		[10] = 'item_relicbox',
		[15] = 'item_lootbox_lv2',
		[20] = 'item_relicbox',
		[25] = 'item_lootbox_lv3',
		[30] = 'item_relicbox',
		[35] = 'item_lootbox_lv4',
		[40] = 'item_relicbox',
		[45] = 'item_lootbox_lv5',
		[50] = 'item_relicbox',
	}
	_G.chess_ability_list = {
		chess_cm = 'cm_mana_aura',
		chess_axe = 'axe_berserkers_call',
		chess_dr = 'dr_shooter_aura',
		chess_eh = 'enchantress_natures_attendants',
		chess_om = 'om_multi_cast',
		chess_tusk = 'tusk_walrus_punch',
		chess_bm = 'bm_beast',
		chess_jugg = 'juggernaut_blade_fury',
		chess_lyc = 'lyc_wolf',
		chess_shredder = 'shredder_whirling_death',
		chess_tk = 'a108',
		chess_light = 'keeper_of_the_light_illuminate',
		chess_ok = 'omniknight_purification',
		chess_razor = 'razor_plasma_field',
		chess_wr = 'windrunner_powershot',
		chess_doom = 'doom_bringer_doom',
		chess_kunkka = 'kunkka_ship',
		chess_lina = 'lina_laguna_blade',
		chess_troll = 'troll_axe',
		chess_veno = 'veno_ward',
		chess_gyro = 'gyrocopter_call_down',
		chess_lich = 'lich_chain_frost',
		chess_qop = 'queenofpain_sonic_wave_datadriven',
		chess_snap = 'snapfire_lil_shredder',
		chess_th = 'tidehunter_ravage',
		chess_br = 'br_web',
		--
		chess_am = 'antimage_mana_break',
		chess_wd = 'witch_doctor_paralyzing_cask',
		chess_clock = 'rattletrap_battery_assault',
		chess_ss = 'lion_voodoo',
		chess_pa = 'phantom_assassin_coup_de_grace',
		chess_puck = 'puck_illusory_orb_datadriven',
		chess_slardar = 'slardar_slithereen_crush',
		chess_ck = 'chaos_knight_chaos_bolt',
		chess_abaddon = 'abaddon_aphotic_shield',
		chess_sk = 'sandking_burrowstrike',
		chess_slark = 'slark_nengliangzhuanyi',
		chess_sniper = 'sniper_assassinate',
		chess_nec = 'necrolyte_death_pulse',
		chess_ta = 'templar_assassin_refraction',
		chess_enigma = 'midnight_pulse_datadriven',
		--
		chess_bat = 'batrider_firefly',
		-- chess_bat = 'batrider_sticky_napalm',
		chess_luna = 'luna_moon_glaive',
		chess_tp = 'tp_seed',
		chess_sf = 'shadow_fiend_requiem_of_souls_lua',
		chess_dk = 'dk_dragon_form',
		chess_viper = 'viper_viper_strike',
		chess_medusa = 'medusa_stone_gaze',
		chess_disruptor = 'ability_disruptor_static_storm',
		chess_ga = 'alchemist_chemical_rage',
		chess_tech = 'chess_tech_bomb',
		--
		chess_fur = 'fur_tree',
		chess_ld = 'ld_bear',
		--
		chess_nec_ssr = 'nec_ssr_scythe',
		chess_morph = 'morphling_waveform',
		chess_tb = 'tb_mohua_new',
		chess_tiny = 'tiny_touzhi',
		--
		chess_riki = 'smoke_screen_trigger',
		chess_pom = 'pom_arrow_far',
		chess_dp = 'death_prophet_exorcism',
		--
		chess_fv = 'fv_zhao',
		--
		chess_zeus = 'zeus_thunder',
		chess_mars = 'mars_bulwark_attack',
		--
		chess_sven = 'sven_gods_strength',
		chess_ww = 'winter_wyvern_cold_embrace',
		chess_rubick = 'rubick_qiequ',
		chess_gs = 'gs_moji',

		chess_cm1 = 'cm_mana_aura',
		chess_axe1 = 'axe_berserkers_call',
		chess_dr1 = 'dr_shooter_aura',
		chess_eh1 = 'enchantress_natures_attendants',
		chess_om1 = 'om_multi_cast',
		chess_tusk1 = 'tusk_walrus_punch',
		chess_bm1 = 'bm_beast',
		chess_jugg1 = 'juggernaut_blade_fury',
		chess_lyc1 = 'lyc_wolf',
		chess_shredder1 = 'shredder_whirling_death',
		chess_tk1 = 'a108',
		chess_light1 = 'keeper_of_the_light_illuminate',
		chess_ok1 = 'omniknight_purification',
		chess_razor1 = 'razor_plasma_field',
		chess_wr1 = 'windrunner_powershot',
		chess_doom1 = 'doom_bringer_doom',
		chess_kunkka1 = 'kunkka_ship',
		chess_lina1 = 'lina_laguna_blade',
		chess_troll1 = 'troll_axe',
		chess_veno1 = 'veno_ward',
		chess_gyro1 = 'gyrocopter_call_down',
		chess_lich1 = 'lich_chain_frost',
		chess_qop1 = 'queenofpain_sonic_wave_datadriven',
		chess_snap1 = 'snapfire_lil_shredder',
		chess_th1 = 'tidehunter_ravage',
		chess_br1 = 'br_web',
		--
		chess_am1 = 'antimage_mana_break',
		chess_wd1 = 'witch_doctor_paralyzing_cask',
		chess_clock1 = 'rattletrap_battery_assault',
		chess_ss1 = 'lion_voodoo',
		chess_pa1 = 'phantom_assassin_coup_de_grace',
		chess_puck1 = 'puck_illusory_orb_datadriven',
		chess_slardar1 = 'slardar_slithereen_crush',
		chess_ck1 = 'chaos_knight_chaos_bolt',
		chess_abaddon1 = 'abaddon_aphotic_shield',
		chess_sk1 = 'sandking_burrowstrike',
		chess_slark1 = 'slark_nengliangzhuanyi',
		chess_sniper1 = 'sniper_assassinate',
		chess_nec1 = 'necrolyte_death_pulse',
		chess_ta1 = 'templar_assassin_refraction',
		chess_enigma1 = 'midnight_pulse_datadriven',
		--
		chess_bat1 = 'batrider_firefly',
		-- chess_bat1 = 'batrider_sticky_napalm',
		chess_luna1 = 'luna_moon_glaive',
		chess_tp1 = 'tp_seed',
		chess_sf1 = 'shadow_fiend_requiem_of_souls_lua',
		chess_dk1 = 'dk_dragon_form',
		chess_viper1 = 'viper_viper_strike',
		chess_medusa1 = 'medusa_stone_gaze',
		chess_disruptor1 = 'ability_disruptor_static_storm',
		chess_ga1 = 'alchemist_chemical_rage',
		chess_tech1 = 'chess_tech_bomb',
		--
		chess_fur1 = 'fur_tree',
		chess_ld1 = 'ld_bear',
		--
		chess_morph1 = 'morphling_waveform',
		chess_tb1 = 'tb_mohua_new',
		chess_tiny1 = 'tiny_touzhi',
		--
		chess_riki1 = 'smoke_screen_trigger',
		chess_pom1 = 'pom_arrow_far',
		chess_dp1 = 'death_prophet_exorcism',
		--
		chess_fv1 = 'fv_zhao',
		--
		chess_zeus1 = 'zeus_thunder',
		chess_mars1 = 'mars_bulwark_attack',
		--
		chess_sven1 = 'sven_gods_strength',
		chess_ww1 = 'winter_wyvern_cold_embrace',
		chess_rubick1 = 'rubick_qiequ',
		chess_gs1 = 'gs_moji',


		chess_cm11 = 'cm_mana_aura',
		chess_axe11 = 'axe_berserkers_call',
		chess_dr11 = 'dr_shooter_aura',
		chess_eh11 = 'enchantress_natures_attendants',
		chess_om11 = 'om_multi_cast',
		chess_tusk11 = 'tusk_walrus_punch',
		chess_bm11 = 'bm_beast',
		chess_jugg11 = 'juggernaut_blade_fury',
		chess_lyc11 = 'lyc_wolf',
		chess_shredder11 = 'shredder_whirling_death',
		chess_tk11 = 'a108',
		chess_light11 = 'keeper_of_the_light_illuminate',
		chess_ok11 = 'omniknight_purification',
		chess_razor11 = 'razor_plasma_field',
		chess_wr11 = 'windrunner_powershot',
		chess_doom11 = 'doom_bringer_doom',
		chess_kunkka11 = 'kunkka_ship',
		chess_lina11 = 'lina_laguna_blade',
		chess_troll11 = 'troll_axe',
		chess_veno11 = 'veno_ward',
		chess_gyro11 = 'gyrocopter_call_down',
		chess_lich11 = 'lich_chain_frost',
		chess_qop11 = 'queenofpain_sonic_wave_datadriven',
		chess_snap11 = 'snapfire_lil_shredder',
		chess_th11 = 'tidehunter_ravage',
		chess_br11 = 'br_web',
		--
		chess_am11 = 'antimage_mana_break',
		chess_wd11 = 'witch_doctor_paralyzing_cask',
		chess_clock11 = 'rattletrap_battery_assault',
		chess_ss11 = 'lion_voodoo',
		chess_pa11 = 'phantom_assassin_coup_de_grace',
		chess_puck11 = 'puck_illusory_orb_datadriven',
		chess_slardar11 = 'slardar_slithereen_crush',
		chess_ck11 = 'chaos_knight_chaos_bolt',
		chess_abaddon11 = 'abaddon_aphotic_shield',
		chess_sk11 = 'sandking_burrowstrike',
		chess_slark11 = 'slark_nengliangzhuanyi',
		chess_sniper11 = 'sniper_assassinate',
		chess_nec11 = 'necrolyte_death_pulse',
		chess_ta11 = 'templar_assassin_refraction',
		chess_enigma11 = 'midnight_pulse_datadriven',
		--
		chess_bat11 = 'batrider_firefly',
		-- chess_bat11 = 'batrider_sticky_napalm',
		chess_luna11 = 'luna_moon_glaive',
		chess_tp11 = 'tp_seed',
		chess_sf11 = 'shadow_fiend_requiem_of_souls_lua',
		chess_dk11 = 'dk_dragon_form',
		chess_viper11 = 'viper_viper_strike',
		chess_medusa11 = 'medusa_stone_gaze',
		chess_disruptor11 = 'ability_disruptor_static_storm',
		chess_ga11 = 'alchemist_chemical_rage',
		chess_tech11 = 'chess_tech_bomb',
		--
		chess_fur11 = 'fur_tree',
		chess_ld11 = 'ld_bear',
		--
		chess_morph11 = 'morphling_waveform',
		chess_tb11 = 'tb_mohua_new',
		chess_tiny11 = 'tiny_touzhi',
		--
		chess_riki11 = 'smoke_screen_trigger',
		chess_pom11 = 'pom_arrow_far',
		chess_dp11 = 'death_prophet_exorcism',
		--
		chess_fv11 = 'fv_zhao',
		--
		chess_zeus11 = 'zeus_thunder',
		chess_mars11 = 'mars_bulwark_attack',
		--

		chess_ck_ssr = 'ck_illusion',
		chess_ss_ssr = 'ss_ssr_wards',
		chess_lich_ssr = 'lich_evil_sacrifice',

		chess_dazzle = 'dazzle_bozang',
		chess_dazzle1 = 'dazzle_bozang',
		chess_dazzle11 = 'dazzle_bozang',

		chess_io = 'wisp_tether',
		chess_io1 = 'wisp_tether',
		chess_sven11 = 'sven_gods_strength',
		chess_ww11 = 'winter_wyvern_cold_embrace',
		chess_rubick11 = 'rubick_qiequ',
		chess_gs11 = 'gs_moji',

		chess_pudge = 'pudge_meat_hook_lua',
		chess_pudge1 = 'pudge_meat_hook_lua',
		chess_pudge11 = 'pudge_meat_hook_lua',


		chess_visage = 'baby_dragon',
		chess_visage1 = 'baby_dragon',
		chess_visage11 = 'baby_dragon',

		chess_lion = 'lion_mana_drain_datadriven',
		chess_lion1 = 'lion_mana_drain_datadriven',
		chess_lion11 = 'lion_mana_drain_datadriven',

		chess_oracle = 'oracle_mingyunsheling',
		chess_oracle1 = 'oracle_mingyunsheling',
		chess_oracle11 = 'oracle_mingyunsheling',

		chess_na = 'nyx_assassin_spiked_carapace_datadriven',
		chess_na1 = 'nyx_assassin_spiked_carapace_datadriven',
		chess_na11 = 'nyx_assassin_spiked_carapace_datadriven',

		chess_bs = 'bloodseeker_blood_bath',
		chess_bs1 = 'bloodseeker_blood_bath',
		chess_bs11 = 'bloodseeker_blood_bath',

		chess_huskar = 'burning_spear_datadriven',
		chess_huskar1 = 'burning_spear_datadriven',
		chess_huskar11 = 'burning_spear_datadriven',

		chess_mk = 'mk_ruyibangfa',
		chess_mk1 = 'mk_ruyibangfa',
		chess_mk11 = 'mk_ruyibangfa',

		chess_kael = "invoke",
		chess_kael1 = "invoke",
		chess_kael11 = "invoke",

		chess_lc = "lc_qianggong",
		chess_lc1 = "lc_qianggong",
		chess_lc11 = "lc_qianggong",

		chess_bh = 'bh_shuriken',
		chess_bh1 = 'bh_shuriken',
		chess_bh11 = 'bh_shuriken',

		chess_chen = 'chen_fuhuo',
		chess_chen1 = 'chen_fuhuo',
		chess_chen11 = 'chen_fuhuo',

		chess_thd = "jakiro_macropyre",
		chess_thd1 = "jakiro_macropyre",
		chess_thd11 = "jakiro_macropyre",

		chess_dw = "dark_willow_cursed_crown",
		chess_dw1 = "dark_willow_cursed_crown",
		chess_dw11 = "dark_willow_cursed_crown",

		chess_brew = "brewmaster_cinder_brew",
		chess_brew1 = "brewmaster_cinder_brew",
		chess_brew11 = "brewmaster_cinder_brew",
		chess_brew_ssr = "brew_ssr_3_pandas",

		chess_ember = 'sleight_of_fist_datadriven',
		chess_ember1 = 'sleight_of_fist_datadriven',
		chess_ember11 = 'sleight_of_fist_datadriven',

		chess_storm = 'storm_spirit_ball_lightning_datadriven',
		chess_storm1 = 'storm_spirit_ball_lightning_datadriven',
		chess_storm11 = 'storm_spirit_ball_lightning_datadriven',

		chess_earth = 'earth_rock_roll',
		chess_earth1 = 'earth_rock_roll',
		chess_earth11 = 'earth_rock_roll',

		chess_void = 'void_astralstep',
		chess_void1 = 'void_astralstep',
		chess_void11 = 'void_astralstep',

		chess_es = 'gouhe',
		chess_es1 = 'gouhe',
		chess_es11 = 'gouhe',

		chess_sb = 'sb_julizhongji',
		chess_sb1 = 'sb_julizhongji',
		chess_sb11 = 'sb_julizhongji',

		chess_meepo = 'poof',
		chess_meepo1 = 'poof',
		chess_meepo11 = 'poof',

		chess_et = 'et_earth_splitter',
		chess_et1 = 'et_earth_splitter',
		chess_et11 = 'et_earth_splitter',

		chess_pangolier = 'pangolier_swashbuckle_datadriven',
		chess_pangolier1 = 'pangolier_swashbuckle_datadriven',
		chess_pangolier11 = 'pangolier_swashbuckle_datadriven',

		chess_vs = 'vs_swap',
		chess_vs1 = 'vs_swap',
		chess_vs11 = 'vs_swap',

		chess_wl = 'wl_inferno',
		chess_wl1 = 'wl_inferno',
		chess_wl11 = 'wl_inferno',

		chess_hw = 'hoodwink_hunters_boomerang',
		chess_hw1 = 'hoodwink_hunters_boomerang',
		chess_hw11 = 'hoodwink_hunters_boomerang',

		chess_aw = 'arc_double',
		chess_aw1 = 'arc_double',
		chess_aw11 = 'arc_double',

		chess_spe = 'spe_haunt',
		chess_spe1 = 'spe_haunt',
		chess_spe11 = 'spe_haunt',

		chess_marci = 'marci_unleash',
		chess_marci1 = 'marci_unleash',
		chess_marci11 = 'marci_unleash',

		chess_naga = 'siren_song',
		chess_naga1 = 'siren_song',
		chess_naga11 = 'siren_song',

		chess_pb = 'primal_beast_pulverize',
		chess_pb1 = 'primal_beast_pulverize',
		chess_pb11 = 'primal_beast_pulverize',

		chess_om_ssr = 'jakiro_dual_breath',

		chess_db = 'dawnbreaker_fire_wreath',
		chess_db1 = 'dawnbreaker_fire_wreath',
		chess_db11 = 'dawnbreaker_fire_wreath',

		chess_ts = 'leshrac_pulse_nova',
		chess_ts1 = 'leshrac_pulse_nova',
		chess_ts11 = 'leshrac_pulse_nova',
	}
	_G.summon_ability_list = {
		visage_dragon_1 = 'visage_grave_chill',
		visage_dragon_2 = 'visage_grave_chill',
		visage_dragon_3 = 'visage_grave_chill',
	}
	--释放技能：0=被动技能，1=随机敌人目标，2=无目标，3=点目标，4=自己目标，5=近身单位目标，6=先知周边树人，7=随机友军目标，8=随机周围空地目标（炸弹人），9=需要治疗的，10=等级最高的敌人（末日），11=沙王穿刺, 13=自己脚下点目标，14=pom的特殊目标，15=小鱼人跳，16=需要护盾的队友，17=按伤害量计算最合适的目标，19=新蝙蝠，20=屠夫（最远的敌人单位目标），21=死灵龙佣兽，22=新大鱼点灯目标，23=全能治疗目标，24=蜘蛛织网点目标，25=天火点目标(选取方式同10)，26=最高费用目标（陈复活对象），27=双头龙两个技能切换，28=小精灵连等级最高的大哥，29=圆形AOE选目标点，30=蓝胖多重施法选择最合适的队友，31=沟壑位置，32=血量最低的敌人，33=随机能攻击到敌人的点目标（滚滚）,34=VS技能目标，35=地狱火
	--能看到这行字的代码哥哥，请勿将测试服拆包内容曝光和公开讨论，谢谢
	_G.ability_behavior_list = {
			dawnbreaker_fire_wreath = 5,
			leshrac_pulse_nova = 2,
			jakiro_dual_breath = 3,
			lion_voodoo = 1,
			primal_beast_pulverize = 5,
			void_astralstep = 2,
			siren_song = 2,
			marci_unleash = 2,
			spe_haunt = 2,
			arc_double = 0,
			hoodwink_hunters_boomerang = 20,
			smoke_screen_trigger = 0,
			troll_axe = 0,
			wl_inferno = 35,
			vs_swap = 34,
			pangolier_swashbuckle_datadriven = 33,
			shadow_shaman_shackles = 1,
			bh_shuriken = 32,
			fv_zhao = 13,
			sb_julizhongji = 0,
			gouhe = 31,
			et_earth_splitter = 31,
			earth_rock_roll = 2,
			storm_spirit_ball_lightning_datadriven = 11,
			ember_spirit_sleight_of_fist = 3,
			brewmaster_cinder_brew = 3,
			brew_ssr_3_pandas = 2,
			wisp_tether = 28,
			dark_willow_cursed_crown = 1,
			jakiro_macropyre = 27,
			jakiro_ice_path = 27,
			bh_zhuizongshu = 1,
			lc_qianggong = 0,
			invoke = 2,
			forge_spirit = 2,
			invoker_ice_wall = 2,
			invoker_sun_strike = 25,
			invoker_chaos_meteor = 3,
			chaos_meteor_datadriven = 3,
			alacrity = 7,
			invoker_emp = 3,
			invoker_cold_snap = 22,
			invoker_deafening_blast_datadriven = 3,
			invoker_tornado_datadriven = 3,
			br_web = 24,
			kunkka_torrent_storm = 2,
			ss_ssr_wards = 1,
			monkey_king_wukongs_command = 13,
			queenofpain_sonic_wave_datadriven = 3,
			snapfire_lil_shredder = 2,
			lich_chain_frost = 1,
			gege_sonicwave = 1,
			burning_spear_datadriven = 0,
			bloodseeker_blood_bath = 13,
			nyx_assassin_spiked_carapace_datadriven = 2,
			oracle_mingyunsheling = 1,
			nyx_assassin_spiked_carapace = 2,
			lion_mana_drain_datadriven = 18,
			slark_nengliangzhuanyi = 0,
			rubick_qiequ = 0,
			gs_moji = 3,
			axe_berserkers_call = 2,
			cm_mana_aura = 0,
			enchantress_natures_attendants = 2,
			om_multi_cast = 30,
			tusk_walrus_punch = 5,
			beastmaster_wild_axes = 3,
			juggernaut_blade_fury = 2,
			lyc_wolf = 2,
			shredder_whirling_death = 2,
			a108 = 2,
			dr_shooter_aura = 0,
			keeper_of_the_light_illuminate = 3,
			omniknight_purification = 23,
			razor_plasma_field = 2,
			windrunner_powershot = 3,
			doom_bringer_doom = 10,
			kunkka_ship = 3,
			lina_laguna_blade = 17,
			troll_warlord_whirling_axes_melee = 2,
			troll_warlord_whirling_axes_ranged = 1,
			troll_warlord_fervor = 0,
			venomancer_poison_nova = 2,
			veno_ward = 8,
			gyrocopter_call_down = 29,
			lich_bingjia = 16,
			queenofpain_scream_of_pain = 2,
			tidehunter_ravage = 2,
			antimage_mana_break = 0,
			bounty_hunter_shuriken_toss = 1,
			witch_doctor_paralyzing_cask = 1,
			rattletrap_battery_assault = 2,
			shadow_shaman_voodoo = 1,
			phantom_assassin_coup_de_grace = 0,
			puck_illusory_orb = 3,
			slardar_amplify_damage = 22,
			chaos_knight_chaos_bolt = 1,
			abaddon_aphotic_shield = 16,
			bump = 11,
			slark_shadow_dance = 2,
			sniper_assassinate = 17,
			necrolyte_death_pulse = 2,
			templar_assassin_refraction = 2,
			midnight_pulse_datadriven = 29,
			batrider_sticky_napalm = 3,
			luna_moon_glaive = 0,
			tp_seed = 10,
			shadow_fiend_requiem_of_souls_lua = 2,
			dk_dragon_form = 2,
			viper_viper_strike = 10,
			medusa_stone_gaze = 2,
			disruptor_static_storm = 29,
			ability_disruptor_static_storm = 29,
			alchemist_acid_spray = 3,
			chess_tech_bomb = 8,
			sven_great_cleave = 0,
			fur_tree = 6,
			ld_bear = 8,
			bm_beast = 8,
			--
			nec_ssr_scythe = 1,
			morphling_waveform = 11,
			sandking_burrowstrike = 11,
			tb_mohua = 2,
			tb_mohua_new = 2,
			tiny_touzhi = 12,
			ck_illusion = 2,

			death_prophet_exorcism = 2,
			pom_arrow_far = 20,
			slark_jump = 15,
			alchemist_chemical_rage = 2,
			--
			zeus_thunder = 2,
			mars_bulwark = 0,
			dazzle_bozang = 9,
			wisp_wildcard = 0,
			sven_gods_strength = 2,
			winter_wyvern_cold_embrace = 9,
			batrider_firefly = 19,
			baby_dragon = 2,
			pudge_meat_hook_lua = 20,
			visage_grave_chill = 21,
			slardar_slithereen_crush = 2,
			chen_fuhuo = 26,
			mk_ruyibangfa = 0,
			poof = 1,
			mars_bulwark_attack = 0,
		}
	
	--组合技技能ability
	--组合技条件condition：0=只有唯一1个同职业/种族的友军，1~3=需要1~3名同职业/种族的友军
	--组合技类型type：0=自身有效果，1=所有同职业/种族的友军的有效果，2=所有友军有效果，3=所有敌军有效果，4=随机一个友军有效果，5=随机一个敌军有效果，
	--6信使有效果，7=所有远程友军有效果，9=巫师效果
	_G.combo_ability_type = {
		--职业技能
		is_warrior = { ability = 'is_warrior_buff', condition = 3, type = 1 },
		is_warrior1 = { ability = 'is_warrior_buff_plus', condition = 6, type = 2 },
		is_warrior11 = { ability = 'is_warrior_buff_plus_plus', condition = 9, type = 2 },
		is_mage = { ability = 'is_mage_buff', condition = 3, type = 3 },
		is_mage1 = { ability = 'is_mage_buff_plus', condition = 6, type = 3 },
		is_mage11 = { ability = 'is_mage_buff_plus_plus', condition = 9, type = 3 },
		is_warlock = { ability = 'is_warlock_buff', condition = 2, type = 2 },
		is_warlock1 = { ability = 'is_warlock_buff_plus', condition = 4, type = 2 },
		is_warlock11 = { ability = 'is_warlock_buff_plus_plus', condition = 6, type = 2 },
		is_mech = { ability = 'is_mech_buff', condition = 3, type = 1 },
		is_mech1 = { ability = 'is_mech_buff_plus', condition = 6, type = 1 },
		is_assassin = { ability = 'is_assassin_buff', condition = 3, type = 1 },
		is_assassin1 = { ability = 'is_assassin_buff_plus', condition = 6, type = 2 },
		is_assassin11 = { ability = 'is_assassin_buff_plus_plus', condition = 9, type = 2 },
		is_hunter = { ability = 'is_hunter_buff', condition = 3, type = 1 },
		is_hunter1 = { ability = 'is_hunter_buff_plus', condition = 6, type = 1 },
		is_hunter11 = { ability = 'is_hunter_buff_plus_plus', condition = 9, type = 2 },
		is_knight = { ability = 'is_knight_buff', condition = 2, type = 1 },
		is_knight1 = { ability = 'is_knight_buff_plus', condition = 4, type = 2 },
		is_knight11 = { ability = 'is_knight_buff_plus_plus', condition = 6, type = 2 },
		is_shaman = {condition = 2 , type = 5},
		is_shaman1 = {condition = 4 , type = 1},
		is_shaman11 = {ability = 'is_shaman_buff_plus_plus', condition = 6 , type = 1},
		is_demonhunter = {condition = 2 , type = 1},
		is_demonhunter1 = {ability = 'is_demon_buff_plus', condition = 4 , type = 2},
		is_druid = {condition = 2, type = 1},
		is_priest = {condition = 2, type = 2},
		is_wizard = { ability = 'is_wizard_buff', condition = 2, type = 1},
		is_wizard1 = { ability = 'is_wizard_buff_plus', condition = 3, type = 1},
		is_monk = { ability = 'is_monk_buff', condition = 2, type = 1},
		is_monk1 = { ability = 'is_monk_buff_plus', condition = 4, type = 1},

		--种族技能
		is_troll = { ability = 'is_troll_buff', condition = 2, type = 2, is_race = true },
		is_troll1 = { ability = 'is_troll_buff_plus', condition = 4, type = 2, is_race = true },
		is_troll11 = { ability = 'troll_rexuezhanhun', condition = 6, type = 2, is_race = true },
		is_beast = { ability = 'is_beast_buff', condition = 2, type = 2, is_race = true },
		is_beast1 = { ability = 'is_beast_buff_plus', condition = 4, type = 2, is_race = true },
		is_beast11 = { ability = 'is_beast_buff_plus_plus', condition = 6, type = 2, is_race = true },
		is_elf = { ability = 'is_elf_buff', condition = 3, type = 1, is_race = true },
		is_elf1 = { ability = 'is_elf_buff_plus', condition = 6, type = 2, is_race = true },
		is_elf11 = { ability = 'is_elf_buff_plus_plus', condition = 9, type = 2, is_race = true },
		is_human = { ability = 'is_human_buff', condition = 3, type = 1, is_race = true },
		is_human1 = { ability = 'is_human_buff_plus', condition = 6, type = 1, is_race = true },
		is_undead = { ability = 'is_undead_buff', condition = 2, type = 3, is_race = true },
		is_undead1 = { ability = 'is_undead_buff_plus', condition = 4, type = 3, is_race = true },
		is_undead11 = { ability = 'is_undead_buff_plus_plus', condition = 6, type = 3, is_race = true },
		is_orc = { ability = 'is_orc_buff', condition = 2, type = 2, is_race = true },
		is_orc1 = { ability = 'is_orc_buff_plus', condition = 4, type = 2, is_race = true },
		is_orc11 = { ability = 'is_orc_buff_plus_plus', condition = 6, type = 2, is_race = true },
		is_naga = { ability = 'is_naga_buff', condition = 2, type = 2, is_race = true },
		is_naga1 = { ability = 'is_naga_buff_plus', condition = 4, type = 2, is_race = true },
		-- is_naga11 = { ability = 'is_naga_buff_plus_plus', condition = 6, type = 2, is_race = true },
		is_goblin = { ability = 'is_goblin_buff', condition = 3, type = 4, is_race = true },
		is_goblin1 = { ability = 'is_goblin_buff', condition = 6, type = 2, is_race = true },
		is_element = { ability = 'is_element_buff', condition = 2, type = 1, is_race = true },
		is_element1 = { ability = 'is_element_buff_plus', condition = 4, type = 2, is_race = true },
		is_demon = { ability = 'is_demon_buff', condition = 1, type = 1, is_race = true },
		is_dwarf = { ability = 'is_dwarf_buff_plus', condition = 2, type = 7, is_race = true },
		is_ogre = { ability = 'is_ogre_buff', condition = 2, type = 1, is_race = true },
		is_dragon = {condition = 3 , type = 1, is_race = true },
		is_dragon1 = {condition = 5 , type = 1, is_race = true },
		is_nraqi = { ability = 'is_nraqi_buff',condition = 1 , type = 2, is_race = true },
		is_aqir = { ability = 'is_aqir_buff', condition = 2 , type = 2, is_race = true },
		is_aqir1 = { ability = 'is_aqir_buff', condition = 4 , type = 2, is_race = true },
		is_god = { condition = 2, type = 2, is_race = true, ability_special = 'is_god_buff' },
		is_god1 = { condition = 4, type = 2, is_race = true, ability_special = 'is_god_buff_plus' },
		is_pandaman = { condition = 1, type = 1, is_race = true },
		is_pandaman1 = { condition = 2, type = 1, is_race = true },
		is_pandaman11 = { condition = 4, type = 1, is_race = true },
		is_tauren = { condition = 2, type = 0, is_race = true },
		is_tauren1 = { condition = 4, type = 0, is_race = true },
		is_kobold = { condition = 1, type = 2, is_race = true},
		is_kobold1 = { condition = 2, type = 2, is_race = true},
		is_satyr = { condition = 1, type = 0, is_race = true},
		is_draenei = { condition = 2, type = 1, is_race = true, ability = 'is_draenei_buff'},
		is_draenei1 = { condition = 4, type = 2, is_race = true, ability = 'is_draenei_buff'},
	}
	_G.class_type = {
		[201] = 'is_warrior',
		[202] = 'is_mage',
		[203] = 'is_warlock',
		[204] = 'is_mech',
		[205] = 'is_assassin',
		[206] = 'is_hunter',
		[207] = 'is_knight',
		[208] = 'is_shaman',
		[209] = 'is_demonhunter',
		[210] = 'is_priest',
		[211] = 'is_wizard',
		[212] = 'is_monk',

		[101] = 'is_troll',
		[102] = 'is_beast',
		[103] = 'is_elf',
		[104] = 'is_human',
		[105] = 'is_undead',
		[106] = 'is_orc',
		[107] = 'is_naga',
		[108] = 'is_goblin',
		[109] = 'is_element',
		[110] = 'is_demon',
		[111] = 'is_dwarf',
		[112] = 'is_ogre',
		[113] = 'is_dragon',
		[114] = 'is_druid',
		[115] = 'is_satyr',
		[116] = 'is_god',
		[117] = 'is_aqir',
		[118] = 'is_pandaman',
		[119] = 'is_tauren',
		[120] = 'is_kobold',
		[121] = 'is_nraqi',
		[122] = 'is_draenei',
	}
	_G.sm_hero_list = {
		h001 = "models/props_gameplay/donkey.vmdl",
		h002 = "models/props_gameplay/donkey_dire.vmdl",
		--普通信使 beginner
		h101 = "models/courier/skippy_parrot/skippy_parrot.vmdl",
		h102 = "models/courier/smeevil_mammoth/smeevil_mammoth.vmdl",
		h103 = "models/items/courier/arneyb_rabbit/arneyb_rabbit.vmdl",
		h104 = "models/items/courier/axolotl/axolotl.vmdl",
		h105 = "models/items/courier/coco_the_courageous/coco_the_courageous.vmdl",
		h106 = "models/items/courier/coral_furryfish/coral_furryfish.vmdl",
		h107 = "models/items/courier/corsair_ship/corsair_ship.vmdl",
		h108 = "models/items/courier/duskie/duskie.vmdl",
		h109 = "models/items/courier/itsy/itsy.vmdl",
		h110 = "models/items/courier/jumo/jumo.vmdl",
		h111 = "models/items/courier/mighty_chicken/mighty_chicken.vmdl",
		h112 = "models/items/courier/nexon_turtle_05_green/nexon_turtle_05_green.vmdl",
		h113 = "models/items/courier/pumpkin_courier/pumpkin_courier.vmdl",
		h114 = "models/items/courier/pw_ostrich/pw_ostrich.vmdl",
		h115 = "models/items/courier/scuttling_scotty_penguin/scuttling_scotty_penguin.vmdl",
		h116 = "models/items/courier/shagbark/shagbark.vmdl",
		h117 = "models/items/courier/snaggletooth_red_panda/snaggletooth_red_panda.vmdl",
		h118 = "models/items/courier/snail/courier_snail.vmdl",
		h119 = "models/items/courier/teron/teron.vmdl",
		h120 = "models/items/courier/xianhe_stork/xianhe_stork.vmdl",
		h121 = "models/items/courier/starladder_grillhound/starladder_grillhound.vmdl",
		h122 = "models/items/courier/pw_zombie/pw_zombie.vmdl",
		h123 = "models/items/courier/raiq/raiq.vmdl",
		h124 = "models/courier/frog/frog.vmdl",
		h125 = "models/courier/godhorse/godhorse.vmdl",
		h126 = "models/courier/imp/imp.vmdl",
		h127 = "models/courier/mighty_boar/mighty_boar.vmdl",
		h128 = "models/items/courier/onibi_lvl_03/onibi_lvl_03.vmdl",
		h129 = "models/items/courier/echo_wisp/echo_wisp.vmdl",  --蠕行水母
		h130 = "models/courier/sw_donkey/sw_donkey.vmdl", --驴法师new
		h131 = "models/items/courier/gnomepig/gnomepig.vmdl", --丰臀公主new
		h132 = "models/items/furion/treant/ravenous_woodfang/ravenous_woodfang.vmdl",--焚牙树精new
		h133 = "models/courier/mechjaw/mechjaw.vmdl",--机械咬人箱new
		h134 = "models/items/courier/mole_messenger/mole_messenger.vmdl",--1级矿车老鼠
		h135 = "models/items/courier/jumo_dire/jumo_dire.vmdl",
		h136 = "models/items/courier/courier_ti9/courier_ti9.vmdl",
		h137 = "models/items/courier/courier_ti9/courier_ti9_lvl2/courier_ti9_lvl2.vmdl",
		h138 = "models/props_gameplay/donkey.vmdl",
		h139 = "models/courier/gold_mega_greevil/gold_mega_greevil.vmdl",  --贪魔1
		h140 = "models/items/courier/catakeet/catakeet.vmdl",
		h141 = "models/items/courier/nexon_turtle_01_grey/nexon_turtle_01_grey.vmdl",
		h142 = "models/balloon/yun.vmdl",
		h143 = "models/balloon/pang.vmdl",
		h144 = "models/balloon/liang.vmdl",
		h145 = "models/balloon/pang.vmdl",
		h146 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant.vmdl",
		h147 = "models/items/courier/courier_ti10_dire/courier_ti10_dire.vmdl",
		h148 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h149 = "models/toon_reaper/toon_reaper.vmdl",
		h150 = "models/items/courier/autumn_wards_courier/autumn_wards_courier.vmdl",
		h151 = "models/items/courier/hand_courier/hand_courier_radiant_lv1.vmdl",
		h152 = "models/items/courier/hand_courier/hand_courier_dire_lv1.vmdl",
		h153 = "models/nian/nian.vmdl",
		
		h199 = "models/gezi/ge.vmdl",

		--小英雄信使 ameteur
		h201 = "models/courier/doom_demihero_courier/doom_demihero_courier.vmdl",
		h202 = "models/courier/huntling/huntling.vmdl",
		h203 = "models/courier/minipudge/minipudge.vmdl",
		h204 = "models/courier/seekling/seekling.vmdl",
		h205 = "models/items/courier/baekho/baekho.vmdl",
		h206 = "models/items/courier/basim/basim.vmdl",
		h207 = "models/items/courier/devourling/devourling.vmdl",
		h208 = "models/items/courier/faceless_rex/faceless_rex.vmdl",
		h209 = "models/items/courier/tinkbot/tinkbot.vmdl",
		h210 = "models/items/courier/lilnova/lilnova.vmdl",
		h211 = "models/items/courier/amphibian_kid/amphibian_kid.vmdl",
		h212 = "models/courier/venoling/venoling.vmdl",
		h213 = "models/courier/juggernaut_dog/juggernaut_dog.vmdl",
		h214 = "models/courier/otter_dragon/otter_dragon.vmdl",
		h215 = "models/items/courier/boooofus_courier/boooofus_courier.vmdl",
		h216 = "models/courier/baby_winter_wyvern/baby_winter_wyvern.vmdl",
		h217 = "models/courier/yak/yak.vmdl",
		h218 = "models/items/furion/treant/eternalseasons_treant/eternalseasons_treant.vmdl",
		h219 = "models/items/courier/blue_lightning_horse/blue_lightning_horse.vmdl",
		h220 = "models/items/courier/waldi_the_faithful/waldi_the_faithful.vmdl",
		h221 = "models/items/courier/bajie_pig/bajie_pig.vmdl",
		h222 = "models/items/courier/courier_faun/courier_faun.vmdl",
		h223 = "models/items/courier/livery_llama_courier/livery_llama_courier.vmdl",
		h224 = "models/items/courier/onibi_lvl_05/onibi_lvl_05.vmdl",
		h225 = "models/items/courier/little_fraid_the_courier_of_simons_retribution/little_fraid_the_courier_of_simons_retribution.vmdl", --胆小南瓜人
		h226 = "models/items/courier/hermit_crab/hermit_crab.vmdl", --螃蟹1
		h227 = "models/items/courier/hermit_crab/hermit_crab_boot.vmdl", --螃蟹2
		h228 = "models/items/courier/hermit_crab/hermit_crab_shield.vmdl", --螃蟹3
		h229 = "models/courier/donkey_unicorn/donkey_unicorn.vmdl", --竭智法师new
		h230 = "models/items/courier/white_the_crystal_courier/white_the_crystal_courier.vmdl", --蓝心白隼new
		h231 = "models/items/furion/treant/furion_treant_nelum_red/furion_treant_nelum_red.vmdl",--莲花人new
		h232 = "models/courier/beetlejaws/mesh/beetlejaws.vmdl",--甲虫咬人箱new
		h233 = "models/courier/smeevil_bird/smeevil_bird.vmdl",
		h234 = "models/items/courier/mole_messenger/mole_messenger_lvl4.vmdl",--蜡烛头矿车老鼠
		h235 = "models/items/courier/chocobo/chocobo.vmdl", --迅捷陆行鸟
		h236 = "models/items/courier/flightless_dod/flightless_dod.vmdl", --嘟嘟鸟
		h237 = "models/items/courier/frostivus2018_courier_serac_the_seal/frostivus2018_courier_serac_the_seal.vmdl",
		h238 = "models/items/courier/pangolier_squire/pangolier_squire.vmdl",
		h239 = "models/hujing_wangyu/hujing.vmdl",
		h240 = "models/items/courier/courier_ti9/courier_ti9_lvl3/courier_ti9_lvl3.vmdl",
		h241 = "models/items/courier/axolotl/axolotl.vmdl",
		h242 = "models/items/courier/snaggletooth_red_panda/snaggletooth_red_panda.vmdl",
		h243 = "models/items/courier/xianhe_stork/xianhe_stork.vmdl",
		h244 = "models/hy/huya.vmdl",
		h245 = "models/daxiang/daxiang.vmdl",
		h246 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h247 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h248 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h249 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h250 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h251 = "models/courier/greevil/greevil.vmdl",  --贪魔1
		h252 = "models/items/courier/catakeet/catakeet.vmdl",
		h253 = "models/items/courier/nexon_turtle_06_green/nexon_turtle_06_green.vmdl",
		h254 = "models/items/courier/supernova_rave_courier/supernova_rave_courier.vmdl",
		h255 = "models/balloon/zhai.vmdl",
		h256 = "models/balloon/dai.vmdl",
		h257 = "models/balloon/meng.vmdl",
		h258 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl2/courier_ti10_radiant_lvl2.vmdl",
		h259 = "models/items/courier/courier_ti10_dire/courier_ti10_dire_lvl2/courier_ti10_dire_lvl2.vmdl",
		h260 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h261 = "models/items/courier/roddy_the_jerboa_courier/roddy_the_jerboa_courier.vmdl",
		h262 = "models/items/courier/longear_courier_courier/longear_courier_courier.vmdl",
		h263 = "models/toon_reaper/toon_reaper.vmdl",
		h264 = "models/items/courier/dplus_zao_jun_the_stove_god/dplus_zao_jun_the_stove_god.vmdl",
		h265 = "models/items/courier/mango_the_courier/mango_the_courier.vmdl",
		h266 = "models/items/courier/spooky_tear_of_the_swamp/spooky_tear_of_the_swamp.vmdl",
		h267 = "models/items/courier/hermid/hermid.vmdl",
		h268 = "models/xuehu/xuehu_00.vmdl",
		h269 = "models/xuehu/xuehu_01.vmdl",
		h270 = "models/elong/elong.vmdl",
		h271 = "models/elong/elong.vmdl",
		h272 = "models/xuezhe/xuezhe.vmdl",
		h273 = "models/xuezhe/xuezhe.vmdl",
		h274 = "models/xiaochou/xiaochou.vmdl",
		h275 = "models/xiaochou/xiaochou.vmdl",
		h276 = "models/shayu/shayu.vmdl",
		h277 = "models/shayu/shayu.vmdl",
		h278 = "models/silingfa/silingfa.vmdl",
		h279 = "models/silingfa/silingfa.vmdl",
		h280 = "models/items/courier/hand_courier/hand_courier_radiant_lv2.vmdl",
		h281 = "models/items/courier/hand_courier/hand_courier_dire_lv3.vmdl",
		h282 = "models/nian/nian.vmdl",

		--珍藏信使 pro
		h301 = "models/items/courier/bookwyrm/bookwyrm.vmdl",
		h302 = "models/items/courier/captain_bamboo/captain_bamboo.vmdl",
		h303 = "models/items/courier/kanyu_shark/kanyu_shark.vmdl",
		h304 = "models/items/courier/tory_the_sky_guardian/tory_the_sky_guardian.vmdl",
		h305 = "models/items/courier/shroomy/shroomy.vmdl",
		h306 = "models/items/courier/courier_janjou/courier_janjou.vmdl",
		h307 = "models/items/courier/green_jade_dragon/green_jade_dragon.vmdl",
		h308 = "models/courier/drodo/drodo.vmdl",
		h309 = "models/courier/mech_donkey/mech_donkey.vmdl",
		h310 = "models/courier/donkey_crummy_wizard_2014/donkey_crummy_wizard_2014.vmdl",
		h311 = "models/courier/octopus/octopus.vmdl",
		h312 = "models/items/courier/scribbinsthescarab/scribbinsthescarab.vmdl",
		h313 = "models/courier/defense3_sheep/defense3_sheep.vmdl",
		h314 = "models/items/courier/snapjaw/snapjaw.vmdl",
		h315 = "models/items/courier/g1_courier/g1_courier.vmdl",
		h316 = "models/courier/donkey_trio/mesh/donkey_trio.vmdl",
		h317 = "models/items/courier/boris_baumhauer/boris_baumhauer.vmdl",
		h318 = "models/courier/baby_rosh/babyroshan.vmdl",
		h319 = "models/items/courier/bearzky/bearzky.vmdl",
		h320 = "models/items/courier/defense4_radiant/defense4_radiant.vmdl",
		h321 = "models/items/courier/defense4_dire/defense4_dire.vmdl",
		h322 = "models/items/courier/onibi_lvl_13/onibi_lvl_13.vmdl",
		h323 = "models/items/juggernaut/ward/fortunes_tout/fortunes_tout.vmdl", --招财猫
		h324 = "models/items/courier/hermit_crab/hermit_crab_necro.vmdl", --螃蟹4
		h325 = "models/items/courier/hermit_crab/hermit_crab_travelboot.vmdl", --螃蟹5
		h326 = "models/items/courier/hermit_crab/hermit_crab_lotus.vmdl", --螃蟹6
		h327 = "models/courier/donkey_ti7/donkey_ti7.vmdl",
		h328 = "models/items/courier/shibe_dog_cat/shibe_dog_cat.vmdl", --天猫地狗new
		h329 = "models/items/furion/treant/hallowed_horde/hallowed_horde.vmdl",--万圣树群new
		h330 = "models/courier/flopjaw/flopjaw.vmdl",--大嘴咬人箱new
		h331 = "models/courier/lockjaw/lockjaw.vmdl",--咬人箱洛克new
		h332 = "models/items/courier/butch_pudge_dog/butch_pudge_dog.vmdl",--布狗new
		h333 = "models/courier/turtle_rider/turtle_rider.vmdl",
		h334 = "models/courier/smeevil_crab/smeevil_crab.vmdl",
		h335 = "models/items/courier/mole_messenger/mole_messenger_lvl6.vmdl",--绿钻头矿车老鼠
		h336 = "models/items/courier/amaterasu/amaterasu.vmdl", --天照大神
		h337 = "models/qie/qie.vmdl",
		h338 = "models/courier/f2p_courier/f2p_courier.vmdl",
		h339 = "models/items/courier/azuremircourierfinal/azuremircourierfinal.vmdl",
		h340 = "models/items/courier/courier_ti9/courier_ti9_lvl6/courier_ti9_lvl6.vmdl",
		h341 = "models/bilibilitv/model/tv.vmdl",
		h342 = "models/courier/baby_rosh/babyroshan.vmdl",
		h343 = "models/courier/baby_rosh/babyroshan.vmdl",
		h344 = "models/courier/baby_rosh/babyroshan.vmdl",
		h345 = "models/courier/baby_winter_wyvern/baby_winter_wyvern.vmdl",
		h346 = "models/courier/beetlejaws/mesh/beetlejaws.vmdl",
		h347 = "models/courier/doom_demihero_courier/doom_demihero_courier.vmdl",
		h348 = "models/courier/huntling/huntling.vmdl",
		h349 = "models/courier/minipudge/minipudge.vmdl",
		h350 = "models/courier/seekling/seekling.vmdl",
		h351 = "models/courier/venoling/venoling.vmdl",
		h352 = "models/items/courier/axolotl/axolotl.vmdl",
		h353 = "models/items/courier/devourling/devourling.vmdl",
		h354 = "models/courier/baby_rosh/babyroshan_elemental.vmdl",
		h355 = "models/courier/baby_rosh/babyroshan_elemental.vmdl",
		h356 = "models/hujing_wangyu/hujing.vmdl",
		h357 = "models/rongyanquan/rongyanquan.vmdl",
		h358 = "models/courier/greevil/greevil.vmdl",  --贪魔3
		h359 = "models/courier/greevil/greevil.vmdl",  --贪魔2
		h360 = "models/items/courier/catakeet/catakeet.vmdl",
		h361 = "models/items/courier/nexon_turtle_11_blue/nexon_turtle_11_blue.vmdl",
		h362 = "models/balloon/hu.vmdl",
		h363 = "models/balloon/qiang.vmdl",
		h364 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl4/courier_ti10_radiant_lvl4.vmdl",
		h365 = "models/items/courier/courier_ti10_dire/courier_ti10_dire_lvl4/courier_ti10_dire_lvl4.vmdl",
		h366 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h367 = "models/items/courier/clockwerks_orange/clockwerks_orange.vmdl",
		h368 = "models/items/courier/enno_the_underlord/enno_the_underlord.vmdl",
		h369 = "models/items/courier/happy_koala/happy_koala.vmdl",
		h370 = "models/items/courier/courier_fall20/courier_fall20.vmdl",
		h371 = "models/toon_reaper/toon_reaper.vmdl",
		h372 = "models/items/courier/loco_the_crocodile_courier/loco_the_crocodile_courier.vmdl",
		h373 = "models/xuehu/xuehu_02.vmdl",
		h374 = "models/elong/elong.vmdl",
		h375 = "models/xuezhe/xuezhe.vmdl",
		h376 = "models/xiaochou/xiaochou.vmdl",
		h377 = "models/items/courier/owl_courier/owl_courier.vmdl",
		h378 = "models/shayu/shayu.vmdl",
		h379 = "models/silingfa/silingfa.vmdl",
		h380 = "models/danshengou/gou.vmdl",
		h381 = "models/items/courier/hand_courier/hand_courier_radiant_lv6.vmdl",
		h382 = "models/items/courier/hand_courier/hand_courier_dire_lv5.vmdl",
		h383 = "models/nian/nian.vmdl",
		

		h398 = "models/guge/guge.vmdl",
		h397 = "models/guge/guge.vmdl",
		h399 = "models/courier/baby_rosh/babyroshan_winter18.vmdl",--姜饼肉山

		--战队信使 master
		h401 = "models/courier/navi_courier/navi_courier.vmdl",
		h402 = "models/items/courier/courier_mvp_redkita/courier_mvp_redkita.vmdl",
		h403 = "models/items/courier/ig_dragon/ig_dragon.vmdl",
		h404 = "models/items/courier/lgd_golden_skipper/lgd_golden_skipper.vmdl",
		h405 = "models/items/courier/vigilante_fox_red/vigilante_fox_red.vmdl",
		h406 = "models/items/courier/virtus_werebear_t3/virtus_werebear_t3.vmdl",
		h407 = "models/items/courier/throe/throe.vmdl",
		h408 = "models/items/courier/vaal_the_animated_constructradiant/vaal_the_animated_constructradiant.vmdl",
		h409 = "models/items/courier/vaal_the_animated_constructdire/vaal_the_animated_constructdire.vmdl",
		h410 = "models/items/courier/carty/carty.vmdl",
		h411 = "models/items/courier/carty_dire/carty_dire.vmdl",
		h412 = "models/items/courier/dc_angel/dc_angel.vmdl",
		h413 = "models/items/courier/dc_demon/dc_demon.vmdl",
		h414 = "models/items/courier/vigilante_fox_green/vigilante_fox_green.vmdl",
		h415 = "models/items/courier/bts_chirpy/bts_chirpy.vmdl",
		h416 = "models/items/courier/krobeling/krobeling.vmdl",
		h417 = "models/items/courier/jin_yin_black_fox/jin_yin_black_fox.vmdl",
		h418 = "models/items/courier/jin_yin_white_fox/jin_yin_white_fox.vmdl",
		h419 = "models/items/courier/fei_lian_blue/fei_lian_blue.vmdl",
		h420 = "models/items/courier/gama_brothers/gama_brothers.vmdl",
		h421 = "models/items/courier/onibi_lvl_21/onibi_lvl_21.vmdl",
		h422 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl", --小飞侠
		h423 = "models/items/courier/hermit_crab/hermit_crab_octarine.vmdl", --螃蟹7
		h424 = "models/items/courier/hermit_crab/hermit_crab_skady.vmdl", --螃蟹8
		h425 = "models/items/courier/hermit_crab/hermit_crab_aegis.vmdl", --螃蟹9
		h426 = "models/items/furion/treant_flower_1.vmdl",--绽放树精new
		h427 = "models/courier/smeevil_magic_carpet/smeevil_magic_carpet.vmdl",
		h428 = "models/items/courier/mole_messenger/mole_messenger_lvl7.vmdl",--绿钻头金矿车老鼠
		h499 = "models/items/courier/krobeling_gold/krobeling_gold.vmdl",--金dp
		h429 = "models/items/courier/nilbog/nilbog.vmdl",--贪小疯魔
		h430 = "models/courier/frull/frull_courier.vmdl", --灵犀弗拉尔
		h431 = "models/items/courier/sltv_10_courier/sltv_10_courier.vmdl", --黄油小生
		h432 = "models/items/courier/nian_courier/nian_courier.vmdl", --年兽宝宝
		h433 = "models/courier/baby_rosh/babyroshan_ti9.vmdl",
		h434 = "models/items/courier/courier_ti9/courier_ti9_lvl7/courier_ti9_lvl7.vmdl",
		h435 = "models/shudaixiong/model/shudaixiong/shudaixiong.vmdl",
		h436 = "models/courier/baby_rosh/babyroshan.vmdl",
		h437 = "models/courier/baby_rosh/babyroshan.vmdl",
		h438 = "models/courier/baby_winter_wyvern/baby_winter_wyvern.vmdl",
		h439 = "models/courier/flopjaw/flopjaw.vmdl",
		h440 = "models/courier/juggernaut_dog/juggernaut_dog.vmdl",
		h441 = "models/courier/smeevil_crab/smeevil_crab.vmdl",
		h442 = "models/items/courier/axolotl/axolotl.vmdl",
		h443 = "models/items/courier/fei_lian_blue/fei_lian_blue.vmdl",
		h444 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl",
		h445 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl",
		h446 = "models/items/courier/wabbit_the_mighty_courier_of_heroes/wabbit_the_mighty_courier_of_heroes.vmdl",
		h447 = "models/jieke/jieke.vmdl",
		h448 = "models/courier/greevil/gold_greevil.vmdl",  --贪魔4
		h449 = "models/douyu/douyu.vmdl", --斗鱼信使
		h450 = "models/items/courier/catakeet/catakeet.vmdl",
		h451 = "models/items/courier/nexon_turtle_15_red/nexon_turtle_15_red.vmdl",
		h452 = "models/items/courier/nexon_turtle_17_gold/nexon_turtle_17_gold.vmdl",
		h453 = "models/balloon/ou.vmdl",
		h454 = "models/balloon/shen.vmdl",
		h455 = "models/balloon/shuai.vmdl",
		h456 = "models/items/courier/onibi_lvl_20/onibi_lvl_20.vmdl",
		h457 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl5/courier_ti10_radiant_lvl5.vmdl",
		h458 = "models/items/courier/courier_ti10_dire/courier_ti10_dire_lvl5/courier_ti10_dire_lvl5.vmdl",
		h459 = "models/items/courier/courier_ti10_radiant/courier_ti10_radiant_lvl7/courier_ti10_radiant_lvl7.vmdl",
		h460 = "models/qiyidan_s2/qiyidan_s2.vmdl",
		h461 = "models/courier/baby_rosh/babyroshan_ti10.vmdl",
		h462 = "models/courier/baby_rosh/babyroshan_ti10_dire.vmdl",
		h463 = "models/items/courier/leafy_the_sea_dragon_courier_courier/leafy_the_sea_dragon_courier_courier.vmdl",
		h464 = "models/items/courier/ol_dirty_boot_courier_courier/ol_dirty_boot_courier_courier.vmdl",
		h465 = "models/items/juggernaut/ward/fortunes_tout/fortunes_tout.vmdl",
		h466 = "models/toon_reaper/toon_reaper.vmdl",
		h467 = "models/items/courier/frosty_the_courier/frosty_the_courier.vmdl",
		h468 = "models/xuehu/xuehu_03.vmdl",
		h469 = "models/elong/elong.vmdl",
		h470 = "models/xuezhe/xuezhe.vmdl",
		h471 = "models/xuezhe/xuezhe01.vmdl",
		h472 = "models/xiaochou/xiaochou.vmdl",
		h473 = "models/shayu/shayu.vmdl",
		h474 = "models/shayu/shayu.vmdl",
		h475 = "models/silingfa/silingfa_gold.vmdl",
		h476 = "models/items/courier/hand_courier/hand_courier_dire_lv7.vmdl",
		h477 = "models/courier/aghanim_courier/aghanim_courier.vmdl",
		h478 = "models/nian/nian.vmdl",
	}
	_G.sm_hero_size = {
		h001 = 1,
		h002 = 1,
		--普通信使 beginner
		h101 = 1.1,
		h102 = 1.1,
		h103 = 1.1,
		h104 = 1,
		h105 = 1,
		h106 = 1,
		h107 = 1.2,
		h108 = 1,
		h109 = 1.1,
		h110 = 1.1,
		h111 = 1.1,
		h112 = 1.2,
		h113 = 1,
		h114 = 1.2,
		h115 = 1.2,
		h116 = 1,
		h117 = 1.3,
		h118 = 1.1,
		h119 = 1.3,
		h120 = 1.3,
		h121 = 1.1,
		h122 = 1.1,
		h123 = 1.2,
		h124 = 1,
		h125 = 1,
		h126 = 1,
		h127 = 1,
		h128 = 1.1,
		h129 = 1.2,  --蠕行水母
		h130 = 1, --驴法师new
		h131 = 1, --丰臀公主new
		h132 = 0.7,--焚牙树精new
		h133 = 1.1,--机械咬人箱new
		h134 = 1.1,--1级矿车老鼠
		h135 = 1.1,
		h136 = 1.1,
		h137 = 1.15,
		h138 = 1.15,
		h139 = 1.4,
		h140 = 1.45,
		h141 = 1.45,
		h142 = 1.3,
		h143 = 1.3,
		h144 = 1.3,
		h145 = 1.3,
		h146 = 0.95,
		h147 = 0.95,

		h199 = 1.5,
		--小英雄信使 ameteur
		h201 = 1.2,
		h202 = 1.2,
		h203 = 1.2,
		h204 = 1.2,
		h205 = 1.2,
		h206 = 1.2,
		h207 = 1.2,
		h208 = 1.3,
		h209 = 1.2,
		h210 = 1.25,

		h211 = 1.2,
		h212 = 1.1,
		h213 = 1,
		h214 = 1.25,
		h215 = 1.2,
		h216 = 1.25,
		h217 = 1.2,
		h218 = 1.1,
		h219 = 1.2,
		h220 = 1.25,
		h221 = 1.25,
		h222 = 1.3,
		h223 = 1.15,
		h224 = 1.25,
		h225 = 1.3, --胆小南瓜人
		h226 = 1.3, --螃蟹1
		h227 = 1.3, --螃蟹2
		h228 = 1.2, --螃蟹3

		h229 = 1.2, --竭智法师new
		h230 = 1.3, --蓝心白隼new
		h231 = 0.8,--莲花人new
		h232 = 1.2,--甲虫咬人箱new
		h233 = 1.2,
		h234 = 1.2,--蜡烛头矿车老鼠
		h235 = 1.2, --迅捷陆行鸟
		h236 = 1.2, --嘟嘟鸟
		h237 = 1.2,
		h238 = 0.7,
		h239 = 1.4,
		h240 = 1.25,
		h241 = 1.1,
		h242 = 1.4,
		h243 = 1.4,
		h244 = 2.5,
		h245 = 0.9,
		h246 = 1.2,
		h247 = 1.2,
		h248 = 1.2,
		h249 = 1.2,
		h250 = 1.2,
		h251 = 1.2,
		h252 = 1.5,
		h253 = 1.45,
		h254 = 1.15,
		h255 = 1.4,
		h256 = 1.4,
		h257 = 1.4,
		h258 = 1,
		h259 = 1,
		h261 = 1.2,
		h262 = 1.1,

		--珍藏信使 pro
		h301 = 1.3,
		h302 = 1.3,
		h303 = 1.3,
		h304 = 1.35,
		h305 = 1.3,
		h306 = 1.3,
		h307 = 1.3,
		h308 = 1.3,
		h309 = 1.2,

		h310 = 1.2,
		h311 = 1.25,
		h312 = 1.3,
		h313 = 1.3,
		h314 = 1.3,
		h315 = 1.25,
		h316 = 1.3,
		h317 = 1.4,
		h318 = 1.25,
		h319 = 1.3,
		h320 = 1.3,
		h321 = 1.3,
		h322 = 1.3,
		h323 = 1.1, --招财猫
		h324 = 1.3, --螃蟹4
		h325 = 1.25, --螃蟹5
		h326 = 1.25, --螃蟹6
		h327 = 1.25,

		h328 = 1.3, --天猫地狗new
		h329 = 0.9,--万圣树群new
		h330 = 1.3,--大嘴咬人箱new
		h331 = 1.25,--咬人箱洛克new
		h332 = 1.3,--布狗new
		h333 = 1.3,
		h334 = 1.3,
		h335 = 1.1,--绿钻头矿车老鼠
		h336 = 1.15, --天照大神
		h337 = 1.4,
		h338 = 1.3,
		h339 = 1.4,
		h340 = 1.3,
		h341 = 2.3,
		h342 = 1.25,
		h343 = 1.25,
		h344 = 1.25,
		h354 = 1.25,
		h355 = 1.25,
		h345 = 1.35,
		h346 = 1.3,
		h347 = 1.3,
		h348 = 1.3,
		h349 = 1.3,
		h350 = 1.3,
		h351 = 1.2,
		h352 = 1.2,
		h353 = 1.3,
		h356 = 1.45,
		h357 = 1.3,
		h358 = 1.25,
		h359 = 1.25,
		h360 = 1.55,
		h361 = 1.5,
		h362 = 1.5,
		h363 = 1.5,
		h364 = 1.05,
		h365 = 1.05,
		h369 = 1.3,
		h368 = 1.25,
		h367 = 1.5,
		h370 = 1,

		h399 = 1.17,--姜饼肉山

		--战队信使 master
		h401 = 1.4,
		h402 = 1.4,
		h403 = 1.4,
		h404 = 1.55,
		h405 = 1.4,
		h406 = 1.5,
		h407 = 1.3,

		h408 = 1.35,
		h409 = 1.35,
		h410 = 1.3,
		h411 = 1.3,
		h412 = 1.3,
		h413 = 1.3,
		h414 = 1.4,
		h415 = 1.35,
		h416 = 1.4,
		h417 = 1.4,
		h418 = 1.4,
		h419 = 1.4,
		h420 = 1.2,
		h421 = 1.35,
		h422 = 1.4, --小飞侠
		h423 = 1.3, --螃蟹7
		h424 = 1.3, --螃蟹8
		h425 = 1.35, --螃蟹9

		h426 = 1.1,--绽放树精new
		h427 = 1.55,
		h428 = 1.2,--绿钻头金矿车老鼠

		h499 = 1.55,--金dp
		h429 = 1.3,--贪小疯魔

		h430 = 1.3, --灵犀弗拉尔
		h431 = 1.2, --黄油小生
		h432 = 1.3, --年兽宝宝
		h433 = 1.3,
		h434 = 1.4,
		h435 = 1.0,
		h438 = 1.45,
		h439 = 1.35,
		h440 = 1.2,
		h441 = 1.4,
		h442 = 1.3,
		h444 = 1.4,
		h445 = 1.4,
		h446 = 1.4,
		h443 = 1.4,
		h436 = 1.35,
		h437 = 1.35,
		h447 = 1.15,
		h448 = 1.5,
		h449 = 1.1,
		h450 = 1.6,
		h451 = 1.55,
		h452 = 1.55,
		h453 = 1.6,
		h454 = 1.6,
		h455 = 1.6,
		h456 = 1.4,
		h457 = 1.1,
		h458 = 1.1,
		h459 = 1.15,

		h398 = 1.15,
		h397 = 1.15,

		h148 = 2.0,
		h260 = 2.2,
		h366 = 2.4,
		h460 = 2.6,
		h461 = 1.35,
		h462 = 1.35,
		h463 = 1.3,
		h464 = 1.15,
		h465 = 1.15, --招财猫

		h149 = 0.6,
		h263 = 0.6,
		h371 = 0.65,
		h466 = 0.65,

		h150 = 1.3,
		h264 = 1.6,
		h265 = 1.3,
		h266 = 1.3,
		h267 = 1.1,
		h372 = 1.25,
		h467 = 1.3,

		h268 = 1.1,
		h269 = 1.1,
		h373 = 1.15,
		h468 = 1.2,

		h270 = 1.4,
		h271 = 1.4,
		h374 = 1.5,
		h469 = 1.6,

		h272 = 1.4,
		h273 = 1.4,
		h375 = 1.5,
		h470 = 1.6,
		h471 = 1.55,

		h274 = 1.1,
		h275 = 1.1,
		h376 = 1.18,
		h472 = 1.25,

		h377 = 1.0,

		h276 = 1.1,
		h277 = 1.1,
		h378 = 1.2,
		h473 = 1.3,
		h474 = 1.3,

		h278 = 1.2,
		h279 = 1.2,
		h379 = 1.25,
		h475 = 1.3,
		h380 = 1,

		h151 = 1.1,
		h152 = 1.1,
		h280 = 1.2,
		h281 = 1.2,
		h381 = 1.3,
		h382 = 1.3,
		h476 = 1.4,
		h477 = 1.2,

		h153 = 1.2,
		h282 = 1.3,
		h383 = 1.4,
		h478 = 1.5,
	}
	_G.sm_hero_flyup_size = {
		h268 = 0.85,
		h269 = 0.85,
		h373 = 0.85,
		h468 = 0.85,
	}
	_G.sm_hero_list_skin = {
		h138 = 1,
		h436 = 1,
		h437 = 2,
		h342 = 3,
		h343 = 4,
		h344 = 5,
		h354 = 1,
		h355 = 2,
		h345 = 1,
		h438 = 2,
		h346 = 1,
		h347 = 1,
		h348 = 1,
		h440 = 1,
		h349 = 1,
		h350 = 1,
		h441 = 1,
		h351 = 1,

		h241 = 1,
		h352 = 2,
		h442 = 3,
		h353 = 1,
		h242 = 1,
		h444 = 1,
		h445 = 2,
		h446 = 3,
		h243 = 1,
		h443 = 1,
		h439 = 1,
		h356 = 1,
		h397 = 1,
		h145 = 1,

		h148 = 3,
		h260 = 2,
		h366 = 1,
		h460 = 0,
		h465 = 1,

		h149 = 1,
		h263 = 2,
		h371 = 0,
		h466 = 3,

		h268 = 0,
		h269 = 1,
		h373 = 2,
		h468 = 3,

		h270 = 2,
		h271 = 0,
		h374 = 1,
		h469 = 3,

		h272 = 0,
		h273 = 1,
		h375 = 2,
		h470 = 3,
		h471 = 0,

		h274 = 0,
		h275 = 1,
		h376 = 2,
		h472 = 3,

		h276 = 2,
		h277 = 3,
		h378 = 0,
		h473 = 1,
		h474 = 4,

		h278 = 2,
		h279 = 1,
		h379 = 0,
		h475 = 0,

		h153 = 2,
		h282 = 1,
		h383 = 3,
		h478 = 0,
	}
	_G.courier_flyup_effect_list = {
		h208 = "effect/xukong/cour_rex_flying.vpcf",
		h432 = "effect/nianshou/courier_nian_ambient.vpcf",
		h499 = "effect/jin_dp/courier_krobeling_gold_ambient.vpcf",
		h399 = "effect/jiangbing/1.vpcf",
		h308 = "effect/drodo/1.vpcf",
		h199 = "effect/gewugu/3.vpcf",
		h239 = "effect/wangyu/1.vpcf",
		h303 = "effect/douyu/2.vpcf",
		h433 = "effect/roshan_ti9/1.vpcf",
		h341 = "effect/music/1.vpcf",
		h354 = "effect/lava_roshan/1.vpcf",
		h355 = "effect/frost_roshan/ambient.vpcf",
		h342 = "effect/darkmoon_roshan/1.vpcf",
		h343 = "effect/sand_roshan/baby_roshan_desert_sands_ambient.vpcf",
		h344 = "effect/biyu_roshan/1.vpcf",
		h436 = "effect/golden_roshan/ambient.vpcf",
		h437 = "effect/platinum_roshan/ambient.vpcf",
		h438 = "effect/golden_ww/1.vpcf",
		h439 = "effect/gold_angel/angels.vpcf",
		h440 = "effect/liansai_dog/1.vpcf",
		h441 = "effect/liansai_dog2/1.vpcf",
		h446 = "effect/wabbit/lvl3.vpcf",
		h244 = "effect/chongya/1econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship_marker.vpcf",
		h425 = "effect/xiexiaowo_guanjundun/1.vpcf",
		h434 = "effect/jinguizi/base.vpcf",
		h356 = "effect/wangyu/1.vpcf",
		-- h245 = "effect/xiaoxiang/pnt.vpcf",
		h397 = "effect/googie/397.vpcf",
		h398 = "effect/googie/398.vpcf",

		h358 = "particles/econ/courier/courier_greevil_white/courier_greevil_white_ambient_3.vpcf",
		h359 = "particles/econ/courier/courier_greevil_black/courier_greevil_black_ambient_3_parent.vpcf",
		h448 = "effect/golden_roshan/ambient.vpcf",
		h450 = "effect/mao/2.vpcf",
		h346 = "effect/golden_roshan/ambient.vpcf",
		h456 = "effect/golden_roshan/ambient.vpcf",
		h461 = "effect/roshan_ti10/flying.vpcf",
		h462 = "effect/roshan_ti10/dire/flying.vpcf",
		h465 = "effect/golden_roshan/ambient.vpcf",
		h466 = "effect/ground_gold/1.vpcf",
		h468 = "effect/mao/2.vpcf",
		h469 = "effect/elong/2.vpcf",
		h457 = "effect/qinger/whilt/ti10_lvl4_ambient_fly.vpcf",
		h458 = "effect/qinger/black/ti10_lvl4_dire_ambient_fly.vpcf",

		h276 = "effect/shayu/3old.vpcf",
		h277 = "effect/shayu/3old.vpcf",
		h378 = "effect/shayu/3old.vpcf",
		h473 = "effect/shayu/3old.vpcf",
		h474 = "effect/shayu/3old.vpcf",
	}
	_G.courier_ground_effect_list = {
		h199 = "effect/gewugu/2.vpcf",
		h303 = "particles/gem/brewmaster_drunken_haze_debuff_bubbles_2.vpcf",
		h397 = "effect/googie/397.vpcf",
		h398 = "effect/googie/398.vpcf",
		h425 = "effect/yuhuofenshen/1_2_embers.vpcf",
		h434 = "effect/yuhuofenshen/1_2_embers.vpcf",
		h357 = "effect/ronghuo_equan/fire.vpcf",
		h356 = "particles/econ/events/ti7/golden_treasure_ti7_ambient_magic.vpcf",
		h349 = "particles/econ/courier/courier_minipudge/courier_minipudge_ambient.vpcf",
		h450 = "effect/mao/1.vpcf",
		h456 = "effect/yuhuofenshen/1_2_embers.vpcf",
		h466 = "effect/ground_gold/1.vpcf",
		h468 = "effect/mao/1.vpcf",
		h469 = "effect/elong/1.vpcf",
		h276 = "effect/shayu/3old.vpcf",
		h277 = "effect/shayu/3old.vpcf",
		h378 = "effect/shayu/3old.vpcf",
		h473 = "effect/shayu/3old.vpcf",
		h474 = "effect/shayu/3old.vpcf",
	}
	_G.pet_list = {
		t101 = "models/qiyidan/qiyidan.vmdl", --奇异蛋圆圆
		t102 = "models/fatiao/fatiao.vmdl", --霸天者11型
		t103 = "models/pets/icewrack_wolf/icewrack_wolf.vmdl", --莉莱的单身狗
		t104 = "models/pets/armadillo/armadillo.vmdl", --小穿山迪洛
		t105 = "models/huaxiyi/huaxiyi.vmdl",--花蜥蜥

		t201 = "models/hailuomei/hailuomei.vmdl", --海螺妹娜娜
		t202 = "models/dujiaoshou/dujiaoshou.vmdl", --独角兽悠妮空
		t203 = "models/rongyanquan/rongyanquan.vmdl",--熔火恶犬
		t204 = "models/heroes/invoker_kid/invoker_kid_trainer_dragon.vmdl", --失落奇艺小龙
		
		t301 = "models/duye/duye.vmdl", --毒液波索拉贡
		t302 = "models/jinlinglong/h018s1.vmdl", --光羽龙帕拉贡
		t303 = "models/tuzimei/tuzimei.vmdl", --兔耳弩手婉
		t304 = "models/laoge/h30.vmdl", --老鸽婺
		t305 = "models/bose/bose01.vmdl", --哥布霍马

		t401 = "models/drodo/drodo.vmdl", --小鸟多多
		t402 = "models/creeps/greevil_shopkeeper/greevil_shopkeeper.vmdl",  --贪魔舞者	
	}
	_G.pet_size_list = {
		t101 = 1.4,
		t102 = 0.8,
		t103 = 1.2,
		t104 = 1.05,
		t201 = 1.5,
		t202 = 1,
		t203 = 1,
		t204 = 0.9,
		t301 = 0.9,
		t302 = 1.6,
		t303 = 1.2,
		t304 = 2.3,
		t305 = 0.6,

		t401 = 1.3,
		t402 = 1,
	}
	_G.user_setting = {}
	_G.greevil_list = {
		--贪魔
		h246 = {
			skin = 1,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth1.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h247 = {
			skin = 2,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth1.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h248 = {
			skin = 3,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth1.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h249 = {
			skin = 4,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth2.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h250 = {
			skin = 5,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth2.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h251 = {
			skin = 6,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears1.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose1.vmdl",
			part5 = "models/courier/greevil/greevil_tail2.vmdl",
			part6 = "models/courier/greevil/greevil_teeth2.vmdl",
			part7 = "models/courier/greevil/greevil_wings1.vmdl",
		},
		h358 = {
			skin = 7,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears2.vmdl",
			part3 = "models/courier/greevil/greevil_horns2.vmdl",
			part4 = "models/courier/greevil/greevil_nose3.vmdl",
			part5 = "models/courier/greevil/greevil_tail3.vmdl",
			part6 = "models/courier/greevil/greevil_teeth3.vmdl",
			part7 = "models/courier/greevil/greevil_wings3.vmdl",
		},
		h359 = {
			skin = 8,
			part1 = "models/courier/greevil/greevil_eyes.vmdl",
			part2 = "models/courier/greevil/greevil_ears2.vmdl",
			part3 = "models/courier/greevil/greevil_horns3.vmdl",
			part4 = "models/courier/greevil/greevil_nose2.vmdl",
			part5 = "models/courier/greevil/greevil_tail4.vmdl",
			part6 = "models/courier/greevil/greevil_teeth4.vmdl",
			part7 = "models/courier/greevil/greevil_wings2.vmdl",
			part8 = "models/courier/greevil/greevil_feathers.vmdl",
		},
		--猫
		h140 = {
			skin = 1,
			part1 = "models/items/courier/catakeet/catakeet_head_curious.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_curious.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
		},
		h252 = {
			skin = 5,
			part1 = "models/items/courier/catakeet/catakeet_head_curious.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_good.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
		},
		h360 = {
			skin = 9,
			part1 = "models/items/courier/catakeet/catakeet_head_sly.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_sly.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
			part4 = "models/items/courier/catakeet/catakeet_wings_sly.vmdl",
		},
		h450 = {
			skin = 3,
			part1 = "models/items/courier/catakeet/catakeet_head_evil.vmdl",
			part2 = "models/items/courier/catakeet/catakeet_tail_evil.vmdl",
			part3 = "models/items/courier/catakeet/catakeet_boxes.vmdl",
			part4 = "models/items/courier/catakeet/catakeet_wings_evil.vmdl",
		},
	}
	--从kv文件读取物品合成配方
	_G.basic_recipe = {}
	_G.item_recipe = {}
	for k,v in pairs(LoadKeyValues("scripts/npc/npc_items_custom.txt")) do
		if string.find(k,'recipe') then
			_G.basic_recipe[v['ItemResult']] = v['ItemRequirements']['01']
			_G.item_recipe[v['ItemResult']] = v['ItemRequirements']['01']
		end
	end
	--basic配方变成最碎
	for k,v in pairs(_G.basic_recipe) do
		_G.basic_recipe[k] = Items2Recipe(v)
	end
	-- 从kv文件读取信使、特效、弹道、宠物等列表
	_G.animation_list = LoadKeyValues("scripts/npc/dac_animation.txt")
	_G.effect_list = LoadKeyValues("scripts/npc/dac_effect.txt")
	_G.projectile_list = LoadKeyValues("scripts/npc/dac_projectile.txt")
	_G.chessboard_list = LoadKeyValues("scripts/npc/dac_chessboard.txt")

	CustomNetTables:SetTableValue( "chess_pool_table", "chess_list_by_mana", _G.chess_list_by_mana)
	CustomNetTables:SetTableValue( "chess_pool_table", "chess_list_by_mana_black", _G.chess_list_by_mana_black)
	CustomNetTables:SetTableValue( "chess_pool_table", "drop_item_list_by_mana", _G.DROP_ITEM_LIST)
	CustomNetTables:SetTableValue( "chess_pool_table", "combined_item_list_by_mana", _G.COMBINED_ITEM_LIST)
	CustomNetTables:SetTableValue( "chess_pool_table", "food_list", _G.ITEM_FOOD_LIST)
	CustomNetTables:SetTableValue( "chess_pool_table", "relic_list", _G.DROP_RELIC_LIST)

	AMHCInit()
	InitHPBarTable()
	LimitPathingSearchDepth(1)
	InitDeathTable()
	InitChessListByLevel()
	--TODO 将courier、pet也搬运到kv，然后在这里load
end
--2、自动选择小精灵作为信使
function DAC:OnPlayerPickHero(keys)
	if IsServer() == true then
		local player = EntIndexToHScript(keys.player)
	    local hero = EntIndexToHScript(keys.heroindex)

		if player == nil or hero == nil then
			return
		end

	    local children = hero:GetChildren()
	    for k,child in pairs(children) do
	       if child:GetClassname() == "dota_item_wearable" then
	           child:RemoveSelf()
	       end
	    end
	    for slot=0,9 do
			if hero:GetItemInSlot(slot)~= nil then
				hero:RemoveItem(hero:GetItemInSlot(slot))
			end
		end
	    hero:SetHullRadius(1)
	    hero:SetAbilityPoints(0)
	    for i=1,16 do
	    	hero:RemoveAbility("empty"..i)
	    end

		hero:SetMana(0)
		hero:SetStashEnabled(false)
		AddAbilityAndSetLevel(hero,'no_hp_bar')

		hero:RemoveModifierByName('modifier_wisp_tentacles')

		hero.team = hero:GetTeam()
		hero.team_id = hero:GetTeam()
		hero.is_auto_combine = 1

		--设置玩家颜色
		-- PlayerResource:SetCustomPlayerColor(hero:GetPlayerID(),_G.team_color[hero:GetTeam()].r,_G.team_color[hero:GetTeam()].g,_G.team_color[hero:GetTeam()].b)
		-- prt('player:GetPlayerID()='..player:GetPlayerID())

		_G.team2playerid[hero:GetTeam()] = player:GetPlayerID()
		_G.counterpart[hero:GetTeam()] = 0
		_G.playerid2team[player:GetPlayerID()] = hero:GetTeam()

		--将所有玩家的英雄存到一个数组
		local heroindex = keys.heroindex
	    _G.hero[heroindex] = EntIndexToHScript(heroindex)
	    _G.playerid2hero[player:GetPlayerID()] = EntIndexToHScript(heroindex)
	    _G.teamid2hero[hero:GetTeam()] = EntIndexToHScript(heroindex)
	    local playercount = 0
	    for i,vi in pairs(_G.hero) do
	    	playercount = playercount +1
	    end

	    local all_playing_player_count = GetPlayingPlayerCount()
	    combat("PLAYER JOINED: "..playercount.."/".._G.playing_player_count)

	    if playercount == all_playing_player_count then
	    	--所有玩家都连进来了，准备开始游戏
	    	InitPlayerIDTable()
	    	InitChessboards()

	    	Timers:CreateTimer(0.1,function()
	    		-- EmitGlobalSound("diretide.begin")
	    		EmitGlobalSound('dac.season.gamestart')
	    		-- Timers:CreateTimer(4,function()
	    		-- 	EmitGlobalSound("welcome.crystal_maiden")
	    		-- end)
	    		UpdatePlayerWorldPanel()
	    		InitHeros()
	    	end)
	    end 


		-- Timers:CreateTimer(1,function()
		-- 	local p = Entities:FindByName(nil,'center'..(hero:GetTeam()-6)):GetAbsOrigin()
		-- 	if (p - hero:GetAbsOrigin()):Length2D() > 1000 then
		-- 		FindClearSpaceForUnit(hero,p,true)
		-- 	end
		-- 	return 1
		-- end)
	end
end
--3、初始化个人信使和获取服务器个人信息
function InitHeros()
	--拼接要向服务器发送的steamid数据
	for pid,sid in pairs(_G.playerid2steamid) do
		if PlayerResource:GetTeam(pid) >= 6 and PlayerResource:GetTeam(pid) <= 13 then
			
			table.insert(_G.send_status,sid)
			_G.upload_detail_stat[sid] = {}
			if _G.playerid2hero[pid] ~= nil then
				if _G.steamidlist == '' then
					_G.steamidlist = sid
					_G.steamidlist_heroindex = sid..'_'.._G.playerid2hero[pid]:entindex()
				else
					_G.steamidlist = _G.steamidlist..','..sid
					_G.steamidlist_heroindex = _G.steamidlist_heroindex..','..sid..'_'.._G.playerid2hero[pid]:entindex()
				end
				if PlayerResource:HasCustomGameTicketForPlayerID ( pid ) == true then
					_G.steamidlist_heroindex = _G.steamidlist_heroindex..'_vip'
				else
					_G.steamidlist_heroindex = _G.steamidlist_heroindex..'_notvip'
				end

				local curr_courier = GetCourierInfo(pid)
				if curr_courier ~= nil then
					_G.steamidlist_heroindex = _G.steamidlist_heroindex..'_|'..curr_courier
					--用|分割是因为courier里面带_，会被截断
				end

			end
		end
	end
	if string.find(_G.steamidlist,'76561198101849234') or string.find(_G.steamidlist,'76561198090961025') or string.find(_G.steamidlist,"76561198090931971") or string.find(_G.steamidlist,"76561198132023205") or string.find(_G.steamidlist,"76561198079679584") or string.find(_G.steamidlist,"76561198069865383") then
		_G.myself = true
	end
	
	if IsInToolsMode() == true then
		combat('WORKSHOP TOOL MODE')
		_G.myself = true
	end
	--防控制台作弊
	if _G.myself ~= true then
		Timers:CreateTimer(1,function()
			if GameRules:IsCheatMode() == true then
				combat('CHEAT MODE! BYEBYE')
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)				
				return
			end
			return 5
		end)
	end

	if _G.playing_player_count == 0 then
		--没有玩家，这局凉了
		Timers:CreateTimer(30,function()
			GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)				
		end)
		return
	end

	_G.cloudlineup = {}
	if _G.playing_player_count == 1 then
		--单人获取云对战列表
		local url = "http://autochess.ppbizon.com/lineup/get?hehe="..RandomInt(1,10000)
		SendHTTP(url..	"&from=InitHeros&difficulty=".._G.difficulty, function(t)
			if t ~= nil then
				combat('LOAD CLOUD LINEUP OK!')
				_G.cloudlineup = t.data
			end
		end)
	end

	--收集玩家的语言
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"request_player_language",{
			key = GetClientKey(team_i),
			hehe = RandomInt(1,100000),
		})
	end

	--从服务器获取玩家信息
	local url = "http://autochess.ppbizon.com/game/new/@".._G.steamidlist_heroindex.."?hehe="..RandomInt(1,10000)..GetSendKey()
	SendHTTP(url.."&from=InitHeros", function(t)
		if t ~= nil and t.err == 0 then
			combat('CONNECT SERVER OK!')

			local gameinfo_have_author = false
			local gameinfo_have_tester = false

			--游戏版本（dist/test/unknown）
			if t.game_version ~= nil then
				print('game_version='..t.game_version)
				CustomNetTables:SetTableValue( "game_info", "game_version", {version = t.game_version})
			end

			if t.is_practice_match and _G.myself == false then
				_G.is_game_ended = true
				combat('GAME OVER')
				Timers:CreateTimer(0.1,function()
					GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
				end)
			end
			for steam_id,user_info in pairs(t.user_info) do
				table.insert(_G.user_md5_table,steam_id)
				local hero_index = user_info.hero_index
				local hero = EntIndexToHScript(hero_index)
				local player_id = hero:GetPlayerID()
				if user_info.settings ~= nil and user_info.settings ~= 'null' then
					_G.user_setting[steam_id] = json.decode(user_info.settings)
				else
					_G.user_setting[steam_id] = {
						is_click_select = 1,
						is_auto_combine = 1,
						is_fog_show = 1,
					}
				end
				hero.is_auto_combine = _G.user_setting[steam_id].is_auto_combine
				CustomNetTables:SetTableValue( "setting_table", "show_settings", _G.user_setting)

				CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"update_config",{
					key = GetClientKey(hero:GetTeam()),
					hehe = RandomInt(1,100000),
				})

				if user_info.mmr_level < GetCurrMapInfo().min_mmr_level then
					Timers:CreateTimer(8,function()
						KillSelfTeam(hero:GetTeam(),true)
						prt(_G.steamid2name[steam_id]..'|txt_low_player')
						CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"msg_box",{
							key = GetClientKey(hero:GetTeam()),
							text = "text_low_player_tips",
							duratrion = 10,
							icon = "file://{images}/custom_game/vip/bird_sang.png",
						})
					end)
				end

				if user_info.is_top_3 ~= nil then
					hero.is_top_3 = 1
				end

				if user_info['xhw'] ~= nil then
					Timers:CreateTimer(7,function()
						KillSelfTeam(hero:GetTeam(),true)
						prt(_G.steamid2name[steam_id]..'|txt_banned_player')
					end)
				end
				if _G.playing_player_count == 1 and user_info.vip_tester == true then
					prt('<font color="#ffff44">WELCOME VIP TESTER!</font>')
					_G.myself = true
				end
				user_info['player_id'] = player_id
				hero.steam_id = steam_id
				if _G.steamid2name[steam_id] ~= nil then
					hero.player_name = _G.steamid2name[steam_id]
				end

				user_info['onduty_hero'] = GetCourierInfo(player_id) or user_info.onduty_hero

				local onduty_hero_long = user_info.onduty_hero
				hero.onduty_hero_long = onduty_hero_long
				local onduty_hero = string.split(onduty_hero_long,'_')[1]
				local onduty_hero_effect = string.split(onduty_hero_long,'_')[2] or ''
				local onduty_hero_projectile = string.split(onduty_hero_long,'_')[4] or ''
				local onduty_hero_pet = string.split(onduty_hero_long,'_')[5] or ''
				local onduty_hero_animation = string.split(onduty_hero_long,'_')[6] or ''

				user_info['onduty_hero'] = onduty_hero
				user_info['onduty_hero_effect'] = onduty_hero_effect

				RemoveAbilityAndModifier(hero,'no_hp_bar')
				AddAbilityAndSetLevel(hero,'pick_chess')
				AddAbilityAndSetLevel(hero,'recall_chess')
			    AddAbilityAndSetLevel(hero,'remove_chess')
			    AddAbilityAndSetLevel(hero,'summon_hero')
			    AddAbilityAndSetLevel(hero,'exp_book')
			    AddAbilityAndSetLevel(hero,'transfer_chess')
			    hero:FindAbilityByName('transfer_chess'):SetHidden(true)
			    AddAbilityAndSetLevel(hero,'disarm_chess')
			    hero:FindAbilityByName('disarm_chess'):SetActivated(false)
			    AddAbilityAndSetLevel(hero,'ban_chess')
			    hero:FindAbilityByName('ban_chess'):SetActivated(false)
			    hero:FindAbilityByName('ban_chess'):SetHidden(true)
				-- AddAbilityAndSetLevel(hero,'show_config')
				AddAbilityAndSetLevel(hero,'jiaoxie_wudi_hero')
				AddAbilityAndSetLevel(hero,'wudi')
			    AddAbilityAndSetLevel(hero,'no_hp_add')
			    AddAbilityAndSetLevel(hero,'no_collision')
				AddAbilityAndSetLevel(hero,'no_hp_bar')

				if PlayerResource:HasCustomGameTicketForPlayerID ( player_id ) == true or user_info.is_vip == true then
					hero.is_vip = true
				end
				if user_info.is_author == true then
					hero.is_author = true
					gameinfo_have_author = true
				end

			    local init_hp = 100
				_G.stat_info[steam_id] = {
					steam_id = steam_id,
					hp = init_hp,
					player_id = player_id,
					duration = 0,
					rank = 0,
					zhugong = onduty_hero,
					zhugong_model = _G.sm_hero_list[onduty_hero],
					zhugong_effect = onduty_hero_effect,
					round = 0,
					win_round = 0,
					lose_round = 0,
					draw_round = 0,
					kills = 0,
					deaths = 0,
					mmr_level = user_info.mmr_level,
					queen_rank = user_info.queen_rank,
					chess_lineup = '',
					chess_hand = '',
					candy = 0,
					biscuit = 0,
					hero_level = 0,
					buff = '',
					show_buff = '',
					hero_damage = 0,
					hero_damaged = 0,
					is_vip = hero.is_vip or false,
					is_author = hero.is_author or false,
					p2team = nil,
					team_id = hero:GetTeam(),
					total_money = 0,
					block_team = {},
					ban_synergy = nil,
					relic = nil,
				}
				hero.onduty_hero = onduty_hero
				hero.steam_id = steam_id
				hero.onduty_hero_effect = onduty_hero_effect

				if user_info.is_crown_current ~= nil then
					hero.is_crown = true
					ShowCrown(hero,1)
				end
				 --初始化任务
				if user_info.vip_info ~= nil and user_info.vip_info.biscuit_quest ~= nil then
					if _G.egg_quest == nil then
						_G.egg_quest = user_info.vip_info.biscuit_quest
						CustomNetTables:SetTableValue( "game_info", "quest", { 
							biscuit_quest = _G.egg_quest,
						})
					end
					for team,_ in pairs(_G.quest_status) do
						if hero:GetTeam() == team and hero.is_vip == true then
							_G.quest_status[team] = _G.quest_init[_G.egg_quest]
						end
					end
				end

				--装饰信使
				SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet, onduty_hero_animation)
				hero:MoveToPosition(hero:GetAbsOrigin())	
			end
			ShowQuest()
			_G.user_info = t.user_info

			CustomNetTables:SetTableValue( "dac_table", "player_info", { info = t.user_info, hehe = RandomInt(1,1000)})
			
			if t.chess_pool ~= nil  then
				if t.chess_pool.pool_size ~= nil then
					_G.CHESS_POOL_SIZE = t.chess_pool.pool_size
				end
				if t.chess_pool.chess_init_1 ~= nil then
					_G.CHESS_INIT_COUNT[1] = t.chess_pool.chess_init_1
				end
				if t.chess_pool.chess_init_2 ~= nil then
					_G.CHESS_INIT_COUNT[2] = t.chess_pool.chess_init_2
				end
				if t.chess_pool.chess_init_3 ~= nil then
					_G.CHESS_INIT_COUNT[3] = t.chess_pool.chess_init_3
				end
				if t.chess_pool.chess_init_4 ~= nil then
					_G.CHESS_INIT_COUNT[4] = t.chess_pool.chess_init_4
				end
				if t.chess_pool.chess_init_5 ~= nil then
					_G.CHESS_INIT_COUNT[5] = t.chess_pool.chess_init_5
				end
				if t.chess_pool.chess_africa_1 ~= nil then
					_G.CHESS_AFRICA_VALUE[1] = t.chess_pool.chess_africa_1
				end
				if t.chess_pool.chess_africa_2 ~= nil then
					_G.CHESS_AFRICA_VALUE[2] = t.chess_pool.chess_africa_2
				end
				if t.chess_pool.chess_africa_3 ~= nil then
					_G.CHESS_AFRICA_VALUE[3] = t.chess_pool.chess_africa_3
				end
				if t.chess_pool.chess_africa_4 ~= nil then
					_G.CHESS_AFRICA_VALUE[4] = t.chess_pool.chess_africa_4
				end
				if t.chess_pool.chess_africa_5 ~= nil then
					_G.CHESS_AFRICA_VALUE[5] = t.chess_pool.chess_africa_5
				end
			end
			if t.ranking_info ~= nil then

				local tb = {}
				local count = 0

				for i,v in pairs(t.ranking_info) do
					tb[i] = {
						steam_id = v.player,
						mmr_level = v.mmr_level,
						queen_rank = v.queen_rank,
						is_vip = v.is_vip,
						chicken_count = v.chicken_count,
					}
					count = count + 1
					if count > 100 then
						break
					end
				end
				CustomNetTables:SetTableValue( "ranking_top_table", "ranking_top", { ranking_top = CopyTable(tb), hehe = RandomInt(1,1000)} )			
			end

			if _G.playing_player_count == 1 then
				--单机测试模式
				if (t.game_version == 'unknown' and gameinfo_have_author) or t.game_version == 'test' or GetCurrMapInfo().map_name == 'test' then
					--显示单机测试工具箱
					combat('SHOW TESTER BOX')
					_G.is_tester_mode = true
					DAC:RequestGetAllCourierList()
					Timers:CreateTimer(5,function()
						CustomGameEventManager:Send_ServerToAllClients("show_tester_box",{
							hehe = RandomFloat(1,10000),
						}) 
					end)
				end
			end

			StartGame()

			table.sort(_G.user_md5_table)
			local user_md5_string = ''
			for _,tt in pairs(_G.user_md5_table) do
			    user_md5_string = user_md5_string..tt..','
			end
			local user_md5 = calmd5(string.sub(user_md5_string,1,-2))
			Timers:CreateTimer(3,function()
				-- if math.fmod(_G.playing_player_count,2) == 0 and math.floor(_G.playing_player_count/2) >= 2 then
				if GetCurrMapInfo().is_2p == true then
					local p2_result = InitP2Mode()
					if p2_result == true then
						prt('#mode_2p')
					else
						if _G.myself ~= true then
							prt('#mode_2p_invalid_player_count')

							_G.is_game_ended = true
							prt('GAME OVER')

							Timers:CreateTimer(5,function()
								GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
							end)
						end
					end
				end
				local heiheurl = 'http://api.xiaoheihe.cn/api/rpg/autochess/report_match_start/?apikey=69f395b2-f7e8-4032-bd0c-41200cfe9dad'
				local heihedata = {
					steamids = _G.steamidlist,
				  	version = '2.0',
				  	key = GetDedicatedServerKey('max'),
				  	key2 = GetDedicatedServerKey('heihe'),
				  	key3 = GetDedicatedServerKeyV2('heihe'),
				}
				SendHTTPPost(heiheurl,heihedata)
				local dotamindurl = 'https://apidota.gamesmindai.com/wisp/handler'
				local localtime = LocalTime()
				local dotaminddata = {
					route = "wisp.game.init",
 					message = {
						appId = '2533c49c3ac74f478253b8ce19d47f7f',
						matchId = localtime.Hours..localtime.Minutes..localtime.Seconds..RandomInt(10000,99999),
						map = GetCurrMapInfo().map_name,
						players = string.split(_G.steamidlist,',')
					},
				}
				SendHTTPPost(dotamindurl,dotaminddata,{serverKey=GetDedicatedServerKeyV2('dotamind')})
			end)
		elseif t ~= nil and t.err == 1100 then
			prt('对不起，有玩家没有获得内测资格，游戏无法开始。')
			_G.is_game_ended = true
			prt('GAME OVER')
			Timers:CreateTimer(0.1,function()
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
			end)
			return
		else
			--连接服务器失败了，用默认信使玩
			if t ~= nil then
				prt('CONNECT SERVER ERROR : '..t.err)
			end
			if GetDedicatedServerKeyV2('hehe') == 'Invalid_NotOnDedicatedServer' then
				prt('对不起，连接服务器失败，游戏无法开始。')
				_G.is_game_ended = true
				prt('GAME OVER')
				Timers:CreateTimer(0.1,function()
					GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
				end)
				return
			end

			local user_info_table = {}
			is_game_can_start = true
			local steamid_table = string.split(_G.steamidlist_heroindex,',')

			--默认玩家数据
			for _,v in pairs(steamid_table) do 
				local steamid = string.split(v,'_')[1]
				local hero_index = string.split(v,'_')[2]
				local hero = EntIndexToHScript(tonumber(hero_index))
				user_info_table[steamid] = {
					steamid = steamid,
					candy = 0,
					biscuit = 0,
					mmr = 0,
					match = 0,
					zhugong = {
						[1] = "h001_e000"
					},
					onduty_hero = "h001_e000",
					mmr_level = 0,
					hero_index = tonumber(hero_index),
				}
			end

			for steam_id,user_info in pairs(user_info_table) do
				local hero_index = user_info.hero_index
				local hero = EntIndexToHScript(hero_index)
				local player_id = hero:GetPlayerID()
				user_info['player_id'] = player_id
				hero.steam_id = steam_id
				if _G.steamid2name[steam_id] ~= nil then
					hero.player_name = _G.steamid2name[steam_id]
				end

				user_info['onduty_hero'] = GetCourierInfo(player_id) or user_info.onduty_hero

				local onduty_hero_long = user_info.onduty_hero
				hero.onduty_hero_long = onduty_hero_long
				local onduty_hero = string.split(onduty_hero_long,'_')[1]
				local onduty_hero_effect = string.split(onduty_hero_long,'_')[2] or ''
				local onduty_hero_projectile = string.split(onduty_hero_long,'_')[4] or ''
				local onduty_hero_pet = string.split(onduty_hero_long,'_')[5] or ''

				user_info['onduty_hero'] = onduty_hero
				user_info['onduty_hero_effect'] = onduty_hero_effect
				RemoveAbilityAndModifier(hero,'no_hp_bar')
				AddAbilityAndSetLevel(hero,'pick_chess')
				AddAbilityAndSetLevel(hero,'recall_chess')
			    AddAbilityAndSetLevel(hero,'remove_chess')
			    AddAbilityAndSetLevel(hero,'summon_hero')
			    AddAbilityAndSetLevel(hero,'exp_book')
			    AddAbilityAndSetLevel(hero,'transfer_chess')
			    hero:FindAbilityByName('transfer_chess'):SetHidden(true)
			    AddAbilityAndSetLevel(hero,'disarm_chess')
			    hero:FindAbilityByName('disarm_chess'):SetActivated(false)
			    AddAbilityAndSetLevel(hero,'ban_chess')
			    hero:FindAbilityByName('ban_chess'):SetActivated(false)
			    hero:FindAbilityByName('ban_chess'):SetHidden(true)
				-- AddAbilityAndSetLevel(hero,'show_config')
				AddAbilityAndSetLevel(hero,'jiaoxie_wudi_hero')
				AddAbilityAndSetLevel(hero,'wudi')
			    AddAbilityAndSetLevel(hero,'no_hp_add')
			    AddAbilityAndSetLevel(hero,'no_collision')
				AddAbilityAndSetLevel(hero,'no_hp_bar')

				--装饰信使
				SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet)

				local init_hp = 100
				_G.stat_info[steam_id] = {
					steam_id = steam_id,
					hp = init_hp,
					player_id = player_id,
					duration = 0,
					rank = 0,
					zhugong = onduty_hero,
					zhugong_model = _G.sm_hero_list[onduty_hero],
					zhugong_effect = onduty_hero_effect,
					round = 0,
					win_round = 0,
					lose_round = 0,
					draw_round = 0,
					kills = 0,
					deaths = 0,
					mmr_level = user_info.mmr_level,
					queen_rank = user_info.queen_rank,
					chess_lineup = '',
					chess_hand = '',
					candy = 0,
					biscuit = 0,
					hero_level = 0,
					buff = '',
					show_buff = '',
					hero_damage = 0,
					hero_damaged = 0,
					p2team = nil,
					team_id = hero:GetTeam(),
					total_money = 0,
					block_team = {},
					ban_synergy = nil,
					relic = nil,
				}

				hero.steam_id = steam_id
				hero.onduty_hero = onduty_hero

				hero:MoveToPosition(hero:GetAbsOrigin())
				
			end
			_G.user_info = user_info_table
			CustomNetTables:SetTableValue( "dac_table", "player_info", { info = user_info_table, hehe = RandomInt(1,1000)})
			StartGame()
			Timers:CreateTimer(3,function()
				if GetCurrMapInfo().is_2p == true then
					local p2_result = InitP2Mode()
					if p2_result == true then
						prt('#mode_2p')
					else
						if _G.myself ~= true then
							prt('#mode_2p_invalid_player_count')

							_G.is_game_ended = true
							prt('GAME OVER')

							Timers:CreateTimer(5,function()
								GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
							end)
						end
					end
				end
			end)
		end
	end, function()
		--连接服务器失败了，用默认信使玩
		prt('CONNECT SERVER ERROR')
		if GetDedicatedServerKeyV2('hehe') == 'Invalid_NotOnDedicatedServer' then
			prt('对不起，连接服务器失败，游戏无法开始。')
			_G.is_game_ended = true
			prt('GAME OVER')
			Timers:CreateTimer(0.1,function()
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
			end)
			return
		end

		local user_info_table = {}
		is_game_can_start = true
		local steamid_table = string.split(_G.steamidlist_heroindex,',')
		--默认玩家数据
		for _,v in pairs(steamid_table) do 
			local steamid = string.split(v,'_')[1]
			local hero_index = string.split(v,'_')[2]
			local hero = EntIndexToHScript(tonumber(hero_index))
			user_info_table[steamid] = {
				steamid = steamid,
				candy = 0,
				biscuit = 0,
				mmr = 0,
				match = 0,
				zhugong = {
					[1] = "h001_e000"
				},
				onduty_hero = "h001_e000",
				mmr_level = 0,
				hero_index = tonumber(hero_index),
			}
		end

		for steam_id,user_info in pairs(user_info_table) do
			local hero_index = user_info.hero_index
			local hero = EntIndexToHScript(hero_index)
			local player_id = hero:GetPlayerID()
			user_info['player_id'] = player_id
			hero.steam_id = steam_id
			if _G.steamid2name[steam_id] ~= nil then
				hero.player_name = _G.steamid2name[steam_id]
			end

			user_info['onduty_hero'] = GetCourierInfo(player_id) or user_info.onduty_hero

			local onduty_hero_long = user_info.onduty_hero
			hero.onduty_hero_long = onduty_hero_long
			local onduty_hero = string.split(onduty_hero_long,'_')[1]
			local onduty_hero_effect = string.split(onduty_hero_long,'_')[2] or ''
			local onduty_hero_projectile = string.split(onduty_hero_long,'_')[4] or ''
			local onduty_hero_pet = string.split(onduty_hero_long,'_')[5] or ''

			user_info['onduty_hero'] = onduty_hero
			user_info['onduty_hero_effect'] = onduty_hero_effect

			RemoveAbilityAndModifier(hero,'no_hp_bar')
			AddAbilityAndSetLevel(hero,'pick_chess')
			AddAbilityAndSetLevel(hero,'recall_chess')
		    AddAbilityAndSetLevel(hero,'remove_chess')
		    AddAbilityAndSetLevel(hero,'summon_hero')
		    AddAbilityAndSetLevel(hero,'exp_book')
		    AddAbilityAndSetLevel(hero,'transfer_chess')
			hero:FindAbilityByName('transfer_chess'):SetHidden(true)
			AddAbilityAndSetLevel(hero,'disarm_chess')
			hero:FindAbilityByName('disarm_chess'):SetActivated(false)
			AddAbilityAndSetLevel(hero,'ban_chess')
			hero:FindAbilityByName('ban_chess'):SetActivated(false)
			hero:FindAbilityByName('ban_chess'):SetHidden(true)
			-- AddAbilityAndSetLevel(hero,'show_config')
			AddAbilityAndSetLevel(hero,'jiaoxie_wudi_hero')
			AddAbilityAndSetLevel(hero,'wudi')
		    AddAbilityAndSetLevel(hero,'no_hp_add')
		    AddAbilityAndSetLevel(hero,'no_collision')
			AddAbilityAndSetLevel(hero,'no_hp_bar')


			--装饰信使
			SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet)

			local init_hp = 100
			_G.stat_info[steam_id] = {
				steam_id = steam_id,
				hp = init_hp,
				player_id = player_id,
				duration = 0,
				rank = 0,
				zhugong = onduty_hero,
				zhugong_model = _G.sm_hero_list[onduty_hero],
				zhugong_effect = onduty_hero_effect,
				round = 0,
				win_round = 0,
				lose_round = 0,
				draw_round = 0,
				kills = 0,
				deaths = 0,
				mmr_level = user_info.mmr_level,
				queen_rank = user_info.queen_rank,
				chess_lineup = '',
				chess_hand = '',
				candy = 0,
				biscuit = 0,
				hero_level = 0,
				buff = '',
				show_buff = '',
				hero_damage = 0,
				hero_damaged = 0,
				p2team = nil,
				team_id = hero:GetTeam(),
				total_money = 0,
				block_team = {},
				ban_synergy = nil,
				relic = nil,
			}

			hero.steam_id = steam_id
			hero.onduty_hero = onduty_hero

			hero:MoveToPosition(hero:GetAbsOrigin())
			
		end
		_G.user_info = user_info_table
		CustomNetTables:SetTableValue( "dac_table", "player_info", { info = user_info_table, hehe = RandomInt(1,1000)})
		StartGame()
		Timers:CreateTimer(3,function()
			if GetCurrMapInfo().is_2p == true then
				local p2_result = InitP2Mode()
				if p2_result == true then
					prt('#mode_2p')
				else
					if _G.myself ~= true then
						prt('#mode_2p_invalid_player_count')

						_G.is_game_ended = true
						prt('GAME OVER')

						Timers:CreateTimer(5,function()
							GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
						end)
					end
				end
			end
		end)
	end)
end
--游戏循环1——开始一轮准备回合
function StartAPrepareRound()
	if _G.is_game_ended == true then
		return
	end
	
	UpdatePlayerWorldPanel()
	CheckEndingStatus()
	CheckP2Status()
	-- StatChess()
	PostPlayerInfo()

	--野怪提醒
	if _G.battle_round == 15 then
		Timers:CreateTimer(5,function()
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			EmitGlobalSound('warning.wolf')
			for team_id = 6,13 do
		    	SayCheerBubble(team_id, nil, 'creep', 1)
		    end
		end)
	end
	if _G.battle_round == 35 then
		Timers:CreateTimer(5,function()
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			EmitGlobalSound('warning.qianjiaomonv')
			for team_id = 6,13 do
		    	SayCheerBubble(team_id, nil, 'creep', 1)
		    end
		end)
	end
	if _G.battle_round == 50 then
		Timers:CreateTimer(5,function()
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			-- EmitGlobalSound('lycan_lycan_ability_howl_04')
			EmitGlobalSound('warning.tangyimaowang')
			for team_id = 6,13 do
		    	SayCheerBubble(team_id, nil, 'creep', 1)
		    end
		end)
		
	end
	--加载棋子
	if _G.battle_round < 5 then
		for k,v in pairs(_G.chess_list_by_mana[_G.battle_round+1]) do
			PrecacheAUnit(k,v)
    	end
    	for k,v in pairs(_G.chess_list_by_mana_black[_G.battle_round+1]) do
			PrecacheAUnit(k,v)
    	end
	end
	if _G.battle_round >= 5 and _G.battle_round < 7 then
		for k,v in pairs(_G.chess_list_by_mana[_G.battle_round-1]) do
			PrecacheAUnit(k,v..'1')
    	end
    	for k,v in pairs(_G.chess_list_by_mana_black[_G.battle_round-1]) do
			PrecacheAUnit(k,v..'1')
    	end
	end
	if _G.battle_round >= 7 and _G.battle_round < 12 then
		for k,v in pairs(_G.chess_list_by_mana[_G.battle_round-6]) do
			PrecacheAUnit(k,v..'11')
    	end
    	for k,v in pairs(_G.chess_list_by_mana_black[_G.battle_round-6]) do
			PrecacheAUnit(k,v..'11')
    	end
	end
	if _G.battle_round == 12 then
		for k,v in pairs(_G.chess_list_by_mana_gold) do
			PrecacheAUnit(k,v)
    	end
    end
    if _G.battle_round == 13 then
		for k,v in pairs(_G.chess_list_by_mana_gold) do
			PrecacheAUnit(k,v..'1')
    	end
    end
    if _G.battle_round == 14 then
		for k,v in pairs(_G.chess_list_by_mana_gold) do
			PrecacheAUnit(k,v..'11')
    	end
    end
    
	--50回合以后，疲劳
	if _G.battle_round > _G.pilao_round then
		for _,heroent in pairs (_G.hero) do
			if heroent ~= nil and heroent:IsNull() == false and heroent:IsAlive() == true then
				local bite_hp = math.floor(heroent:GetHealth() / 2)
				local after_hp = heroent:GetHealth() - bite_hp
				if after_hp <= 0 then
					after_hp = 0
				end
				prt('#text_grand_final_pilao')
				EmitSoundOn('diretide_select_target_Stinger',heroent)
				play_particle("particles/econ/items/legion/legion_overwhelming_odds_ti7/legion_commander_odds_ti7_proj_hit_streaks.vpcf",PATTACH_ABSORIGIN_FOLLOW,heroent,3)
				if after_hp <= 0 then
					--死了
					heroent:ForceKill(false)
					_G.counterpart[heroent:GetTeam()] = -1
					SyncHP(heroent)
					AMHC:CreateNumberEffect(heroent,bite_hp,2,AMHC.MSG_MISS,"red",9)
					return
				end
				heroent:SetHealth(after_hp)
				SyncHP(heroent)
				AMHC:CreateNumberEffect(heroent,bite_hp,2,AMHC.MSG_MISS,"red",9)
				-- EmitSoundOn("Frostivus.PointScored.Enemy",hero)
				EmitSoundOn("diretide.sad",hero)
				
			end
		end		
	end
	
	--显示玩家排名
	StatAllPlayerLineup()
	UpdatePlayerCurrRank()
	CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = _G.stat_info, hehe = RandomInt(1,1000)})
	
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"battle_info",{
			key = GetClientKey(team_i),
			type = "prepare",
			round = _G.battle_round,
		})
		local hhh = TeamId2Hero(team_i)
		
		if hhh ~= nil then
			--野怪回合后给一次拆装备机会
			if _G.battle_round == 11 or
				_G.battle_round == 16 or 
				_G.battle_round == 21 or 
				_G.battle_round == 26 or 
				_G.battle_round == 31 or 
				_G.battle_round == 36 or 
				_G.battle_round == 41 or 
				_G.battle_round == 46 or 
				_G.battle_round == 51 then
				hhh:FindAbilityByName('disarm_chess'):SetActivated(true)
			end
			if hhh.synergy_banned then
				local aaa = hhh:FindAbilityByName(hhh.synergy_banned..'_banned')
				if aaa ~= nil then
					aaa:SetActivated(true)
				end
			end
		end
	end

	CustomNetTables:SetTableValue( "game_info", "round_info", { round = _G.battle_round } )

	local alldead = true
	for i,v in pairs (_G.counterpart) do
		if v ~= -1 then
			local hhh = TeamId2Hero(i)
			RemoveAbilityAndModifier(hhh,'is_priest_buff')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_plus')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_plus_plus')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_courier')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_courier_plus')
			RemoveAbilityAndModifier(hhh,'is_priest_buff_courier_plus_plus')
			if hhh.hand_entities ~= nil then
				for _,ent in pairs(hhh.hand_entities) do
					if ent ~= nil and ent:IsNull() == false then
						ent:RemoveAbility('outofgame')
						ent:RemoveModifierByName('modifier_outofgame')
					end
				end
			end
			if _G.battle_round >= 35 and _G.egg_quest == 'q006' then
				SetQuest(hhh.team_id,true)
			end
			alldead = false
		end
	end
	if alldead == true then
		--所有玩家都死亡了，不开始准备回合了
		return
	end

	--决定准备回合时长
	InitPrepareTime()
	
	--正式开始准备回合
	GameRules:SetTimeOfDay(0.8)
	EmitGlobalSound("Loot_Drop_Stinger_Legendary")
	_G.game_status = 1
	_G.start_ai = false

	Timers:CreateTimer(function()
		-- if GetTime().phase ~= GAME_PHASE_PREPARE then
		-- 	return
		-- end

		if GetTime().left <= 10 and GetTime().left > 5 then
			--5~10秒，倒计时音效
			-- EmitGlobalSound("diretide.countdown")
			EmitGlobalSound("dac.season.countdown")
		end

		--发送当前游戏时间给客户端
		UpdateTimer()

		if GetTime().left <= 5 then
			--5秒，准备战斗
			if GetTime().left == 5 then
				--通知UI初始化胜负显示
				for team_i=6,13 do
					CustomGameEventManager:Send_ServerToTeam(team_i,"clear_round_win_lose",{
						key = GetClientKey(team_i),
					})
				end
				CustomGameEventManager:Send_ServerToTeam(1,"clear_round_win_lose",{
						key = GetClientKey(1),
					})

				-- if _G.battle_round == 50 then

				-- 	Timers:CreateTimer(1,function()
				-- 		EmitGlobalSound("diretide.darkwillow")
				-- 	end)
				-- end

				for team_i=6,13 do
					ShowStarsOnAllChess(team_i)
				end
				EmitGlobalSound("GameStart.DireAncient")

				if _G.battle_boss[_G.battle_round] ~= nil then
					ShowCombat({
						t = 'round_pve',
						text = _G.battle_round
					})
				else
					ShowCombat({
						t = 'round_pvp',
						text = _G.battle_round
					})

					--分配对手
					if _G.p2_mode == true then
						AllocateP2Counterpart()
					else
						AllocateABattleRoundV3()
					end
				end
				Timers:CreateTimer(3,function()
					ShowBattleInfo()
				end)
			end

			if GetTime().left == 3 then
				--4秒，踢回多的棋子
				RandomRecallChess()
			end
			
			for i,v in pairs (_G.hero) do
				CancelPickBattleChess(v)
				-- v:FindAbilityByName('pick_chess'):SetActivated(false)
				v:FindAbilityByName('recall_chess'):SetActivated(false)
			end
		end
		if GetTime().left <= 0 then
			--0秒，开始战斗AI
			Timers:CreateTimer(1,function()
				_G.battle_round = _G.battle_round + 1
				_G.game_status = 2
				_G.battle_timer = 50
				Timers:CreateTimer(1,function()
					_G.start_ai = true
				end)
			end)
			return
		end
		if GetTime().left == 2 then
			--2秒，开始战斗回合
			StartABattleRound()
		end

		_G.prepare_timer_ingame = _G.prepare_timer_ingame - 1
		return 1
	end)
	Timers:CreateTimer(0.3,function()
		if _G.battle_round == 1 then
			--第1回合显示退出按钮
			for team_i=6,13 do
				local hero = TeamId2Hero(team_i)
				if IsUnitExist(hero) then
					hero:AddItemByName('item_suggest_liuju')
				end
				-- CustomGameEventManager:Send_ServerToTeam(team_i,"show_liuju",{
				-- 	key = GetClientKey(team_i),
				-- 	hehe = RandomInt(1,100000)
				-- })
			end
		end
		--第2-3回合判断流局
		if _G.battle_round == 2 then
			local liuju_player_count = 0
			for _,h in pairs(_G.hero) do
				if h == nil or h:IsNull() == true or h:IsAlive() == false or h.isDisconnected == true or h.isSuggestLiuju == true then
					liuju_player_count = liuju_player_count + 1
				end
			end
			if liuju_player_count >= _G.playing_player_count/2.0 then
				--流局
				prt('#txt_liuju_go')
				--EmitGlobalSound("Frostivus.PointScored.Enemy")
				EmitGlobalSound("dac.season.liuju")
				_G.is_game_ended = true
				prt('GAME OVER')
				PostGame()
				Timers:CreateTimer(3,function()
					GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
				end)
				return
			end
		end
		if _G.battle_round == 3 or _G.battle_round == 4 then
			--第3回合移除退出按钮
			for team_i=6,13 do
				-- CustomGameEventManager:Send_ServerToTeam(team_i,"hide_liuju",{
				-- 	key = GetClientKey(team_i),
				-- 	hehe = RandomInt(1,100000)
				-- })

				local hero = TeamId2Hero(team_i)
				if IsUnitExist(hero) and hero:GetItemInSlot(16) and hero:GetItemInSlot(16):GetAbilityName() == 'item_suggest_liuju' then
					hero:RemoveItem(hero:GetItemInSlot(16))
				end

				-- local hh = TeamId2Hero(team_i)
				-- if IsUnitExist(hh) then
				-- 	hh:FindAbilityByName('ban_chess'):SetActivated(true)
				-- end
				EnableBanChess()
			end
		end
		for i,v in pairs(_G.hero) do
			if IsUnitExist(v) == true and v.is_banned == true then
				KillSelfTeam(v:GetTeam(),true)
			elseif IsUnitExist(v) == true then
				AddPickAndRemoveAbility(v)
				if v ~= nil then 
					local level = v:GetLevel()
					AddAbilityAndSetLevel(v,'summon_hero',level)
				end

				v.is_battle_completed = nil

				Timers:CreateTimer(1,function()
					--给蓝
					local mana = math.floor(_G.battle_round/2+0.5)
					if mana> 4 then
						mana = 4
					end

					local lixi = math.floor(v:GetMana()/10)
					
					if lixi > 4 then
						if v:HasModifier('modifier_item_more_interest') then
							PlaySendMoneyEffect(v.great_vault,v)
							lixi = 4 + 2*math.floor((v:GetMana()-40)/10)
						else
							lixi = 4
						end
					end
					if lixi >= 4 and _G.egg_quest == 'q031' then
						SetQuest(v:GetTeam(),true)
					end
					mana = mana + lixi

					local anwei = 0
					if v.lose_streak then 
						if v.lose_streak >=2 and v.lose_streak < 5 then
							anwei = 1
						end
						if v.lose_streak >=5 and v.lose_streak < 10 then
							anwei = 2
						end
						if v.lose_streak >=10 then
							anwei = 3
						end
						if v:HasModifier('modifier_item_streak_plus') then
							anwei = anwei * 2
							-- ExpBook({
							-- 	caster = v,
							-- 	xpadd = anwei,
							-- 	disable_quick_lvl_up = true,
							-- 	cost = 0,
							-- })
						end
					end
					mana = mana + anwei

					local jiangli = 0
					if v.win_streak then
						if v.win_streak >=2 and v.win_streak < 5 then
							jiangli = 1
						end
						if v.win_streak >=5 and v.win_streak < 10 then
							jiangli = 2
						end
						if v.win_streak >=10 then
							jiangli = 3
						end
						if v:HasModifier('modifier_item_streak_plus') then
							jiangli = jiangli * 2
							-- ExpBook({
							-- 	caster = v,
							-- 	xpadd = jiangli,
							-- 	disable_quick_lvl_up = true,
							-- 	cost = 0,
							-- })
						end
					end
					mana = mana + jiangli

					AddMana(v, mana)
					AddTotalMoneyStat(v:GetPlayerID(), mana)
				end)
				Timers:CreateTimer(0.5,function()
					--自动抽卡一次
					Draw5ChessAndShow(v:GetTeam(), false)
				end)
				
				--给一点经验
				if _G.battle_round ~= 1 then
					if v:GetLevel() < 10 then
						v:AddExperience(1,0,false,false)					
					end
					if v:GetLevel() >= 10 then
						v:FindAbilityByName('exp_book'):SetActivated(false)						
					end
				end

				_G.damage_stat[v:GetTeam()] = {}

				--大头菜概率长大
				if v.hand_entities ~= nil and v:HasModifier('modifier_item_bench_contract') and _G.battle_round % 10 ~= 1 then
					--11/21/31/41...回合不+1，为了缓冲开圣物的时间，开魔法种子圣物的时候就把第一回合的+1加进去了
					for k,x in pairs(v.hand_entities) do
						if x:GetUnitName() == 'placeholder' and RandomInt(1,100) <= 75 then
							local scale = AddTrackMoneyCount(x,1)
							AddModelScalePlus(x, 1.2+scale/10.0)
							-- AddTotalMoneyStat(v:GetPlayerID(), 1)
							x:SetBaseMaxHealth(scale)
							x:SetMaxHealth(scale)
							x:SetHealth(scale)
							-- CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
							-- 	unit_index = x:entindex(),
							-- 	text = '+1',
							-- })
						end
					end
				end

				--蛋概率长大
				if v.hand_entities ~= nil and v:HasModifier('modifier_item_egg') and _G.battle_round % 10 ~= 1 then
					--11/21/31/41...回合不+1，为了缓冲开圣物的时间
					for k,x in pairs(v.hand_entities) do
						if x:GetUnitName() == 'egg' and x.egg_chess ~= nil and FindChessCountInChessPool(x.egg_chess) > 0 and RandomInt(1,100) <= 60 then
							x.egg_chess_count = x.egg_chess_count + 1

							if x.egg_chess_count > 9 then
								x.egg_chess_count = 9
							end
							local scale = x.egg_chess_count
							AddModelScalePlus(x, 1.4+scale*0.2)
							x:SetBaseMaxHealth(9)
							x:SetMaxHealth(9)
							x:SetHealth(scale)

							CustomNetTables:SetTableValue( "unit_table", 'egg_'..x:entindex(), {
								chess = x.egg_chess,
								count = x.egg_chess_count,
							})

							RemoveChessFromChessPool(x.egg_chess)
							-- CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
							-- 	unit_index = x:entindex(),
							-- 	text = '+1',
							-- })
						end
					end
				end

				--熊猫人钓鱼
				Timers:CreateTimer(0.5,function()
					Fish(v)
				end)
				--人类经验
				if GetHumanCount(v:GetTeam()) >= 3 then
					AddItemPlus(v,'item_zhishizhishu')
					EmitSoundOn("is_human.magic",hero)
				end
				if GetHumanCount(v:GetTeam()) >= 6 then
					AddItemPlus(v,'item_zhishizhishu')
				end
			end
		end
	end)
end
--游戏循环1.1——清理战斗场地并重新摆上自己的随从
function ClearARound(teamid)
	for _,v in pairs(GetValidChessOnBoard(teamid)) do
		if v ~= nil and v:IsNull() == false then
			-- AddAbilityAndSetLevel(v,'no_selectable')

			Timers:CreateTimer(0.1,function()
				if v ~= nil and v:IsNull() == false and v.team_id ~= 4 then
					v.is_clearing = true
					FillEmptySlot(v)
					SaveItem(teamid,v:entindex(),function()
						if v ~= nil and v:IsNull() == false then v:Destroy() end
					end)
				else
					if v ~= nil and v:IsNull() == false then v:Destroy() end
				end
			end)
		end
	end
	_G.to_be_destory_list[teamid] = {}
	_G.unit[teamid] = {}

	local hero = TeamId2Hero(teamid)
	if hero.mirror_chesser ~= nil then
		Timers:CreateTimer(4,function()
			if hero.mirror_chesser.pet2 ~= nil then
				hero.mirror_chesser.pet2:Destroy()
				hero.mirror_chesser.pet2 = nil
			end
			hero.mirror_chesser:Destroy()
			hero.mirror_chesser = nil
		end)
	end
end
function RestoreARound(teamid)
	if _G.is_game_ended == true then
		return
	end

	_G.restore_check = true
	ClearARound(teamid)
	Timers:CreateTimer(0.8,function()
		_G.restore_check = false
		for _,v in pairs(_G.mychess[teamid]) do
			RestoreOneChess(v,teamid)
		end
		if _G.is_tester_mode == true then
			for _,v in pairs(_G.yourchess[teamid]) do
				v.x = 9-v.x
				v.y = 9-v.y
				RestoreOneChess(v,teamid)
			end
		end
	end)
end
--游戏循环1.2——抽卡用到的方法
function Draw5ChessAndShow(team_id, unlock, is_gold)
	--unlock==false表示是系统自动抽牌
	--is_gold==1表示抽5橙卡，2表示抽小黑屋卡，3表示抽上个对手的卡
	local h = TeamId2Hero(team_id)
	if h.chesslock == true then
		CustomGameEventManager:Send_ServerToTeam(h:GetTeam(),"show_draw_card",{
			key = GetClientKey(h:GetTeam()),
			chesses = h.curr_chess_table,
			curr_money = h:GetMana(),
			auto_unlock = true,
		})
		h.chesslock = false
		return
	end
	
	--D+：洗回的-->ban_chess_list
	--D++：ban_chess_list-->ban_chess_list2
	h.ban_chess_list2 = {}
	if h.ban_chess_list ~= nil then
		for _,chess in pairs(h.ban_chess_list) do
			if chess ~= nil then
				table.insert(h.ban_chess_list2,chess)
			end
		end
	end

	--把上次剩的洗回棋库
	h.ban_chess_list = {}
	if h.curr_chess_table ~= nil then
		for _,chess in pairs(h.curr_chess_table) do
			if chess ~= nil and (h.is_gold_draw == nil or h.is_gold_draw == 3) then
				table.insert(h.ban_chess_list,chess.chess)
				AddAChessToChessPool(chess.chess)
			end
		end
	end
	--把上上次的删掉，
	h.curr_chess_table = {}
	--抽！
	if is_gold == 1 then
		h.is_gold_draw = 1
	elseif is_gold == 2 then
		h.is_gold_draw = 2
	elseif is_gold == 3 then
		h.is_gold_draw = 3
	else
		h.is_gold_draw = nil
	end
	local curr_chess_table = RandomNDrawChessNew(team_id,5,unlock,is_gold)
	h.curr_chess_table = curr_chess_table
	local level_one_chess = FindLevelOneChess(h)
	h.level_one_chess = level_one_chess

	CustomGameEventManager:Send_ServerToTeam(team_id,"show_draw_card",{
		key = GetClientKey(team_id),
		chesses = curr_chess_table,
		level_one_chess = level_one_chess,
		curr_money = h:GetMana(),
		unlock = unlock,
	})
end
--结算一名玩家，兼容1P和2P的模式
function PostOneToServer(hero,steamid,rank,mode)
	SetStat(hero:GetPlayerID(), 'rank', rank)

	local quest = _G.quest_status[hero:GetTeam()]
	local chess_lineup = GetStat(hero:GetPlayerID(),'chess_lineup')
	local url = "http://autochess.ppbizon.com/game/post/one/@".._G.steamidlist.."@"..steamid.."@"..rank.."?hehe="..RandomInt(1,10000).."&duration="..math.floor(GameRules:GetGameTime() - _G.START_TIME)..GetSendKey()..'&map='..(GetCurrMapInfo().map_name_real or GetCurrMapInfo().map_name)..'&chess_lineup='..chess_lineup

	if hero.onduty_hero_long ~= nil then
		url = url..'&onduty_courier='..hero.onduty_hero_long
	end

	local onduty_chessboard = GetChessboardInfo(hero:GetPlayerID())
	if onduty_chessboard ~= nil and onduty_chessboard.id ~= nil then
		url = url..'&onduty_chessboard='..onduty_chessboard.id
	end

	if mode == 'p1' then
		url = url..'&settings='..json.encode(_G.user_setting[steamid])
	else
		url = url..'&mode=p2&teammate='..TeamId2Hero(GetP2Ally(hero:GetTeam())).steam_id..'&settings='..json.encode(_G.user_setting[steamid])
	end
	if quest == true then
		url = url..'&finish_quest=1'
	end
	local tt = _G.stat_info[steamid]
	local total_team = _G.playing_player_count
	if _G.p2_mode == true then
		total_team = math.floor(_G.playing_player_count/2)
	end
	_G.send_info[steamid] = {
		account_id = steamid,
		rank = rank,
		total = total_team,
		level = tt['mmr_level'],
		candy = 0,
		biscuit = 0,
		chess = tt['chess_lineup'],
		win_round = tt['win_round'],
		lose_round = tt['lose_round'],
		kills = tt['kills'],
		deaths = tt['deaths'],
		gold = tt['gold'],
		duration = tt['duration'],
		total_money = tt['total_money'],
		ban_synergy = tt['ban_synergy'],
	}
	SendHTTP(url.."&from=SyncHP", function(t)
		if t.err == 0 then

			local v = t.mmr_info
			if _G.stat_info[v.userid] ~= nil then

				_G.send_info[v.userid]['account_id'] = v.userid
				_G.send_info[v.userid]['rank'] = v.rank
				_G.send_info[v.userid]['total'] = v.total
				_G.send_info[v.userid]['level'] = v.level
				_G.send_info[v.userid]['candy'] = v.candy or 0
				_G.send_info[v.userid]['biscuit'] = v.biscuit or 0
				_G.send_info[v.userid]['chess'] = t.lineup_info.chess
				_G.send_info[v.userid]['buff'] = t.lineup_info.buff

				_G.stat_info[v.userid]['candy'] = v.candy or 0
				_G.stat_info[v.userid]['biscuit'] = v.biscuit or 0
				_G.stat_info[v.userid]['level_delta'] = v.level_delta or 0
				_G.stat_info[v.userid]['delta'] = v.mmr_delta or 0
				_G.stat_info[v.userid]['mmr_level'] = v.level
				_G.stat_info[v.userid]['queen_rank'] = v.queen_rank

				CustomGameEventManager:Send_ServerToAllClients("msg",{
			        data = _G.send_info[v.userid]
			    })

				_G.send_time = {
					end_time = t.end_time,
					year = t.year,
					month = t.month,
					date = t.date,
					hour = t.hour,
					minute = t.minute,
					second = t.second,
				}
				local totalrank = 1
				if mode == 'p1' then
					totalrank = _G.playing_player_count
				else
					totalrank = GetP2TeamCount()
				end
				CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_gameover",{
					key = GetClientKey(hero:GetTeam()),
					hehe = RandomInt(1,100000),
					rank = v.rank,
					total_rank = totalrank,
					level = v.level,
					candy = v.candy,
					biscuit = v.biscuit,
					mmr_delta = v.mmr_delta,
					level_delta = v.level_delta,
					queen_rank = v.queen_rank,
					mode = mode,
					exp_info = t.exp_info,
					lineup_info = t.lineup_info,
					quest_id = _G.egg_quest,
					quest_status = v.quest_status,
				})
				if mode == 'p1' and rank == 1 then
					local dur = GameRules:GetGameTime() - _G.START_TIME+3

					SetStat(_G.steamid2playerid[hero.steam_id], 'duration', dur)
					SetStat(_G.steamid2playerid[hero.steam_id], 'round', _G.battle_round)
					--保存最终阵容
					local lineup = ''
					for _,v in pairs(_G.mychess[hero:GetTeam()]) do
						if v ~= nil and v.chess ~= nil then 
							lineup = lineup..v.chess..','
						end
					end
					SetStat(_G.steamid2playerid[hero.steam_id], 'chess_lineup',lineup)
					Timers:CreateTimer(2,function()
						local ready_2_post = false
						local ready_1_post = false
						for y,z in pairs(_G.send_info) do
							if z.rank == 1 then
								ready_1_post = true
							end
							if z.rank == 2 then
								ready_2_post = true
							end
						end
						--展示结束面板，结束游戏！
						Timers:CreateTimer(8,function()
							GameRules:SetGameWinner(hero:GetTeam())
							_G.setwin = 1
						end)
						Timers:CreateTimer(5,function()
							PostGame()
						end)
						if ready_2_post == true and ready_1_post == true then
							prt('Send Amazon Data')
							local t = _G.send_time
							local amzdate = string.format(
							    '%s%s%sT%s%s%sZ',
							    t.year, t.month, t.date, t.hour, t.minute, t.second
							)
							local datestamp = string.format(
							    '%s%s%s',
							    t.year, t.month, t.date
							)
							SendAmazonData(CollectAmazonData(dur),amzdate,datestamp)					
						end
					end)
					EmitGlobalSound("DOTAMusic_Diretide_Finale")

					--提交阵容
					if table.maxn(_G.upload_lineup) > 0 then
						local str = ''
						for i,v in pairs(_G.upload_lineup) do
							str = str..json.encode(v)..'|'
						end
						str = string.sub(str,1,-2)
						local url_up = "http://autochess.ppbizon.com/lineup/add?lineups="..str.."&bans=".._G.bans.."&hehe="..RandomInt(1,10000)..GetSendKey()
						local req_up = CreateHTTPRequestScriptVM("GET", url_up)
						req_up:SetHTTPRequestAbsoluteTimeoutMS(20000)
						req_up:Send(function (result)
							-- local t_up = json.decode(result["Body"])
							-- if t_up.err == 0 then
							-- 	prt('SAVE CLOUD LINEUP OK!')
							-- end
						end)
					end
				elseif mode == 'p2' and rank == 1 then
					local dur = GameRules:GetGameTime() - _G.START_TIME+3
					SetStat(hero:GetPlayerID(), 'duration', dur)
					SetStat(hero:GetPlayerID(), 'round', _G.battle_round)
					--保存最终阵容
					local lineup = ''
					for _,v in pairs(_G.mychess[hero:GetTeam()]) do
						if v ~= nil and v.chess ~= nil then 
							lineup = lineup..v.chess..','
						end
					end
					SetStat(hero:GetPlayerID(), 'chess_lineup',lineup)
					--胜利队伍第一个人提交
					if _G.p2_win_settle == false then
						_G.p2_win_settle = true
					--胜利队伍第二个人提交
					else
						prt('2P END GAME')
						EmitGlobalSound("DOTAMusic_Diretide_Finale")
						local dur = GameRules:GetGameTime() - _G.START_TIME+3
						SetStat(hero:GetPlayerID(), 'duration', dur)
						SetStat(hero:GetPlayerID(), 'round', _G.battle_round)

						Timers:CreateTimer(4,function()
							prt('Send Amazon Data')					
							local t = _G.send_time
							local amzdate = string.format(
							    '%s%s%sT%s%s%sZ',
							    t.year, t.month, t.date, t.hour, t.minute, t.second
							)
							local datestamp = string.format(
							    '%s%s%s',
							    t.year, t.month, t.date
							)
							SendAmazonData(CollectAmazonData(dur,'2p'),amzdate,datestamp)
						end)
						--提交阵容
						if table.maxn(_G.upload_lineup) > 0 then
							local str = ''
							for i,v in pairs(_G.upload_lineup) do
								str = str..json.encode(v)..'|'
							end
							str = string.sub(str,1,-2)
							local url_up = "http://autochess.ppbizon.com/lineup/add?lineups="..str.."&hehe="..RandomInt(1,10000)..GetSendKey()
							local req_up = CreateHTTPRequestScriptVM("GET", url_up)
							req_up:SetHTTPRequestAbsoluteTimeoutMS(20000)
							req_up:Send(function (result)
								local t_up = json.decode(result["Body"])
								if t_up.err == 0 then
									prt('SAVE CLOUD LINEUP OK!')
								end
							end)
						end
						-- 展示结束面板，结束游戏！
						Timers:CreateTimer(8,function()
							GameRules:SetGameWinner(hero:GetTeam())
							_G.setwin = 1
						end)
						Timers:CreateTimer(5,function()
							PostGame()
						end)
					end
				end
			end
		else
			prt('GAME POST FAILED...')
			--单独结算失败了，不应该结束游戏
			-- PostGame()
			-- Timers:CreateTimer(3,function()
			-- 	GameRules:SetGameWinner(hero:GetTeam())
			-- 	_G.setwin = 1
			-- end)

			
			local dur = GameRules:GetGameTime() - _G.START_TIME+3
			SetStat(_G.steamid2playerid[hero.steam_id], 'duration', dur)
			SetStat(_G.steamid2playerid[hero.steam_id], 'round', _G.battle_round)
			--保存最终阵容
			local lineup = ''
			for _,v in pairs(_G.mychess[hero:GetTeam()]) do
				if v ~= nil and v.chess ~= nil then 
					lineup = lineup..v.chess..','
				end
			end
			SetStat(_G.steamid2playerid[hero.steam_id], 'chess_lineup',lineup)
				
			if rank == 1 then
				Timers:CreateTimer(8,function()
					GameRules:SetGameWinner(hero:GetTeam())
					_G.setwin = 1
				end)
				-- 展示结束面板，结束游戏！
				Timers:CreateTimer(5,function()
					PostGame()
				end)
			end
		end
	end,function(t)
		prt('GAME POST FAILED...')
		--单独结算失败了，不应该结束游戏
		-- PostGame()
		-- Timers:CreateTimer(3,function()
		-- 	GameRules:SetGameWinner(hero:GetTeam())
		-- 	_G.setwin = 1
		-- end)
		local dur = GameRules:GetGameTime() - _G.START_TIME+3
		SetStat(_G.steamid2playerid[hero.steam_id], 'duration', dur)
		SetStat(_G.steamid2playerid[hero.steam_id], 'round', _G.battle_round)
		--保存最终阵容
		local lineup = ''
		for _,v in pairs(_G.mychess[hero:GetTeam()]) do
			if v ~= nil and v.chess ~= nil then 
				lineup = lineup..v.chess..','
			end
		end
		SetStat(_G.steamid2playerid[hero.steam_id], 'chess_lineup',lineup)
			
		if rank == 1 then
			Timers:CreateTimer(8,function()
				GameRules:SetGameWinner(hero:GetTeam())
				_G.setwin = 1
			end)
			-- 展示结束面板，结束游戏！
			Timers:CreateTimer(5,function()
				PostGame()
			end)
		end
	end)

	if rank == 1 then
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_win",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
			emoji = 12,
		})

		if RandomInt(1,100) <= 50 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'chicken', 1)
	    end
	    if RandomInt(1,100) <= 50 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'chicken', 4)
	    end
	    if RandomInt(1,100) <= 50 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'chicken', 7)
	    end
	end
end
function SyncHP(hero)
	SetStat(hero:GetPlayerID(),'hp',hero:GetHealth())
	if hero:GetHealth() < 100 and _G.battle_round <= 10 and _G.egg_quest == 'q010' then
		SetQuest(hero.team_id,false)
	end
	UpdatePlayerCurrRank()
	CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = _G.stat_info, hehe = RandomInt(1,1000)})

	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = hero:GetPlayerID(),
		hp = hero:GetHealth(),
		hp_max = hero:GetMaxHealth(),
		mp = hero:GetMana(),
		level = hero:GetLevel(),
		win_streak = hero.win_streak,
		unit_index = hero:entindex(),
		courier_id = hero.onduty_hero,
		sync_hp_bar = true,
	})

	local courier_info = CustomNetTables:GetTableValue( "player_id_table", "courier_"..hero:GetPlayerID() ) or {}
	courier_info['level'] = hero:GetLevel() 
	courier_info['win_streak'] = hero.win_streak
	CustomNetTables:SetTableValue( "player_id_table", 'courier_'..hero:GetPlayerID(), courier_info)

	if _G.START_TIME == nil then
		return
	end
	SetStat(hero:GetPlayerID(), 'duration', GameRules:GetGameTime() - _G.START_TIME)
	SetStat(hero:GetPlayerID(), 'round', _G.battle_round)
	Timers:CreateTimer(0.3,function()
		if hero:IsAlive() == false or hero:GetHealth() <= 0 then
			SetPlayerDead(hero)
		end
	end)
end
function SetPlayerDead(hero)
	if _G.death[hero:GetTeam()] == true then
		return
	end
	_G.death[hero:GetTeam()] = true
	SetRankingState(hero)
	Timers:CreateTimer(0.5,function()
		DealFuneralAffairs(hero)
	end)

	CustomNetTables:SetTableValue( "game_info", "death_team", _G.death )

	RemoveAllCheerCourier(hero:GetTeam())
end
--处理玩家后事
function DealFuneralAffairs(hero)
	if hero:IsAlive() == true then
		hero:ForceKill(false)
	end
	EmitSoundOn("diretide.sad",hero)	

	--保存最终阵容
	local lineup = ''
	local lineup_count = 0

	--统计这个死亡的玩家都有哪些装备
	local gg_items = {}

	for _,v in pairs(_G.mychess[hero:GetTeam()]) do
		if v ~= nil and v.chess ~= nil and lineup_count < hero:GetLevel() then 
			lineup = lineup..v.chess..','
			AddAChessToChessPool(v.chess)
			lineup_count = lineup_count + 1

			if v.lastitem ~= nil then
				for _,i in pairs(v.lastitem) do
					if i ~= nil then
						table.insert(gg_items,i)
					end
				end
			end
		end
	end
	--把牌+洗回牌库
	if hero.hand_entities ~= nil then
		for i=1,8 do
			local unitname = ''
			if hero.hand_entities[i] ~= nil and hero.hand_entities[i]:IsNull() == false then
				local unit = hero.hand_entities[i]
				unitname = unit:GetUnitName()
				if unitname == 'egg' and unit.egg_chess ~= nil then
					local count = unit.egg_chess_count or 1
					local egg_chess = unit.egg_chess
					--把count个egg_chess洗回
					for i=1,count do
						AddAChessToChessPool(egg_chess)
					end
				else
					AddAChessToChessPool(unitname)

					for slot=0,9 do
						if hero.hand_entities[i]:GetItemInSlot(slot) ~= nil then
							local name = hero.hand_entities[i]:GetItemInSlot(slot):GetAbilityName()
							table.insert(gg_items,name)
						end
					end			
				end					
			end
		end
	end
	SetStat(hero:GetPlayerID(), 'chess_lineup',lineup)

	--清理商店残留棋子
	if hero.curr_chess_table ~= nil then
		for _,chess in pairs(hero.curr_chess_table) do
			if chess ~= nil then
				AddAChessToChessPool(chess.chess)
			end
		end
	end

	for slot=0,9 do
		if hero:GetItemInSlot(slot)~= nil then
			local name = hero:GetItemInSlot(slot):GetAbilityName()
			table.insert(gg_items,name)
			hero:RemoveItem(hero:GetItemInSlot(slot))
		end
	end
	--遗产
	local gg_item_count = 0
	local alive_player_count = GetAlivePlayerCount()
	for _,gg_item in pairs(gg_items) do
		if RandomInt(1,100) < (alive_player_count*8) then
			if _G.basic_recipe[gg_item] ~= nil then
				for _,v in pairs(string.split(_G.basic_recipe[gg_item],';')) do
					RandomDropOneGGItem(v,hero)
					gg_item_count = gg_item_count + 1
				end
			else
				RandomDropOneGGItem(gg_item,hero)
				gg_item_count = gg_item_count + 1
			end
		end
	end
	--棺材本
	local guancai_money = math.floor(hero:GetMana()*(alive_player_count*10)/100)
	local lucky_team_table = {
		[6] = 0,
		[7] = 0,
		[8] = 0,
		[9] = 0,
		[10] = 0,
		[11] = 0,
		[12] = 0,
		[13] = 0,
	}
	local try_count = 0
	local money_left = guancai_money
	while try_count < 10000 and money_left > 0 do 
		local random_team = RandomInt(6,13)
		local h = TeamId2Hero(random_team)
		if h ~= nil and h:IsAlive() == true and random_team ~= hero:GetTeam() then
			lucky_team_table[random_team] = lucky_team_table[random_team] + 1
			money_left = money_left - 1
		end
		try_count = try_count + 1
	end

	for t,count in pairs(lucky_team_table) do
		if count > 0 then
			local position_to = CenterVector(t) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
			DropMoneyBag(Vector(0,0,128), position_to, 300, ( count or 1 ))
			-- local hero = TeamId2Hero(t)
			-- if hero ~= nil and hero:GetPlayerID() ~= nil then
			-- 	AddTotalMoneyStat(hero:GetPlayerID(),count)
			-- end
		end
	end

	ShowCombat({
		t = 'player_dead',
		player = hero:GetPlayerID(),
		num = gg_item_count,
		gold = guancai_money,
	})

	--给击杀者一个大红包
	local last_damaged_by_team = hero.last_damaged_by_team
	local win_round = math.floor(GetStat(hero:GetPlayerID(),'win_round')/2.0+0.5)

	if last_damaged_by_team ~= nil and last_damaged_by_team ~= hero:GetTeam() and win_round ~= nil and win_round > 0 then
		local position_to = CenterVector(last_damaged_by_team) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
		DropMoneyBag(Vector(0,0,128), position_to, 100, ( win_round or 1 ))
		ShowCombat({
			t = 'terminate',
			player = hero:GetPlayerID(),
			player2 = TeamId2Hero(last_damaged_by_team):GetPlayerID(),
			num = win_round,
		})

		if TeamId2Hero(last_damaged_by_team) ~= nil and TeamId2Hero(last_damaged_by_team):HasModifier('modifier_item_more_reward') then
			--获得收割者经验
			ExpBook({
				caster = TeamId2Hero(last_damaged_by_team),
				xpadd = win_round * 2,
				disable_quick_lvl_up = true,
				cost = 0,
			})
			--在客场信使上显示特效
			if TeamId2Hero(last_damaged_by_team).my_away_mirror_chesser ~= nil then
				AMHC:CreateNumberEffect(TeamId2Hero(last_damaged_by_team).my_away_mirror_chesser,win_round * 2,7,AMHC.MSG_MISS,{255,255,128},0)
			end
		end
	end

	Timers:CreateTimer(0.3,function()
		ClearHand(hero:GetTeam())
	end)
end
--根据玩家存活情况结算刚刚战败的玩家hero
function SetRankingState(hero)
	_G.counterpart[hero:GetTeam()] = -1
	if GetAlivePlayerCount() == 1 and _G.playing_player_count == 1 then
		--1P单人模式，直接结束游戏
		_G.is_game_ended = true
		prt('GAME OVER')
		EmitGlobalSound("dac.season.gameover")
		PostGame()
		Timers:CreateTimer(3,function()
			GameRules:SetGameWinner(DOTA_TEAM_NEUTRALS)
		end)
		return
	end
	if _G.p2_mode == true and FindValueInTable(_G.p2_death_table,hero.p2team) == false then
		table.insert(_G.p2_death_table,hero.p2team)
	end

	local alive_player_count = GetAlivePlayerCount()

	if _G.p2_mode == true and alive_player_count >= 2 then
		--2P模式，剩余队伍>=1，正常结算
		local team_rank = nil
		for xx,yy in pairs(_G.p2_death_table) do
			if hero.p2team == yy then
				team_rank = GetP2TeamCount()+1-xx
			end
		end
		if team_rank ~= nil then
			if FindValueInTable(_G.send_status,hero.steam_id) == true then
				RemoveTableItem(_G.send_status,hero.steam_id)
				PostOneToServer(hero,hero.steam_id,team_rank,'p2')
				local teammate = TeamId2Hero(GetP2Ally(hero:GetTeam()))
				if teammate ~= nil and FindValueInTable(_G.send_status,teammate.steam_id) == true then
					RemoveTableItem(_G.send_status,teammate.steam_id)
					PostOneToServer(teammate,teammate.steam_id,team_rank,'p2')
				end
			end
		end
	end
	if _G.p2_mode == true and alive_player_count <= 2 then
		--2P模式，剩余队伍<=1，结算胜者（2个玩家），游戏结束
		if _G.p2_win_sent == true then
			return
		end
		_G.p2_win_sent = true
		_G.is_game_ended = true
		prt('GAME OVER')
		if alive_player_count > 0 then
			if _G.send_status[2] ~= nil then
				local steamid_2 = _G.send_status[2]
				RemoveTableItem(_G.send_status,steamid_2)
				local h_2 = PlayerId2Hero(_G.steamid2playerid[steamid_2])
				if _G.egg_quest == 'q002' and GetCurrMapInfo().map_name == 'ranked_2x4' then
					SetQuest(h_2.team_id,true)
				end
				PostOneToServer(h_2,steamid_2,1,'p2')
			end
			if _G.send_status[1] ~= nil then
				local steamid_1 = _G.send_status[1]
				RemoveTableItem(_G.send_status,steamid_1)
				local h_1 = PlayerId2Hero(_G.steamid2playerid[steamid_1])
				if _G.egg_quest == 'q002' and GetCurrMapInfo().map_name == 'ranked_2x4' then
					SetQuest(h_1.team_id,true)
				end
				PostOneToServer(h_1,steamid_1,1,'p2')
			end
		end
	end

	if alive_player_count >= 2 and _G.p2_mode ~= true and _G.playing_player_count > 1 then
		--1P多人模式，当前名次>=2，正常结算
		if FindValueInTable(_G.send_status,hero.steam_id) == true then
			RemoveTableItem(_G.send_status,hero.steam_id)
			PostOneToServer(hero,hero.steam_id,alive_player_count,'p1')
		end
	end
	if alive_player_count <= 2 and _G.p2_mode ~= true and _G.playing_player_count > 1 then
		_G.is_game_ended = true
		--1P第一名
		if GetAlivePlayerCount() == 1 then
			local last_steamid = _G.send_status[1]
			local last_hero = PlayerId2Hero(_G.steamid2playerid[last_steamid])
			RemoveTableItem(_G.send_status,last_steamid)
			if _G.egg_quest == 'q001' and GetCurrMapInfo().map_name == 'ranked_1x8' then
				SetQuest(last_hero.team_id,true)
			end

			PostOneToServer(last_hero,last_steamid,1,'p1')
		end
		--为防止发送失败了，30秒后自动结束游戏
		Timers:CreateTimer(30,function()
			if _G.setwin == nil then
				GameRules:SetGameWinner(last_hero:GetTeam())
			end
		end)
	end
	--hero是刚刚战败的玩家
	if GetAlivePlayerCount() == 2 and _G.playing_player_count > 2 and _G.p2_mode ~= true then
		--1P模式：决赛提醒
		_G.pilao_round = _G.battle_round + 6 --野怪关不算
		prt('#text_grand_final_start')
		-- EmitGlobalSound("diretide_eventstart_Stinger")
		EmitGlobalSound("dac.season.grandfinal")

		--给决赛双方添加一些观众
		for _,steam_id in pairs(_G.send_status) do
			local player_id = _G.steamid2playerid[steam_id]
			local team_id = _G.playerid2team[player_id]
			SummonCheerCourier(team_id,3)
		end
		if RandomInt(1,100) < 25 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'grand_final', 3)
	    end
	    if RandomInt(1,100) < 25 then
	    	SayCheerBubble(hero:GetTeam(), nil, 'grand_final', 6)
	    end
	end
end
function PostGame()
	CustomNetTables:SetTableValue( "dac_table", "end_board", { data = _G.stat_info, hehe = RandomInt(1,100000)})
end
function PostPlayerInfo()
	StatAllPlayerLineup()
	UpdateStatUI()
end
function LoadPVEEnemy(wave,team)
	if _G.battle_boss[wave] ~= nil then
		for _,vi in pairs(_G.battle_boss[wave]) do
			LoadOnePVEEnemy(vi,team)
		end
	end
	Timers:CreateTimer(4.5,function()
		AddComboAbility(team)
	end)
end
function LoadOnePVEEnemy(vi,team)
	local animation_info = GetAnimation('n101')
	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector(vi.x,vi.y,team),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end
			_G.unit[team][vi.y..'_'..vi.x] = 1
			local x = CreateUnitByName(vi.enemy,XY2Vector(vi.x,vi.y,team),true,nil,nil,DOTA_TEAM_NEUTRALS)
			x:SetForwardVector(Vector(0,-1,0))
			x.y_x = vi.y..'_'..vi.x
			x.y = vi.y
			x.x = vi.x
			x.team_id = 4
			x.at_team_id = team
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			table.insert(_G.to_be_destory_list[team],x)

			local hero = TeamId2Hero(team)
			if hero:HasModifier('modifier_item_more_creep') then
				x.kobold_result = true
				x.kobold_hp_per = -25
				AddAbilityAndSetLevel(x,'more_creep')
			end

			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
		end)
	end)
end
function DropItem(unit)
	local unit_level = unit:GetLevel()
	if unit_level <= 2 or unit.is_summoned == true then 
		return
	end

	local hero = TeamId2Hero(unit.at_team_id)
	local ran = RandomInt(1,100)
	if hero.undrop_item_count_total ~= nil and hero.undrop_item_count_total > 0 then
		ran = ran + hero.undrop_item_count_total
	end
	if ran > 100 then
		ran = 100
	end
	local item_level = 0
	local curr_per = 0
	

	if _G.drop_item_gailv[unit_level] ~= nil then
		for per,lv in pairs(_G.drop_item_gailv[unit_level]) do
			if ran >= per and curr_per<=per then
				curr_per = per
				item_level = lv
			end
		end
	end

	if item_level > 0 then
		-- if IsUnitExist(hero) and hero:HasModifier('modifier_item_upgrade_lootbox') and RandomInt(1,100) < 70 then
		-- 	item_level = item_level + 1
		-- 	if item_level > 3 then
		-- 		item_level = 3
		-- 	end
		-- end
		if hero.undrop_item_count_total == nil then
			hero.undrop_item_count_total = -1
		else
			hero.undrop_item_count_total = hero.undrop_item_count_total - item_level
		end

		--掉
		local i = _G.DROP_ITEM_LIST[item_level][RandomInt(1,table.maxn(_G.DROP_ITEM_LIST[item_level]))]

		if hero:HasModifier('modifier_item_double_lootbox') then
			--绿皮船长的宝藏
			i = _G.wave_2_lootbox[_G.battle_round - 1]
			if i == 'item_relicbox' then
				--圣物宝箱关的绿皮掉落，取-5关的宝箱
				i = _G.wave_2_lootbox[_G.battle_round - 6]
			end
		end

		-- hero:AddItemByName(i)

		local newItem = CreateItem( i, hero, hero )
		local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
		local dropRadius = RandomFloat( 50, 200 )
		newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
		hero.undrop_item_count = 0
	else
		--没掉
		if hero.undrop_item_count_total == nil then
			hero.undrop_item_count_total = 1
		else
			hero.undrop_item_count_total = hero.undrop_item_count_total + 1
		end

		if hero.undrop_item_count == nil then
			hero.undrop_item_count = 1
		else
			hero.undrop_item_count = hero.undrop_item_count + 1
			if hero.undrop_item_count >= 5 then
				hero.undrop_item_count = 0
				local i = _G.ITEM_FOOD_LIST[RandomInt(1,table.maxn(_G.ITEM_FOOD_LIST))]

				if hero:HasModifier('modifier_item_double_lootbox') then
					--绿皮船长的宝藏
					i = _G.wave_2_lootbox[_G.battle_round - 1]
					if i == 'item_relicbox' then
						--圣物宝箱关的绿皮掉落，取-5关的宝箱
						i = _G.wave_2_lootbox[_G.battle_round - 6]
					end
				end
				-- hero:AddItemByName(i)

				local newItem = CreateItem( i, hero, hero )
				local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
				local dropRadius = RandomFloat( 50, 200 )
				newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
			end
		end
	end
end
function DropItemAppointed(hero,unit,item)
	-- hero:AddItemByName(item)
	local newItem = CreateItem( item, hero, hero )
	local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
	local dropRadius = RandomFloat( 10, 100 )
	if unit == nil or unit:IsNull() == true or unit:GetAbsOrigin() == nil then
		unit = hero
	end
	newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
end
function StartAPVERound()
	-- _G.battle_count = 0
	InitBattleTable()

	--为每个场地加载敌人
	for i,v in pairs (_G.counterpart) do
		if v ~= -1 then
			-- _G.battle_count = _G.battle_count + 1
			SetBattleTable(i,true)
			v = 0
			local h = TeamId2Hero(i)
			CheckChess(i)
			CancelPickBattleChess(h)
			StatClassCount(i)
			_G.battle_round_type = 'pve'
			LoadPVEEnemy(_G.battle_round,i)
			local mana = h:GetMana()
			if mana>5 then
				mana = 5
			end
			Timers:CreateTimer(3.1,function()
				CopyArcWarden(i)
			end)
		end
	end
	--每秒判断每个场地是否决出了胜负
	Timers:CreateTimer(4.5,function()
		if _G.start_ai == false then
			return 1
		end
		for m,n in pairs (_G.to_be_destory_list) do
			if table.maxn(GetValidChessOnBoard(m)) > 0 then
				Timers:CreateTimer(function()
					if _G.battle_timer <= 0 then
						--平局
						SetBattleTable(m,false)
						EmitSoundOn("dac.round.win",TeamId2Hero(m))
						ShowCombat({
							t = 'battle_pve_draw',
							player = TeamId2Hero(m):GetPlayerID(),
							text = 'pve_'..(_G.battle_round-1),
						})
						SaveMaxObj(m,'draw')
						DropMangoAndUpdateLastBattle(m, 3)

						--通知UI显示胜负
						for team_i=6,13 do
							CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
								key = GetClientKey(team_i),
								player_id = TeamId2Hero(m):GetPlayerID(),
								winlose = "draw",
							})
						end
						CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
							key = GetClientKey(1),
							player_id = TeamId2Hero(m):GetPlayerID(),
							winlose = "draw",
						})
						TeamId2Hero(m).is_battle_completed = true
						ShowDamageStatOfTeam(m)
						if _G.battle_round%10 == 1 then
							TeamId2Hero(m):RemoveItem(TeamId2Hero(m):GetItemInSlot(16))
							if TeamId2Hero(m).mango_tree ~= nil and TeamId2Hero(m).mango_tree:IsNull() == false then
								EmitSoundOn("item.mangotree.break",TeamId2Hero(m).mango_tree)
								TeamId2Hero(m).mango_tree:ForceKill(false)
								TeamId2Hero(m).mango_tree:SetModelScale(0.001)
								play_particle("effect/animation/tree/2_oak_01_destruction.vpcf",PATTACH_ABSORIGIN_FOLLOW,TeamId2Hero(m).mango_tree,3)
							end
							if TeamId2Hero(m).great_vault ~= nil and TeamId2Hero(m).great_vault:IsNull() == false then
								EmitSoundOn("item.mangotree.break",TeamId2Hero(m).great_vault)
								TeamId2Hero(m).great_vault:ForceKill(false)
								TeamId2Hero(m).great_vault:SetModelScale(0.001)
								play_particle("particles/creatures/aghanim/aghanim_shard_channel_swirl.vpcf",PATTACH_ABSORIGIN_FOLLOW,TeamId2Hero(m).great_vault,3)
							end
							SetStat(TeamId2Hero(m):GetPlayerID(),'relic','',true)
						end
						return
					else
						local mychess = 0
						local enemychess = 0
						local my_last_chess = nil
						for p,q in pairs(GetValidChessOnBoard(m)) do
							if q.team_id == m then
								mychess = mychess + 1
								my_last_chess = q
							else
								enemychess = enemychess + 1
							end
						end
						if enemychess == 0 then
							SetBattleTable(m,false)
							HoorayAndMechHuman(m)
							local hero = TeamId2Hero(m)
							if my_last_chess ~= nil or hero.pet1 ~= nil then
								if hero.pet1 ~= nil and RandomInt(1,100) < 50 then
									PlayPetDialogue(hero.pet1, true, hero.language)
								else
									if my_last_chess ~= nil then
										PlayChessDialogue(my_last_chess,'win')
									end
								end
							end
							ShowCombat({
								t = 'battle_pve_win',
								player = TeamId2Hero(m):GetPlayerID(),
								text = 'pve_'..(_G.battle_round-1),
								num = mychess,
							})

							EmitSoundOn("dac.round.win",TeamId2Hero(m))
							SaveMaxObj(m,'win'..mychess)
							GiveALootBox(TeamId2Hero(m))
							AddHistoryWin(m,4)
							TeamId2Hero(m).is_battle_completed = true
							ShowDamageStatOfTeam(m)
							DropMangoAndUpdateLastBattle(m, 1)

							--通知UI显示胜负
							for team_i=6,13 do
								CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
									key = GetClientKey(team_i),
									player_id = TeamId2Hero(m):GetPlayerID(),
									winlose = "win",
								})
							end
							CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
								key = GetClientKey(1),
								player_id = TeamId2Hero(m):GetPlayerID(),
								winlose = "win",
							})
							if _G.battle_round%10 == 1 then
								TeamId2Hero(m):RemoveItem(TeamId2Hero(m):GetItemInSlot(16))
								if TeamId2Hero(m).mango_tree ~= nil and TeamId2Hero(m).mango_tree:IsNull() == false then
									EmitSoundOn("item.mangotree.break",TeamId2Hero(m).mango_tree)
									TeamId2Hero(m).mango_tree:ForceKill(false)
									TeamId2Hero(m).mango_tree:SetModelScale(0.001)
									play_particle("effect/animation/tree/2_oak_01_destruction.vpcf",PATTACH_ABSORIGIN_FOLLOW,TeamId2Hero(m).mango_tree,3)
								end
								if TeamId2Hero(m).great_vault ~= nil and TeamId2Hero(m).great_vault:IsNull() == false then
									EmitSoundOn("item.mangotree.break",TeamId2Hero(m).great_vault)
									TeamId2Hero(m).great_vault:ForceKill(false)
									TeamId2Hero(m).great_vault:SetModelScale(0.001)
									play_particle("particles/creatures/aghanim/aghanim_shard_channel_swirl.vpcf",PATTACH_ABSORIGIN_FOLLOW,TeamId2Hero(m).great_vault,3)
								end
								SetStat(TeamId2Hero(m):GetPlayerID(),'relic','',true)
							end
							return
						elseif mychess == 0 then
							Timers:CreateTimer(0.5,function()
								local enemychess_new = 0
								for p,q in pairs(GetValidChessOnBoard(m)) do
									if q.team_id ~= m then
										enemychess_new = enemychess_new + 1
									end
								end
								if enemychess_new == 0 then
									SetBattleTable(m,false)
									HoorayAndMechHuman(m)
									local hero = TeamId2Hero(m)
									if my_last_chess ~= nil or hero.pet1 ~= nil then
										if hero.pet1 ~= nil and RandomInt(1,100) < 50 then
											PlayPetDialogue(hero.pet1, true, hero.language)
										else
											if my_last_chess ~= nil then
												PlayChessDialogue(my_last_chess,'win')
											end
										end
									end
									ShowCombat({
										t = 'battle_pve_win',
										player = TeamId2Hero(m):GetPlayerID(),
										text = 'pve_'..(_G.battle_round-1),
										num = mychess,
									})
									SaveMaxObj(m,'win'..mychess)
									GiveALootBox(TeamId2Hero(m))
									EmitSoundOn("dac.round.win",TeamId2Hero(m))
									AddHistoryWin(m,4)
									DropMangoAndUpdateLastBattle(m, 1)

									--通知UI显示胜负
									for team_i=6,13 do
										CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
											key = GetClientKey(team_i),
											player_id = TeamId2Hero(m):GetPlayerID(),
											winlose = "win",
										})
									end
									CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
										key = GetClientKey(1),
										player_id = TeamId2Hero(m):GetPlayerID(),
										winlose = "win",
									})
								else
									if _G.egg_quest == 'q017' then
										SetQuest(m,false)
									end
									SetBattleTable(m,false)

									local hero = TeamId2Hero(m)
									local curr_hp = hero:GetHealth()

									ShowCombat({
										t = 'battle_pve_lose',
										player = TeamId2Hero(m):GetPlayerID(),
										text = 'pve_'..(_G.battle_round-1),
										num = enemychess_new,
									})

									--通知UI显示胜负
									for team_i=6,13 do
										CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
											key = GetClientKey(team_i),
											player_id = TeamId2Hero(m):GetPlayerID(),
											winlose = "lose",
										})
										CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
											key = GetClientKey(1),
											player_id = TeamId2Hero(m):GetPlayerID(),
											winlose = "lose",
										})
									end
									SaveMaxObj(m,'lose'..enemychess_new)
									EmitSoundOn("dac.round.lose.pve",hero)
									AddHistoryLose(m,4)
									DropMangoAndUpdateLastBattle(m, -1)

									--清除拉比克技能
									for _,rchess in pairs(_G.mychess[m]) do
										if string.find(rchess.chess,'rubick') ~= nil then
											rchess.rubick_a = nil
										end
									end
									--大魔导师的袖里乾坤
									if hero:HasModifier('modifier_item_steal_chess') then
										AddItemPlus(hero,'item_magic_card')
										EmitSoundOn("ui.inv_pickup_key",hero)
									end
								end
								TeamId2Hero(m).is_battle_completed = true
								ShowDamageStatOfTeam(m)
								if _G.battle_round%10 == 1 then
									TeamId2Hero(m):RemoveItem(TeamId2Hero(m):GetItemInSlot(16))
									if TeamId2Hero(m).mango_tree ~= nil and TeamId2Hero(m).mango_tree:IsNull() == false then
										EmitSoundOn("item.mangotree.break",TeamId2Hero(m).mango_tree)
										TeamId2Hero(m).mango_tree:ForceKill(false)
										TeamId2Hero(m).mango_tree:SetModelScale(0.001)
										play_particle("effect/animation/tree/2_oak_01_destruction.vpcf",PATTACH_ABSORIGIN_FOLLOW,TeamId2Hero(m).mango_tree,3)
									end
									if TeamId2Hero(m).great_vault ~= nil and TeamId2Hero(m).great_vault:IsNull() == false then
										EmitSoundOn("item.mangotree.break",TeamId2Hero(m).great_vault)
										TeamId2Hero(m).great_vault:ForceKill(false)
										TeamId2Hero(m).great_vault:SetModelScale(0.001)
										play_particle("particles/creatures/aghanim/aghanim_shard_channel_swirl.vpcf",PATTACH_ABSORIGIN_FOLLOW,TeamId2Hero(m).great_vault,3)
									end
									SetStat(TeamId2Hero(m):GetPlayerID(),'relic','',true)
								end
								return
							end)
						else
							return 1
						end
					end
				end)
			end
		end
	end)
	
	Timers:CreateTimer(5,function()
		if _G.start_ai == false then
			return 1
		end
		--战斗回合倒计时，所有比赛结束或者时间到了就终止，每秒同步倒计时时间给客户端
		CheckP2Status()
		if _G.battle_timer <= 0 then
			Timers:CreateTimer(2,function()
				for i,v in pairs(_G.hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				_G.game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		elseif GetBattleCount() == 0 and _G.battle_timer >= 3 then
			Timers:CreateTimer(2,function()
				for i,v in pairs(_G.hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				_G.game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		else
			--发送当前游戏时间给客户端
			UpdateTimer()

			_G.battle_timer = _G.battle_timer - 1
			return 1
		end
	end)
	Timers:CreateTimer(4.5,function()
		--添加战斗技能，开启ai
		for t = 6,13 do
			for _,v in pairs(GetValidChessOnBoard(t)) do
				v.is_in_battle = true
				if _G.chess_ability_list[v:GetUnitName()] ~= nil then
					local a = _G.chess_ability_list[v:GetUnitName()]
					if v.steal_ability ~= nil then
						a = v.steal_ability
					end
					local a_level = 1
					if string.find(v:GetUnitName(),'1') then
						a_level = 2
					end
					if string.find(v:GetUnitName(),'11') then
						a_level = 3
					end
					if v:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(v,a,a_level)
					else
						v:FindAbilityByName(a):SetLevel(a_level)
					end
					if v.is_dragon_zhanhou == nil then
						InitChessMana(v)
					end
				end
				Timers:CreateTimer(0.5,function()
					if v == nil or v:IsNull() == true or v:IsAlive() == false or v.alreadywon == true then
						return
					end
					ChessAI(v)
					return 1
				end)
			end
		end
	end)
end
function StartAPVPRound()
	local send_table = {}
	for p,vp in pairs(_G.counterpart) do
		send_table[p] = _G.team2playerid[vp]
	end
	--为每个场地加载敌人（延时0.1-0.5秒）
	for i,v in pairs (_G.counterpart) do
		if v ~= -1 then
			local h = TeamId2Hero(i)
			if h.hand_entities ~= nil then
				for _,ent in pairs(h.hand_entities) do
					AddAbilityAndSetLevel(ent,'outofgame',1)
				end
			end
			CheckChess(i)
			CancelPickBattleChess(h)
			StatClassCount(i)
			if _G.playing_player_count == 1 and _G.cloudlineup[''.._G.battle_round] ~= nil then
				local chesses = nil
				for _,data in pairs(_G.cloudlineup[''.._G.battle_round]) do
					chesses = json.decode(data)
				end
				_G.battle_round_type = 'cloud'
				LoadCloudEnemy(_G.battle_round,i)
				h.cloud_opp_name = chesses.owner
			else
				_G.battle_round_type = 'pvp'
				MirrorARound(i)
				h.cloud_opp_name = nil
			end

			Timers:CreateTimer(3.1,function()
				CopyArcWarden(i)
			end)

			if RandomInt(1,100) < 25 then
		    	SayCheerBubble(h:GetTeam(), nil, 'battle', 6)
		    end
		end
	end
	InitBattleTable()
	--添加战斗技能和棋子AI
	Timers:CreateTimer(4.5,function()
		for t = 6,13 do
			for _,v in pairs(GetValidChessOnBoard(t)) do
				v.is_in_battle = true
				if _G.chess_ability_list[v:GetUnitName()] ~= nil then
					local a = _G.chess_ability_list[v:GetUnitName()]
					if v.steal_ability ~= nil then
						a = v.steal_ability
					end
					local a_level = 1
					if string.find(v:GetUnitName(),'1') then
						a_level = 2
					end
					if string.find(v:GetUnitName(),'11') then
						a_level = 3
					end
					if v:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(v,a,a_level)
					else
						v:FindAbilityByName(a):SetLevel(a_level)
					end
					-- v:RemoveAbility('jiaoxie_wudi')
					-- v:RemoveModifierByName('modifier_jiaoxie_wudi')
					if v.is_dragon_zhanhou == nil then
						-- v:SetMana(0)
						InitChessMana(v)
					end

					if a == 'lc_qianggong' and v.press_count ~= nil and v.press_count > 0 then
						SetPressStack(v)
					end
					if v.track_money_count ~= nil and v.track_money_count > 0 then
						SetTrackMoneyStack(v)
					end
				end
				Timers:CreateTimer(0.5,function()
					if v == nil or v:IsNull() == true or v:IsAlive() == false or v.alreadywon == true then
						return
					end
					ChessAI(v)
					return 1
				end)
			end
		end
	end)
	--启动判断每个场地胜负的计时器
	Timers:CreateTimer(4.5,function()
		for team = 6,13 do
			if _G.counterpart[team] ~= nil and _G.counterpart[team] ~= -1 then
				-- SaveMaxObj(team)
				-- _G.battle_count = _G.battle_count + 1
				SetBattleTable(team,true)
				StartWinLoseDrawTimerForTeam(team)
			end
		end
	end)

	--判断分是否战斗回合结束、进入准备回合的计时器（延时4.5秒）
	Timers:CreateTimer(5,function()
		CheckP2Status()
		if _G.battle_timer <= 0 then
			--战斗时间到了，进入准备回合
			Timers:CreateTimer(2,function()
				for i,v in pairs(_G.hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				_G.game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		elseif GetBattleCount() == 0 and _G.battle_timer >= 3 then
			--没有正在战斗的了，进入准备回合
			Timers:CreateTimer(2,function()
				for i,v in pairs(_G.hero) do
					if IsUnitExist(v) == true then
						RestoreARound(v:GetTeam())
					end
				end
			end)
			Timers:CreateTimer(5,function()
				_G.game_status = 1
				StartAPrepareRound()
				return
			end)
			return
		else
			--还有正在战斗的，发送时间给客户端
			UpdateTimer()

			_G.battle_timer = _G.battle_timer - 1
			return 1
		end
	end)
end
--为指定队伍的场地开启一个胜平负判断计时器
function StartWinLoseDrawTimerForTeam(m)
	Timers:CreateTimer(3,function()
		if _G.battle_timer <= 0 then
			--第一种情况：时间到了，平局
			DrawARound(m)
			SaveMaxObj(m,'draw')
			TeamId2Hero(m).is_battle_completed = true
			ShowDamageStatOfTeam(m)
			return
		end
		
		--统计活着的敌我单位数量
		local mychess,enemychess,my_last_chess = GetChessCountInBattleGround(m)

		if mychess == 0 and enemychess == 0 then
			--第二种情况，敌我都没人了，平局
			DrawARound(m)
			SaveMaxObj(m,'draw')
			TeamId2Hero(m).is_battle_completed = true
			ShowDamageStatOfTeam(m)
			return
		end

		if mychess > 0 and enemychess == 0 then
			--第三种情况：敌方死光了，获胜
			WinARound(m,mychess,my_last_chess)
			SaveMaxObj(m,'win'..mychess)
			TeamId2Hero(m).is_battle_completed = true
			ShowDamageStatOfTeam(m)
			return
		elseif mychess == 0 then
			Timers:CreateTimer(0.5,function()
				--重新统计活着的敌我单位数量
				local mychess,enemychess_new,my_last_chess = GetChessCountInBattleGround(m)
				if enemychess_new == 0 then
					--第四种情况：敌我都死光了，平局
					DrawARound(m)
					SaveMaxObj(m,'draw')
					TeamId2Hero(m).is_battle_completed = true
					ShowDamageStatOfTeam(m)
					return
				else
					--第五种情况：只剩敌人了，失败
					LoseARound(m,enemychess_new)
					SaveMaxObj(m,'lose'..enemychess_new)
					TeamId2Hero(m).is_battle_completed = true
					ShowDamageStatOfTeam(m)
					return
				end
			end)
		else
			return 1
		end
	end)
end
function DrawARound(team)

	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	
	-- _G.battle_count = _G.battle_count - 1
	SetBattleTable(team,false)
	DropMangoAndUpdateLastBattle(team, 3)
	if TeamId2Hero(team).cloud_opp_name ~= nil then
		ShowCombat({
			t = 'battle_cloud_draw',
			player = TeamId2Hero(team):GetPlayerID(),
			text = TeamId2Hero(team).cloud_opp_name,
		})
	else
		ShowCombat({
			t = 'battle_pvp_draw',
			player = TeamId2Hero(team):GetPlayerID(),
			player2 = TeamId2Hero(_G.counterpart[team]):GetPlayerID(),
		})
	end

	EmitGlobalSound('crowd.lv_01')
	AddStat(TeamId2Hero(team):GetPlayerID(),'draw_round')
	RemoveLoseStreak(team)
	RemoveWinStreak(team)

	--通知UI显示胜负
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
			key = GetClientKey(team_i),
			player_id = hero:GetPlayerID(),
			winlose = "draw",
		})
	end
	CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
			key = GetClientKey(1),
			player_id = hero:GetPlayerID(),
			winlose = "draw",
		})
end
function WinARound(team,mychess,my_last_chess)
	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	local all_modifier = hero:FindAllModifiers()
	DropMangoAndUpdateLastBattle(team, 1)

	HoorayAndMechHuman(team)
	SetBattleTable(team,false)
	--宠物庆祝动作
	if hero.pet1 ~= nil then
		Celebrate(hero.pet1)
		--发表胜利感言
		if my_last_chess ~= nil or hero.pet1 ~= nil then
			if hero.pet1 ~= nil and RandomInt(1,100) < 20 then
				PlayPetDialogue(hero.pet1, true, hero.language)
			else
				if my_last_chess ~= nil then
					PlayChessDialogue(my_last_chess,'win')
				end
			end
		end
	end
	--信使庆祝动作
	Celebrate(hero)

	if TeamId2Hero(team).cloud_opp_name ~= nil then
		AddHistoryWin(team,5)
		ShowCombat({
			t = 'battle_cloud_win',
			player = TeamId2Hero(team):GetPlayerID(),
			num = mychess,
			text = TeamId2Hero(team).cloud_opp_name,
		})
	else
		if _G.counterpart[team] ~= nil and TeamId2Hero(_G.counterpart[team]) ~= nil then
			AddHistoryWin(team,_G.counterpart[team])
			ShowCombat({
				t = 'battle_pvp_win',
				player = TeamId2Hero(team):GetPlayerID(),
				player2 = TeamId2Hero(_G.counterpart[team]):GetPlayerID(),
				num = mychess,
			})
		end
	end
	
	AddStat(TeamId2Hero(team):GetPlayerID(),'win_round')
	RemoveLoseStreak(team)
	AddWinStreak(team)

	local hero = TeamId2Hero(team)
	if hero.mirror_chesser ~= nil then
		hero.mirror_chesser:ForceKill(false)
		hero.mirror_chesser = nil
	end
	--得1金币
	AddMana(hero, 1)
	AddTotalMoneyStat(hero:GetPlayerID(), 1)
	--通知UI显示胜负
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
			key = GetClientKey(team_i),
			player_id = hero:GetPlayerID(),
			winlose = "win",
		})
	end
	CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
		key = GetClientKey(1),
		player_id = hero:GetPlayerID(),
		winlose = "win",
	})

	--召唤观战信使
	if RandomInt(1,100) <= 25 then
		RandomSummonCheerCourier(hero:GetTeam())
	end
	if RandomInt(1,100) < 50 then
    	SayCheerBubble(hero:GetTeam(), nil, 'win', 1)
    end
    if RandomInt(1,100) < 25 then
    	SayCheerBubble(hero:GetTeam(), nil, 'win', 4)
    end
	
	--概率存阵容
	if RandomInt(1,100) < 5 then
		local lineup_table = {}
		local chess_count = 0
		for _,savechess in pairs(_G.mychess[team]) do
			table.insert(lineup_table,{
				x = savechess.x,
				y = savechess.y,
				lastitem = CopyTable(savechess.lastitem),
				chess = savechess.chess,
			})
			chess_count = chess_count + 1
		end
		local obj = {
			owner = TeamId2Hero(team).steam_id,
			chess_count = chess_count,
			lineup = lineup_table,
			round = _G.battle_round - 1,
			result = 'win',
			relic = GetCurrRelicByTeam(team),
		}
		table.insert(_G.upload_lineup,obj)
	end
end
function LoseARound(team,enemychess_new)
	
	-- _G.battle_count = _G.battle_count - 1
	SetBattleTable(team,false)

	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	DropMangoAndUpdateLastBattle(team, -1)
	--大魔导师的袖里乾坤
	if hero:HasModifier('modifier_item_steal_chess') then
		AddItemPlus(hero,'item_magic_card')
		EmitSoundOn("ui.inv_pickup_key",hero)
	end

	local curr_hp = hero:GetHealth()
	local delay_time = 0
	local damage_all = 0
	local is_have_thunder =false

	local oppo_hero = TeamId2Hero(_G.counterpart[team])
	local pj = _G.projectile_list['default_projectile']
	local projectile_partical = _G.projectile_list[pj]['effect']
	if oppo_hero ~= nil then
		if oppo_hero.is_vip == true then
			pj = _G.projectile_list['default_projectile_vip']
			projectile_partical = _G.projectile_list[pj]['effect']
		end

		if oppo_hero.projectile ~= nil and _G.projectile_list[oppo_hero.projectile] ~= nil then
			pj = oppo_hero.projectile
			projectile_partical = _G.projectile_list[oppo_hero.projectile]['effect']
		end
	end

	--宠物庆祝动作
	local mirror_chesser = TeamId2Hero(team).mirror_chesser
	if mirror_chesser ~= nil and mirror_chesser.pet2 ~= nil then
		Celebrate(mirror_chesser.pet2)
		PlayPetDialogue(mirror_chesser.pet2, true, mirror_chesser.language)
	end
	Celebrate(mirror_chesser)

	--显示胜利！
	local zeus_damage_max = 0
	local alive_draenei = {}
	for _,unit in pairs(GetValidChessOnBoard(team)) do
		--德莱尼技能
		if unit:HasAbility('is_draenei') and unit:HasModifier('modifier_is_draenei_buff') then
			table.insert(alive_draenei,unit)
		end
	end
	for _,u in pairs(GetValidChessOnBoard(team)) do
		if IsUnitExist(u) == true and u.team_id ~= team then
			u.alreadywon = true
			delay_time = (hero:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() / 1000
			AddStat(hero:GetPlayerID(),'deaths')

			if u:FindAbilityByName('zeus_thunder') == nil then
				--普通敌人
				-- if u:HasModifier('modifier_is_draenei_buff') then
				if table.maxn(alive_draenei) > 0 then
					--德莱尼：看看能不能传送到客场/主场助战
					if DraeneiAssist(u) == true then
						--助战
					else
						--不助战，照常欢呼
						AddAbilityAndSetLevel(u,'act_victory')
					end
				else
					AddAbilityAndSetLevel(u,'act_victory')
				end

				projectile = ProjectileManager:CreateTrackingProjectile({
			        Target = hero,
			        Source = u,
			        Ability = nil,
			        EffectName = projectile_partical,
			        bDodgeable = false,
			        iMoveSpeed = 1000,
			        bProvidesVision = false,
			        iVisionRadius = 0,
			        iVisionTeamNumber = u:GetTeamNumber(),
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    })
			    damage_all = damage_all + math.floor(GetHitDamage(u) or 1)
			else
				--宙斯，要雷劈的
				AddAbilityAndSetLevel(u,'act_thunder')
				local u_thunder_level = u:FindAbilityByName('zeus_thunder'):GetLevel()
				local u_thunder_table = {
					[1] = 15,
					[2] = 25,
					[3] = 45,
				}
				local zeus_damage = math.floor(hero:GetHealth()*(u_thunder_table[u_thunder_level])/100)
				if zeus_damage > zeus_damage_max then
					--宙斯雷劈伤害取最高的一个，不叠加
					zeus_damage_max = zeus_damage
				end
				is_have_thunder = true
				damage_all = damage_all + math.floor(GetHitDamage(u) or 1) 
			end
		end
	end

	if is_have_thunder == true and zeus_damage_max > 0 then
		damage_all = damage_all + zeus_damage_max
	end

	if hero:HasModifier('modifier_item_conceal_prepare') and RandomInt(1,100) <= 25 then
		--帷幕，25%闪避
		damage_all = 0
		-- play_particle("effect/dead/3.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,8)
		-- AddAbilityAndSetLevel(hero,'riki_permanent_invisibility',1)
	end

	if IsUnitExist(oppo_hero) and oppo_hero:HasModifier('modifier_item_more_reward') then
		--对方获得收割者经验
		ExpBook({
			caster = oppo_hero,
			xpadd = 4,
			disable_quick_lvl_up = true,
			cost = 0,
		})
		--在客场信使上显示特效
		if oppo_hero.my_away_mirror_chesser ~= nil then
			AMHC:CreateNumberEffect(oppo_hero.my_away_mirror_chesser,3,7,AMHC.MSG_MISS,{255,255,128},0)
		end
	end
	Timers:CreateTimer(delay_time,function()

		if damage_all == 0 then
			--闪避了
			play_particle("effect/dead/3.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,8)
		end

		--牧师护盾效果
		if _G.big_damage ~= 1 then
			damage_all = damage_all * _G.big_damage
		end
		if is_have_thunder ~= true and hero:FindModifierByName('modifier_item_fengwangjiang') ~= nil and damage_all >= 3 then
			--消耗一个蜂王浆
			local fengwangjiang = FindItemInInventory(hero,'item_fengwangjiang')
			if fengwangjiang ~= nil then
				damage_all = math.floor(damage_all*0.8 + 0.5)
				if damage_all == 0 then
					damage_all = 1
				end
				--第二次机会
				if hero:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
					PlayItemMultiCastParticle(hero)
				else
					-- fengwangjiang:SpendCharge()
					ItemSpendCharge({
						caster = hero,
						ability = fengwangjiang,
					})
				end
			end
		end
		--牧师护盾效果
		if is_have_thunder ~= true and damage_all >= hero:GetHealth() and hero:FindModifierByName('modifier_item_pingguo') ~= nil then
			--消耗一个苹果
			local pingguo = FindItemInInventory(hero,'item_pingguo')
			if pingguo ~= nil then
				damage_all = hero:GetHealth() - 1
				--第二次机会
				if hero:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
					PlayItemMultiCastParticle(hero)
				else
					-- pingguo:SpendCharge()
					ItemSpendCharge({
						caster = hero,
						ability = pingguo,
					})
				end
				if _G.egg_quest == 'q030' then
					SetQuest(team,true)
				end
				--特效和音效
				play_particle('effect/apple/2.vpcf',PATTACH_ABSORIGIN_FOLLOW,hero,6)
				EmitSoundOn("DOTA_Item.MagicLamp.Cast", hero)
			end
		end
		
		--牧师职业技能
		if hero:FindModifierByName('modifier_is_priest_buff_courier') ~= nil and damage_all < hero:GetHealth() then
			if damage_all > 17 then
				AddItemPlus(hero,'item_pingguo')
			elseif damage_all > 7 then
				AddItemPlus(hero,'item_chishu',0.1)
			elseif damage_all > 0 then
				AddItemPlus(hero,'item_fengwangjiang',0.2)
			end
			play_particle("particles/items_fx/aegis_respawn_spotlight.vpcf",PATTACH_OVERHEAD_FOLLOW,hero,5)
		end
		
		if is_have_thunder == true then
			--雷击特效和音效
			EmitSoundOn('Hero_Zuus.GodsWrath.Target',hero)
			PlayParticleOnUnitUntilDeath({
				caster = hero,
				p = "particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_bolt_parent.vpcf",
			})
		end

		if IsUnitExist(oppo_hero) and oppo_hero:HasModifier('modifier_item_vampiric_embrace') then
			--吸血鬼吸血
			local heal_hp = damage_all
			if hero:GetHealth() < damage_all then
				heal_hp = hero:GetHealth()
			end
			ValdmirRestore(oppo_hero,math.floor(heal_hp*0.4))
		end
		if _G.p2_mode == true and GetP2Ally(team) ~= nil then
			--2P模式，队友分担伤害
			local damage_all_2p = math.floor(damage_all/2+0.5)
			if damage_all_2p == 0 then
				damage_all_2p = 1
			end
			--记录最后造成伤害的队伍
			TeamId2Hero(team).last_damaged_by_team = _G.counterpart[team]
			TeamId2Hero(GetP2Ally(team)).last_damaged_by_team = _G.counterpart[team]
			DamageTeam(team, damage_all_2p, pj)
			DamageTeam(GetP2Ally(team), damage_all_2p, pj)

			AddStat(TeamId2Hero(team):GetPlayerID(),'hero_damaged',damage_all)
			
		else
			--记录最后造成伤害的队伍
			TeamId2Hero(team).last_damaged_by_team = _G.counterpart[team]
			--1P模式，正常伤害
			DamageTeam(team, damage_all, pj)
			AddStat(TeamId2Hero(team):GetPlayerID(),'hero_damaged',damage_all)
		end
	end)

	Timers:CreateTimer(delay_time+2, function()
		RemoveAbilityAndModifier(hero,'riki_permanent_invisibility')
	end)

	--显示战报
	if TeamId2Hero(team).cloud_opp_name ~= nil then
		AddHistoryLose(team,5)
		ShowCombat({
			t = 'battle_cloud_lose',
			player = TeamId2Hero(team):GetPlayerID(),
			num = enemychess_new,
			text = TeamId2Hero(team).cloud_opp_name,
			hp_damage = damage_all,
		})
	else
		AddHistoryLose(team,_G.counterpart[team])
		ShowCombat({
			t = 'battle_pvp_lose',
			player = TeamId2Hero(team):GetPlayerID(),
			player2 = TeamId2Hero(_G.counterpart[team]):GetPlayerID(),
			num = enemychess_new,
			hp_damage = damage_all,
		})

		AddStat(TeamId2Hero(_G.counterpart[team]):GetPlayerID(),'hero_damage',damage_all)

		if _G.egg_quest == 'q020' and GetStat(TeamId2Hero(_G.counterpart[team]):GetPlayerID(),'hero_damage') >= 150 then
			SetQuest(_G.counterpart[team],true)
		end
	end
	
	EmitSoundOn("dac.round.lose",hero)
	AddStat(TeamId2Hero(team):GetPlayerID(),'lose_round')
	AddLoseStreak(team)
	RemoveWinStreak(team, _G.counterpart[team])

	--通知UI显示胜负
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_round_win_lose",{
			key = GetClientKey(team_i),
			player_id = hero:GetPlayerID(),
			winlose = "lose",
		})
	end
	CustomGameEventManager:Send_ServerToTeam(1,"show_round_win_lose",{
			key = GetClientKey(1),
			player_id = hero:GetPlayerID(),
			winlose = "lose",
		})

	if RandomInt(1,100) < 25 then
    	SayCheerBubble(hero:GetTeam(), nil, 'lose', 3)
    end
    if RandomInt(1,100) < 25 then
    	SayCheerBubble(hero:GetTeam(), nil, 'lose', 6)
    end

	--概率存阵容
	if RandomInt(1,100) < 5 then
		local lineup_table = {}
		local chess_count = 0
		for _,savechess in pairs(_G.mychess[team]) do
			table.insert(lineup_table,{
				x = savechess.x,
				y = savechess.y,
				lastitem = CopyTable(savechess.lastitem),
				chess = savechess.chess
			})
			chess_count = chess_count + 1
		end
		if chess_count > 2 then
			local obj = {
				owner = TeamId2Hero(team).steam_id,
				chess_count = chess_count,
				lineup = lineup_table,
				round = _G.battle_round - 1,
				result = 'lose',
				relic = GetCurrRelicByTeam(team),
			}
			table.insert(_G.upload_lineup,obj)
		end
	end
	--清除拉比克技能
	for _,rchess in pairs(_G.mychess[team]) do
		if string.find(rchess.chess,'rubick') ~= nil then
			rchess.rubick_a = nil
		end
	end
	--圣剑掉落
	DropShengJian(team)
	hero.last_lose_lineup = hero.last_opp_lineup
end

--游戏循环2——开始一轮战斗回合（包括回合结果判断）
function StartABattleRound()
	if _G.is_game_ended == true then
		return
	end
	PostPlayerInfo()
	for i = 6,13 do
		ConcealToggle(i,-1)
	end
	CustomNetTables:SetTableValue( "dac_table", "hide_damage_stat", 
		{ 
			hehe = RandomInt(1,100000) 
		} 
	)

	GameRules:SetTimeOfDay(0.3)

	ResetAllDeadChessList()

	if _G.battle_boss[_G.battle_round] ~= nil then
		StartAPVERound()
	else
		StartAPVPRound()
	end
end
--2v2相关的方法
function SetP2Team(team,p2team)
	local h = TeamId2Hero(team)
	if h ~= nil then
		h.p2team = p2team
		table.insert(_G.p2_player[p2team],team)
		h:FindAbilityByName('transfer_chess'):SetHidden(false)
		SetStat(TeamId2Hero(team):GetPlayerID(),'p2team',p2team)
		UpdatePlayerCurrRank()
		CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = _G.stat_info, hehe = RandomInt(1,1000)})
	end
end
function GetP2Team(team)
	local h = TeamId2Hero(team)
	if h ~= nil then
		return h.p2team
	else
		return nil
	end
end
function GetP2Ally(team)
	local h = TeamId2Hero(team)
	if h ~= nil and h.p2team ~= nil then
		for i,v in pairs(_G.p2_player[h.p2team]) do
			if v ~= team then
				return v
			end
		end 
	else
		return nil
	end
end
function IsP2TeamAlive(p2team)
	local hero_1 = TeamId2Hero(_G.p2_player[p2team][1])
	local hero_2 = TeamId2Hero(_G.p2_player[p2team][2])
	if IsUnitExist(hero_1) == false or IsUnitExist(hero_2) == false then
		_G.p2_battle[p2team] = -1
		return false
	else
		return true
	end
end
function GetP2TeamCount()
	local count_team = 0
	for i,v in pairs(_G.p2_player) do
		if table.maxn(v) == 2 then
			count_team = count_team + 1
		end
	end
	return count_team
end
function GetP2TeamAliveCount()
	local alive_team = 0
	for i,v in pairs(_G.p2_player) do
		if IsP2TeamAlive(i) == true then
			alive_team = alive_team + 1
		end
	end
	return alive_team
end
function AllocateP2Battle()
	local alive_team = GetP2TeamAliveCount()
	if _G.lastalive_team == nil or _G.lastalive_team ~= alive_team then
		_G.lastrandomn_team = nil
	end
	_G.lastalive_team = alive_team
	--随即一种方案
	local rann = _G.lastrandomn_team or 1
	local check_duplicate = 1
	if alive_team <= 2 then
		rann = 1
	else
		while rann == _G.lastrandomn_team or check_duplicate == 1 do
			rann = RandomInt(1,table.maxn(_G.p2_match[alive_team]))
			check_duplicate = 0
			if _G.lastrandomn_team ~= nil then
				for j,k in pairs(_G.p2_match[alive_team][rann]) do
					if k == _G.p2_match[alive_team][_G.lastrandomn_team][j] then
						check_duplicate = 1
					end
				end
			end
		end
	end
	_G.lastrandomn_team = rann
	local allo_table = {}
	for i=1,4 do
		if IsP2TeamAlive(i) == true then
			table.insert(allo_table,i)
		end
	end
	for j=1,#allo_table do
		_G.p2_battle[allo_table[j]] = allo_table[j+_G.p2_match[alive_team][rann][j]]
	end
end
function AllocateP2Counterpart()
	AllocateP2Battle()
	for i,v in pairs(_G.p2_battle) do
		if v ~= -1 then
			if RandomInt(1,100) > 50 then
				_G.counterpart[_G.p2_player[i][1]] = _G.p2_player[v][1]
				_G.counterpart[_G.p2_player[i][2]] = _G.p2_player[v][2]
			else
				_G.counterpart[_G.p2_player[i][1]] = _G.p2_player[v][2]
				_G.counterpart[_G.p2_player[i][2]] = _G.p2_player[v][1]
			end
		else
			if table.maxn(_G.p2_player[i]) > 0 then
				_G.counterpart[_G.p2_player[i][1]] = -1
				_G.counterpart[_G.p2_player[i][2]] = -1
			end
		end
	end
end
--游戏循环2.1——分配对手
function AllocateABattleRound()
	local finished = false
	--local trytime = 0

	-- while finished == false and trytime < 10000 do
		--trytime = trytime + 1
		local alive_player_count = 0
		--统计玩家死活
		for u,v in pairs(_G.counterpart) do
			if TeamId2Hero(u) ~= nil and TeamId2Hero(u):IsNull() == false and TeamId2Hero(u):IsAlive() == true then
				--活玩家
				_G.counterpart[u] = u
				alive_player_count = alive_player_count +1
			else
				--死玩家
				_G.counterpart[u] = -1
			end
		end
		local rann = _G.lastrandomn
		if alive_player_count < 1 then
			return
		elseif alive_player_count == 1 then
			rann = 0
		elseif alive_player_count == 2 then
			rann = 1
		else
			while rann == _G.lastrandomn do
				rann = RandomInt(1,alive_player_count-1)
			end
		end
		_G.lastrandomn = rann
		--给活玩家分配一个随机对手
		for rotate_count = 1,rann do
			for i,j in pairs(_G.counterpart) do
				if j ~= -1 then
					local aliveteam = j
					
					local n = 1
					local try_count = 0
					while (aliveteam == j or _G.counterpart[aliveteam] == nil or _G.counterpart[aliveteam] == -1) and try_count<10000 do
						aliveteam = aliveteam + 1
						if aliveteam > 13 then
							aliveteam = 6
						end
						try_count = try_count + 1
					end
					_G.counterpart[i] = aliveteam
				end
			end
		end
	-- 	finished = CheckCounterpart()
	-- end
end
function GetMyHostEnemyTeam(t)
	return _G.counterpart[t]
end
function GetMyGuestEnemyTeam(t)
	for i,v in pairs(_G.counterpart) do
		if v == t then
			return i
		end
	end
	return nil
end
--游戏循环2.1.x——分配对手用到的方法
function CheckCounterpart()
	local all_team_count = 0
	for _,__ in pairs(_G.counterpart) do
		all_team_count = all_team_count + 1
	end
	for team,conter in pairs(_G.counterpart) do
		if team == conter and all_team_count > 1 then
			return false
		end
	end
	return true
end
--为teamid的场地上所有的敌我棋子添加组合技
function AddComboAbility(teamid)
	local combo_chess_table_self = {}
	local combo_chess_table_enemy = {}
	local combo_count_table_self = {}
	local combo_count_table_enemy = {}
	local max_combo_self = 0
	local baojun_table_self = {}
	local baojun_table_enemy = {}
	local baojun_ability_table_self = {}
	local baojun_ability_table_enemy = {}
	--第一次循环：棋子分组，将棋子实体归类进combo_chess_table_self/combo_chess_table_enemy
	for w,vw in pairs(GetValidChessOnBoard(teamid)) do
		if vw.team_id == teamid then --我的棋子
			if IsUnitExist(vw) == true and vw:HasModifier('modifier_item_baojunwangpao') then
				table.insert(baojun_table_self,vw)
			end
			
			for k,vk in pairs(_G.combo_ability_type) do
				if combo_chess_table_self[k] == nil then
					combo_chess_table_self[k] = {}
				end
				if vw:FindAbilityByName(k) ~= nil or vw:FindAbilityByName(string.sub(k,1,-2)) ~= nil or vw:FindAbilityByName(string.sub(k,1,-3)) ~= nil then
					table.insert(combo_chess_table_self[k],vw)
				end
			end
		else --敌人的棋子
			if IsUnitExist(vw) == true and vw:HasModifier('modifier_item_baojunwangpao') then
				table.insert(baojun_table_enemy,vw)
			end
			local opp = 0
			--找到被镜像的棋子对手是谁
			for teama,teamb in pairs(_G.counterpart) do
				if teamb == vw.at_team_id then
					opp = teama
				end
			end
			for k,vk in pairs(_G.combo_ability_type) do
				if combo_chess_table_enemy[k] == nil then
					combo_chess_table_enemy[k] = {}
				end
				if vw:FindAbilityByName(k) ~= nil or vw:FindAbilityByName(string.sub(k,1,-2)) ~= nil or vw:FindAbilityByName(string.sub(k,1,-3)) ~= nil then
					table.insert(combo_chess_table_enemy[k],vw)
				end
			end
		end
	end
	--第二次循环：计数，把职业/种族的独特数量写入combo_count_table_self/combo_count_table_enemy
	for k,vk in pairs(combo_chess_table_self) do
		--统计不同的种类数
		local diff_count = 0
		local diff_string = ''
		for _,chess in pairs(combo_chess_table_self[k]) do
			--去掉等级变量
			local find_name = chess:GetUnitName()
			if string.find(find_name,'11') ~= nil then
				find_name = string.sub(find_name,1,-3)
			end
			if string.find(find_name,'1') ~= nil then
				find_name = string.sub(find_name,1,-2)
			end
			--搜索是否重复了
			if string.find(diff_string,'<'..find_name..'>') == nil then
				diff_count = diff_count + 1
				diff_string = diff_string..'<'..find_name..'>'
			end
		end
		if TeamId2Hero(teamid):FindAbilityByName(k) ~= nil then
			diff_count = diff_count + 1
		end
		combo_count_table_self[k] = diff_count
	end
	TeamId2Hero(teamid).combo_self = combo_count_table_self
	for k,vk in pairs(combo_chess_table_enemy) do
		--统计不同的种类数
		local diff_count = 0
		local diff_string = ''
		for _,chess in pairs(combo_chess_table_enemy[k]) do
			--去掉等级变量
			local find_name = chess:GetUnitName()
			if string.find(find_name,'11') ~= nil then
				find_name = string.sub(find_name,1,-3)
			end
			if string.find(find_name,'1') ~= nil then
				find_name = string.sub(find_name,1,-2)
			end
			--搜索是否重复了
			if string.find(diff_string,'<'..find_name..'>') == nil then
				diff_count = diff_count + 1
				diff_string = diff_string..'<'..find_name..'>'
			end
		end
		combo_count_table_enemy[k] = diff_count
	end
	--第三次循环：巫师、恶魔猎手相关的数量变换，以及统计唯一羁绊

	local the_only_combo_self = nil  --是否有唯一combo，初始=nil，有=combo名（去掉1和11），没有='not_only'
	local the_only_combo_enemy = nil  --是否有唯一combo，初始=nil，有=combo名（去掉1和11），没有='not_only'
	

	for m,vm in pairs(combo_count_table_self) do
		local find_combo_name = m
		if string.find(find_combo_name,'11') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-3)
		end
		if string.find(find_combo_name,'1') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-2)
		end

		if m ~= 'is_demon' and m ~= 'is_wizard' and m ~= 'is_wizard1' and combo_count_table_self[m] >= 3 and combo_count_table_self['is_wizard'] >= 2 and _G.combo_ability_type[m]['condition'] >= 4 then
			--2巫师
			combo_count_table_self[m] = combo_count_table_self[m] + 1
		end

		--恶魔猎手与恶魔
		if find_combo_name == 'is_demon' then
			if (combo_count_table_enemy['is_demonhunter'] or 0) >= 2 then
				vm = vm + 1
			end
			if vm == 1 or (combo_count_table_self['is_demonhunter'] or 0) >= 2 then
				combo_count_table_self['is_demon'] = 1
				vm = 1
			else
				combo_count_table_self['is_demon'] = 0
				vm = 0
			end
		end

		if vm > 0 then
			--唯一羁绊
			local c = _G.combo_ability_type[find_combo_name]['condition']
			if vm >= c and the_only_combo_self ~= nil and the_only_combo_self ~= 'not_only' and find_combo_name ~= 'is_wizard' and the_only_combo_self ~= find_combo_name then
				the_only_combo_self = 'not_only'
			end
			if vm >= c and the_only_combo_self == nil and find_combo_name ~= 'is_wizard' then
				the_only_combo_self = find_combo_name
			end
		end
	end
	for m,vm in pairs(combo_count_table_enemy) do
		local find_combo_name = m
		if string.find(find_combo_name,'11') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-3)
		end
		if string.find(find_combo_name,'1') ~= nil then
			find_combo_name = string.sub(find_combo_name,1,-2)
		end

		if m ~= 'is_demon' and m ~= 'is_wizard' and m ~= 'is_wizard1' and combo_count_table_enemy[m] >= 3 and combo_count_table_enemy['is_wizard'] >= 2 and _G.combo_ability_type[m]['condition'] >= 4 then
			--2巫师
			combo_count_table_enemy[m] = combo_count_table_enemy[m] + 1
		end

		--恶魔
		if find_combo_name == 'is_demon' then
			if (combo_count_table_self['is_demonhunter'] or 0) >= 2 then
				vm = vm + 1
			end
			if vm == 1 or (combo_count_table_enemy['is_demonhunter'] or 0) >= 2 then
				combo_count_table_enemy['is_demon'] = 1
				vm = 1
			else
				combo_count_table_enemy['is_demon'] = 0
				vm = 0
			end
		end
		if vm > 0 then
			--唯一羁绊
			local c = _G.combo_ability_type[find_combo_name]['condition']
			if vm >= c and the_only_combo_enemy ~= nil and the_only_combo_enemy ~= 'not_only' and find_combo_name ~= 'is_wizard' and the_only_combo_enemy ~= find_combo_name then
				the_only_combo_enemy = 'not_only'
			end
			if vm >= c and the_only_combo_enemy == nil and find_combo_name ~= 'is_wizard' then
				the_only_combo_enemy = find_combo_name
			end
		end
	end


	--暂存the_only_combo_self
	TeamId2Hero(teamid).the_only_combo_self = the_only_combo_self

	--补充4巫师触发了的唯一羁绊数量
	if combo_count_table_self['is_wizard'] ~= nil and combo_count_table_self['is_wizard'] >= 3 and the_only_combo_self ~= nil and the_only_combo_self ~= 'not_only' then
		if combo_count_table_self[the_only_combo_self] ~= nil then
			combo_count_table_self[the_only_combo_self] = _G.combo_ability_type[the_only_combo_self]['condition']
		end
		if combo_count_table_self[the_only_combo_self..'1'] ~= nil then
			combo_count_table_self[the_only_combo_self..'1'] = _G.combo_ability_type[the_only_combo_self..'1']['condition']
		end
		if combo_count_table_self[the_only_combo_self..'11'] ~= nil then
			combo_count_table_self[the_only_combo_self..'11'] = _G.combo_ability_type[the_only_combo_self..'11']['condition']
		end
	end
	if combo_count_table_enemy['is_wizard'] ~= nil and combo_count_table_enemy['is_wizard'] >= 3 and the_only_combo_enemy ~= nil and the_only_combo_enemy ~= 'not_only' then
		if combo_count_table_enemy[the_only_combo_enemy] ~= nil then
			combo_count_table_enemy[the_only_combo_enemy] = _G.combo_ability_type[the_only_combo_enemy]['condition']
		end
		if combo_count_table_enemy[the_only_combo_enemy..'1'] ~= nil then
			combo_count_table_enemy[the_only_combo_enemy..'1'] = _G.combo_ability_type[the_only_combo_enemy..'1']['condition']
		end
		if combo_count_table_enemy[the_only_combo_enemy..'11'] ~= nil then
			combo_count_table_enemy[the_only_combo_enemy..'11'] = _G.combo_ability_type[the_only_combo_enemy..'11']['condition']
		end
	end

	--统计keal_combo（人数最多的羁绊）记录在英雄上，卡尔在切技能的时候读取自己英雄或者找到敌方英雄的keal_combo决定用什么技能
	TeamId2Hero(teamid).kael_combo = nil
	for a,b in pairs(combo_count_table_self) do
		local con = _G.combo_ability_type[a]['condition']
		if string.find(a,'1') == nil and a ~= 'is_wizard' and a ~= 'is_wizard1' and b >= 2 and b > max_combo_self then
			max_combo_self = b
			TeamId2Hero(teamid).kael_combo = a
		end
	end

	if _G.egg_quest == 'q014' then
		for pp,qq in pairs(combo_count_table_self) do
			local con = _G.combo_ability_type[pp]['condition']
			if _G.quest_14_buff_list[pp] ~= nil and qq >= _G.quest_14_buff_list[pp] then
				SetQuest(teamid,true)
			end
			if _G.quest_14_buff_list[pp] ~= nil and TeamId2Hero(teamid).the_only_combo_self ~= nil and TeamId2Hero(teamid).the_only_combo_self == pp then
				SetQuest(teamid,true)
			end
			if _G.quest_14_buff_list[pp] ~= nil and combo_count_table_self['is_wizard'] >= 2 and qq+1 >= _G.quest_14_buff_list[pp] then
				SetQuest(teamid,true)
			end
		end
	end

	--第四次循环：为所有棋子添加羁绊技能
	local combo_count_race = 0
	local dragon_sound = false --龙战吼的声音是否触发过（只吼一次，否则声音太吵了）
	local god_sound = false --神战吼的声音是否触发过（只吼一次，否则声音太吵了）
	local combo_type_table = {} --用来统计combo种类数（比如3猎人和猎人6算1个combo_type）
	for s,x in pairs(combo_count_table_self) do
		local condition_0 = _G.combo_ability_type[s]['condition']
		local condition = condition_0
		local is_race = _G.combo_ability_type[s]['is_race']
		if x >= condition and is_race ~= true then
			for m,n in pairs(combo_chess_table_self[s]) do
				n.class = 1
			end
		end
		if x >= condition and is_race == true and string.find(s,'is_god') == nil then
			for m,n in pairs(combo_chess_table_self[s]) do
				n.race = 1
			end
		end
	end
	--恩拉基（在统计神的触发之后）
	if the_only_combo_self ~= 'is_nraqi' or GetWizardCount(teamid) >= 2 then
		combo_count_table_self['is_nraqi'] = 0
	end
	for p,vp in pairs(combo_chess_table_self) do
		local shaman_hex = false
		local shaman_hexhex = false
		local tauren_ward = false
		local kobold_together = false
		local type1 = _G.combo_ability_type[p]['type']
		local condition_0 = _G.combo_ability_type[p]['condition']
		local condition = condition_0
		local buff_ability = _G.combo_ability_type[p]['ability']
		local is_race = _G.combo_ability_type[p]['is_race']
		if combo_count_table_self[p] >= condition then
			if is_race == true then
				combo_count_race = combo_count_race + 1
			end
			SAdd(combo_type_table,p)
			local tauren_level = nil
			if combo_count_table_self['is_tauren'] ~= nil and combo_count_table_self['is_tauren'] >= _G.combo_ability_type['is_tauren']['condition'] then
				tauren_level = 'is_tauren'
				if combo_count_table_self['is_tauren1'] >= _G.combo_ability_type['is_tauren1']['condition'] then
					tauren_level = 'is_tauren1'
				end
			end
			for _,chess in pairs(combo_chess_table_self[p]) do
				if p == 'is_kobold' and kobold_together == false then
					kobold_together = true
					local double_table = {}
					for _,cc in pairs(GetValidChessOnBoard(teamid)) do
						if cc.team_id == teamid then
							if IsUnitExist(cc) == true then
								if double_table[cc:GetUnitName()] == nil then
									double_table[cc:GetUnitName()] = {}
								end
								table.insert(double_table[cc:GetUnitName()],cc)
							end
						end
					end
					local kobold_base = {}
					local kobold_active = true
					for _,kk in pairs(double_table) do
						if string.find(_,'chess_meepo') ~= nil then
							if FindValueInTable(kobold_base,'chess_meepo') == false then
								table.insert(kobold_base,'chess_meepo')
							end
							if table.maxn(kk)%2 ~= 0 then
								kobold_active = false
							end
						end
						if string.find(_,'chess_aw') ~= nil then
							if FindValueInTable(kobold_base,'chess_aw') == false then
								table.insert(kobold_base,'chess_aw')
							end
							if table.maxn(kk)%2 ~= 0 then
								kobold_active = false
							end
						end
					end
					if table.maxn(kobold_base) > 0 and kobold_active == true then
						for _,kk in pairs(double_table) do
							-- if table.maxn(kk)%2 == 0 then
							-- 	local result_count = math.floor(table.maxn(kk)/2)							
							-- 	table.sort(kk,function(a,b)
							-- 		return table.maxn(GetAllItemsInUnits({[1] = a})) > table.maxn(GetAllItemsInUnits({[1] = b}))
							-- 	end)
							-- 	for index = 1,result_count do
							-- 		kk[index].kobold_result = true
							-- 		if table.maxn(kobold_base) == 2 then
							-- 			kk[index].kobold_item = 1
							-- 		end
							-- 	end
							-- end
							if table.maxn(kk)%2 == 0 then						
								table.sort(kk,function(a,b)
									return table.maxn(GetAllItemsInUnits({[1] = a})) > table.maxn(GetAllItemsInUnits({[1] = b}))
								end)
								kk[1].kobold_result = true
								if table.maxn(kobold_base) == 2 then
									kk[1].kobold_item = 1
								end
							end
						end
					end
				end
				if p == 'is_shaman' and shaman_hex == false then
					shaman_hex =  true
					local shaman_target = nil
					local trycount = 0
					while shaman_target == nil and trycount < 100 do
						trycount = trycount + 1
						for _,cc in pairs(GetValidChessOnBoard(teamid)) do
							if cc:GetTeam() ~= teamid and RandomInt(1,100) > 25 and string.find(cc:GetUnitName(),'chess_') ~= nil then
								shaman_target = cc
								break
							end
						end
					end
					if IsUnitExist(shaman_target) == true then
						if BlockByLinken(shaman_target) == false then
							AddAbilityAndSetLevel(shaman_target,'no_selectable')
							shaman_target.devolve_result = RandomEvolveChess(shaman_target,0)
						end
					end
				end
				if p == 'is_shaman1' and shaman_hexhex == false then
					shaman_hexhex = true
					for _,cc in pairs(GetValidChessOnBoard(teamid)) do
						if cc.team_id == teamid and cc:HasAbility('is_shaman') then
							if IsUnitExist(cc) == true then
								AddAbilityAndSetLevel(cc,'no_selectable')
								cc.evolve_result = RandomEvolveChess(cc,2)
							end
						end
					end
					table.insert(baojun_ability_table_self,'is_shaman1')
				end
				if p == 'is_dragon' then
					play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,chess,5)
					if dragon_sound == false then
						EmitSoundOn('Hero_DragonKnight.DragonTail.Target',chess)
						dragon_sound = true
					end
					chess.is_dragon_zhanhou = true
					chess:SetMana(100)
					AMHC:CreateNumberEffect(chess,100,2,AMHC.MSG_MISS,{128,128,255},0)
					table.insert(baojun_ability_table_self,'flag_dragon3')
				end
				if p == 'is_dragon1' then
					if combo_count_table_self[p] >= condition then
						for kkkk,vvvv in pairs(GetValidChessOnBoard(teamid)) do
							if vvvv.team_id == teamid and vvvv.class ~= 1 then
								vvvv.is_dragon_zhanhou = true
								vvvv:SetMana(100)
								AMHC:CreateNumberEffect(vvvv,100,2,AMHC.MSG_MISS,{128,128,255},0)
								play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
							end
						end
					end
				end
				if p == 'is_god' then
					if combo_count_table_self[p] >= condition then
						for kkkk,vvvv in pairs(GetValidChessOnBoard(teamid)) do
							if vvvv.team_id == teamid then
								if vvvv.race ~= 1 then
									if god_sound == false then
										EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
										god_sound = true
									end
									if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff') == nil then
										AddAbilityAndSetLevelDelay(vvvv,'is_god_buff')
										table.insert(baojun_ability_table_self,'flag_god2')
										play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
									end
								end
							end
						end
					end
				end
				if p == 'is_god1' then
					if combo_count_table_self[p] >= condition then
						for kkkk,vvvv in pairs(GetValidChessOnBoard(teamid)) do
							if vvvv.team_id == teamid then
								if vvvv.race ~= 1 then
									if god_sound == false then
										EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
										god_sound = true
									end
									if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff_plus') == nil then
										AddAbilityAndSetLevelDelay(vvvv,'is_god_buff_plus')
										table.insert(baojun_ability_table_self,'flag_god4')
										play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
									end
								end
							end
						end
					end
				end
				if p == tauren_level then
					if tauren_ward == false then
						tauren_ward = true
						local first_tauren = nil
						for i0,v0 in pairs(GetValidChessOnBoard(teamid)) do
							if v0:HasAbility('is_tauren') and v0:GetTeam() == teamid then
								first_tauren = v0
							end
						end
						if first_tauren ~= nil then
							if tauren_level == 'is_tauren' then
								SummonTaurenWard(first_tauren,1)
							elseif tauren_level == 'is_tauren1' then
								SummonTaurenWard(first_tauren,2)
							end
						end
					end
				end
			end
			--同类有技能
			if type1 == 1 then
				for _,chess in pairs(combo_chess_table_self[p]) do
					if buff_ability ~= nil then
						AddAbilityAndSetLevelDelay(chess,buff_ability)
						table.insert(baojun_ability_table_self,buff_ability)
					end
				end
			end
			--友军有技能
			if type1 == 2 then
				for _,chess in pairs(GetValidChessOnBoard(teamid)) do
					--是友军
					if chess.team_id == teamid then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								if buff_ability == 'is_aqir_buff' then
									if chess:HasModifier("modifier_kill") == false and (chess.is_copied_aw ~= true or chess.is_self_aw == true) then
										--特殊情况，亚基
										if condition == 2 then
											if chess:HasAbility('is_aqir') == false then
												AddAbilityAndSetLevelDelay(chess,buff_ability)
												table.insert(baojun_ability_table_self,buff_ability)
											end
										else
											AddAbilityAndSetLevelDelay(chess,buff_ability)
											table.insert(baojun_ability_table_self,buff_ability)
										end
									end
								elseif buff_ability == 'is_orc_buff_plus_plus' then
									local hero = TeamId2Hero(teamid)
									local lost_hp = 100 - hero:GetHealth()
									local hp_bouns_by_6_orc = lost_hp*8
									ModMaxHP({
										caster = chess,
										const = hp_bouns_by_6_orc
									})
									play_particle("effect/big.vpcf",PATTACH_ABSORIGIN_FOLLOW,chess,2)
									chess.hp_bouns_by_6_orc = hp_bouns_by_6_orc
									chess:SetRenderColor(255, 255-(2*lost_hp), 255-(2*lost_hp))
									AddAbilityAndSetLevelDelay(chess,buff_ability)
								else
									--正常情况
									AddAbilityAndSetLevelDelay(chess,buff_ability)
								end
							end
						end
					end
				end
			end
			--敌军有技能
			if type1 == 3 then
				for _,chess in pairs(GetValidChessOnBoard(teamid)) do
					--是敌军
					if chess.team_id == 4 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
							end
						end
					end
				end
			end
			--随机一个友军有技能
			if type1 == 4 then
				local try_count = 0
				local is_ok = false
				while is_ok == false and try_count < 100 do
					local r = RandomInt(1,table.maxn(GetValidChessOnBoard(teamid)))
					local chess = GetValidChessOnBoard(teamid)[r]
					if chess.team_id == teamid then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
								table.insert(baojun_ability_table_self,buff_ability)
								is_ok = true
							end
						end
					end
					try_count = try_count + 1
				end
			end
			--随机一个敌军有技能
			if type1 == 5 then
				local try_count = 0
				local is_ok = false
				while is_ok == false and try_count < 100 do
					local r = RandomInt(1,table.maxn(GetValidChessOnBoard(teamid)))
					local chess = GetValidChessOnBoard(teamid)[r]
					if chess.team_id == 4 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
								is_ok = true
							end
						end
					end
					try_count = try_count + 1
				end
			end
			--远程友军有技能
			if type1 == 7 then
				for _,chess in pairs(GetValidChessOnBoard(teamid)) do
					--是友军
					if chess.team_id == teamid and chess:Script_GetAttackRange() > 205 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
								table.insert(baojun_ability_table_self,'flag_drawf2')
							end
						end
					end
				end
			end
		end
	end
	--priest
	local courier = TeamId2Hero(teamid)
	if combo_count_table_self['is_priest'] ~= nil and combo_count_table_self['is_priest'] >= 2 then
		AddAbilityAndSetLevelDelay(courier,'is_priest_buff_courier')
	end
	
	if _G.egg_quest == 'q015' and table.maxn(combo_type_table) >= 6 then
		SetQuest(teamid,true)
	end

	local combo_count_race = 0
	local dragon_sound_enemy = false
	local god_sound_enemy = false
	
	for s,x in pairs(combo_count_table_enemy) do
		local condition_0 = _G.combo_ability_type[s]['condition']
		local condition = condition_0
		local is_race = _G.combo_ability_type[s]['is_race']
		if x >= condition and is_race ~= true then
			for m,n in pairs(combo_chess_table_enemy[s]) do
				n.class = 1
			end
		end
		if x >= condition and is_race == true and string.find(s,'is_god') == nil then
			for m,n in pairs(combo_chess_table_enemy[s]) do
				n.race = 1
			end
		end
	end

	--恩拉基
	local opp = 0
	if the_only_combo_enemy ~= 'is_nraqi'  or GetWizardCount(_G.counterpart[teamid]) >= 2 then
		combo_count_table_enemy['is_nraqi'] = 0
	end
	for p,vp in pairs(combo_chess_table_enemy) do
		local shaman_hex = false
		local shaman_hexhex = false
		local tauren_wardward = false
		local kobold_tt = false
		local type1 = _G.combo_ability_type[p]['type']
		local condition_0 = _G.combo_ability_type[p]['condition']
		local condition = condition_0
		local buff_ability = _G.combo_ability_type[p]['ability']
		local is_race = _G.combo_ability_type[p]['is_race']
		if combo_count_table_enemy[p] >= condition then
			if is_race == true then
				combo_count_race = combo_count_race + 1
			end
			local troll_levels = 0
			local tauren_level = nil
			if combo_count_table_enemy['is_tauren'] ~= nil and combo_count_table_enemy['is_tauren'] >= _G.combo_ability_type['is_tauren']['condition'] then
				tauren_level = 'is_tauren'
				if combo_count_table_enemy['is_tauren1'] >= _G.combo_ability_type['is_tauren1']['condition'] then
					tauren_level = 'is_tauren1'
				end
			end
			for _,chess in pairs(combo_chess_table_enemy[p]) do
				if p == 'is_kobold' and kobold_tt == false then
					kobold_tt = true
					local double_table = {}
					for _,cc in pairs(GetValidChessOnBoard(teamid)) do
						if cc.team_id ~= teamid then
							if IsUnitExist(cc) == true then
								if double_table[cc:GetUnitName()] == nil then
									double_table[cc:GetUnitName()] = {}
								end
								table.insert(double_table[cc:GetUnitName()],cc)
							end
						end
					end
					local kobold_base = {}
					local kobold_active = true
					for _,kk in pairs(double_table) do
						if string.find(_,'chess_meepo') ~= nil then
							if FindValueInTable(kobold_base,'chess_meepo') == false then
								table.insert(kobold_base,'chess_meepo')
							end
							if table.maxn(kk)%2 ~= 0 then
								kobold_active = false
							end
						end
						if string.find(_,'chess_aw') ~= nil then
							if FindValueInTable(kobold_base,'chess_aw') == false then
								table.insert(kobold_base,'chess_aw')
							end
							if table.maxn(kk)%2 ~= 0 then
								kobold_active = false
							end
						end
					end
					if table.maxn(kobold_base) > 0 and kobold_active == true then
						for _,kk in pairs(double_table) do
							-- if table.maxn(kk)%2 == 0 then
							-- 	local result_count = math.floor(table.maxn(kk)/2)
							-- 	table.sort(kk,function(a,b)
							-- 		return table.maxn(GetAllItemsInUnits({[1] = a})) > table.maxn(GetAllItemsInUnits({[1] = b}))
							-- 	end)
							-- 	for index = 1,result_count do
							-- 		kk[index].kobold_result = true
							-- 		if table.maxn(kobold_base) == 2 then
							-- 			kk[index].kobold_item = 1
							-- 		end
							-- 	end
							-- end
							if table.maxn(kk)%2 == 0 then						
								table.sort(kk,function(a,b)
									return table.maxn(GetAllItemsInUnits({[1] = a})) > table.maxn(GetAllItemsInUnits({[1] = b}))
								end)
								kk[1].kobold_result = true
								if table.maxn(kobold_base) == 2 then
									kk[1].kobold_item = 1
								end
							end
						end
					end
				end
				if p == 'is_shaman' and shaman_hex == false then
					shaman_hex = true
					local shaman_target = nil
					local trycount = 0
					while shaman_target == nil and trycount < 100 do
						trycount = trycount + 1
						for _,cc in pairs(GetValidChessOnBoard(teamid)) do
							if cc:GetTeam() == teamid and RandomInt(1,100) > 25 and string.find(cc:GetUnitName(),'chess_') ~= nil then
								shaman_target = cc
								break
							end
						end
					end
					if IsUnitExist(shaman_target) == true then
						if BlockByLinken(shaman_target) == false then
							AddAbilityAndSetLevel(shaman_target,'no_selectable')
							shaman_target.devolve_result = RandomEvolveChess(shaman_target,0)
						end
					end
				end
				if p == 'is_shaman1' and shaman_hexhex == false then
					shaman_hexhex = true
					for _,cc in pairs(GetValidChessOnBoard(teamid)) do
						if cc.team_id == 4 and cc:HasAbility('is_shaman') then
							if IsUnitExist(cc) == true then
								AddAbilityAndSetLevel(cc,'no_selectable')
								cc.evolve_result = RandomEvolveChess(cc,2)
							end
						end
					end
					table.insert(baojun_ability_table_enemy,'is_shaman1')
				end
				if p == 'is_dragon' then
					play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,chess,5)
					if dragon_sound_enemy == false then
						dragon_sound_enemy = true
						EmitSoundOn('Hero_DragonKnight.DragonTail.Target',chess)
					end
					chess.is_dragon_zhanhou = true
					chess:SetMana(100)
					AMHC:CreateNumberEffect(chess,100,2,AMHC.MSG_MISS,{128,128,255},0)
					table.insert(baojun_ability_table_enemy,'flag_dragon3')
				end
				if p == 'is_dragon1' then
					if combo_count_table_enemy[p] >= condition then
						for kkkk,vvvv in pairs(GetValidChessOnBoard(teamid)) do
							if vvvv.team_id == 4 and vvvv.class ~= 1 then
								vvvv.is_dragon_zhanhou = true
								vvvv:SetMana(100)
								AMHC:CreateNumberEffect(vvvv,100,2,AMHC.MSG_MISS,{128,128,255},0)
								play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)

							end
						end
					end
				end
				if p == 'is_god' then
					if combo_count_table_enemy[p] >= condition then
						for kkkk,vvvv in pairs(GetValidChessOnBoard(teamid)) do
							if vvvv.team_id == 4 then
								if vvvv.race ~= 1 then
									if god_sound == false then
										EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
										god_sound = true
									end
									if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff') == nil then
										AddAbilityAndSetLevelDelay(vvvv,'is_god_buff')
										table.insert(baojun_ability_table_enemy,'flag_god2')
										play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
									end
								end
							end
						end
					end
				end
				if p == 'is_god1' then
					if combo_count_table_enemy[p] >= condition then
						for kkkk,vvvv in pairs(GetValidChessOnBoard(teamid)) do
							if vvvv.team_id == 4 then
								if vvvv.race ~= 1 then
									if god_sound == false then
										EmitSoundOn('Hero_Disruptor.StaticStorm.Cast',vvvv)
										god_sound = true
									end
									if string.find(vvvv:GetUnitName(),'hero') == nil and vvvv:FindAbilityByName('is_god_buff_plus') == nil then
										AddAbilityAndSetLevelDelay(vvvv,'is_god_buff_plus')
										table.insert(baojun_ability_table_enemy,'flag_god4')
										play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,vvvv,5)
									end
								end
							end
						end
					end
				end
				if p == tauren_level then
					if tauren_wardward == false then
						tauren_wardward = true
						local first_tauren = nil
						for i0,v0 in pairs(GetValidChessOnBoard(teamid)) do
							if v0:HasAbility('is_tauren') and v0:GetTeam() ~= teamid then
								first_tauren = v0
							end
						end
						if first_tauren ~= nil then
							if tauren_level == 'is_tauren' then
								SummonTaurenWard(first_tauren,1)
							elseif tauren_level == 'is_tauren1' then
								SummonTaurenWard(first_tauren,2)
							end
						end
					end
				end
			end
			--同类有技能
			if type1 == 1 then
				for _,chess in pairs(combo_chess_table_enemy[p]) do
					if buff_ability ~= nil then
						AddAbilityAndSetLevelDelay(chess,buff_ability)
						table.insert(baojun_ability_table_enemy,buff_ability)
					end
				end
			end
			--友军有技能
			if type1 == 2 then
				for _,chess in pairs(GetValidChessOnBoard(teamid)) do
					if chess.team_id == 4 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								if buff_ability == 'is_aqir_buff' then
									--特殊情况，亚基
									if chess:HasModifier("modifier_kill") == false and (chess.is_copied_aw ~= true or chess.is_self_aw == true) then
										if condition == 2 then
											if chess:HasAbility('is_aqir') == false then
												AddAbilityAndSetLevelDelay(chess,buff_ability)
												table.insert(baojun_ability_table_enemy,buff_ability)
											end
										else
											AddAbilityAndSetLevelDelay(chess,buff_ability)
											table.insert(baojun_ability_table_enemy,buff_ability)
										end
									end
								elseif buff_ability == 'is_orc_buff_plus_plus' then
									local oppo = _G.counterpart[teamid]
									local hero = TeamId2Hero(oppo)
									local lost_hp = 100 - hero:GetHealth()
									local hp_bouns_by_6_orc = lost_hp*8
									ModMaxHP({
										caster = chess,
										const = hp_bouns_by_6_orc
									})
									play_particle("effect/big.vpcf",PATTACH_ABSORIGIN_FOLLOW,chess,2)
									chess.hp_bouns_by_6_orc = hp_bouns_by_6_orc
									AddAbilityAndSetLevelDelay(chess,buff_ability)
								else
									AddAbilityAndSetLevelDelay(chess,buff_ability)
									table.insert(baojun_ability_table_enemy,buff_ability)
								end
							end
						end
					end
				end
			end
			--敌军有技能
			if type1 == 3 then
				for _,chess in pairs(GetValidChessOnBoard(teamid)) do
					--是敌军
					if chess.team_id == teamid then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevel(chess,buff_ability)
							end
						end
					end
				end
			end
			--随机一个友军有技能
			if type1 == 4 then
				local try_count = 0
				local is_ok = false
				while is_ok == false and try_count < 100 do
					local r = RandomInt(1,table.maxn(GetValidChessOnBoard(teamid)))
					local chess = GetValidChessOnBoard(teamid)[r]
					if chess.team_id == 4 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
								table.insert(baojun_ability_table_enemy,buff_ability)
								is_ok = true
							end
						end
					end
					try_count = try_count + 1
				end
			end
			--随机一个敌军有技能
			if type1 == 5 then
				local try_count = 0
				local is_ok = false
				while is_ok == false and try_count < 100 do
					local r = RandomInt(1,table.maxn(GetValidChessOnBoard(teamid)))
					local chess = GetValidChessOnBoard(teamid)[r]
					if chess.team_id ~= 4 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
								table.insert(baojun_ability_table_enemy,buff_ability)
								is_ok = true
							end
						end
					end
					try_count = try_count + 1
				end
			end
			--远程友军有技能
			if type1 == 7 then
				for _,chess in pairs(GetValidChessOnBoard(teamid)) do
					if chess.team_id == 4 and chess:Script_GetAttackRange() > 205 then
						if string.find(chess:GetUnitName(),'hero') == nil then
							if buff_ability ~= nil then
								AddAbilityAndSetLevelDelay(chess,buff_ability)
								table.insert(baojun_ability_table_enemy,'flag_drawf2')
							end
						end
					end
				end
			end
		end
	end

	--第四次循环：给暴君添加所有友军享受的技能
	if table.maxn(baojun_table_self) > 0 and table.maxn(baojun_ability_table_self) > 0 then
		for _,baojun in pairs(baojun_table_self) do
			for _,ability in pairs(baojun_ability_table_self) do
				AddABaojunAbility(baojun, ability)
			end
		end
	end
	if table.maxn(baojun_table_enemy) > 0 and table.maxn(baojun_ability_table_enemy) > 0 then
		for _,baojun in pairs(baojun_table_enemy) do
			for _,ability in pairs(baojun_ability_table_enemy) do
				AddABaojunAbility(baojun, ability)
			end
		end
	end
end
--给暴君添加所有友军享受的技能
function AddABaojunAbility(baojun, ability)
	if baojun == nil or IsUnitExist(baojun) == false or baojun:HasModifier('modifier_item_baojunwangpao') == false then
		return
	end
	--特例：
	if ability == 'flag_dragon3' then
		play_particle("particles/units/heroes/hero_monkey_king/monkey_king_fur_army_positions_ring_dragon.vpcf",PATTACH_OVERHEAD_FOLLOW,baojun,5)
		EmitSoundOn('Hero_DragonKnight.DragonTail.Target',baojun)
		baojun.is_dragon_zhanhou = true
		baojun:SetMana(100)
		AMHC:CreateNumberEffect(baojun,100,2,AMHC.MSG_MISS,{128,128,255},0)
	elseif ability == 'flag_god2' then
		if baojun:HasAbility('is_god_buff') == false then
			AddAbilityAndSetLevelDelay(baojun,'is_god_buff')
			play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,baojun,5)
		end
	elseif ability == 'flag_god4' then
		if baojun:HasAbility('is_god_buff_plus') == false then
			AddAbilityAndSetLevelDelay(baojun,'is_god_buff_plus')
			play_particle("effect/god/1.vpcf",PATTACH_OVERHEAD_FOLLOW,baojun,5)
		end
	elseif ability == 'flag_drawf2' or ability == 'is_dwarf_buff' or ability == 'is_dwarf_buff_plus' then
		if baojun:HasAbility(ability) == false and baojun:Script_GetAttackRange() > 205 then
			AddAbilityAndSetLevelDelay(baojun,ability)
		end
	elseif ability == 'is_shaman1' then
		AddAbilityAndSetLevel(baojun,'no_selectable')
		baojun.evolve_result = RandomEvolveChess(baojun,2)
	else
		--非特例
		if baojun:HasAbility(ability) == false then
			AddAbilityAndSetLevelDelay(baojun,ability)
		end
	end
end
function AddAbilityAndSetLevelDelay(chess,buff_ability)
	AddAbilityAndSetLevel(chess,buff_ability)
end
function AddAbilty2BaoJunList(baojun_table,buff_ability)
	for _,v in pairs(baojun_table) do
		AddAbilityAndSetLevel(v,buff_ability)
	end
end
--游戏循环2.2——镜像要打的敌人和给他们加组合技
function MirrorARound(teamid)
	local opp = nil
	local my_opp = nil
	local opp_lineup = {}
	Timers:CreateTimer(0.1,function()
		for myteam,enemyteam in pairs(_G.counterpart) do
			if enemyteam == teamid then
				opp = myteam
			end
			if myteam == teamid then
				my_opp = enemyteam
			end
		end
		if opp ~= nil then
			--镜像棋手
			Timers:CreateTimer(1,function()
				local opp_hero = TeamId2Hero(my_opp)
				local opp_steam_id = opp_hero.steam_id
				local opp_model = GetStat(opp_hero:GetPlayerID(),'zhugong_model')
				local opp_effect = GetStat(opp_hero:GetPlayerID(),'zhugong_effect')
				local mirror_chesser = MirrorChesser(
					teamid,
					opp_model,
					opp_effect,
					opp_hero:GetModelScale(),
					opp_hero.ori_skin,
					opp_hero.win_streak
				)
				mirror_chesser.onduty_hero = GetStat(opp_hero:GetPlayerID(),'zhugong')
				opp_hero.my_away_mirror_chesser = mirror_chesser
				MakeGreevil(mirror_chesser,true)

				if mirror_chesser ~= nil and opp_hero.pet_name1 ~= nil and opp_hero.pet_name1 ~= 't000' then
					local pet = RefreshPets(mirror_chesser,mirror_chesser.pet1,opp_hero.pet_name1,2)
					if pet ~= nil then
						pet:SetForwardVector(Vector(0,-1,0))
					end
				end
			end)

			for i=1,4 do
				for j=1,8 do
					if _G.mychess[teamid][i..'_'..j] ~= nil then
						_G.unit[teamid][i..'_'..j] = 1
						_G.unit[opp][(9-i)..'_'..(9-j)] = 1
						local loopcount = GetChessRank1Count(_G.mychess[teamid][i..'_'..j].chess)
						for t=1,loopcount do
							table.insert(opp_lineup,GetChessBaseName(_G.mychess[teamid][i..'_'..j].chess))
						end
						--复制棋子
						MirrorAChess(teamid,i,j,opp)
					end
				end
			end
			TeamId2Hero(opp).last_opp_lineup = opp_lineup
			Timers:CreateTimer(4.5,function()
				AddComboAbility(teamid)
			end)
		end
	end)
end
function MirrorAChess(teamid,i,j,opp)
	--获取出场动画
	local hero = TeamId2Hero(teamid)
	if IsUnitExist(hero) == false then
		return
	end
	local animation_info = GetAnimation(hero.animation or 'n000')


	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector(9-j,9-i,opp),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(1.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end
			local x = CreateUnitByName(_G.mychess[teamid][i..'_'..j].chess,XY2Vector(9-j,9-i,opp),true,nil,nil,DOTA_TEAM_NEUTRALS)
			SetChessSpecialLook(x)
			x:SetForwardVector(Vector(0,-1,0))

			x.y_x = (9-i)..'_'..(9-j)
			x.y = 9-i
			x.x = 9-j
			x.press_count = _G.mychess[teamid][i..'_'..j].press_count
			x.track_money_count = _G.mychess[teamid][i..'_'..j].track_money_count
			x.xuejingshi_count = _G.mychess[teamid][i..'_'..j].xuejingshi_count

			x.team_id = 4
			x.at_team_id = opp
			x.from_team_id = teamid
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			table.insert(_G.to_be_destory_list[opp],x)

			if _G.mychess[teamid][i..'_'..j].rubick_a ~= nil then
				AddAbilityAndSetLevel(x,_G.mychess[teamid][i..'_'..j].rubick_a,0)
				x.steal_ability = _G.mychess[teamid][i..'_'..j].rubick_a
				if _G.mychess[teamid][i..'_'..j].rubick_range ~= nil then
					if _G.mychess[teamid][i..'_'..j].rubick_range > 210 then
						if _G.mychess[teamid][i..'_'..j].rubick_range > 410 then
							AddAbilityAndSetLevel(x,'attackrange_600',1)
						else
							AddAbilityAndSetLevel(x,'attackrange_400',1)
						end
					end
				end
			end
			--复制物品
			local uindex = _G.mychess[teamid][i..'_'..j].index
			for slot=0,9 do
				if EntIndexToHScript(uindex):GetItemInSlot(slot)~= nil then
					local name = EntIndexToHScript(uindex):GetItemInSlot(slot):GetAbilityName()
					if name ~= nil then
						if name == 'item_silingshu' or name == 'item_silingshu_2' or name == 'item_silingshu_3' then
							name = GetCurrSilingshuItemName(x)
						end
						x:AddItemByName(name)
					end
				end
			end

			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
			if animation_info.end_effect ~= nil then
				play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,x,3)
			end
		end)
	end)	
end

--为teamid场地镜像my_opp队伍的敌人棋手镜像
function MirrorChesser(teamid,opp_model,opp_effect,model_scale,skin,win_streak)
	local mirror_chesser_position = Entities:FindByName(nil,"center"..(teamid-6)):GetAbsOrigin()
	local mirror_chesser = CreateUnitByName("player_image",mirror_chesser_position+Vector(0,128*6.5,256),true,nil,nil,DOTA_TEAM_NEUTRALS)
	mirror_chesser:SetForwardVector(Vector(0,-1,0))
	if model_scale == nil then
		model_scale = 1
	end
	mirror_chesser:SetModelScale(model_scale)
	TeamId2Hero(teamid).mirror_chesser = mirror_chesser
	--镜像棋手形象
	if opp_model ~= nil then
		mirror_chesser:SetOriginalModel(opp_model)
		mirror_chesser:SetModel(opp_model)
		mirror_chesser:SetSkin(skin)
	end
	if opp_effect ~= nil and opp_effect ~= 'e000' then
		AddAbilityAndSetLevel(mirror_chesser,opp_effect)
	end

	--连胜膨胀/起飞
	local sca = (model_scale or 1)+(win_streak or 0)*0.05
	if sca >= (model_scale or 1) + 0.5 then
		sca = (model_scale or 1) + 0.5
		--起飞！
		local new_m = ChangeFlyingCourierModel(opp_model)
		mirror_chesser:SetOriginalModel(new_m)
		mirror_chesser:SetModel(new_m)
		MakeGreevil(mirror_chesser,true)
		AddAbilityAndSetLevel(mirror_chesser,'courier_fly')
		ShowCourierEffect(mirror_chesser,2)
	end
	mirror_chesser:SetModelScale(sca)



	-- PlaySpawnAnimation(mirror_chesser)
	mirror_chesser:StartGesture(ACT_DOTA_SPAWN)

	Timers:CreateTimer(3,function()
		if IsUnitExist(mirror_chesser) == true then
			mirror_chesser:StartGesture(ACT_DOTA_IDLE)
			return 1
		end
	end)

	return mirror_chesser
end

function LoadCloudEnemy(wave,team)
	if GetYourChessCount(team) > 0 then
		--有yourchess,直接加载yourchess
		for i,vi in pairs(_G.yourchess[team]) do
			vi.y = 9-vi.y
			vi.x = 9-vi.x
			LoadOneCloudChess(vi,team)
		end
	else
		if _G.cloudlineup[''..wave] ~= nil then
			local chesses = nil
			for _,data in pairs(_G.cloudlineup[''.._G.battle_round]) do
				chesses = json.decode(data)
			end

			--镜像棋手
			if chesses['zhugong'] ~= nil then
				local cloud_hero = string.split(chesses['zhugong'],'_')[1]
				local cloud_hero_effect = string.split(chesses['zhugong'],'_')[2] or ''

				local opp_model = _G.sm_hero_list[cloud_hero]

				Timers:CreateTimer(1,function()
					MirrorChesser(
						team,
						opp_model,
						cloud_hero_effect,
						(_G.sm_hero_size[cloud_hero] or 1),
						(_G.sm_hero_list_skin[cloud_hero] or 0)
					)
				end)
			end

			if chesses ~= nil then
				for i,vi in pairs(chesses.lineup) do
					LoadOneCloudChess(vi,team)
				end
			end
		end
	end
	Timers:CreateTimer(4.5,function()
		AddComboAbility(team)
	end)
end
function LoadOneCloudChess(vi,team)
	--获取出场动画
	--TODO: 暂时用默认的TP，后续可以改造为获取镜像玩家装备的动画
	local animation_info =  GetAnimation('n000')

	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector((9-vi.x),(9-vi.y),team),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end
			_G.unit[team][(9-vi.y)..'_'..(9-vi.x)] = 1
			local x = CreateUnitByName(vi.chess,XY2Vector((9-vi.x),(9-vi.y),team),true,nil,nil,DOTA_TEAM_NEUTRALS)
			x:SetForwardVector(Vector(0,-1,0))
			x.y_x = (9-vi.y)..'_'..(9-vi.x)
			x.y = (9-vi.y)
			x.x = (9-vi.x)
			x.team_id = 4
			x.at_team_id = team
			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			table.insert(_G.to_be_destory_list[team],x)
			--复制物品
			if vi.lastitem ~= nil then
				for _,it in pairs(vi.lastitem) do
					if it == 'item_silingshu' or it == 'item_silingshu_2' or it == 'item_silingshu_3' then
						it = GetCurrSilingshuItemName(x)
					end
					x:AddItemByName(it)
				end
			end
			
			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
			if animation_info.end_effect ~= nil then
				play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,x,3)
			end
		end)
	end)
end
--游戏循环2.3——自走！
function ChessAI(u,force_delay)
	if IsUnitExist(u) == false or GetBattleTable(u.at_team_id or u.team_id) == false then
		return
	end
	if _G.start_ai == true and (u.aitimer == nil or Timers.timers[u.aitimer] == nil) then
		u:RemoveGesture(ACT_DOTA_SPAWN)
		u:RemoveGesture(ACT_DOTA_IDLE)
		--kobold
		if u.kobold_result == true and _G.is_game_ended ~= true then
			Timers:CreateTimer(RandomFloat(0.01,0.1),function()
				--复制狗头人
				local aposition = FindEmptyGridAtUnit(u)
				local team_id = u:GetTeam()
				local at_team_id = u.at_team_id or u.team_id
				local items = GetAllItemsInUnits({[1] = u})
				local x = nil
				if u.kobold_item == 1 then
					--（2）狗头人：带装备
					x = SummonAChess(team_id,aposition,u:GetUnitName(),at_team_id,100,0,items,false)
					if string.find(u:GetUnitName(),'pve_') == nil then
						x:AddNewModifier(x,nil,"modifier_kill",{duration = 60})
					end
				else
					--（1）狗头人：不带装备
					x = SummonAChess(team_id,aposition,u:GetUnitName(),at_team_id,100,0,{},false)
					if string.find(u:GetUnitName(),'pve_') == nil then
						x:AddNewModifier(x,nil,"modifier_kill",{duration = 30})
					end
				end
				BlinkChessX({caster=x,blink_type="breaksoil"})
				u.kobold_result = nil
				u.kobold_item = nil
				x.is_copied_kobold = true
				if u.kobold_hp_per ~= nil then
					ModMaxHP({
						caster = u,
						per = u.kobold_hp_per or 0,
						is_heal = false,
					})
					ModMaxHP({
						caster = x,
						per = u.kobold_hp_per or 0,
						is_heal = false,
					})
					AddAbilityAndSetLevel(x,'more_creep')
				end
			end)
		end
		--shaman
		if u.evolve_result ~= nil then
			AddAbilityAndSetLevel(u,'evolve')
		elseif u.devolve_result ~= nil then
			DevolveAChess(u)
			return
		end
		--rubick
		if u:FindAbilityByName('rubick_qiequ') ~= nil then
			--拉比克窃取技能
			local steal_chess = nil
			local steal_chess_unit = nil
			local try_time = 0
			while steal_chess == nil and try_time < 100 do
				local rant = RandomInt(1,table.maxn(GetValidChessOnBoard(u.at_team_id or u.team_id)))
				local cc = GetValidChessOnBoard(u.at_team_id or u.team_id)[rant]
				if cc:GetTeam() ~= u.team_id and not string.find(cc:GetUnitName(),'chess_rubick') and not string.find(cc:GetUnitName(),'chess_meepo') and not string.find(cc:GetUnitName(),'chess_kael') and not cc:HasAbility('is_ward') and _G.ability_behavior_list[_G.chess_ability_list[cc:GetUnitName()]] ~= 0 then
					steal_chess = cc:GetUnitName()
					steal_chess_unit = cc
				end
				try_time = try_time + 1
			end
			if steal_chess ~= nil and not string.find(steal_chess,'chess_rubick') then
				if steal_chess_unit:Script_GetAttackRange() > 210 then
					if steal_chess_unit:Script_GetAttackRange() > 410 then
						AddAbilityAndSetLevel(u,'attackrange_600',1)
					else
						AddAbilityAndSetLevel(u,'attackrange_400',1)
					end
				end
				local a = _G.chess_ability_list[steal_chess]
				if a ~= nil then
					u.steal_ability = a
					if u.team_id ~= 4 then
						for ii,vv in pairs(_G.mychess[u.team_id]) do
							if vv.index == u:entindex() then
								vv.rubick_a = a
								vv.rubick_range = steal_chess_unit:Script_GetAttackRange()
							end
						end
					end
					local a_level = 1
					if string.find(u:GetUnitName(),'1') then
						a_level = 2
					end
					if string.find(u:GetUnitName(),'11') then
						a_level = 3
					end
					if u:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(u,a,a_level)
					else
						u:FindAbilityByName(a):SetLevel(a_level)
					end
					RemoveAbilityAndModifier(u,'rubick_qiequ')
					--特效、音效
					local effect_name = "particles/units/heroes/hero_rubick/rubick_spell_steal.vpcf"
					if u:GetUnitName() == 'chess_rubick11' then
						effect_name = "particles/econ/items/rubick/rubick_arcana/rubick_arc_spell_steal_default.vpcf"
					end
					ProjectileManager:CreateTrackingProjectile({
				        Target = u,
				        Source = steal_chess_unit,
				        Ability = nil,
				        EffectName = effect_name,
				        bDodgeable = false,
				        iMoveSpeed = 1200,
				        bProvidesVision = false,
				        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
				    })
				    u:StartGesture(ACT_DOTA_CAST_ABILITY_4)
				    EmitSoundOn("Hero_Rubick.SpellSteal.Cast",u)
					UpdateBHGold({caster = u})
				end
			end
		end
		--kael
		if u:FindAbilityByName('invoke') ~= nil then
			local find_team = 0
			local find_combo = nil
			if _G.battle_boss[_G.battle_round-1] == nil then
				if u.team_id == 4 then
					find_team = u.at_team_id
				else
					find_team = _G.counterpart[u.team_id]
				end
			end
			if find_team ~= 0 then
				local find_combo = TeamId2Hero(find_team).kael_combo
			end
			RefreshKaelOrbandAbility(u,find_combo)
		end
		--术士
		if u:FindAbilityByName('is_warlock') ~= nil then
			EmitSoundOn("dac.warlock.soul_ring",u)
    		play_particle("particles/items2_fx/soul_ring.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,2)
			u:StartGestureWithPlaybackRate(ACT_DOTA_CAST_ABILITY_1,1)
			u:SetHealth(u:GetHealth()*0.8)
			local u_mana = u:GetMana() + 40
			if u_mana > 100 then
				u_mana = 100
			end
			u:SetMana(u_mana)
		end
		if u:HasAbility('lc_qianggong') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"legion_commander_moment_of_courage",3)
		elseif u:HasAbility('lc_qianggong') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"legion_commander_moment_of_courage",2)
		elseif u:HasAbility('lc_qianggong') then
			AddAbilityAndSetLevel(u,"legion_commander_moment_of_courage",1)
		end

		if u:HasAbility('troll_axe') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"troll_warlord_whirling_axes_ranged",3)
			AddAbilityAndSetLevel(u,"troll_warlord_whirling_axes_melee",3)
		elseif u:HasAbility('troll_axe') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"troll_warlord_whirling_axes_ranged",2)
			AddAbilityAndSetLevel(u,"troll_warlord_whirling_axes_melee",2)
		elseif u:HasAbility('troll_axe') then
			AddAbilityAndSetLevel(u,"troll_warlord_whirling_axes_ranged",1)
			AddAbilityAndSetLevel(u,"troll_warlord_whirling_axes_melee",2) --不知道为啥，直接set1级会被自动禁用
			u:FindAbilityByName("troll_warlord_whirling_axes_melee"):SetLevel(1)
			u:FindAbilityByName("troll_warlord_whirling_axes_melee"):SetActivated(true)
		end

		if u:HasAbility('enchantress_natures_attendants') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"enchantress_untouchable",3)
		elseif u:HasAbility('enchantress_natures_attendants') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"enchantress_untouchable",2)
		elseif u:HasAbility('enchantress_natures_attendants') then
			AddAbilityAndSetLevel(u,"enchantress_untouchable",1)
		end
		-- if u:HasAbility('fv_zhao') then
		-- 	AddAbilityAndSetLevel(u,"faceless_void_time_lock",1)
		-- end
		if u:HasAbility('spe_haunt') then
			AddAbilityAndSetLevel(u,"spe_desolate",1)
		end

		if u:HasAbility('templar_assassin_refraction') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"templar_assassin_psi_blades",3)
		elseif u:HasAbility('templar_assassin_refraction') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"templar_assassin_psi_blades",2)
		elseif u:HasAbility('templar_assassin_refraction') then
			AddAbilityAndSetLevel(u,"templar_assassin_psi_blades",1)
		end

		if u:HasAbility('medusa_stone_gaze') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"medusa_split_shot",3)
			u:FindAbilityByName("medusa_split_shot"):ToggleAbility()
		elseif u:HasAbility('medusa_stone_gaze') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"medusa_split_shot",2)
			u:FindAbilityByName("medusa_split_shot"):ToggleAbility()
		elseif u:HasAbility('medusa_stone_gaze') then
			AddAbilityAndSetLevel(u,"medusa_split_shot",1)
			u:FindAbilityByName("medusa_split_shot"):ToggleAbility()
		end

		if u:HasAbility('winter_wyvern_cold_embrace') and string.find(u:GetUnitName(), '11') then
			AddAbilityAndSetLevel(u,"ww_frost",3)
		elseif u:HasAbility('winter_wyvern_cold_embrace') and string.find(u:GetUnitName(), '1') then
			AddAbilityAndSetLevel(u,"ww_frost",2)
		elseif u:HasAbility('winter_wyvern_cold_embrace') then
			AddAbilityAndSetLevel(u,"ww_frost",1)
		end


		
		--以技能名做判断，让拉比克偷窃sven技能后，在攻击近身目标时有分裂效果
		if u:HasAbility('sven_gods_strength') then
			AddAbilityAndSetLevel(u,"sven_great_cleave")
		end

		if u:HasAbility('mars_bulwark_attack') then	
			StartMarsShieldCD(u)
		end
		if u:HasAbility('mk_ruyibangfa') then	
			Timers:CreateTimer(1,function()
				if IsUnitExist(u) then
					AddAbilityAndSetLevel(u,"monkey_king_boundless_strike",u:FindAbilityByName('mk_ruyibangfa'):GetLevel())
					-- u:FindAbilityByName("monkey_king_boundless_strike"):SetHidden(true)
				end
			end)
		end
		
		if u:HasAbility('pudge_meat_hook_lua') then
			AddAbilityAndSetLevel(u,"pudge_dismember",u:FindAbilityByName('pudge_meat_hook_lua'):GetLevel())
			-- u:FindAbilityByName("pudge_dismember"):SetHidden(true)
		end
		if u:HasAbility('lion_mana_drain_datadriven') then
			AddAbilityAndSetLevel(u,"keeper_of_the_light_chakra_magic",1)
			u:FindAbilityByName("keeper_of_the_light_chakra_magic"):SetHidden(true)
		end
		if u:HasAbility('jakiro_macropyre') then
			AddAbilityAndSetLevel(u,"jakiro_ice_path",u:FindAbilityByName('jakiro_macropyre'):GetLevel())
			if RandomInt(1,100) > 50 then
				u:FindAbilityByName("jakiro_ice_path"):SetHidden(true)
				u.ice_or_fire = 'fire'
			else
				u:FindAbilityByName("jakiro_macropyre"):SetHidden(true)
				u.ice_or_fire = 'ice'
			end			
		end
		
		if u:HasAbility('is_assassin') then
			u.has_assassin_blink = true
		end

		AddAbilityAndSetLevel(u,'jiaoxie')
		RemoveAbilityAndModifier(u,'jiaoxie_wudi')
		-- AddAbilityAndSetLevel(u,'no_hp_bar')

		-- AddHPBar2HPBarTable({
		-- 	unit_index = u:entindex(),
		-- })

		local start_delay = 0
		if u:FindAbilityByName('is_assassin') ~= nil and _G.chess_ability_list[u:GetUnitName()] ~= nil then
			-- start_delay = 0.75
		end
		if u:HasAbility('is_assassin') == false and u:HasModifier('modifier_is_assassin_buff_plus_plus') then
			--非刺客的9刺buff，一开始不跳跃，也不延迟
			u.assassin_blinked = true
			-- start_delay = 0
		end
		local delay = RandomFloat(0.1,1.0)

		if u.y == 1 or u.y == 8 then
			start_delay = RandomFloat(0.3,0.4)
		elseif u.y == 2 or u.y == 7 then
			start_delay = RandomFloat(0.2,0.3)
		elseif u.y == 3 or u.y == 6 then
			start_delay = RandomFloat(0.1,0.2)
		elseif u.y == 4 or u.y == 5 then
			start_delay = RandomFloat(0.05,0.1)
		end

		--新版delay方案，按星级启动
		local chess_star = GetChessStar(u)
		if u:HasAbility('is_assassin') or chess_star == 1 then
			delay = RandomFloat(1.1,1.5)
		elseif chess_star == 2 then
			delay = RandomFloat(0.6,1)
		elseif chess_star == 3 then
			delay = RandomFloat(0.1,0.5)
		end

		delay = delay + start_delay

		if force_delay and force_delay > 0 then
			delay = force_delay
		end

		if u:HasModifier('modifier_item_fulingsuo') == true or u:HasModifier('modifier_item_atuosi') == true or u:HasModifier('modifier_item_wangchongtui') == true then
			delay = 0.01
		end

		if u:HasModifier('modifier_smoke_screen_trigger') then
			u:RemoveModifierByName('modifier_smoke_screen_trigger')
			--riki：烟雾弹
			local enemy_team_id = 4
			if u:GetTeam() == 4 then
				enemy_team_id = u.at_team_id
			end
			if IsLonely4Team(u,enemy_team_id) == true then		
				--如果没有近身敌人，就在u的镜像位置施放
				InvisibleUnitCast({
					caster = u,
					ability = 'smoke_screen_datadriven',
					level = u:FindAbilityByName('smoke_screen_trigger'):GetLevel(),
					caster_position = CentrosymmetryPosition(u.at_team_id or u.team_id,u.x,u.y),
					position = CentrosymmetryPosition(u.at_team_id or u.team_id,u.x,u.y),
					ignore_nether_ward = true,
				})
			else
				--否则，在u的位置施放
				InvisibleUnitCast({
					caster = u,
					ability = 'smoke_screen_datadriven',
					level = u:FindAbilityByName('smoke_screen_trigger'):GetLevel(),
					caster_position = XY2Vector(u.x,u.y,u.at_team_id or u.team_id),
					position = XY2Vector(u.x,u.y,u.at_team_id or u.team_id),
					ignore_nether_ward = true,
				})
			end
		end

		if u:HasAbility('arc_double') and u.is_copied_aw ~= true and u.is_copied_kobold ~= true then
			--战斗中生成的本尊，复制本尊
			local aposition = FindEmptyGridAtUnit(u,nil,true)
			local team_id = u:GetTeam()
			local at_team_id = u.at_team_id or u.team_id
			local items = GetAllItemsInUnits({[1] = u})
			local x = SummonAChess(u:GetTeam(),aposition,u:GetUnitName(),at_team_id,100,0,items,false,nil)
			BlinkChessX({caster=x,blink_type="breaksoil"})
			x.is_copied_aw = true

			local chess_star = GetChessStar(x) or 1
			x:AddNewModifier(x,nil,"modifier_kill",{duration = 10*chess_star})
			-- u:AddNewModifier(x,nil,"modifier_kill",{duration = 20*chess_star})
		end

		--骑士：如果有相邻骑士，启动原地开盾，必开盾
		if u:HasAbility('is_knight') and u.knight_first_shield == nil then
			if FindFriendlyChessInRadius(u,'is_knight',205) == true then
				if u:HasAbility('is_knight_buff') then
					-- delay = delay + 2
					--开盾
					u:FindAbilityByName('is_knight_buff'):ApplyDataDrivenModifier(u,u,'modifier_is_knight_buff_2',{duration = delay})
					OnKnightBuffCreate({
						caster = u
					})
					play_particle('particles/econ/items/omniknight/omni_ti8_head/omniknight_repel_buff_ti8_rings.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,3)
					EmitSoundOn("dac.shield",u)
				end
				-- u:StartGesture(ACT_DOTA_DISABLED)
				u.knight_first_shield = true
				-- u.cannot_move = true
				-- Timers:CreateTimer(delay,function()
				-- 	if IsUnitExist(u) then
				-- 		u.cannot_move = nil
				-- 		u:RemoveGesture(ACT_DOTA_DISABLED)
				-- 	end
				-- end)
			else
				u.knight_first_shield = true
			end
		end


		if _G.is_game_ended == true then
			return
		end
		u.aitimer = Timers:CreateTimer(delay, function()
			--棋子死亡或者回合/游戏结束，就终止AI
			if u == nil or u:IsNull() == true or u:IsAlive() == false or u.alreadywon == true or u.transforming == true or _G.is_game_ended == true then
				return
			end

			if GetBattleTable(u.at_team_id or u.team_id) == false then
				return
			end

			--容错
			if u:FindAbilityByName('modifier_no_hp_bar') ~= nil or u:FindAbilityByName('modifier_jiaoxie_wudi') ~= nil then
				u:Destroy()
				return
			end

			--如果棋子在不宜打断的状态，就暂缓运行AI
			if u:IsStunned() == true or IsHexxed(u) == true or u.is_moving == true or u.is_comboing == true or u:IsChanneling() == true or u:IsFrozen() == true or HasMovingModifier(u) == true then
				return 0.1
			end
			u.ai_started = true
			local ai_delay = 0

			--【优先级1：变身！！】
			--进化
			if u.evolve_result ~= nil then
				if u:HasModifier("modifier_kill") then
					--有持续时间的棋子不进化
					u.evolve_result = nil
				else
					--开始读条进化！
					local evolveresult = EvolveThink(u)
					if evolveresult then
						return evolveresult
					end
				end
			end
			if u.evolve_result_6 ~= nil then
				--开始进化！
				local evolveresult = EvolveThink(u)
				if evolveresult then
					return evolveresult
				end
			end
			--被魔化了
			if u.is_mohua == true and u.is_evolving ~= true then
				TransformAMohuaChess(u,u.demon_buff)
				return 1
			end

			--【优先级2：使用物品】
			if IsChessCanUseItem(u) == true then
				local bkb_result = TriggerBKB(u)
				if bkb_result ~= nil and bkb_result > 0 then
					return bkb_result + ai_delay
				end

				local renjia_result = TriggerRenjia(u)
				if renjia_result ~= nil and renjia_result > 0 then
					return renjia_result + ai_delay
				end

				local hudie_result = TriggerHudie(u)
				if hudie_result ~= nil and hudie_result > 0 then
					return hudie_result + ai_delay
				end

				local sadan_result = TriggerSadan(u)
				if sadan_result ~= nil and sadan_result > 0 then
					return sadan_result + ai_delay
				end

				local tiaodao_result = TriggerTiaodao(u)
				if tiaodao_result ~= nil and tiaodao_result > 0 then
					return tiaodao_result + ai_delay
				end

				local sheep_result = TriggerSheepStick(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local sheep_result = TriggerAtuosi(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local sheep_result = TriggerYonghengzhipan(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local sheep_result = TriggerJurenzhijie(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local sheep_result = TriggerShenjingdun(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local sheep_result = TriggerFulingsuo(u)
				if sheep_result ~= nil and sheep_result > 0 then
					return sheep_result + ai_delay
				end

				local dagon_result = TriggerDagon(u)
				if dagon_result ~= nil and dagon_result > 0 then
					return dagon_result + ai_delay
				end

				local dagon_result = TriggerXueji(u)
				if dagon_result ~= nil and dagon_result > 0 then
					return dagon_result + ai_delay
				end

				local huanying_result = TriggerHuanyingfu(u)
				if huanying_result ~= nil and huanying_result > 0 then
					return huanying_result + ai_delay
				end

				local xiwa_result = TriggerXiwa(u)
				if xiwa_result ~= nil and xiwa_result > 0 then
					return xiwa_result + ai_delay
				end

				local pipe_result = TriggerPipe(u)
				if pipe_result ~= nil and pipe_result > 0 then
					return pipe_result + ai_delay
				end

				local chihongjia_result = TriggerChihongjia(u)
				if chihongjia_result ~= nil and chihongjia_result > 0 then
					return chihongjia_result + ai_delay
				end

				-- local gua_result = TriggerFrogGua(u)
				-- if gua_result ~= nil and gua_result > 0 then
				-- 	return gua_result + ai_delay
				-- end

				local fenglian_result = TriggerFengKuangMianJu(u)
				if fenglian_result ~= nil and fenglian_result > 0 then
					return fenglian_result + ai_delay
				end

				local mifaxie_result = TriggerMiFaXie(u)
				if mifaxie_result ~= nil and mifaxie_result > 0 then
					return mifaxie_result + ai_delay
				end

				local tuitui_result = TriggerTuiTui(u)
				if tuitui_result ~= nil and tuitui_result > 0 then
					return tuitui_result + ai_delay
				end

				local jufeng_result = TriggerJuFeng(u)
				if jufeng_result ~= nil and jufeng_result > 0 then
					return jufeng_result + ai_delay
				end

				local meiken_result = TriggerMeiken(u)
				if meiken_result ~= nil and meiken_result > 0 then
					return meiken_result + ai_delay
				end

				local weishi_result = TriggerWeishijingjia(u)
				if weishi_result ~= nil and weishi_result > 0 then
					return weishi_result + ai_delay
				end

				local silingshu_result = TriggerSilingshu(u)
				if silingshu_result ~= nil and silingshu_result > 0 then
					return silingshu_result + ai_delay
				end

				local refresh_result = TriggerRefreshOrb(u)
				if refresh_result ~= nil and refresh_result > 0 then
					return refresh_result + ai_delay
				end
			end

			--【优先级3：释放技能】
			local a = GetChessAbility(u)
			--多重施法
			if u:HasModifier('modifier_om_multi_cast') == true and u.is_multi_cast_enable == true then
				--使用多重施法buff，刷新技能
				local refresh_result = MultiCast(u)
				if refresh_result ~= nil and refresh_result > 0 then
					return refresh_result + ai_delay
				end
			else
				--卡尔：切换技能
				if u.kael_ability_refresh == true then
					local kael_result = RefreshKaelOrbandAbility(u)
					if kael_result then
						return 0.5 + ai_delay
					end
				end
			end
			--决定是否要放技能
			if a ~= nil and u:HasModifier('modifier_axe_berserkers_call') == false and u:FindModifierByName('modifier_doom_bringer_doom') == nil and IsHexxed(u) == false and u:FindModifierByName('modifier_medusa_stone_gaze_stone') == nil and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and u:HasModifier('modifier_vs_swap_debuff') == false and u:IsSilenced() == false and u:FindAbilityByName(a) ~= nil then

				if u:GetMana() >= GetManaCostX(u,a) and _G.ability_behavior_list[a] ~= 0 and u:FindAbilityByName(a):IsCooldownReady() == true then
					--有蓝，释放技能
					if _G.ability_behavior_list[a] == 1 then
						--单位目标
						local unluckydog = FindUnluckyDog(u)
						if a == 'oracle_mingyunsheling' then
							unluckydog = FindMingyunShelingTarget(unluckydog)		
						end
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							if a == 'shadow_shaman_voodoo' then
								TriggerHex({
									target = unluckydog
								})
							end
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil and a ~= 'poof' then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 2 then
                        --无目标
                        local unluckydog = nil
                        if a == 'tiny_touzhi' then
                            unluckydog = FindUnluckyDog190(u)
                        end
 
                        if a == 'axe_berserkers_call' or a == 'juggernaut_blade_fury' or a == 'shredder_whirling_death' or a == 'rattletrap_battery_assault' or a == 'siren_song' then
                            --确保斧王、剑圣、发条、伐木机近身范围内有敌人（如果希望靠近敌人前就放技能，可以调整 205 的值。）
                            if FindUnluckyDogInRange(u, 205) ~= nil then
                                local newOrder = {
	                                UnitIndex = u:entindex(),
	                                OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	                                TargetIndex = nil, --Optional.  Only used when targeting units
	                                AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
	                                Position = nil, --Optional.  Only used when targeting the ground
	                                Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                OnChessCastStart(u)
                                return RandomFloat(0.5,2) + ai_delay
                            end
						elseif a == 'void_astralstep' then
							--紫猫：确保能跳出来才放技能
							if FindAstralStepPosition(u) ~= nil then
								local newOrder = {
	                                UnitIndex = u:entindex(),
	                                OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	                                TargetIndex = nil, --Optional.  Only used when targeting units
	                                AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
	                                Position = nil, --Optional.  Only used when targeting the ground
	                                Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                OnChessCastStart(u)
                                return RandomFloat(0.5,2) + ai_delay
							end
                        elseif a == 'queenofpain_scream_of_pain' then
                            --确保痛苦女王技能范围内有敌人
                            if FindUnluckyDogInRange(u, 400) ~= nil then
                                local newOrder = {
	                                UnitIndex = u:entindex(),
	                                OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	                                TargetIndex = nil, --Optional.  Only used when targeting units
	                                AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
	                                Position = nil, --Optional.  Only used when targeting the ground
	                                Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                OnChessCastStart(u)
                                return RandomFloat(0.5,2) + ai_delay
                            end
                        elseif a == 'leshrac_pulse_nova' then
							u:FindAbilityByName(a):ToggleAbility()
                        elseif unluckydog ~= nil or a ~= 'tiny_touzhi' then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							if a == 'alchemist_chemical_rage' then
								AcidSpray({
									caster = u,
									ability_level = u:FindAbilityByName(a):GetLevel(),
								})
							end
							if a == 'dragon_knight_elder_dragon_form' then
								
								local dragon_level = u:FindAbilityByName('dragon_knight_elder_dragon_form'):GetLevel()

								if dragon_level == 2 then
									Timers:CreateTimer(1,function()
										u:SetRangedProjectileName("effect/dragon/baseattack/2.vpcf")
									end)
								end
								if dragon_level == 3 then
									Timers:CreateTimer(1,function()
										u:SetRangedProjectileName("effect/dragon/baseattack/3.vpcf")
									end)
								end
							end
							if a == "sven_gods_strength" then
								CastGodsStrength(u)
							end
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 4 then
						--以自己为目标
						if u ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = u:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 5 then
						--近身单位目标
						local unluckydog = FindUnluckyDogInRange(u, u:Script_GetAttackRange())
						if a == 'primal_beast_pulverize' then
							--獸：寻找附近敌人中生命值最高的
							unluckydog = FindMaxHPUnluckyDogInRange(u, u:Script_GetAttackRange(),'modifier_primal_beast_pulverize')
						end
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							StartPrimalBeastThink(unluckydog)

							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 6 then
						--棋盘边缘的空格点目标，先知用
						local unluckypoint = FindUnluckyPoint(u)
						if unluckypoint ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckypoint, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 7 then
						--随机友军单位目标
						local unluckydog = FindUnluckyDogRandomFriend(u,a,true)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 8 then
						--点目标，随机一个空格子
						local unluckypoint = FindEmptyGridAtUnit(u)--FindRandomEmptyGrid(u)
						if unluckypoint ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckypoint, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 9 then
						local unluckydog = FindShallowGraveFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 10 then
						--等级最高的敌方单位目标
						local unluckydog = nil
						if a == 'doom_bringer_doom' then
							--末日：稳定选最高等级目标，不选被动棋子，不重复
							unluckydog = FindHighLevelUnluckyDog(u,true,true,'modifier_doom_bringer_doom')
						end
						if a == 'tp_seed' then
							--寄生种子：稳定选最高等级目标，可选被动棋子，不重复
							unluckydog = FindHighLevelUnluckyDog(u,true,false,'modifier_tp_seed_debuff')
						end
						if a == 'viper_viper_strike' then
							--蝮蛇突袭：稳定选最高等级目标，可选被动棋子，可重复（因为有弹道，设为不重复也没用）
							unluckydog = FindHighLevelUnluckyDog(u,true,false,nil)
						end

						
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							if a == 'shadow_shaman_voodoo' then
								TriggerHex({
									target = unluckydog
								})
							end
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 11 then
						if not IsChessCanMove(u) then
							return 1+ai_delay
						end
						local tt = FindFarthestGridForAbility(u,a)
					    local unluckypoint = tt['skip_postion']
					    if unluckypoint ~= nil then

					        --先占领目标格子
					        local target_x = Vector2X(unluckypoint,u.at_team_id or u.team_id)
					        local target_y = Vector2Y(unluckypoint,u.at_team_id or u.team_id)
					        _G.unit[u.at_team_id or u.team_id][target_y..'_'..target_x] = 1
					        _G.unit[u.at_team_id or u.team_id][u.y_x] = nil
					        u.y_x = target_y..'_'..target_x
					        u.x = target_x
					        u.y = target_y
					    
					        --计算位移过程的时长+技能前后摇时长
					        local go_duration = 2
					        if a == "morphling_waveform" then
					            go_duration = (unluckypoint - u:GetAbsOrigin()):Length2D() / u:FindAbilityByName(a):GetSpecialValueFor('speed') + 0.6
					        elseif a == "sandking_burrowstrike" then
					            go_duration = (unluckypoint - u:GetAbsOrigin()):Length2D() / u:FindAbilityByName(a):GetSpecialValueFor('burrow_speed') + 0.2
					        elseif a == "storm_spirit_ball_lightning_datadriven" then
					            go_duration = (unluckypoint - u:GetAbsOrigin()):Length2D() / u:FindAbilityByName(a):GetSpecialValueFor('ball_lightning_move_speed') + 0.2
					        end
					    
					        --穿刺/波浪 过去！
					        local newOrder = {
					             UnitIndex = u:entindex(), 
					             OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
					             TargetIndex = nil, --Optional.  Only used when targeting units
					             AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
					             Position = unluckypoint, --Optional.  Only used when targeting the ground
					             Queue = 0 --Optional.  Used for queueing up abilities
					        }
					        ExecuteOrderFromTable(newOrder)
					    
					        --如果是水人，在施法完成后标准化他的位置，避免近战可以隔行打到他的问题
					        if a == 'morphling_waveform' then
					            Timers:CreateTimer(go_duration, function()
					                --如果不在波浪形态状态，则重设水人位置
					                if (u:GetAbsOrigin() - unluckypoint):Length2D() < 50 and u:FindModifierByName('modifier_morphling_waveform') ~= true then
					                    ChangeUnitPosition(u, unluckypoint, true)
					                end
					            end)
					        end
					        OnChessCastStart(u)
					        return RandomFloat(0.5,1) + go_duration + ai_delay
					    end
					elseif _G.ability_behavior_list[a] == 12 then
                        --小小投掷，确认周围有敌人
                        local unluckydog = FindUnluckyDog190(u)
                        if IsUnitExist(unluckydog) == true and unluckydog.is_moving ~= true then
                            local unluckypoint = FindFarthestEmptyGrid(u)
                            if unluckypoint ~= nil then
                                local newOrder = {
                                    UnitIndex = u:entindex(),
                                    OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
                                    TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
                                    AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
                                    Position = unluckypoint, --Optional.  Only used when targeting the ground
                                    Queue = 0 --Optional.  Used for queueing up abilities
                                }
                                ExecuteOrderFromTable(newOrder)
                                OnChessCastStart(u)
                                return RandomFloat(0.5,2) + ai_delay
                            end
                        end
					elseif _G.ability_behavior_list[a] == 13 then
						--自己为中心的点目标
						local unluckydog = FindUnluckyDogInRange(u, 300)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = u:GetAbsOrigin(),
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)

							if a == "bloodseeker_blood_bath" then
								BsDelaySilenceEnemy(u,u:FindAbilityByName(a):GetLevel())
							end
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 15 then
						--小鱼人跳
						local unluckydog = FindSlarkJumpUnluckyDogClosest(u)

						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(),--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(1.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 16 then
						local unluckydog = FindNeedShieldFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 17 then
						local unluckydog = FindUnluckyDogByAbilityDamage(u,a)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							-- if a == 'lina_laguna_blade' then
							-- 	local level = u:FindAbilityByName('lina_laguna_blade'):GetLevel()
							-- 	InvisibleUnitCast({
							-- 		caster = u,
							-- 		ability = 'give_fiery_soul',
							-- 		level = level,
							-- 		unluckydog = u,
							-- 	})
							-- end
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 18 then
						--寻找蓝最多的敌人
						local unluckydog = FindMaxManaUnluckydog(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 19 then
						-- 蝙蝠火
						if not IsChessCanMove(u) then
							return 1+ai_delay
						end
						local tt = FindFarthestGridForAbility(u,a)
						local unluckypoint = tt['skip_postion']
						if unluckypoint ~= nil and u.stop_moving ~= true then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							-- 跳跃
							local target_x = Vector2X(unluckypoint,u.at_team_id or u.team_id)
							local target_y = Vector2Y(unluckypoint,u.at_team_id or u.team_id)
							local xx = u.x
							local yy = u.y
							u.y_x = target_y..'_'..target_x
							u.y = target_y
							u.x = target_x
							_G.unit[u.at_team_id or u.team_id][yy..'_'..xx] = nil
							_G.unit[u.at_team_id or u.team_id][target_y..'_'..target_x] = 1
							u.is_moving = true
							Timers:CreateTimer(0.5,function()
								u:SetForwardVector((unluckypoint - u:GetAbsOrigin()):Normalized())
								if u.stop_moving ~= true and u:HasModifier('modifier_toss') ~= true then
									BlinkChessX({
										p = unluckypoint,
										caster = u,
										blink_type = 'run',
										set_forward = true,
									})
								end
							end)
							OnChessCastStart(u)
							return 2 + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 20 then
						
						local unluckydog = FindUnluckyDogFarthest(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(),
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = nil,
						 		Queue = 0
						 	}
							ExecuteOrderFromTable(newOrder)

							if a == 'pudge_meat_hook_lua' then
								--屠夫的连招
								
								u.hook_unluckydog = unluckydog

								local new_position = FindClosestEmptyGrid(u)
								if new_position ~= nil and unluckydog:HasMovementCapability() == true and unluckydog:HasAbility('is_ward') == false then
									-- unluckydog.stop_moving = true
									local chessboard_id = u.at_team_id or u.team_id
									local yy = unluckydog.y
									local xx = unluckydog.x
									local y = Vector2Y(new_position,chessboard_id)
									local x = Vector2X(new_position,chessboard_id)
									local stun_duration = ((u:GetAbsOrigin()-unluckydog:GetAbsOrigin()):Length2D()/1600) + 0.4

									Timers:CreateTimer(stun_duration,function()
										if unluckydog:HasModifier('modifier_primal_beast_pulverize') then
											return
										end
										if unluckydog.is_hooked == true then
											unluckydog:AddNewModifier(unluckydog,nil,"modifier_stunned",{ duration = stun_duration+1 })
											_G.unit[chessboard_id][y..'_'..x] = 1

											unluckydog.stop_moving = nil
											unluckydog.is_moving = true
											BlinkChessX({
												p = new_position,
												caster = unluckydog,
												blink_type = 'hook',
											})
											unluckydog.y_x = y..'_'..x
											unluckydog.y = y
											unluckydog.x = x
											_G.unit[chessboard_id][yy..'_'..xx] = nil
											unluckydog.is_hooked = nil
										end
									end)
									unluckydog.hook_pudge = u
									unluckydog.hook_cb = (function(uuu)
										
										if IsUnitExist(uuu.hook_unluckydog) == true and IsUnitExist(uuu) == true then
											uuu.is_comboing = true --is_comboing为true的时候，不会执行其他AI打断连招操作

											if ((uuu.hook_unluckydog:GetAbsOrigin() - uuu:GetAbsOrigin()):Length2D() < 200) then
												--肢解
												-- uuu:SwapAbilities('pudge_meat_hook_lua','pudge_dismember', false, true)
												Timers:CreateTimer(0.1,function()
													if uuu:FindAbilityByName('pudge_dismember') ~= nil then
														ExecuteOrderFromTable({
													 		UnitIndex = uuu:entindex(), 
													 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
													 		TargetIndex = uuu.hook_unluckydog:entindex(), --Optional.  Only used when targeting units
													 		AbilityIndex = u:FindAbilityByName('pudge_dismember'):entindex(), --Optional.  Only used when casting abilities
													 		Position = nil, --Optional.  Only used when targeting the ground
													 		Queue = 0 --Optional.  Used for queueing up abilities
													 	})
													 	if uuu:GetUnitName() == 'chess_pudge11' then
													 		EmitSoundOn("dac.pudge.fresh_meat",uuu)
													 	end
													 	
													 	Timers:CreateTimer(2,function()
													 		if IsUnitExist(uuu) == false then
													 			return
													 		end
													 		if uuu:IsChanneling() == false then
														 		-- uuu:SwapAbilities('pudge_dismember','pudge_meat_hook_lua', false, true)
														 		uuu.is_comboing = nil
														 		return
														 	end
													 		return 0.1
													 	end)
													end
												end)
											else
												--不肢解
												uuu.is_comboing = nil
											end
											uuu.hook_cb = nil
										end
										unluckydog.stop_moving = nil
									end)

									OnChessCastStart(u)
									-- 将钩子来回的总时间加上随机量，做为进行下一次行动前的延迟。避免屠夫提前移动导致连招失败。
									return (u:GetAbsOrigin() - unluckydog:GetAbsOrigin()):Length2D() / 800 * 2 + RandomFloat(0.5,1) + ai_delay
								end
							end

							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 21 then
						-- 佣兽寻找攻速最快的敌人
						local unluckydog_1 = nil
						local speed_1 = 0.1
						for i1,v1 in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
							if IsUnitExist(v1) and v1:GetAttacksPerSecond() > speed_1 and v1.team_id ~= u.team_id and v1:HasModifier("modifier_visage_grave_chill_debuff") ~= true then
								speed_1 = v1:GetAttacksPerSecond()
								unluckydog_1 = v1
							end
						end
						if unluckydog_1 ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog_1:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end	
					elseif _G.ability_behavior_list[a] == 22 then
						--新大鱼点灯目标
						local unluckydog = nil
						if u:GetAttackTarget() ~= nil and IsUnitExist(u:GetAttackTarget()) == true then
							unluckydog = u:GetAttackTarget()
						else
							unluckydog = FindUnluckyDogInRange(u, u:Script_GetAttackRange(),'modifier_slardar_amplify_damage')
						end
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 23 then
						--全能选择目标
						local unluckydog = FindPurificationFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 24 then
						--蜘蛛选择目标
						local unluckydog = FindUnluckyDogInRange(u, 300,'modifier_br_web_debuff')
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 25 then
						--天火选择目标
						local unluckydog = FindUnluckyDogFarthest(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)

							if u:FindAbilityByName(a):GetLevel() == 2 then
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 2,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
							end
							if u:FindAbilityByName(a):GetLevel() == 3 then
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 3,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 3,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
								Timers:CreateTimer(RandomFloat(0,0.5),function()
									local unluckydog = FindUnluckyDog(u)
									if unluckydog ~= nil then
										InvisibleUnitCast({
											caster = u,
											ability = 'invoker_sun_strike',
											level = 3,
											position = unluckydog:GetAbsOrigin(),
											ignore_nether_ward = true,
										})
									end
								end)
							end
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 26 then
						--陈复活目标buff
						local unluckydog = GetMaxLevelChessFromDeadChessList({
							at_team_id = u.at_team_id or u.team_id,
						})
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
						 		TargetIndex = nil, --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 27 then
						--双头龙两个头的技能切换
						local tt = FindFarthestGridForAbility(u,a)
						local target_enemy = tt['target_enemy']
						local target_postion = tt['skip_postion']
						if target_enemy ~= nil then
							unluckydog = target_enemy
						else
							unluckydog = FindUnluckyDog(u) or unluckydog
						end

						--根据现在是什么技能决定怎么放
						if u.ice_or_fire == nil or u.ice_or_fire == 'fire' then
							a = 'jakiro_macropyre'
						else
							a = 'jakiro_ice_path'
						end
						if target_postion ~= nil and u:FindAbilityByName(a):IsCooldownReady() == true then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = target_postion, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
							Timers:CreateTimer(1,function()
								if u.ice_or_fire == 'ice' then
									--冰切火
									u.ice_or_fire = 'fire'
									local cd = u:FindAbilityByName("jakiro_ice_path"):GetCooldown(u:FindAbilityByName("jakiro_ice_path"):GetLevel())
									u:FindAbilityByName("jakiro_ice_path"):SetHidden(true)
									u:FindAbilityByName("jakiro_macropyre"):SetHidden(false)
									if u:HasAbility('is_god_buff_plus') then
										u:FindAbilityByName("jakiro_macropyre"):StartCooldown(cd*0.25+1)
									elseif u:HasAbility('is_god_buff') then
										u:FindAbilityByName("jakiro_macropyre"):StartCooldown(cd*0.5+1)
									else
										u:FindAbilityByName("jakiro_macropyre"):StartCooldown(cd+1)
									end
								else
									--火切冰
									u.ice_or_fire = 'ice'
									local cd = u:FindAbilityByName("jakiro_macropyre"):GetCooldown(u:FindAbilityByName("jakiro_macropyre"):GetLevel())
									u:FindAbilityByName("jakiro_macropyre"):SetHidden(true)
									u:FindAbilityByName("jakiro_ice_path"):SetHidden(false)
									if u:HasAbility('is_god_buff_plus') then
										u:FindAbilityByName("jakiro_ice_path"):StartCooldown(cd*0.25+1)
									elseif u:HasAbility('is_god_buff') then
										u:FindAbilityByName("jakiro_ice_path"):StartCooldown(cd*0.5+1)
									else
										u:FindAbilityByName("jakiro_ice_path"):StartCooldown(cd+1)
									end
								end
							end)

							OnChessCastStart(u)
							return RandomFloat(1,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 28 then
						local luckydog = FindHighLevelLuckyDog(u)
						if luckydog ~= nil and luckydog:HasModifier('modifier_wisp_tether') == false then
							u.tether_target = luckydog
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = luckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)

							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 29 then
						--圆形AOE施法AI
						local target_position = FindBestGridForCircleAOE(u,a)
						if target_position ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = target_position, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
						 	OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end	
					elseif _G.ability_behavior_list[a] == 30 then
						--多重施法选择合适目标AI
						local unluckydog = FindBestMulticastFriend(u)
						if unluckydog ~= nil then
							local newOrder = {
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	}
							ExecuteOrderFromTable(newOrder)
							OnChessCastStart(u)
							return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 31 then
						local di = FindGouheDirection(u)
						if di ~= nil then
							local point = u:GetAbsOrigin() + Vector(di.x*128,di.y*128,0)
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = point, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
						 	OnChessCastStart(u)
						 	return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 32 then
						local unluckydog = FindMinHPEnemy(u)
						if unluckydog ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
						 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
						 		Position = nil, --Optional.  Only used when targeting the ground
						 		Queue = 0 --Optional.  Used for queueing up abilities
						 	})
						 	OnChessCastStart(u)
						 	if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
								CopyAbility2FuhunUnit(u,unluckydog,a)
							end
							if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
								CopyAbility2QinglianbaozhuUnit(u,unluckydog,a)
							end
						 	return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 33 then
						--滚滚，找个随机地点冲刺过去
						if not IsChessCanMove(u) then
							return 1+ai_delay
						end
						local point = FindRandomCanAttackEnemyEmptyGrid(u)
						if point ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
						 		TargetIndex = nil,
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = point,
						 		Queue = 0,
						 	})
						 	OnChessCastStart(u)
						 	return RandomFloat(0.5,2) + ai_delay
						end
					elseif _G.ability_behavior_list[a] == 34 then
						--VS换
						local target = FindUnluckyDogEnemySameStar(u)
						if target ~= nil then
							ExecuteOrderFromTable({
						 		UnitIndex = u:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = target:entindex(),
						 		AbilityIndex = u:FindAbilityByName(a):entindex(),
						 		Position = nil,
						 		Queue = 0,
						 	})
						 	OnChessCastStart(u)
					 		return RandomFloat(0.5,2) + ai_delay
					 	end
					 elseif _G.ability_behavior_list[a] == 35 then
						--术士地狱火
						ExecuteOrderFromTable({
					 		UnitIndex = u:entindex(), 
					 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
					 		TargetIndex = nil,
					 		AbilityIndex = u:FindAbilityByName(a):entindex(),
					 		Position = nil,
					 		Queue = 0,
					 	})
					 	OnChessCastStart(u)
				 		return RandomFloat(0.5,2) + ai_delay
					else
						--点目标
						local unluckydog = FindUnluckyDog(u)
						if unluckydog ~= nil then
							if a == "windrunner_powershot" then
								--强力击+束缚击
								local tt = FindFarthestGridForAbility(u,a)
								local target_enemy = tt['target_enemy']
								local target_postion = tt['skip_postion']
								if target_enemy ~= nil then
									unluckydog = target_enemy
								else
									unluckydog = FindUnluckyDogClosest(u) or unluckydog
								end
								if unluckydog ~= nil then
									InvisibleUnitCast({
										caster = u,
										ability = "windrunner_shackleshot",
										level = u:FindAbilityByName(a):GetLevel(),
										unluckydog = unluckydog,
										ignore_nether_ward = true,
									})

									ExecuteOrderFromTable({
								 		UnitIndex = u:entindex(), 
								 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
								 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
								 		Position = target_postion, --Optional.  Only used when targeting the ground
								 		Queue = 0 --Optional.  Used for queueing up abilities
								 	})

								 	if unluckydog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
										CopyAbility2FuhunUnit(u,unluckydog,'windrunner_shackleshot')
									end
									if unluckydog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
										CopyAbility2QinglianbaozhuUnit(u,unluckydog,'windrunner_shackleshot')
									end
								end
							elseif a == "keeper_of_the_light_illuminate" then
								--光法冲击波
								local tt = FindFarthestGridForAbility(u,a)
								local target_postion = tt['skip_postion']
								if target_postion ~= nil then
									ExecuteOrderFromTable({
								 		UnitIndex = u:entindex(), 
								 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
								 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
								 		Position = target_postion, --Optional.  Only used when targeting the ground
								 		Queue = 0 --Optional.  Used for queueing up abilities
								 	})
								end
							elseif a == "chaos_meteor_datadriven" then
								--陨石
								local tt = FindFarthestGridForAbility(u,a)
								local target_enemy = tt['target_enemy']
								local target_postion = tt['skip_postion']
								if target_enemy ~= nil then
									unluckydog = target_enemy
								else
									unluckydog = FindUnluckyDogClosest(u) or unluckydog
								end
								if unluckydog ~= nil then
									ExecuteOrderFromTable({
								 		UnitIndex = u:entindex(), 
								 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
								 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
								 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
								 		Queue = 0 --Optional.  Used for queueing up abilities
								 	})
								end
							else
								ExecuteOrderFromTable({
							 		UnitIndex = u:entindex(), 
							 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
							 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
							 		AbilityIndex = u:FindAbilityByName(a):entindex(), --Optional.  Only used when casting abilities
							 		Position = unluckydog:GetAbsOrigin(), --Optional.  Only used when targeting the ground
							 		Queue = 0 --Optional.  Used for queueing up abilities
							 	})
							end

							--光法 风行 蓄力
							if a=="keeper_of_the_light_illuminate" or a=="windrunner_powershot" then
								OnChessCastStart(u)
								return 3.5 + ai_delay
							else
								OnChessCastStart(u)
								return RandomFloat(0.5,2) + ai_delay
							end
						end
					end
				end
			end

			--判断武僧残血状态的变化
			if u.is_monk_escaping == true and IsGridCanBeAttackedByEnemy(u.x,u.y,u) == false then
				u.is_monk_escaping = nil
				u.is_monk_escaped = true
				return 1 + ai_delay
			end
			if u.is_monk_escaped == true or u.is_monk_escaping == true then
				local hp = u:GetHealth()
				local max_hp = u:GetMaxHealth()
				if 1.0*hp/max_hp > 0.3 then
					u.is_monk_escaped = nil
					u.is_monk_escaping = nil
				end
			end
			--判断牧师被近身状态的变化
			local enemy_team_id = 4
			if u:GetTeam() == 4 then
				enemy_team_id = u.at_team_id
			end
			if u.is_priest_escaping == true and IsLonely4Team(u,enemy_team_id) == true then
				u.is_priest_escaping = nil 	
			end

			--【优先级4：攻击】决定是否要攻击
			if IsChessCanAttack(u) == true then
				if IsEscapeMonk(u) == false and IsEscapePriest(u) == false and IsChannelingWalk(u) == false then
					local attack_result = FindAClosestEnemyAndAttack(u)
					if attack_result ~= nil and attack_result > 0 then
						return attack_result + ai_delay
					end
				end
			end

			--【优先级5：移动】不攻击就走动
			if u.stop_moving ~= true and IsChessCanMove(u) == true then
				local find_ok = nil
				local try_count = 0
				local blink_type = 'run'

				--寻路
				if u.has_assassin_blink == true then
					--背刺跳跃
					u.has_assassin_blink = nil
					find_ok = FindAssassinJumpPosition(u)
					blink_type = 'jump'
					InitAssassinJump(u)
				else
					if IsEscapeMonk(u) == true then
						--残血武僧：逃离行走
						find_ok = FindNextMonkEscapePosition(u)
						u.is_monk_escaping = true
						u.is_monk_escaped = true
						blink_type = 'jump'
					elseif IsEscapePriest(u) == true then
						--牧师：走向不被近身的格子
						find_ok = FindNextPriestEscapePosition(u)
						u.is_priest_escaping = true
					elseif IsChannelingWalk(u) == true then
						--剑圣、老鹿等，在释放技能的时候，走向最近的临近敌人的空格子
						find_ok = FindNearestChannelingWalkPosition(u)
					else
						--正常行走：走向最近的能攻击到敌人的格子
						find_ok = FindNextSkipPosition(u)
					end
					if find_ok ~= nil then
						if HasShoes(u) then
							blink_type = 'jump'
						else
							local pos1 = XY2Vector(u.x,u.y,u.at_team_id or u.team_id)
							if (find_ok - pos1):Length2D() > 128*3 then
								find_ok = (find_ok - pos1):Normalized() * 128 * 3 + pos1
							end
						end
						-- if u:FindModifierByName('modifier_is_elf_buff_plus_plus') ~= nil then
						-- 	blink_type = 'elfrun'
						-- end
					end
				end

				if (u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') or u:HasModifier('modifier_vs_swap_debuff') or u:HasModifier('modifier_lion_voodoo')) and IsChessCanMove(u) then
					--混乱，随机走动
					find_ok = FindRandomEmptyGridAtUnit(u,false)
					blink_type = 'run'
				end

				if find_ok ~= nil then
					--走！
					local x = Vector2X(find_ok,u.at_team_id or u.team_id)
					local y = Vector2Y(find_ok,u.at_team_id or u.team_id)
					local xx = u.x
					local yy = u.y
					_G.unit[u.at_team_id or u.team_id][y..'_'..x] = 1
					u:SetForwardVector((find_ok - u:GetAbsOrigin()):Normalized())
					u.is_moving = true
					BlinkChessX({
						p = find_ok,
						caster = u,
						blink_type = blink_type,
						set_forward = true,
					})
					u.y_x = y..'_'..x
					u.y = y
					u.x = x
					_G.unit[u.at_team_id or u.team_id][yy..'_'..xx] = nil

					return 0.5
				end
			end

			--无事可做，挂机
			return RandomFloat(0.1,0.2) + ai_delay
		end)
	end
end
function StartGame()
	for i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(i,"start_game",{
			key = GetClientKey(i),
			hehe = RandomInt(1,100000),
		})
	end
	Timers:CreateTimer(function()
	    for i=6,13 do
	    	local h1 = TeamId2Hero(i)
	    	if h1 ~= nil and h1:IsNull() == false then
	    		if IsUnitExist(h1) == true then
		    		AddFOWViewer(i, Entities:FindByName(nil,"center"..(i-6)):GetOrigin(), 1000, 3, true)
		    	end
		    	local open_fog = _G.user_setting[h1.steam_id]['is_fog_show']
	    		if open_fog and tonumber(open_fog) ~= 1 then
			    	for j=0,11 do
			    		local hero = TeamId2Hero(j+6)
			    		if hero ~= nil and IsUnitExist(hero) == true then
				    		AddFOWViewer(i, Entities:FindByName(nil,"center"..j):GetOrigin(), 1000, 3, false)
				    	end
				    end
				end
	    	end
		end
		return 2
	end)
	--5秒后开始游戏
	Timers:CreateTimer(5,function()
		if _G.playing_player_count == 1 then
			prt('#tips_1_player')
		else
			prt('GAME START!')
		end

		--初始化棋子库
		InitChessPool(_G.playing_player_count)

		EnableBanChess()

    	_G.START_TIME = GameRules:GetGameTime()
		StartAPrepareRound()
    end)
	-- ShowLuaPing()
end
function GameOver()
	_G.is_game_ended = true
	if _G.ended == false then
		CustomNetTables:SetTableValue( "dac_table", "curtain_tips", { text = "#gameover", hehe = RandomInt(1,1000)})
		CustomNetTables:SetTableValue( "dac_table", "game_over", { text = "#gameover", hehe = RandomInt(1,1000)})

		local win_team = 2
		if _G.good_castle.hp > 0 then
			win_team = 2
		end
		if _G.bad_castle.hp > 0 then
			win_team = 3
		end

		for i,v in pairs(_G.hero) do
			if v.team == win_team then
				v:AddAbility('gameover_win')
				v:FindAbilityByName('gameover_win'):SetLevel(1)
			else
				v:AddAbility('gameover_lose')
				v:FindAbilityByName('gameover_lose'):SetLevel(1)
			end
		end

		_G.ended = true
		-- EmitGlobalSound("Loot_Drop_Stinger_Arcana")

		GameRules:SendCustomMessage('gameover',0,0)

		Timers:CreateTimer(2,function()
			CalScore()
		end)
	end
end


--【底层方法】
function IsValueInTable(value, table)
	for k,v in pairs(table) do
	  if v == value then
	  	return true
	  end
	end
	return false
end

function FindValueInTable(tbl,value)
	if tbl == nil then
		tbl = {}
	end
	local found = false
	for i,v in pairs(tbl) do
		if v == value then
			found = true
		end
	end
	return found
end
function CopyTable(origin_table)
	local new_table = {}
	if origin_table ~= nil then
		for k,v in pairs(origin_table) do
			table.insert(new_table,v)
		end
		return new_table
	else
		return {}
	end
end
function DiffTable(big_table,small_table)
	local temp_table  = {}
	for k,v in pairs(big_table) do
		table.insert(temp_table,v)
	end
	for k1,v1 in pairs(small_table) do
		RemoveOneKeyInTable(temp_table,v1)
	end
	if table.maxn(temp_table) > 0 then
		return temp_table
	else
		return {}
	end
end
function RemoveOneKeyInTable(tbl,key)
	local max = table.maxn(tbl)
	for i = max,1,-1 do
		if key == tbl[i] then
			table.remove(tbl,i)
			return true
		end
	end
	return false
end
function prt(t)
	CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
		player_id = nil,
		text = ''..t,
		time_stamp = math.floor(GameRules:GetGameTime()),
		type = 'common',
	})
end
function combat(t)
	CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
		type = 'common',
		text = t,
		time_stamp = math.floor(GameRules:GetGameTime()),
	})	
end
function debugg(t)
	if _G.is_debug == true then
		GameRules:SendCustomMessage(''..t,0,0)
	end
end
function unit2text(u)
	local id1 = u.team_id or 'X'
	local id2 = u.at_team_id or 'X'
	return ''..id1..'-'..id2..'的'..u:GetUnitName()
end
function RemoveTableItem(t,item)
	for i,v in pairs (t) do
		if v == item then
			table.remove(t,i)
			return t
		end
	end
end
function string.split(s, sep)
    if sep == nil then
            sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(s, "([^"..sep.."]+)") do
            t[i] = str
            i = i + 1
    end
    return t
end
function JoinTableString(t)
	local str = ''
	for _,v in pairs(t) do
		str = str..v..','
	end
	return string.sub(str, 1, -2)
end
function string.fromhex(str)
    return (str:gsub('..', function(cc)
        return string.char(tonumber(cc, 16))
    end))
end

function string.tohex(str)
    return (str:gsub('.', function (c)
        return string.format('%02X',string.byte(c))
    end))
end
function string.split(s, sep)
    if sep == nil then
            sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(s, "([^"..sep.."]+)") do
            t[i] = str
            i = i + 1
    end
    return t
end
function sign(key, msg)
	return sha2.hex2bin(sha2.hmac(sha2.sha256,key,msg))
end
function calmd5(str)
	return sha2.md5(str)
end
function getSignatureKey(key, dateStamp, regionName, serviceName)
    kDate = sign('AWS4'..key, dateStamp)
    kRegion = sign(kDate, regionName)
    kService = sign(kRegion, serviceName)
    kSigning = sign(kService, 'aws4_request')
    return kSigning
end
function SendAmazonData(ctx,amzdate,datestamp)
	local data_compressed = LibDeflate:CompressDeflate(json.encode(ctx));
	local data = {
	  StreamName = "report_reciver",
	  Data = base64.encode(data_compressed),
	  PartitionKey = 'AMAZON'..RandomInt(1,1000),
	}
	local body_data = json.encode(data)
	
	local method = 'POST'
	local service = 'kinesis'
	local host = 'kinesis.cn-north-1.amazonaws.com.cn'
	local region = 'cn-north-1'
	local endpoint = 'https://kinesis.cn-north-1.amazonaws.com.cn'
	local request_parameters = ""
	local enc_AWS_ACCESS_KEY_ID = "27715D326D6432E154E7D91D1662D7C14783D4ADE24394565A17BF91B6FD653A"
	local AWS_ACCESS_KEY_ID = aeslua.decrypt(GetDedicatedServerKeyV2('fgnb'),string.fromhex(enc_AWS_ACCESS_KEY_ID))
	local access_key = AWS_ACCESS_KEY_ID
	local enc_AWS_SECRET_ACCESS_KEY = "3C77FACD23AE027A4580075B1C5FC1B70339120A07B5FA37CC78A36B526045D84AA1493432AE6CBB443EFB9604C4AAD2"
	local AWS_SECRET_ACCESS_KEY = aeslua.decrypt(GetDedicatedServerKeyV2('fgnb'),string.fromhex(enc_AWS_SECRET_ACCESS_KEY))
	local secret_key = AWS_SECRET_ACCESS_KEY

	-- local method = 'POST'
	-- local service = 'kinesis'
	-- local host = 'kinesis.us-east-2.amazonaws.com'
	-- local region = 'us-east-2'
	-- local endpoint = 'https://kinesis.us-east-2.amazonaws.com'
	-- local request_parameters = ""
	-- local enc_AWS_ACCESS_KEY_ID = "032B547325EC3CA77B5A41BAA5E8B6E2782DAA707CF787D83F927EA83AF924D3"
	-- local AWS_ACCESS_KEY_ID = aeslua.decrypt(GetDedicatedServerKeyV2('bsl,bgbxh'),string.fromhex(enc_AWS_ACCESS_KEY_ID))
	-- local access_key = AWS_ACCESS_KEY_ID
	-- local enc_AWS_SECRET_ACCESS_KEY = '528D3C17F37D92A89DF81451B99D2ABE458689E62F5B9DD9E1D6AAE6C93B2B077554BF139D2C15ED745A0197D67C9BC8'
	-- local AWS_SECRET_ACCESS_KEY = aeslua.decrypt(GetDedicatedServerKeyV2('bsl,bgbxh'),string.fromhex(enc_AWS_SECRET_ACCESS_KEY))
	-- local secret_key = AWS_SECRET_ACCESS_KEY

	local canonical_uri = '/'
	local canonical_querystring = request_parameters
	local canonical_headers = 'host:'..host..'\n'..'x-amz-date:'..amzdate..'\n'
	local signed_headers = 'host;x-amz-date'
	local payload_hash = sha2.sha256(body_data)
	local canonical_request = method..'\n'..canonical_uri..'\n'..canonical_querystring..'\n'.. canonical_headers..'\n'..signed_headers..'\n'..payload_hash


	local algorithm = 'AWS4-HMAC-SHA256'
	local credential_scope = datestamp..'/'..region..'/'..service..'/'..'aws4_request'
	local string_to_sign = algorithm..'\n'..amzdate..'\n'..credential_scope..'\n'..sha2.sha256(canonical_request)

	local signing_key = getSignatureKey(secret_key, datestamp, region, service)
	local signature = sha2.hmac(sha2.sha256,signing_key,string_to_sign)

	local authorization_header = algorithm..' '..'Credential='..access_key..'/'..credential_scope..', '..'SignedHeaders='..signed_headers..', '..'Signature='..signature

	local request_url = endpoint..'/'

	local req = CreateHTTPRequestScriptVM("POST",request_url)
    req:SetHTTPRequestHeaderValue("x-amz-date", amzdate)
    req:SetHTTPRequestHeaderValue("Content-Type", "application/x-amz-json-1.1")
    req:SetHTTPRequestHeaderValue("X-Amz-Target", "Kinesis_20131202.PutRecord")
    req:SetHTTPRequestHeaderValue("Authorization", authorization_header)
    req:SetHTTPRequestRawPostBody("application/x-amz-json-1.1",body_data)
    req:Send(function(res)
        if res.StatusCode ~= 200 or not res.Body then
            return
        else

        end
    end)
end
--向table中添加一个内容（去重,后面的11和1会被去掉）
function SAdd(t, v)
	if string.find(v,'11') ~= nil then
		v = string.sub(v,1,-3)
	end
	if string.find(v,'1') ~= nil then
		v = string.sub(v,1,-2)
	end
	if FindValueInTable(t, v) == true then
		return table.maxn(t)
	else
		table.insert(t, v)
		return table.maxn(t)
	end
end
function GaussRandom()
	local ranbase = 9999
	while (ranbase > 4 or ranbase < -4) do
		local u = RandomInt(1,10000)/10000
		local v = RandomInt(1,10000)/10000
		ranbase = math.sqrt((-2)*math.log(u))*math.cos(2*math.pi*v)
	end
	local ranresult = math.ceil(ranbase*128+512)
	return ranresult
end
--【通用方法】
--添加棋子战斗技能
function AddChessAbility(x,level)
	if _G.chess_ability_list[x:GetUnitName()] ~= nil then
		local a = _G.chess_ability_list[x:GetUnitName()]
		if x:FindAbilityByName(a) == nil then
			AddAbilityAndSetLevel(x,a,(level or 0))
		end
	end
end
function DecreaseMana(keys)
	local caster = keys.caster
	local target = keys.target
	local mana = keys.mana
	if mana == nil or mana <= 0 then
		return
	end

	-- if caster:IsRangedAttacker() == true then
	-- 	mana = mana / 2
	-- end

	local mana_result = math.floor(target:GetMana()-mana)

	if mana_result < 0 then
		mana_result = 0
	end
	
	if mana_result < target:GetMana() then
		EmitSoundOn('DOTA_Item.DiffusalBlade.Target',target)
		play_particle("particles/items_fx/diffusal_slow.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
	end

	target:SetMana(mana_result)
end
function EnableBanChess()
	for team_i=6,13 do
		local hh = TeamId2Hero(team_i)
		if IsUnitExist(hh) and hh:FindAbilityByName('ban_chess') ~= nil then
			hh:FindAbilityByName('ban_chess'):SetHidden(false)
			hh:FindAbilityByName('ban_chess'):SetActivated(true)
		end
	end
end
--通用方法之坐标系转换
function HandIndex2Vector(team_id,index)
	return _G.base_vector[team_id] + Vector((index-1)*128,-2*128,256)
end
function XY2Vector(x,y,team_id)
	return _G.base_vector[team_id] + Vector(((x or 1)-1)*128,((y or 1)-1)*128,256)
end
function Vector2X(v,team_id)
	if v == nil or team_id == nil then
		return nil
	end
	local relative_position = v - _G.base_vector[team_id]
	local x = math.floor((relative_position.x+192)/128)
	-- if x < 1 or x > 8 then
	-- 	x = -1
	-- end
	return x
end
function Vector2Y(v,team_id)
	if _G.base_vector[team_id] == nil or v == nil then
		return -1
	end
	local relative_position = v - _G.base_vector[team_id]
	local y = math.floor((relative_position.y+192)/128)
	-- if y < 1 or y > 8 then
	-- 	y = -1
	-- end
	return y
end
function CenterVector(team_id)
	return _G.base_vector[team_id] + Vector(3.5*128,2.5*128,0)
end
function CentrosymmetryPosition(teamid,x,y)
	return XY2Vector(9-x,9-y,teamid)
end
--通用方法之位置判断
function IsInMap(x,y)
	--格子是否在防守场地
	if x<1 or x>8 or y<1 or y>4 then
		return false
	else
		return true
	end
end
function IsInDefendArea(x,y)
	if x>=1 and x<=8 and y>=1 and y<=4 then
		return true
	else
		return false
	end
end
function IsInAttackArea(x,y)
	--格子是否在进攻场地
	if x>=1 and x<=8 and y>=5 and y<=8 then
		return true
	else
		return false
	end
end
function IsIn8x8(x,y)
	if x>=1 and x<=8 and y>=1 and y<=8 then
		return true
	else
		return false
	end
end
function IsBlocked(x,y,team_id)
	if IsInMap(x,y) == false then
		return "map"
	end
	if _G.unit[team_id][y..'_'..x] ~= nil then
		return "unit"
	end
	return false
end
function PrecacheAUnit(delay,unitname)
	Timers:CreateTimer(delay,function()
		PrecacheUnitByNameAsync(unitname,function()
		end)
	end)
end
function RandomRelic()
	local remove_table = {}
	local ll = table.maxn(_G.DROP_RELIC_LIST)
	local locked_relic_list = {
		-- 'item_steal_chess',
	}

	while ll > 10 do
		local rn = RandomInt(1,ll)
		local chess = _G.DROP_RELIC_LIST[rn]
		if FindValueInTable(locked_relic_list,chess) == false then
			table.insert(remove_table,chess)
			table.remove(_G.DROP_RELIC_LIST,rn)
			ll = table.maxn(_G.DROP_RELIC_LIST)
		end
	end

	return remove_table
end
function RandomLegendary()
	local remove_table = {}
	local ll = table.maxn(_G.chess_list_by_mana[5])
	local locked_chess_list = {
		-- 'chess_pb',
	}

	while ll > 8 do
		local rn = RandomInt(1,ll)
		local chess = _G.chess_list_by_mana[5][rn]
		if FindValueInTable(locked_chess_list,chess) == false then
			table.insert(remove_table,chess)
			table.remove(_G.chess_list_by_mana[5],rn)
			ll = table.maxn(_G.chess_list_by_mana[5])
		end
	end

	for k,v in pairs(LoadKeyValues("scripts/npc/npc_units_custom.txt")) do
		if string.find(k,'chess_') and string.find(k,'1') == nil then
			for i=1,5 do
				if FindValueInTable(_G.chess_list_by_mana[i],k) then
					for kk,tt in pairs(_G.chess_list_by_synergy) do
						if kk == v['Ability1'] then
							table.insert(tt,k)
						end
						if kk == v['Ability2'] then
							table.insert(tt,k)
						end
						if kk == v['Ability3'] then
							table.insert(tt,k)
						end
					end
				end
			end
			for i=1,5 do
				if FindValueInTable(_G.chess_list_by_mana_black[i],k) then
					for kk,tt in pairs(_G.chess_list_by_synergy_black_and_pandaman) do
						if kk == v['Ability1'] then
							table.insert(tt,k)
						end
						if kk == v['Ability2'] then
							table.insert(tt,k)
						end
						if kk == v['Ability3'] then
							table.insert(tt,k)
						end
					end
				end
			end
			if FindValueInTable(_G.pandaman_list,k) then
				for kk,tt in pairs(_G.chess_list_by_synergy_black_and_pandaman) do
					if k ~= 'chess_brew' then
						if kk == v['Ability1'] then
							table.insert(tt,k)
						end
						if kk == v['Ability2'] then
							table.insert(tt,k)
						end
						if kk == v['Ability3'] then
							table.insert(tt,k)
						end
					end
				end
			end
			if FindValueInTable(_G.chess_list_ssr,k) then
				for kk,tt in pairs(_G.chess_list_by_synergy_ban_unavailable) do
					if kk == v['Ability1'] then
						table.insert(tt,k)
					end
					if kk == v['Ability2'] then
						table.insert(tt,k)
					end
					if kk == v['Ability3'] then
						table.insert(tt,k)
					end
				end
			end
			if FindValueInTable(remove_table,k) then
				for kk,tt in pairs(_G.chess_list_by_synergy_ban_unavailable) do
					if kk == v['Ability1'] then
						table.insert(tt,k)
					end
					if kk == v['Ability2'] then
						table.insert(tt,k)
					end
					if kk == v['Ability3'] then
						table.insert(tt,k)
					end
				end
			end
		end
	end	

	--排序
	for s,t in pairs(_G.chess_list_by_synergy) do
		table.sort(t,function(a,b)
			return _G.chess_2_mana[b] > _G.chess_2_mana[a]
		end)
	end
	for s,t in pairs(_G.chess_list_by_synergy_black_and_pandaman) do
		table.sort(t,function(a,b)
			return _G.chess_2_mana[b] > _G.chess_2_mana[a]
		end)
	end
	for s,t in pairs(_G.chess_list_by_synergy_ban_unavailable) do
		table.sort(t,function(a,b)
			return _G.chess_2_mana[b] > _G.chess_2_mana[a]
		end)
	end

	CustomNetTables:SetTableValue( "chess_pool_table", "chess_list_by_synergy", _G.chess_list_by_synergy)
	CustomNetTables:SetTableValue( "chess_pool_table", "chess_list_by_synergy_black_and_pandaman", _G.chess_list_by_synergy_black_and_pandaman)
	CustomNetTables:SetTableValue( "chess_pool_table", "chess_list_by_synergy_ban_unavailable", _G.chess_list_by_synergy_ban_unavailable)

	return remove_table
end
function StatAllPlayerLineup()
	for team_i=6,13 do
		local hero = TeamId2Hero(team_i)
		if IsUnitExist(hero) == true and hero.steam_id ~= nil then
			local lineup_count = 0
			local lineup = ''
			local chess_5 = 0
			local chess_5_2star = 0
			for _,v in pairs(_G.mychess[team_i]) do
				if v ~= nil and v.chess ~= nil and lineup_count < hero:GetLevel() then 
					lineup = lineup..v.chess..','
					lineup_count = lineup_count + 1

					local cname = GetChessBaseName(v.chess)
					local ccost = _G.chess_2_mana[cname]
					if ccost == 5 then
						chess_5 = chess_5 + 1
						local chess_star = GetChessNameStar(v.chess) or 1
						if chess_star >= 2 then
							chess_5_2star = chess_5_2star + 1
						end
					end
				end
			end
			if _G.egg_quest == 'q029' and chess_5_2star >= 3 then
				SetQuest(team_i,true)
			end
			SetStat(hero:GetPlayerID(),'chess_lineup',lineup,true)

			local hands = ''
			if hero.hand_entities ~= nil then
				for _,ent in pairs(hero.hand_entities) do
					if ent ~= nil and ent:IsNull() == false then
						hands = hands..ent:GetUnitName()..','
					end
				end
			end
			SetStat(hero:GetPlayerID(),'chess_hand',hands,false)
		end
	end
end
--容错：检查有没有2P队友没一起死的，杀死他
function CheckP2Status()
	if _G.p2_mode == true then
		for i,v in pairs(_G.p2_player) do
			if table.maxn(v) > 0 and v[1] ~= nil and v[2] ~= nil and TeamId2Hero(v[1]) ~= nil and TeamId2Hero(v[2]) ~= nil then
				if TeamId2Hero(v[1]):IsAlive() == false and TeamId2Hero(v[2]):IsAlive() == true then
					--杀死v[2]
					local hh = TeamId2Hero(v[2])
					hh:ForceKill(false)
					_G.counterpart[hh:GetTeam()] = -1
					SyncHP(hh)

				end
				if TeamId2Hero(v[2]):IsAlive() == false and TeamId2Hero(v[1]):IsAlive() == true then
					--杀死v[1]
					local hh = TeamId2Hero(v[1])
					hh:ForceKill(false)
					_G.counterpart[hh:GetTeam()] = -1
					SyncHP(hh)
				end
			end
		end
	end
end
function CheckEndingStatus()
	local live_count = GetAlivePlayerCount()
	local last_steamid = _G.send_status[1]
	local last_hero = PlayerId2Hero(_G.steamid2playerid[last_steamid])
	if _G.playing_player_count > 1 then
		--1P
		if _G.p2_mode ~= true and live_count <= 1 and last_hero ~= nil then
			SetPlayerDead(last_hero)
		end
		--2P
		if _G.p2_mode == true and GetAlivePlayerCount() <= 2 then
			if last_hero ~= nil then
				SetPlayerDead(last_hero)
				if GetP2Ally(last_hero:GetTeam()) ~= nil and TeamId2Hero(GetP2Ally(last_hero:GetTeam())) ~= nil then
					local hh = TeamId2Hero(GetP2Ally(last_hero:GetTeam()))
					SetPlayerDead(hh)
				end
			end
		end
	end
end
function SuggestGG(keys)
	local caster = keys.caster
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_liuju",{
		key = GetClientKey(caster:GetTeam()),
		hehe = RandomInt(1,100000)
	})
	-- DAC:OnSuggestLiuju({
	-- 	PlayerID = caster:GetPlayerID(),
	-- 	player_id = caster:GetPlayerID(),
	-- })
end
function AddPickAndRemoveAbility(v)
	Timers:CreateTimer(1.5,function()
		if v:FindAbilityByName('pick_chess') == nil then
			AddAbilityAndSetLevel(v,'pick_chess')
		end
	   	if v:FindAbilityByName('recall_chess') == nil then
	   		AddAbilityAndSetLevel(v,'recall_chess')
	   	end
		if v:FindAbilityByName('remove_chess') == nil then
	    	AddAbilityAndSetLevel(v,'remove_chess')
	    end
		v:FindAbilityByName('pick_chess'):SetActivated(true)
		v:FindAbilityByName('recall_chess'):SetActivated(true)
	end)
	-- v:FindAbilityByName('remove_chess'):SetActivated(true)
end
function ShowDamageStatOfTeam(teamid)
	if _G.egg_quest == 'q016' then
		for i,v in pairs(_G.damage_stat[teamid]) do
			if v['total'] >= 10000 then
				SetQuest(teamid,true)
			end
		end
	end
	--显示伤害统计
	CustomGameEventManager:Send_ServerToTeam(teamid,"show_damage_stat",{
		key = GetClientKey(teamid),
		damage_table = _G.damage_stat[teamid],
		-- time_this_level = 51 - _G.battle_timer,
		hehe = RandomInt(1,100000)
	})
end
function GetAlivePlayerCount()
	return table.maxn(_G.send_status)
end
function SaveMaxObj(team,outcome)
	local inserttable = {}
	for _,insertchess in pairs(_G.mychess[team]) do
		table.insert(inserttable,{
			x = insertchess.x,
			y = insertchess.y,
			chess = insertchess.chess
		})
	end

	local against = TeamId2Hero(_G.counterpart[team])
	if against == nil then
		enemy = ''
	else
		enemy = against.steam_id
	end
	local maxobj = {
		owner = TeamId2Hero(team).steam_id,
		lineup = inserttable,
		round = _G.battle_round - 1,
		hp = TeamId2Hero(team):GetHealth(),
		against = enemy,
		outcome = outcome,
	}
	table.insert(_G.upload_detail_stat[TeamId2Hero(team).steam_id],maxobj)
end
--查户口
function CheckChess(team_id)
	local index_table = {}
	local dup_table = {}
	local chess_count = 0
	if TeamId2Hero(team_id) == nil then
		return
	end
	local hero_level = TeamId2Hero(team_id):GetLevel()
	for y_x,obj in pairs(_G.mychess[team_id]) do
		if FindValueInTable(index_table,obj.index) == true and string.find(obj.chess,'1') then
			--重复了
			table.insert(dup_table,y_x)
		else
			table.insert(index_table,obj.index)
			chess_count = chess_count + 1
		end
	end
	_G.population[team_id] = chess_count
	_G.population_max[team_id] = hero_level
	
	if table.maxn(dup_table) > 0 then
		for _,y_x in pairs(dup_table) do
			_G.mychess[team_id][y_x] = nil
		end
	end

	--同步ui人口
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = _G.population_max[team_id],
		count = _G.population[team_id],
	})
end
function InitChessListByLevel()
	for i,t in pairs(_G.chess_list_by_mana) do
		if i == 5 then
			t = _G.chess_list_by_mana_gold
		end
		for ii,vv in pairs(t) do
			--1星
			if _G.chess_list_by_level[i] == nil then
				_G.chess_list_by_level[i] = {}
			end
			table.insert(_G.chess_list_by_level[i],vv)
			--2星
			if _G.chess_list_by_level[i+2] == nil then
				_G.chess_list_by_level[i+2] = {}
			end
			table.insert(_G.chess_list_by_level[i+2],vv..'1')
			--3星（有特殊情况）
			if vv == 'chess_eh' or vv == 'chess_fur' or vv == 'chess_tp' or vv == 'chess_ld' or vv == 'chess_ts' or vv == 'chess_et' or vv == 'chess_meepo' or vv == 'chess_aw' then
				if _G.chess_list_by_level[i+3] == nil then
					_G.chess_list_by_level[i+3] = {}
				end
				table.insert(_G.chess_list_by_level[i+3],vv..'11')
			else
				if _G.chess_list_by_level[i+4] == nil then
					_G.chess_list_by_level[i+4] = {}
				end
				table.insert(_G.chess_list_by_level[i+4],vv..'11')
			end
		end
	end
end
function ShowTPEffectAtPosition(p,e)
	if e ~= nil then
		local ppp = ParticleManager:CreateParticle(e, PATTACH_WORLDORIGIN ,nil)
	    ParticleManager:SetParticleControl(ppp, 0, p)
	    ParticleManager:SetParticleControl(ppp, 1, p)
	    return ppp
	else
		return nil
	end
end

--棋子变身
function TransformAChess(u,new_chess_name,item_inherited,cb)
	if u.transforming == true then
		return
	end
	u.transforming = true
	if IsUnitExist(u) == false or IsHexxed(u) == true then
		return
	end
	u:Stop()
	FillEmptySlot(u)
	AddAbilityAndSetLevel(u,'jiaoxie')
	RemoveAbilityAndModifier(u,'jiaoxie_wudi')

	u:SetModelScale(0.5)
	local combo_ability_table = GetAllComboModifierAbilityByChess(u) or {}
	local hp_bouns_by_6_orc = u.hp_bouns_by_6_orc
	local track_money_count = u.track_money_count

	Timers:CreateTimer(0.1,function()
		if IsUnitExist(u) == true then
			local team_id = u:GetTeam()
			local chessboard_id = u.at_team_id or u.team_id
			local aposition = XY2Vector(u.x,u.y,chessboard_id) or u:GetAbsOrigin()

			local items = GetAllItemsAndCDInUnits({[1] = u})
			local hp_per = u:GetHealth()/u:GetMaxHealth()
			local knight_first_shield = u.knight_first_shield
			RemoveFromToBeDestroyList(u)
			if IsUnitExist(u) == true then
				if u:FindAbilityByName('dr_shooter_aura') ~= nil then
					RemoveDrShooterAura({
						caster = u,
						ability = u:FindAbilityByName('dr_shooter_aura'),
					})
				end

				local forward_vector = u:GetForwardVector()
				forward_vector.z = 0

				if u:GetTeam() ~= 4 then
					SaveItem(team_id,u:entindex(),function()
						u:SetModelScale(0.0001)
						if IsUnitExist(u) then
							AddAbilityAndSetLevel(u,'no_hp_bar')
							u.no_death_rattle = true
							u:ForceKill(false)
						end
					end)
				else
					u:SetModelScale(0.0001)
					if IsUnitExist(u) then
						AddAbilityAndSetLevel(u,'no_hp_bar')
						u.no_death_rattle = true
						u:ForceKill(false)
					end
				end

				if not item_inherited then
					items = {}
				end
				local x = SummonAChess(team_id,aposition,new_chess_name,chessboard_id,100,0,items,true,forward_vector)
				x.knight_first_shield = knight_first_shield
				x:SetHealth(x:GetMaxHealth()*hp_per)

				--继承combo技能
				for _,a in pairs(combo_ability_table) do
					AddAbilityAndSetLevel(x,a)
					if a == "is_orc_buff_plus_plus" and hp_bouns_by_6_orc ~= nil then
						ModMaxHP({
							caster = x,
							const = hp_bouns_by_6_orc
						})
						play_particle("effect/big.vpcf",PATTACH_ABSORIGIN_FOLLOW,x,2)
					end
				end
				if x:Script_GetAttackRange() <= 505 then
					RemoveAbilityAndModifier(x,'is_dwarf')
					RemoveAbilityAndModifier(x,'is_dwarf_buff_plus')
				end
				--继承点金手效果
				if track_money_count ~= nil then
					x.track_money_count = track_money_count
					SetTrackMoneyStack(x)
				end

				if cb then
					cb(x)
				end
			end
		end
	end)
end
--通用方法之添加技能
function AddAbilityAndSetLevel(u,a,l)
	if l == nil then
		l = 1
	end
	if u == nil or u:IsNull() == true then
		return
	end
	if u:FindAbilityByName(a) == nil then
		u:AddAbility(a)
		if u:FindAbilityByName(a) ~= nil then
			u:FindAbilityByName(a):SetLevel(l)
		end
	else
		u:FindAbilityByName(a):SetLevel(l)
	end
	return u:FindAbilityByName(a)
end
function RemoveAbilityAndModifier(u,a)
	if u == nil or u:IsNull() == true then
		return
	end
	if u:FindAbilityByName(a) ~= nil then
		u:RemoveAbility(a)
		u:RemoveModifierByName('modifier_'..a)
	end
end
function RemoveFromToBeDestroyList(u)
	if (u.at_team_id or u.team_id) ~= nil and _G.to_be_destory_list[(u.at_team_id or u.team_id)] ~= nil then
		for p,q in pairs(_G.to_be_destory_list[(u.at_team_id or u.team_id)]) do
			if u ~= nil and u:IsNull() == false and q ~= nil and q:IsNull() == false then
				if q:entindex() == u:entindex() then
					table.remove(_G.to_be_destory_list[(u.at_team_id or u.team_id)],p)
				end
			end
		end
	end
end
function GetValidChessOnBoard(at_team_id)
	local tt = {}
	if _G.to_be_destory_list[at_team_id] ~= nil then
		for p,q in pairs(_G.to_be_destory_list[at_team_id]) do
			if q ~= nil and q:IsNull() == false and q:IsAlive() == true then
				table.insert(tt,q)
			end
		end
	end
	return tt
end
function AttackHeal(keys)
	local target = keys.attacker
	local damage = keys.damage
	local per = keys.per
	target:Heal(damage*per, target)
end
function ModMaxHP(keys)
	local caster = keys.caster
	local is_heal = keys.is_heal or false
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		--信使无效，守卫无效
		return
	end

	if not caster.hp_basic then
		caster.hp_basic = caster:GetMaxHealth()
	end

	local per = tonumber(keys.per or 0)
	local const = tonumber(keys.const or 0)
	caster.hp_per = tonumber(caster.hp_per or 0) + per
	caster.hp_const = tonumber(caster.hp_const or 0) + const

	local hp_result_max = math.floor(caster.hp_basic*(100+caster.hp_per)/100 + caster.hp_const)

	if is_heal == true then
		local heal = hp_result_max - caster:GetMaxHealth()
		caster:SetBaseMaxHealth(hp_result_max)
		caster:SetMaxHealth(hp_result_max)

		caster:Heal(heal, caster)
	else
		local hp_per_now = caster:GetHealth()/caster:GetMaxHealth()
		caster:SetBaseMaxHealth(hp_result_max)
		caster:SetMaxHealth(hp_result_max)
		local hp_result = hp_result_max * hp_per_now
		caster:SetHealth(hp_result)
	end	
end
function AddMaxHPPer(keys)
	local caster = keys.caster
	local per = keys.per
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		return
	end

	local hp = caster:GetMaxHealth()
	local hp_final = hp * ((100 + tonumber(per))/100)
	local heal = hp*tonumber(per)/100
	caster:SetBaseMaxHealth(hp_final)
	caster:SetMaxHealth(hp_final)
	-- caster:SetHealth(hp*hp_per)
	caster:Heal(heal, caster)
end
function AddMaxHP(keys)
	local caster = keys.caster
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		return
	end
	local hp = keys.hp
	local hp1 = caster:GetMaxHealth()
	local hp_per = caster:GetHealth()/caster:GetMaxHealth()
	local hp1 = hp1 + tonumber(hp)
	caster:SetBaseMaxHealth(hp1)
	caster:SetMaxHealth(hp1)
	caster:SetHealth(hp1*hp_per)
end
function UnAddMaxHP(keys)
	local caster = keys.caster
	if caster:IsAncient() == true or caster:HasAbility('is_ward') then
		return
	end
	local hp = keys.hp
	local hp1 = caster:GetMaxHealth()
	local hp_per = caster:GetHealth()/caster:GetMaxHealth()
	local hp1 = hp1 - tonumber(hp)
	caster:SetBaseMaxHealth(hp1)
	caster:SetMaxHealth(hp1)
	caster:SetHealth(hp1*hp_per)
end
--辅助功能——创建隐藏单位施法
function InvisibleUnitCast(keys)
	local shiban = keys.caster
	local caster_position = keys.caster_position
	local shiban_ability = keys.ability
	local ability_level = keys.level
	local unluckydog = keys.unluckydog
	local position = keys.position
	local team = DOTA_TEAM_NEUTRALS
	if shiban ~= nil then
		team = shiban:GetTeam()
	end

	local uu = CreateUnitByName("invisible_unit", caster_position or shiban:GetAbsOrigin() ,false,nil,nil, team) 
	uu.ftd = 2009
	uu:SetOwner(shiban)
	uu.damage_owner = shiban
	uu.ignore_nether_ward = keys.ignore_nether_ward or false -- 获取是否无视啄木鸟图腾，默认为否
	uu.team_id = shiban.team_id
	uu.at_team_id = shiban.at_team_id

	uu:AddAbility(shiban_ability)
	uu:FindAbilityByName(shiban_ability):SetLevel(ability_level)

	if shiban:HasModifier('modifier_is_demon_buff_plus') then
		AddAbilityAndSetLevel(uu,'is_demon_buff_plus',1)
	end

	Add2InvisibleUnitTable(shiban,uu)
	Timers:CreateTimer(0.05,function()
		if keys.force_unluckydog then
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
		 		TargetIndex = keys.force_unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
			uu.cast_target = keys.force_unluckydog
		elseif uu:FindAbilityByName(shiban_ability):GetBehavior() == DOTA_ABILITY_BEHAVIOR_UNIT_TARGET and unluckydog ~= nil then
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
		 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
			uu.cast_target = unluckydog
		elseif uu:FindAbilityByName(shiban_ability):GetBehavior() == DOTA_ABILITY_BEHAVIOR_NO_TARGET then
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
		 		TargetIndex = unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
		else
			local newOrder = {
		 		UnitIndex = uu:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
		 		TargetIndex = nil, --Optional.  Only used when targeting units
		 		AbilityIndex = uu:FindAbilityByName(shiban_ability):entindex(), --Optional.  Only used when casting abilities
		 		Position = position, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	}
			ExecuteOrderFromTable(newOrder)
		end
		Timers:CreateTimer(10,function()
			if IsUnitExist(uu) == true then -- 销毁隐藏单位前做一个判断，避免一些报错
				uu:ForceKill(false)
				uu:Destroy()
			end
		end)
	end)

	-- 如果是复制缚魂施法，则添加对主施法者和主目标的状态监听
	-- 之前这一块被放在上一个 Timer 之中，似乎有一些问题，现在就挪出来了
	if IsUnitExist(keys.origin_unluckydog) == true then 
		Timers:CreateTimer(0.5,function()
			if IsUnitExist(keys.origin_unluckydog) == true then 
				-- 针对持续施法技能。监听主人的状态，如果异常了，就中断
				if IsUnitExist(uu) == false then
					return
				end
				-- 判断主施法者是否存在、主施法者是否能够施法、主目标是否存活。若任意为否则终止终止隐藏单位施法。
				if IsUnitExist(shiban) == false or IsUnitAbleToCast(shiban) == false or keys.origin_unluckydog:IsAlive() == false then
					uu:Stop()
					uu:ForceKill(false)
					-- uu:Destroy() -- 之前的代码中有 Destroy。经测试，如果紧跟 Destroy，会造成视觉特效消失但实际控制效果仍在的问题。这里先注释掉了。
					return
				end
				return 0.5
			end
		end)
	end
end
function Add2InvisibleUnitTable(u,i)
	if IsUnitExist(u) == false then
		return
	end
	if u.invisible_unit == nil then
		u.invisible_unit = {}
	end
	table.insert(u.invisible_unit, i)
end
function RemoveInvisibleUnitTable(u)
	if IsUnitExist(u) == false then
		return
	end
	if u.invisible_unit == nil then
		return
	end
	for _,v in pairs(u.invisible_unit) do
		if IsUnitExist(v) == true then
			v:Stop()
			v:ForceKill(false)
			v:Destroy()
		end
	end
	u.invisible_unit = {}
end
function PlayerId2Hero(id)
	return _G.playerid2hero[id]
end
function TeamId2Hero(id)
	if id == nil then
		return nil
	else
		return _G.teamid2hero[id]
	end
end
function GetMaxChessCount(team)
	if TeamId2Hero(team) ~= nil then
		return TeamId2Hero(team):GetLevel()
	else
		return 1
	end
end
function GetStat(id,prop)
	local hero =  PlayerId2Hero(id)
	if hero == nil or hero.steam_id == nil then
		return nil
	end
	return _G.stat_info[hero.steam_id][prop]
end
function SetStat(id,prop,v,need_update_ui)
	if id == nil then 
		return
	end
	local hero =  PlayerId2Hero(id)
	if hero == nil or hero.steam_id == nil then
		return
	end
	_G.stat_info[hero.steam_id][prop] = v
	if need_update_ui ~= false then
		UpdateStatUI()
	end
end
function AddStat(id,prop,amount)
	local hero =  PlayerId2Hero(id)
	if hero == nil or hero.steam_id == nil then
		return
	end
	if amount == nil then
		amount = 1
	end
	_G.stat_info[hero.steam_id][prop] = _G.stat_info[hero.steam_id][prop] + amount
	if prop == 'hero_damage' then
		PlayerResource:IncrementLastHits(id,1)
	end
	if prop == 'hero_damaged' then
		PlayerResource:IncrementDenies(id,1)
	end

	if prop == 'win_round' then
		PlayerResource:IncrementKills(id,1)
	end
	if prop == 'lose_round' then
		PlayerResource:IncrementDeaths(id,1)
	end
	if prop == 'draw_round' then
		PlayerResource:IncrementAssists(id,1)
	end

	UpdateStatUI()
end
function play_particle(p, pos, u, d)
	-- if u == nil then
	-- 	return
	-- end
	local pp = ParticleManager:CreateParticle(p, pos, u)
	-- Timers:CreateTimer(function()
	-- 	if u:IsNull() ~= false or u:IsAlive() ~= false then
	-- 		ParticleManager:DestroyParticle(pp,true)
	-- 		return
	-- 	end
	-- 	return 1
	-- end)
	if d then
		Timers:CreateTimer(d,function()
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
		end)
	end
	return pp
end
function play_particle_controlIndex(p, pos, u, d, controlIndex)
	local pp = ParticleManager:CreateParticle(p, pos, u)
	ParticleManager:SetParticleControl(pp,1,u:GetAbsOrigin())

	Timers:CreateTimer(d,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)
end
function PlayParticleOnUnitUntilDeath(keys)
	local p = keys.p
	local u = keys.caster
	if u == nil then
		return
	end
	local pos = keys.pos or PATTACH_ABSORIGIN_FOLLOW
	local pp = ParticleManager:CreateParticle(p, pos, u)
	ParticleManager:SetParticleControlEnt( pp, 0, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 2, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 3, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 4, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 5, u, pos, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 6, u, pos, nil, u:GetOrigin(), true );

	Timers:CreateTimer(0.3,function()
		if u == nil or u:IsNull() == true or u:IsAlive() == false then
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
			return
		end
		if pp == nil then
			return
		end
		return 0.3
	end)

	return pp
end
function FindUnitsInRadiusOnTeamGround(keys)
	local team = keys.team
	local at_team = keys.at_team
	local role = keys.role or 1 --1=队友,2=敌人,3=全部
	local radius = keys.radius or 9999
	local position = keys.position or Vector(0,0,0)
	local units = {}

	for i,v in pairs(GetValidChessOnBoard(at_team)) do
		if IsUnitExist(v) == true and (v:GetAbsOrigin() - position):Length2D() <= radius then
			if role == 1 and v:GetTeam() == team then
				table.insert(units,v)
			end
			if role == 2 and v:GetTeam() ~= team then
				table.insert(units,v)
			end
			if role == 3 then
				table.insert(units,v)
			end
		end
	end

	return units
end
--高级选取单位，适应所有team
function FindUnitsInRadiusByTeam(keys)
	local team = keys.team
	local role = keys.role or 1 --1=队友,2=敌人,3=全部
	local radius = keys.radius or 500
	local position = keys.position or Vector(0,0,0)
	local units = {}

	local all_units = FindUnitsInRadius(
		DOTA_TEAM_BADGUYS,
		Vector(0,0,0),
		nil,
		9999,
		DOTA_UNIT_TARGET_TEAM_BOTH,  --用BOTH可以选到所有team的单位
		DOTA_UNIT_TARGET_ALL,
		DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES,
		FIND_ANY_ORDER,
		false)

	for u,v in pairs(all_units) do
		if (v:GetAbsOrigin() - position):Length2D() <= radius then
			if role == 1 and v:GetTeam() == team then
				table.insert(units,v)
			end
			if role == 2 and v:GetTeam() ~= team then
				table.insert(units,v)
			end
			if role == 3 then
				table.insert(units,v)
			end
		end
	end

	return units
end
function ApplyDamageInRadius(keys)
	local caster = keys.caster
	local team = keys.team
	local role = keys.role or 2
	local position = keys.position
	local damage = keys.damage or 1
	local damage_per = keys.damage_per
	local radius = keys.radius or 500
	local damage_type = keys.damage_type or DAMAGE_TYPE_MAGICAL
	local delay = keys.delay or 0
	local stun_duration = keys.stun_duration or 0
	local stun_partical = keys.stun_partical
	local knockback = keys.knockback or false

	Timers:CreateTimer(delay,function()
		local unlucky_dogs = FindUnitsInRadiusByTeam({
			team = team,
			role = role,
			position = position,
			radius = radius,
		})
		for _,u in pairs(unlucky_dogs) do
			if u ~= nil and u:IsNull() == false and u:IsAlive() == true then
				if damage_per ~= nil and damage_per > 0 then
					local max_hp = u:GetMaxHealth()
					damage = max_hp / 100 * damage_per
				end

				ApplyDamage({
					victim = u,
					attacker = caster,
					damage_type = damage_type,
					damage = damage,
					ability = keys.ability_entity or caster:FindAbilityByName(keys.ability)
				})
				if stun_duration > 0 then
					u:AddNewModifier(u,nil,"modifier_stunned",{ duration = stun_duration })
				end

				if stun_partical ~= nil then
					play_particle(stun_partical,PATTACH_ABSORIGIN_FOLLOW,u,3)
				end
				if knockback == true then
					HunterKnockBack({
						caster = caster,
						target = u,
					})
				end
			end
		end 
	end)
end
function AddModifierInRadius(keys)
	local caster = keys.caster
	local team = caster:GetTeam()
	local role = keys.role or 2
	local radius = keys.radius or 500
	local modifier = keys.modifier
	local ability = keys.ability
	local unlucky_dogs = FindUnitsInRadiusByTeam({
		team = team,
		role = role,
		position = caster:GetAbsOrigin(),
		radius = radius,
	})
	for _,u in pairs(unlucky_dogs) do
		if u ~= nil and u:IsNull() == false and u:IsAlive() == true then
			u:AddNewModifier(caster,keys.ability,modifier,nil)
		end
	end
end
function ChangeModelScale(keys)
	local u = keys.caster
	local x = keys.x
	local s = u:GetModelScale()
	-- u:SetModelScale(s*x)
	if not u:HasAbility('is_ward') then
		AddModelScalePlus(u, s*x)
		if keys.effect then
			play_particle("effect/big.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,2)
		end
	end
end
function ChessAddMana(chess,mana)
	chess:SetMana(chess:GetMana()+mana)
	if chess.tether_target ~= nil and IsUnitExist(chess.tether_target) and chess.tether_target:FindModifierByName('modifier_wisp_tether_haste') ~= nil then

		local mana_add = 0
		if chess.tether_target:FindModifierByName('modifier_wisp_tether_haste'):GetAbility():GetLevel() == 1 then
			mana_add = mana*2.5
		elseif chess.tether_target:FindModifierByName('modifier_wisp_tether_haste'):GetAbility():GetLevel() == 2 then
			mana_add = mana*5
		end
		Timers:CreateTimer(0.2,function()
			if mana_add > 0 and chess.tether_target ~= nil and chess.tether_target:IsNull() == false then
				chess.tether_target:SetMana(chess.tether_target:GetMana()+mana_add)
				if mana_add >= 40 then
					AMHC:CreateNumberEffect(chess.tether_target,mana_add,2,AMHC.MSG_MISS,{128,128,255},0)
				end
			end
		end)
	end
end
function show_damage(keys)
	local caster = keys.caster
	local attacker = keys.attacker
	local damage = math.floor(keys.DamageTaken)

	if attacker ~= nil then
		attacker = attacker.damage_owner or attacker
	end

	if damage <= 0 then
		return
	end

	if attacker ~= nil and attacker:IsNull() == false and attacker:IsHero() == true then
		return
	end

	--回蓝（法力获取）

	--受到伤害回蓝
	if IsUnitExist(attacker) == true then
		local mana_get = damage/5
		if mana_get > 20 then
			mana_get = 20
		end
		if caster:HasAbility('is_warrior') then
			mana_get = mana_get *1.5
		end
		local mana_amp = AmplifyMPRecharge(caster)
		mana_get = math.floor(mana_get * (100+mana_amp) / 100)
		--恶魔猎手使敌方恶魔的邪能之力伤害不回蓝
		local dh_friend = 0
		local dh_enemy = 0
		for _,unit in pairs(GetValidChessOnBoard(attacker.at_team_id or attacker.team_id)) do
			if IsUnitExist(unit) and unit.team_id == attacker.team_id and unit:HasAbility('is_demonhunter') then
				dh_friend = dh_friend + 1
			end
			if IsUnitExist(unit) and unit.team_id ~= attacker.team_id and unit:HasAbility('is_demonhunter') then
				dh_enemy = dh_enemy + 1
			end
		end
		if attacker:HasModifier('modifier_is_demon_buff') and (dh_friend>=2 or dh_enemy>=1) then
			mana_get = 0
		end
		if attacker:HasAbility('antimage_mana_break') == true then
			mana_get = 0
		end
		
		if mana_get > 0 then
			ChessAddMana(caster,mana_get)
		end
	end

	--造成伤害回蓝
	if IsUnitExist(attacker) == true then
		mana_get = damage/10
		if mana_get > 20 then
			mana_get = 20
		end
		local mana_amp = AmplifyMPRecharge(attacker)

		mana_get = math.floor(mana_get * (100+mana_amp) / 100)
		
		ChessAddMana(attacker,mana_get)
	end

	--术士吸血
	if IsUnitExist(attacker) == true and keys.ability ~= 'is_monk_buff' then
		if attacker:FindModifierByName("modifier_is_warlock_buff") ~= nil then
			AttackHeal({
				attacker = attacker,
				damage = damage,
				per = 0.05,
			})
			play_particle("particles/generic_gameplay/generic_lifesteal.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,2)
		end
		if attacker:FindModifierByName("modifier_is_warlock_buff_plus") ~= nil then
			AttackHeal({
				attacker = attacker,
				damage = damage,
				per = 0.3,
			})
		end
	end

	--蜘蛛网普攻吸血
	if IsUnitExist(attacker) == true and caster:HasModifier('modifier_br_web_debuff') and (attacker:HasAbility('br_web') or attacker:GetUnitName() == 'br_spider1' or attacker:GetUnitName() == 'br_spider2' or attacker:GetUnitName() == 'br_spider3') then
		AttackHeal({
			attacker = attacker,
			damage = damage,
			per = 0.4,
		})
		play_particle("particles/generic_gameplay/generic_lifesteal.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,2)
	end

	--新武僧，duang
	if IsUnitExist(attacker) and attacker:HasModifier("modifier_is_monk_buff") and keys.ability ~= 'is_monk_buff' then
		Timers:CreateTimer(0.3,function()
			if IsUnitExist(caster) == true then
				local v_hp = caster:GetHealth()
				local v_max_hp = caster:GetMaxHealth()
				local v_hp_per = 1.0 * v_hp / v_max_hp
				local duang_check_prob = 0
				if math.tan(v_hp_per*3) > 0 and v_hp_per < 0.5 then
					duang_check_prob = math.pow(1/math.tan(v_hp_per*3.1),1/3)*(-math.log(v_hp_per))/20
				end
				if RandomFloat(0,1) <= duang_check_prob then
				    play_particle("effect/monk_duang/1positions.vpcf",PATTACH_OVERHEAD_FOLLOW,caster,2)
				    EmitSoundOn("monk.duang",caster)
					caster.killer = attacker
				    caster:ForceKill(false)
				end 
			end
		end)
	end
	if IsUnitExist(attacker) and attacker:HasModifier("modifier_is_monk_buff_plus") and keys.ability ~= 'is_monk_buff_plus' then
		Timers:CreateTimer(0.3,function()
			if IsUnitExist(caster) == true then
				local monk_hp = caster:GetHealth()
				if RandomFloat(0,1) <= 0.1 then
				    play_particle("effect/monk_duang/2positions.vpcf",PATTACH_OVERHEAD_FOLLOW,caster,2)
				    EmitSoundOn("monk.duang2",caster)
				    caster:SetHealth(monk_hp*0.5)
				end 
			end
		end)
	end
	
	if caster ~= nil then
		caster.last_damage_ability = keys.ability
	end
end
function ExpBook(keys)
    local caster = keys.caster
    if caster == nil then
    	return
    end
    local team_id = caster:GetTeam()
    local xpnow = caster:GetCurrentXP()
    local xpadd = keys.xpadd or 4
    local disable_quick_lvl_up = keys.disable_quick_lvl_up

    if disable_quick_lvl_up == true then
    	caster.quick_lvl_up = false
    end

    local xpnextlvl = _G.HeroExpTable[caster:GetLevel() + 1]
    local next_lvl_cost = math.ceil((xpnextlvl - xpnow) / 4) * 4

    local cost = keys.cost or 4
    -- 判断是否满足直接升级的条件
    if caster.quick_lvl_up == true and xpnextlvl - xpnow > 4 and caster:GetMana() >= next_lvl_cost - 4 then
        xpadd = next_lvl_cost
        cost = next_lvl_cost - 4
        caster:ReduceMana(cost)
        caster:FindAbilityByName("exp_book"):StartCooldown(2)
    end
    -- 超过10级时去掉经验值零头
    if xpadd + xpnow > _G.HeroExpTable[10] then
        xpadd = _G.HeroExpTable[10] - xpnow
    end
    if xpadd < 0 then
        xpadd = 0
    end
    -- 添加经验值，达到10级则禁用经验按钮
    caster:AddExperience (xpadd,0,false,false)
    if caster:GetLevel() >= 10 then
        caster:FindAbilityByName('exp_book'):SetActivated(false)
    end
    -- 显示特效
    if cost > 0 then
	    if xpadd > 4 then
	    	play_particle_controlIndex("particles/econ/items/keeper_of_the_light/kotl_ti10_immortal/kotl_ti10_blinding_light.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster.ai_pet or caster,3,1)
	    	EmitSoundOn("quick_lvl_up",caster)
	    else
	    	AMHC:CreateParticle("particles/units/heroes/hero_oracle/oracle_false_promise_cast_enemy.vpcf",PATTACH_ABSORIGIN_FOLLOW,false,caster.ai_pet or caster,3)
	    	EmitSoundOn("lvl_up",caster)
	    end
	    AMHC:CreateNumberEffect(caster.ai_pet or caster,cost,3,AMHC.MSG_MISS,{80,80,255},3)
	end
    Timers:CreateTimer(0.5,function()
        AMHC:CreateNumberEffect(caster.ai_pet or caster,xpadd,3,AMHC.MSG_MISS,{255,255,128},0)
    end)
    -- 添加快速升级标签
    caster.quick_lvl_up = true
    Timers:CreateTimer(0.18,function()
        caster.quick_lvl_up = false
    end)
    -- 同步UI
    CustomGameEventManager:Send_ServerToTeam(team_id,"show_gold",{
        key = GetClientKey(team_id),
        gold = caster:GetMana(),
        lose_streak = caster.lose_streak or 0,
        win_streak = caster.win_streak or 0,
    })
    CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
        player_id = caster:GetPlayerID(),
        hp = caster:GetHealth(),
        hp_max = caster:GetMaxHealth(),
        mp = caster:GetMana(),
        level = caster:GetLevel(),
        win_streak = caster.win_streak,
		unit_index = caster:entindex(),
		courier_id = caster.onduty_hero,
    })
end
function AddMana(unit, mana, show_number_unit)
	if mana == nil or mana <= 0 then
		return
	end

	local mana_result = math.floor(unit:GetMana()+mana+0.5)
	if mana_result < 0 then
		mana_result = 0
	end
	if mana_result > 100 then
		mana_result = 100
	end
	if mana_result >= 100 and _G.egg_quest == 'q007' then
		SetQuest(unit:GetTeam(),true)
	end
	if mana_result > 20 and _G.egg_quest == 'q008' then
		SetQuest(unit:GetTeam(),false)
	end
	unit:SetMana(mana_result)
	
	if mana >= 10 then
		EmitSoundOn("General.CoinsBig",unit)
	else
		EmitSoundOn("General.Coins",unit)
	end

	local show_u = show_number_unit or unit
	AMHC:CreateNumberEffect(show_u,mana,3,AMHC.MSG_MISS,{255,255,0},0)
	AMHC:CreateParticle("particles/generic_gameplay/rune_bounty_owner.vpcf",PATTACH_OVERHEAD_FOLLOW,false,show_u,5)

	CustomGameEventManager:Send_ServerToTeam(unit:GetTeam(),"show_gold",{
		key = GetClientKey(unit:GetTeam()),
		gold = mana_result,
		lose_streak = unit.lose_streak or 0,
		win_streak = unit.win_streak or 0,
	})
	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = unit:GetPlayerID(),
		hp = unit:GetHealth(),
		hp_max = unit:GetMaxHealth(),
		mp = unit:GetMana(),
		level = unit:GetLevel(),
		win_streak = unit.win_streak,
		unit_index = unit:entindex(),
		courier_id = unit.onduty_hero,
	})
end
function CostMana(unit, mana)
	if mana == nil or mana <= 0 then
		return
	end
	unit:SetMana(unit:GetMana()-mana)
	if AMHC ~= nil then AMHC:CreateNumberEffect(unit.ai_pet or unit,mana,3,AMHC.MSG_MISS,{80,80,255},3) end
	
	CustomGameEventManager:Send_ServerToTeam(unit:GetTeam(),"show_gold",{
		key = GetClientKey(unit:GetTeam()),
		gold = unit:GetMana(),
		lose_streak = unit.lose_streak or 0,
		win_streak = unit.win_streak or 0,
	})
	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = unit:GetPlayerID(),
		hp = unit:GetHealth(),
		hp_max = unit:GetMaxHealth(),
		mp = unit:GetMana(),
		level = unit:GetLevel(),
		win_streak = unit.win_streak,
		unit_index = unit:entindex(),
		courier_id = unit.onduty_hero,
	})
end
function AddModelScalePlus(unit, scale)
	local curr_scale = unit:GetModelScale()
	local step = (scale - curr_scale)/5
	unit.target_scale = scale
	Timers:CreateTimer(0.01,function()
		if not IsUnitExist(unit) then
			return
		end
		if unit.target_scale ~= scale then
			return
		end
		curr_scale = unit:GetModelScale()
		if math.abs(curr_scale - unit.target_scale) <= math.abs(step) then
			unit:SetModelScale(unit.target_scale)
			return
		else
			unit:SetModelScale(curr_scale+step)
			return 0.1
		end
	end)
end
function PlayChessDialogue(unit,dialogue)
	if unit == nil or unit:IsNull() == true or unit:IsAlive() == false then
		return
	end
	if unit:IsHero() then
		return
	end
	play_particle("particles/speechbubbles/speech_voice.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,3)
	CustomGameEventManager:Send_ServerToTeam(unit:GetTeam(),"play_chess_dialogue",{
		unit_index = unit:GetEntityIndex(),
		unit_name = unit:GetUnitName(),
		dialogue_type = dialogue, --spawn/win/merge
	})
end
function PlayPetDialogue(unit, is_win, language)
	if unit == nil or unit:IsNull() == true or unit:IsAlive() == false then
		return
	end
	local pet_name = unit.pet_name
	local r = 'chat'
	if is_win == true then
		r = 'win'
	end
	if language == 'schinese' or language == 'tchinese' then
		language = 'schinese'
	else
		language = 'english'
	end 
	play_particle("particles/speechbubbles/speech_voice.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,3)
	EmitSoundOn("pet."..pet_name.."."..r.."."..language,unit)
end
function GetKillModifierAndDuration(unit)
	local kill_modifier = nil
	local kill_time = nil
	if unit:HasModifier('modifier_skeleton_king_reincarnation_scepter_active') then
		kill_modifier = 'modifier_skeleton_king_reincarnation_scepter_active'
	end
	if unit:HasModifier('modifier_kill') then
		kill_modifier = 'modifier_kill'
	end
	if unit:HasModifier('modifier_illusion') then
		kill_modifier = 'modifier_illusion'
	end
	if kill_modifier ~= nil then
		kill_time = unit:FindModifierByName(kill_modifier):GetRemainingTime()
	end
	return kill_modifier,kill_time
end
function FindTauntEnemy(unit)
	local taunt_table = {}
	if (unit.at_team_id or unit.team_id) == nil or _G.to_be_destory_list[unit.at_team_id or unit.team_id] == nil then
		return taunt_table
	end
	for _,u in pairs(GetValidChessOnBoard(unit.at_team_id or unit.team_id)) do
		if IsUnitExist(u) == true and (unit:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() <= u:Script_GetAttackRange() and unit:GetTeam() ~= u:GetTeam() then
			table.insert(taunt_table,u)
		end
	end
	return taunt_table
end
function TauntEnemy(keys)
	local caster = keys.caster
	local unlucky_dogs = FindTauntEnemy(caster)

	for _,u in pairs(unlucky_dogs) do 
		if u:IsChanneling() == false and u:HasModifier('modifier_is_nraqi_buff') == false then
			ExecuteOrderFromTable({
		 		UnitIndex = u:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
		 		TargetIndex = caster:entindex(), 
		 		Queue = 0
		 	})
		 	Taunt(u,caster)
		end
	end
end
function Taunt(u,caster)
	if u.taunt_particle ~= nil then
		ParticleManager:DestroyParticle(u.taunt_particle,true)
	end

	u.taunt_particle = ParticleManager:CreateParticle('effect/taunt_debuff/1.vpcf', PATTACH_OVERHEAD_FOLLOW, u)
	u.taunt_target = caster
	local newOrder = {
		UnitIndex = u:entindex(), 
		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
		TargetIndex = u.taunt_target:entindex(), 
		Queue = 0 
	}
   	ExecuteOrderFromTable(newOrder)

	Timers:CreateTimer(0.5,function()
		if IsUnitExist(u.taunt_target) == false or IsUnitExist(u) == false then
			--caster或者u死亡，嘲讽终止
			if u.taunt_particle ~= nil then
				ParticleManager:DestroyParticle(u.taunt_particle,true)
			end
			u.taunt_particle = nil
			u.taunt_target = nil
			return
		end
		if (u.taunt_target:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() > u:Script_GetAttackRange() then
			--超出距离，嘲讽终止
			if u.taunt_particle ~= nil then
				ParticleManager:DestroyParticle(u.taunt_particle,true)
			end
			u.taunt_particle = nil
			u.taunt_target = nil
			return
		end
		return 0.5
	end)
end
function HealAlly(keys)
	local caster = keys.caster
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	for _,unit in pairs(GetValidChessOnBoard(at_team_id)) do
		if unit.team_id == team_id and unit:HasAbility('is_ward') == false then
			local hp_base = unit:GetMaxHealth()
			unit:Heal(math.ceil(hp_base/25),unit)
		end
	end
end
function SummonOneMinion(caster, minion, p, chessai)
	local summon_chess_duarion_table = {
		bm_beast1 = 30,
		bm_beast2 = 30,
		bm_beast3 = 30,
		ss_ssr_ward = 20,
		lyc_wolf1 = 30,
		lyc_wolf2 = 30,
		lyc_wolf3 = 30,
		veno_ward1 = 20,
		veno_ward2 = 20,
		veno_ward3 = 15,
		invoker_spirit1 = 40,
		invoker_spirit2 = 40,
		invoker_spirit3 = 40,
		fur_tree1 = 30,
		fur_tree2 = 20,
		fur_tree3 = 20,
		ld_bear1 = 40,
		ld_bear2 = 40,
		ld_bear3 = 40,
		minglingshu = 20,
		br_spider1 = 30,
		br_spider2 = 30,
		br_spider3 = 40,
		wl_golem = 10,
		visage_dragon_1 = 40,
		visage_dragon_2 = 40,
		visage_dragon_3 = 30,
		disarm_ward = 40,
		taunt_ward = 40,
		nether_ward = 40,
		necro_archer = 4,
		necro_warrior = 4,
	}
	if caster == nil then
		return
	end
	if chessai == nil then
		chessai = true
	end

	if p == 'random' then
		p = FindUnluckyPoint(caster)
	end

	local v = p or FindEmptyGridAtUnit(caster)
	local teamid = caster.team_id
	local at_teamid = caster.at_team_id or caster.team_id

	if IsEmptyGrid(at_teamid,Vector2X(v,at_teamid),Vector2Y(v,at_teamid)) ~= true then
		v = FindEmptyGridAtPosition(at_teamid,v)
	end

	if v == nil then
		return
	end
	if teamid == nil then
		return
	end
	if at_teamid == nil then
		return
	end

	--判断英雄是否还活着
	local hero1 = TeamId2Hero(at_teamid)
	if hero1 == nil or hero1:IsNull() or hero1:IsAlive() == false then
		return
	end

	if _G.battle_timer <= 1 then
		return
	end
	
	local x = CreateUnitByName(minion,v,true,nil,nil,teamid)
	x.is_summoned = true

	table.insert(_G.to_be_destory_list[at_teamid],x)
	x:SetForwardVector(caster:GetForwardVector() or Vector(0,1,0))
	AddAbilityAndSetLevel(x,'root_self')
	AddAbilityAndSetLevel(x,'jiaoxie_wudi')
	x.x = Vector2X(v,at_teamid)
	x.y = Vector2Y(v,at_teamid)
	x.y_x = ''..x.y..'_'..x.x
	if caster.at_team_id ~= nil then
		x.at_team_id = caster.at_team_id
	end
	if caster.team_id ~= nil then
		x.team_id = caster.team_id
	end
	_G.unit[at_teamid][x.y..'_'..x.x] = 1
	if chessai == true then
		Timers:CreateTimer(function()
			if x == nil or x:IsNull() == true or x:IsAlive() == false or x.alreadywon == true then
				return
			end
			ChessAI(x)
			return 1
		end)
	end

	--有持续时间的召唤物
	if summon_chess_duarion_table[minion] ~= nil then
		local duration = summon_chess_duarion_table[minion]
		if minion == 'wl_golem' then
			duration = RandomInt(5,10)
		end
		if minion == 'necro_archer' or minion == 'necro_warrior' then
			local level = caster:GetLevel()
			if level > 9 then
				level = 9
			end
			duration = level * 4
		end
		if caster:FindModifierByName('modifier_item_zhaohuanshenshi') ~= nil or caster:FindModifierByName('modifier_item_minglingshu') ~= nil then
			duration = duration * 1.5
		end
		x:AddNewModifier(x,nil,"modifier_kill",{duration = duration})
	end

	--动态设置死灵战士/死灵法师的血量、技能等
	if minion == 'necro_warrior' then
		local level = caster:GetLevel()
		if level > 9 then 
			level = 9
		end
		if x:FindAbilityByName('necronomicon_warrior_last_will') ~= nil then 
			x:FindAbilityByName('necronomicon_warrior_last_will'):SetLevel(level)
		end
		local hp = 120+90*level
		x:SetBaseMaxHealth(hp)
		x:SetMaxHealth(hp)
		x:SetHealth(hp)

		x:SetModelScale(0.25+0.03*level)
	end
	if minion == 'necro_archer' then
		local level = caster:GetLevel()
		if level > 9 then 
			level = 9
		end
		if x:FindAbilityByName('necronomicon_warrior_mana_burn') ~= nil then 
			x:FindAbilityByName('necronomicon_warrior_mana_burn'):SetLevel(level)
		end
		local hp = 80+60*level
		x:SetBaseMaxHealth(hp)
		x:SetMaxHealth(hp)
		x:SetHealth(hp)

		x:SetModelScale(0.25+0.03*level)
	end

	return x
end
function AddLoseStreak(team)
	local hero = _G.teamid2hero[team]
	if hero.lose_streak == nil then
		hero.lose_streak = 0
	end
	hero.lose_streak = hero.lose_streak + 1
end
function RemoveLoseStreak(team)
	local hero = _G.teamid2hero[team]
	if hero.lose_streak ~= nil and hero.lose_streak > 4 and hero:HasModifier('modifier_item_streak_plus') then
		--明暗终途
		local position_to = CenterVector(team) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
		local drop_money = hero.lose_streak or 1
		DropMoneyBag(Vector(0,0,128), position_to, 100, drop_money)
		ShowCombat({
			t = 'item_get_money',
			player = TeamId2Hero(team):GetPlayerID(),
			item = 'item_streak_plus',
			num = drop_money,
		})
	end
	hero.lose_streak = 0
end
function AddWinStreak(team)
	local hero = _G.teamid2hero[team]
	if hero.win_streak == nil then
		hero.win_streak = 0
	end
	hero.win_streak = hero.win_streak + 1

	--连胜膨胀
	local sca = (hero.init_model_scale or 1)+hero.win_streak*0.05
	if sca >= (hero.init_model_scale or 1) + 0.5 then
		sca = (hero.init_model_scale or 1) + 0.5
		--起飞！
		if _G.egg_quest == 'q012' then
			SetQuest(hero.team_id,true)
		end
		play_particle("particles/units/heroes/hero_shadowshaman/shadowshaman_voodoo.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,3)
		local new_m = ChangeFlyingCourierModel(hero.ori_model)
		hero:SetOriginalModel(new_m)
		hero:SetModel(new_m)
		MakeGreevil(hero,true)
		AddAbilityAndSetLevel(hero,'courier_fly')

		ShowCourierEffect(hero,2)

		if _G.sm_hero_flyup_size[hero.courier_name] then
			sca = sca * (_G.sm_hero_flyup_size[hero.courier_name] or 1)
		end
	end
	hero:SetModelScale(sca)
	if hero.win_streak == 5 or hero.win_streak == 8 or hero.win_streak == 10 then
		for i=6,13 do
			CustomGameEventManager:Send_ServerToTeam(i,"win_streak",{
				key = GetClientKey(i),
				player_id = hero:GetPlayerID(),
				streak = hero.win_streak,
				is_vip = hero.is_vip,
			})
		end
		if hero.is_crown == true then
			ShowCrown(hero,2)
		end
	end

	--同步ui血量
	SyncHP(hero)	
end
function RemoveWinStreak(team, attacker_team)

	local hero = _G.teamid2hero[team]
	local ws = hero.win_streak
	local money = ws or 0
	if hero.win_streak ~= nil and hero.win_streak >= 5 and TeamId2Hero(attacker_team) and TeamId2Hero(attacker_team):HasModifier('modifier_item_more_reward') then
		--获得收割者经验
		ExpBook({
			caster = TeamId2Hero(attacker_team),
			xpadd = money * 2,
			disable_quick_lvl_up = true,
			cost = 0,
		})
		--在客场信使上显示特效
		if TeamId2Hero(attacker_team).my_away_mirror_chesser ~= nil then
			AMHC:CreateNumberEffect(TeamId2Hero(attacker_team).my_away_mirror_chesser,money * 2,7,AMHC.MSG_MISS,{255,255,128},0)
		end
	end

	if hero ~= nil and hero.win_streak ~= nil and hero.win_streak >= 5 then
		--扎破
		if attacker_team ~= nil and attacker_team ~= team then
			local attacker = TeamId2Hero(attacker_team)
			if _G.egg_quest == 'q021' then
				SetQuest(attacker_team,true)
			end
			local position_to = CenterVector(attacker_team) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
			DropMoneyBag(Vector(0,0,128), position_to, 100, ( money or 1 ))

			--扎破者获得奖励
			ShowCombat({
				t = 'terminate',
				player = hero:GetPlayerID(),
				player2 = attacker:GetPlayerID(),
				num = ws,
			})
		end


		EmitSoundOn("DOTA_Item.AbyssalBlade.Activate",hero)
		play_particle("particles/items_fx/abyssal_blade_jugger.vpcf",PATTACH_OVERHEAD_FOLLOW,hero,3)

		hero:SetOriginalModel(hero.ori_model)
		hero:SetModel(hero.ori_model)
		MakeGreevil(hero,false)
		RemoveAbilityAndModifier(hero,'courier_fly')

		ShowCourierEffect(hero,1)
		if hero.is_crown == true then
			ShowCrown(hero,1)
		end
	end

	if hero.win_streak ~= nil and hero.win_streak > 4 and hero:HasModifier('modifier_item_streak_plus') then
		--明暗终途
		local position_to = CenterVector(team) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
		local drop_money = hero.win_streak or 1
		DropMoneyBag(Vector(0,0,128), position_to, 100, drop_money)
		ShowCombat({
			t = 'item_get_money',
			player = TeamId2Hero(team):GetPlayerID(),
			item = 'item_streak_plus',
			num = drop_money,
		})
	end

	hero.win_streak = 0
	hero:SetModelScale(hero.init_model_scale or 1)

	--同步ui血量
	SyncHP(hero)
end
--调用寻路算法
function FindPath(p1,p2,team)
	local map = {
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
	}

	for u,v in pairs(_G.unit[team]) do
		local y = tonumber(string.split(u,'_')[1])
		local x = tonumber(string.split(u,'_')[2])
		if v == 1 then
			map[y][x] = 1
		end
	end

	local walkable = 0
	local grid = Grid(map)
	local myFinder = Pathfinder(grid, 'JPS', walkable)

	local startx, starty = Vector2X(p1,team),Vector2Y(p1,team)
	local endx, endy = Vector2X(p2,team), Vector2Y(p2,team)

	map[starty][startx] = 0

	local path, length = myFinder:getPath(startx, starty, endx, endy)

	if path then
		--找到路了
		-- local dx = 0
		-- local dy = 0
		-- local lastx = -100
		-- local lasty = -100
		-- local lastdx = -100
		-- local lastdy = -100
		-- local lastd = -100
		-- local d = 0
		-- local pppp = {}

		for node, count in path:iter() do
			if node.x ~= startx or node.y ~= starty then
				return XY2Vector(node.x,node.y,team)
			end
			-- dx = node.x-lastx
			-- dy = node.y-lasty

			-- if dy==0 then
			-- 	d = 999
			-- else
			-- 	d = dx/dy
			-- end

			-- local lastindex = table.maxn (pppp)

			-- if d~=lastd or lastindex<=1 then
			-- 	table.insert (pppp, node)
			-- else
			-- 	pppp[lastindex] = node
			-- end
			-- lastdx = dx
			-- lastdy = dy
			-- lastx = node.x
			-- lasty = node.y
			-- lastd = d

		end
	else
		--没找到路
		return nil
	end

	-- 	--找到路了
	-- 	for _,node in pairs(pppp) do
	-- 		if node.x ~= startx or node.y ~= starty then
				
	-- 			-- if node.x > startx + 1 then
	-- 			-- 	node.x = startx + 1
	-- 			-- end
	-- 			-- if node.x < startx - 1 then
	-- 			-- 	node.x = startx - 1
	-- 			-- end
	-- 			-- if node.y > starty + 1 then
	-- 			-- 	node.y = starty + 1
	-- 			-- end
	-- 			-- if node.y < starty - 1 then
	-- 			-- 	node.y = starty - 1
	-- 			-- end

	-- 			local p_next = XY2Vector(node.x,node.y,team)

	-- 			return p_next
	-- 		end
	-- 	end

	-- 	return nil
	
end
function InitChessPool()
	local remove_table = RandomLegendary()
	local relic_remove_table = RandomRelic()
	CustomNetTables:SetTableValue( "chess_pool_table", "legendary_info", {chess_banned = remove_table,
		chess_active = _G.chess_list_by_mana[5],relic_banned = relic_remove_table,
		relic_active = _G.DROP_RELIC_LIST, hehe = RandomInt(1,1000)})
	local chess_pool_times = _G.CHESS_POOL_SIZE or 6
	for cost,v in pairs(_G.chess_list_by_mana) do
		for _,chess in pairs(v) do
			local chess_count = _G.CHESS_INIT_COUNT[cost]*chess_pool_times
			for i=1,chess_count do
				AddAChessToChessPool(chess)
			end
		end
	end
	local ban_table = {}
	for syn,tbl in pairs(_G.chess_list_by_synergy) do
		if ban_table[syn] == nil then
			ban_table[syn] = {}
		end
		for _,chs in pairs(tbl) do
			if FindValueInTable(ban_table[syn],chs) == false then
				table.insert(ban_table[syn],chs)
			end
		end
	end
	for syn,tbl in pairs(_G.chess_list_by_synergy_black_and_pandaman) do
		if ban_table[syn] == nil then
			ban_table[syn] = {}
		end
		for _,chs in pairs(tbl) do
			if FindValueInTable(ban_table[syn],chs) == false then
				table.insert(ban_table[syn],chs)
			end
		end
	end
	CustomNetTables:SetTableValue( "chess_pool_table", "synergy_info", ban_table)

	combat('INIT CHESS POOL OK!')
end
function PrintChessPool()
	local count = {
		[1] = 0,
		[2] = 0,
		[3] = 0,
		[4] = 0,
		[5] = 0,
	}
	local count_all = 0

	for i=1,5 do
		count[i] = table.maxn(_G.chess_pool[i])
		count_all = count_all + count[i]
	end

	prt('棋库有'..count_all..'个棋子（'..count[1]..'/'..count[2]..'/'..count[3]..'/'..count[4]..'/'..count[5]..'）')
end
function SendHTTP(url, callback, fail_callback)
	local str0 = url
	local str1 = ''
	local str2 = ''
	local str3 = ''
	local usercheck = 0
	local x1 = string.find(str0,'@',1)
	if x1 then
		usercheck = 1
		str1 = string.sub(str0,x1+1,-1)
	else
		str1 = str0
	end
	local x2 = string.find(str1,'@',1)
	if x2 then
		str2 = string.sub(str1,0,x2-1)
	else
		str2 = str1
	end
	local x3 = string.find(str2,'?',1)
	if x3 then
		str3 = string.sub(str2,0,x3-1)
	else
		str3 = str2
	end
	if usercheck == 1 then
		local usertable = string.split(str3,',')
		for _,userid in pairs(usertable) do
			if userid then
				if not string.find(_G.steamidlist,userid,1) and not string.find(_G.steamidlist_heroindex,userid,1) then
					return
				end
			end
		end
	end
	local req = CreateHTTPRequestScriptVM('GET', url)
	req:SetHTTPRequestAbsoluteTimeoutMS(20000)

    req:Send(function(res)
        if res.StatusCode ~= 200 or not res.Body then
            if fail_callback ~= nil then
            	fail_callback(obj)
            end
            return
        end

        local obj = json.decode(res.Body)
        if callback ~= nil then
        	callback(obj)
        end
    end)
end
function StatChess()
	local statinfo = {}
	for i=6,13 do
		for _,chess in pairs(_G.mychess[i]) do
			local find_name = chess.chess
			local chess_count = 1
			if string.find(chess.chess,'11') ~= nil and (string.find(chess.chess,'tp') ~= nil or string.find(chess.chess,'eh') ~= nil) then
				find_name = string.sub(chess.chess,1,-2)
				chess_count = 4
			end
			if string.find(chess.chess,'1') ~= nil and (string.find(chess.chess,'tp') ~= nil or string.find(chess.chess,'eh') ~= nil) then
				find_name = string.sub(chess.chess,1,-2)
				chess_count = 2
			end
			if string.find(chess.chess,'11') then
				chess_count = 9
				find_name = string.sub(chess.chess,1,-3)
			elseif string.find(chess.chess,'1') then
				chess_count = 3
				find_name = string.sub(chess.chess,1,-2)
			end
			if statinfo[find_name] == nil then
				statinfo[find_name] = chess_count
			else
				statinfo[find_name] = statinfo[find_name] + chess_count
			end
		end
	end
	for j=6,13 do
		local hhh = TeamId2Hero(j)
		if hhh ~= nil and hhh.hand_entities ~= nil then
			for _,ent in pairs(hhh.hand_entities) do
				local find_name = ent:GetUnitName()
				local chess_count = 1
				if string.find(ent:GetUnitName(),'11') then
					chess_count = 9
					find_name = string.sub(ent:GetUnitName(),1,-3)
				elseif string.find(ent:GetUnitName(),'1') then
					chess_count = 3
					find_name = string.sub(ent:GetUnitName(),1,-2)
				end
				if statinfo[find_name] == nil then
					statinfo[find_name] = chess_count
				else
					statinfo[find_name] = statinfo[find_name] + chess_count
				end
			end
		end
	end
	CustomNetTables:SetTableValue( "dac_table", "stat_chess", { statinfo = statinfo, hehe = RandomInt(1,1000)})
end
--type = round_pve/round_pvp/combine/battle/say/notice
--text = 要显示的文字
--player = 玩家id
function ShowCombat(keys)
	local combat_type = keys.t
	local combat_text = keys.text
	local combat_num = keys.num
	local combat_gold = keys.gold
	local combat_player = keys.player
	local combat_player2 = keys.player2
	local combat_hero = keys.hero
	local combat_item = keys.item
	local gameEvent = {}

	if _G.egg_quest == 'q009' then
		if combat_type == 'battle_pvp_win' and combat_num >= 10 then
			SetQuest(PlayerId2Hero(combat_player).team_id,true)
		end
		if combat_type == 'battle_pvp_lose' and combat_num >= 10 then
			SetQuest(PlayerId2Hero(combat_player2).team_id,true)
		end
	end

	if combat_type == 'battle_pvp_lose' or combat_type == 'battle_cloud_lose' then
		combat_num = keys.hp_damage or 0
	end

	if combat_player ~= nil then
		gameEvent["player_id"] = combat_player
	end
	if combat_player2 ~= nil then
		gameEvent["player_id2"] = combat_player2
	end
	if combat_text ~= nil then
		gameEvent["locstring_value"] = combat_text
	end
	if combat_num ~= nil then
		gameEvent["int_value"] = combat_num
	end
	if combat_hero ~= nil then
		gameEvent["hero_name"] = combat_hero
		gameEvent["heroname"] = combat_hero
	end
	-- gameEvent["teamnumber"] = -1
	-- gameEvent["message"] = "#text_combat_event_"..combat_type
	-- FireGameEvent( "dota_combat_event_message", gameEvent )

	if combat_type == 'round_pve' or combat_type == 'round_pvp' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'common',
			text = 'ROUND '..combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})	
	end
	if combat_type == 'battle_pve_win' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pve_win',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pve_draw' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pve_draw',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pve_lose' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pve_lose',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'battle_cloud_win' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_cloud_win',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_cloud_draw' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_cloud_draw',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_cloud_lose' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_cloud_lose',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'battle_pvp_win' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pvp_win',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pvp_draw' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pvp_draw',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'battle_pvp_lose' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'battle_pvp_lose',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'player_dead' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'player_dead',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			gold1 = combat_gold,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'terminate' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'terminate',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'drop_shengjian' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'drop_shengjian',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			player_id2 = combat_player2,
			win_streak2 = PlayerId2Hero(combat_player2).win_streak or 0,
			vip2 = PlayerId2Hero(combat_player2).is_vip,
			onduty_hero2 = PlayerId2Hero(combat_player2).onduty_hero,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'player_get_lootbox' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'player_get_lootbox',
			player_id1 = combat_player,
			win_streak1 = PlayerId2Hero(combat_player).win_streak or 0,
			vip1 = PlayerId2Hero(combat_player).is_vip,
			onduty_hero1 = PlayerId2Hero(combat_player).onduty_hero,
			num1 = combat_num,
			text = combat_text,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end

	if combat_type == 'destroy_piece' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'destroy_piece',
			player_id = combat_player,
			win_streak = PlayerId2Hero(combat_player).win_streak or 0,
			vip = PlayerId2Hero(combat_player).is_vip,
			onduty_hero = PlayerId2Hero(combat_player).onduty_hero,
			num = combat_num,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
	if combat_type == 'item_get_money' then
		CustomGameEventManager:Send_ServerToAllClients("drodo_combat",{
			type = 'item_get_money',
			player_id = combat_player,
			win_streak = PlayerId2Hero(combat_player).win_streak or 0,
			vip = PlayerId2Hero(combat_player).is_vip,
			onduty_hero = PlayerId2Hero(combat_player).onduty_hero,
			num = combat_num,
			item = combat_item,
			time_stamp = math.floor(GameRules:GetGameTime()),
		})
	end
end
function CollectAmazonData(dur,mode)

	local base_data = {
		version = '0.2',
		ticket = _G.dotamind_ticket,
		map_name = GetCurrMapInfo().map_name,
	    end_time= _G.send_time['end_time'],
	    duration= dur,
	    players = _G.send_info,
	    chess_detail = _G.upload_detail_stat,
	}
	return base_data
end
function SendHTTPPost(url,game_data,header_table)
    local req = CreateHTTPRequestScriptVM("POST",url)
    local json_data = json.encode(game_data)
    req:SetHTTPRequestHeaderValue("Content-Type", "application/json;charset=UTF-8")
    req:SetHTTPRequestRawPostBody("application/json;charset=UTF-8",json_data)
    if header_table ~= nil then
    	for h,t in pairs(header_table) do
    		req:SetHTTPRequestHeaderValue(h,t)
    	end
    end
    req:Send(function(res)
        if res.StatusCode ~= 200 or not res.Body then
            return
        end
        local obj = json.decode(res.Body)
        if obj and type(obj) == 'table' then
        	_G.dotamind_ticket = obj.ticket
        end
    end)
end
function SilenceChess(keys)
	if keys.caster:GetUnitName() == 'npc_dota_hero_wisp' then
		keys.caster:RemoveModifierByName("modifier_silence")
	else
		keys.caster:AddNewModifier(keys.caster,nil,"modifier_silence",{})
	end
end
function CleaveAttack( keys )
    local caster = keys.caster
    local target = keys.target
    local damage = keys.damage
    local cleave_per = keys.cleave_per
    local cleave_radius = keys.cleave_radius

    --远程无效
    if caster:Script_GetAttackRange() > 300 then
    	return
    end

    local cleave_units = FindUnitsInRadiusByTeam({
		team = target:GetTeam(),
		role = 1,
		position = target:GetAbsOrigin(),
		radius = cleave_radius,
	})

	for _,unit in pairs(cleave_units) do
		if IsUnitExist(unit) == true and unit:entindex() ~= target:entindex() then
		    local attack_damage = damage*cleave_per/100
		    local damage_table = {
		    	victim = unit,
		    	attacker = caster,
		    	damage_type = DAMAGE_TYPE_PURE,
		    	damage = attack_damage
		    }
		    ApplyDamage(damage_table)
		end
	end
end
function HideCombo(keys)
	local team_id = keys.team_id
	local hero = TeamId2Hero(team_id)
	for _,k in pairs(_G.class_type) do
		hero:RemoveModifierByName('modifier_show_combo_'..k)
	end
end
function ShowCombo(keys)
	local team_id = keys.team_id
	local hero = TeamId2Hero(team_id)
	local combo_table = keys.combo_table

	if _G.is_game_ended == true then
		return
	end

	-- AddAbilityAndSetLevel(hero,'show_combo')
	-- local ability = hero:FindAbilityByName('show_combo')

	-- for _,k in pairs(_G.class_type) do
		-- hero:RemoveModifierByName('modifier_show_combo_'..k)
	-- end

	local combo_array = {}
	for m,s in pairs(combo_table) do
		local sc = 0
		for score1,k in pairs(_G.class_type) do
			if k == m then
				sc = score1
			end
		end

		table.insert(combo_array,{
			m = m,
			s = s,
			score = s*10000 + sc
		})

	end

	table.sort(combo_array,function(a,b)
		return a.score > b.score
	end)


	--将种族/职业现在各有几个了的BUFF按顺序显示在信使上
	local combo_buff_str = ''
	for i = 1,table.maxn(combo_array) do
		local modifier_i = combo_array[i]
		combo_buff_str = combo_buff_str..modifier_i.m..':'..modifier_i.s..','
		-- local modifier_name = 'modifier_show_combo_'..modifier_i.m
		-- Timers:CreateTimer(i*0.03,function()
		-- 	ability:ApplyDataDrivenModifier(hero,hero,modifier_name,{})
		-- 	if hero:FindModifierByName(modifier_name) ~= nil then
		-- 		hero:FindModifierByName(modifier_name):SetStackCount(modifier_i.s)
		-- 	end
		-- end)
	end
	if IsUnitExist(hero) then
		SetStat(hero:GetPlayerID(),'buff',combo_buff_str,false)

		CustomGameEventManager:Send_ServerToAllClients("show_drodo_courier_buff",{
			player_id = hero:GetPlayerID(),
			team_id = team_id,
			buff = combo_buff_str,
		})
	end
	StatAllPlayerLineup()
end
function StatClassCount(team_id)
	--通用技能
	local combo_chess_table_self = {}
	local combo_count_table_self = {}

	--第一次循环：棋子分组
	for w,vw in pairs(GetValidChessOnBoard(team_id)) do
		if vw.team_id == team_id then --我的棋子
			for _,k in pairs(_G.class_type) do
				if combo_chess_table_self[k] == nil then
					combo_chess_table_self[k] = {}
				end
				if vw:FindAbilityByName(k) ~= nil then
					table.insert(combo_chess_table_self[k],vw)
				end
			end
		end
	end

	--第二次循环：计数
	for k,vk in pairs(combo_chess_table_self) do
		--统计不同的种类数
		local diff_count = 0
		local diff_string = ''
		for _,chess in pairs(combo_chess_table_self[k]) do
			--去掉等级变量
			local find_name = chess:GetUnitName()
			if string.find(find_name,'11') ~= nil then
				find_name = string.sub(find_name,1,-3)
			end
			if string.find(find_name,'1') ~= nil then
				find_name = string.sub(find_name,1,-2)
			end
			--搜索是否重复了
			if string.find(diff_string,'<'..find_name..'>') == nil then
				diff_count = diff_count + 1
				diff_string = diff_string..'<'..find_name..'>'
			end
		end
		if diff_count > 0 then
			combo_count_table_self[k] = diff_count
		end
	end
	ShowCombo({
		team_id = team_id,
		combo_table = combo_count_table_self,
	})
	UpdateLineup({
		player_id = _G.teamid2playerid[team_id],
		my_vchess_list = _G.mychess[team_id],
	})
end

function UpdateLineup(keys)
	CustomNetTables:SetTableValue( "player_id_table", "vchess_"..keys.player_id, keys.my_vchess_list)
end

function GetClientKey(team)
	return _G.client_key[team]
end
function GetSendKey()
	return "&key="..GetDedicatedServerKey('drodo').."&key2="..GetDedicatedServerKeyV2('zzwdjs').."&key3="..GetDedicatedServerKeyV2('xgnb').."&key4="..GetDedicatedServerKeyV2('fgnb').."&key5="..GetDedicatedServerKeyV2('bsl,bgbxh')
end
function IsUnitExist(u)
	if u ~= nil and u:IsNull() == false and u:IsAlive() == true and u.is_removing ~= true then
		return true
	else
		return false
	end
end
function ApplyDamageDelay(keys)
	local caster = keys.caster
	local damage = keys.damage or 1
	local damage_type = keys.damage_type or DAMAGE_TYPE_MAGICAL
	local delay = keys.delay or 0
	local victim = keys.victim
	local ability = keys.ability
	local p = keys.p

	Timers:CreateTimer(delay,function()
		if victim ~= nil and victim:IsNull() == false and victim:IsAlive() == true then
			ApplyDamage({
				victim = victim,
				attacker = caster,
				damage_type = damage_type,
				damage = damage,
				ability = ability,
			})
			if p ~= nil then
				play_particle(p,PATTACH_ABSORIGIN_FOLLOW,victim,3)
			end
		end
	end)
end
function IsHexxed(u)
	if IsUnitExist(u) == false then
		return false
	end
	if u:FindModifierByName('modifier_hexxed') ~= nil then
		return true
	end
	if u:FindModifierByName('modifier_shadow_shaman_voodoo') ~= nil then
		return true
	end
	if u:FindModifierByName('modifier_lion_voodoo') ~= nil then
		return true
	end
	return false
end
function SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet, onduty_hero_animation, courier_id)
	local onduty_hero_model = _G.sm_hero_list[onduty_hero]
	local onduty_hero_skin = _G.sm_hero_list_skin[onduty_hero] or 0

	hero.init_model_scale = _G.sm_hero_size[onduty_hero] or 1
	
	hero.ori_model = onduty_hero_model
	hero.ori_skin = onduty_hero_skin
	hero.onduty_hero = onduty_hero
	hero.projectile = onduty_hero_projectile
	hero.pet = onduty_hero_pet
	hero.animation = onduty_hero_animation
	if _G.egg_quest == 'q024' and (string.find(hero.onduty_hero,'h1') ~= nil or string.find(hero.onduty_hero,'h0') ~= nil) then
		SetQuest(hero:GetTeam(),true)
	end
	if _G.egg_quest == 'q025' and string.find(hero.onduty_hero,'h2') ~= nil then
		SetQuest(hero:GetTeam(),true)
	end
	if _G.egg_quest == 'q026' and string.find(hero.onduty_hero,'h3') ~= nil then
		SetQuest(hero:GetTeam(),true)
	end
	if _G.egg_quest == 'q027' and string.find(hero.onduty_hero,'h4') ~= nil then
		SetQuest(hero:GetTeam(),true)
	end

	hero.courier_name = onduty_hero

	if hero.effect ~= nil then
		hero:RemoveAbility(hero.effect)
		hero:RemoveModifierByName('modifier_texiao_star')
	end
	if onduty_hero_effect ~= nil and onduty_hero_effect ~= '' and onduty_hero_effect ~= 'e000' then
    	if _G.effect_list ~= nil and _G.effect_list[onduty_hero_effect] ~= nil then
			Timers:CreateTimer(2,function()
				AddAbilityAndSetLevel(hero,onduty_hero_effect)
			end)
			hero.effect = onduty_hero_effect
		end
	else
		hero.effect = nil
    end
    ShowCourierEffect(hero,1)
    hero.onduty_hero = onduty_hero

    -- BlinkChessX({caster=hero,blink_type="fall"})

    CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
		player_id = hero:GetPlayerID(),
		win_streak = hero.win_streak or 0,
		vip = hero.is_vip,
		onduty_hero = onduty_hero,
		text = "notice_player_select_courier",
		time_stamp = math.floor(GameRules:GetGameTime()),
		type = 'player_courier_event',
	})

    RefreshPets(hero,hero.pet_entity,onduty_hero_pet)

	-- CustomGameEventManager:Send_ServerToAllClients("hp_bar",{
	-- 	player_id = hero:GetPlayerID(),
	-- 	unit_index = hero:entindex(),
	-- 	courier_id = onduty_hero,
	-- 	win_streak = hero.win_streak,
	-- 	level = hero:GetLevel(),
	-- })

	AddAbilityAndSetLevel(hero,'moving_self')
	local animation_info = GetAnimation(hero.animation or 'n000')
	-- hero:SetOrigin(hero:GetOrigin() + Vector(0,0,1000))
	local p = Entities:FindByName(nil,'center'..(hero:GetTeam()-6)):GetOrigin()+Vector(0,-320,512)
	hero:SetAbsOrigin(p)

    --获取出场动画
	Timers:CreateTimer(1,function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(p,animation_info.tp_effect)

		Timers:CreateTimer(2,function()
			if ppp ~= nil then
				ParticleManager:DestroyParticle(ppp,true)
			end
			hero:SetOriginalModel(onduty_hero_model)
			hero:SetModel(onduty_hero_model)
			hero:SetModelScale(hero.init_model_scale)
			hero:SetSkin(onduty_hero_skin)
			MakeGreevil(hero,false)
			RemoveAbilityAndModifier(hero,'moving_self')
			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,hero)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=hero,blink_type=animation_info.animation_modifier})
			end
			if animation_info.end_effect ~= nil then
				play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,hero,3)
			end

			DAC:OnChooseCourier({
				PlayerID = hero:GetPlayerID(),
				courier = onduty_hero,
				courier_id = courier_id,
			})

			AddHPBar2HPBarTable({
				unit_index = hero:entindex(),
			})
		end)
	end)
 	
 	DAC:ResetFOW({
 		local_player_team = hero:GetTeam(),
 		target_player_team = hero:GetTeam()
 	})
end
function InitP2Mode()

	local team1_player_count = 0
	if TeamId2Hero(6) ~= nil then
		team1_player_count = team1_player_count + 1
	end
	if TeamId2Hero(7) ~= nil then
		team1_player_count = team1_player_count + 1
	end
	if team1_player_count ~= 0 and team1_player_count ~= 2 then
		return false
	end

	local team2_player_count = 0
	if TeamId2Hero(8) ~= nil then
		team2_player_count = team2_player_count + 1
	end
	if TeamId2Hero(9) ~= nil then
		team2_player_count = team2_player_count + 1
	end
	if team2_player_count ~= 0 and team2_player_count ~= 2 then
		return false
	end

	local team3_player_count = 0
	if TeamId2Hero(10) ~= nil then
		team3_player_count = team3_player_count + 1
	end
	if TeamId2Hero(11) ~= nil then
		team3_player_count = team3_player_count + 1
	end
	if team3_player_count ~= 0 and team3_player_count ~= 2 then
		return false
	end

	local team4_player_count = 0
	if TeamId2Hero(12) ~= nil then
		team4_player_count = team4_player_count + 1
	end
	if TeamId2Hero(13) ~= nil then
		team4_player_count = team4_player_count + 1
	end
	if team4_player_count ~= 0 and team4_player_count ~= 2 then
		return false
	end

	SetP2Team(6,1)
	SetP2Team(7,1)
	SetP2Team(8,2)
	SetP2Team(9,2)
	SetP2Team(10,3)
	SetP2Team(11,3)
	SetP2Team(12,4)
	SetP2Team(13,4)

	_G.p2_mode = true
	return true
end

function ExtraAttack(keys)
	--实测效果不稳定
	local caster = keys.caster
	local target = keys.target
	caster:PerformAttack(target, true, true, true, false, false, false, true)
end
--设置英雄血量并同步UI 和 判断死亡
function SetHeroHP(hero,hp)
	if hero == nil or hp == nil then
		return
	end
	if hp < 0 then
		hp = 0
	end

	if hp == 0 then
		--玩家死亡
		play_particle("effect/dead/2.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,8)
		-- hero:ForceKill(false)
		-- hero:SetHealth(1)
		hero:StartGesture(ACT_DOTA_DIE)
		AddAbilityAndSetLevel(hero,"root_self")
		Timers:CreateTimer(1,function()
			hero:SetModelScale(0.01)
			-- prt('ForceKill:'..hero:GetUnitName())
			hero:ForceKill(false)
			SyncHP(hero)
		end)
		_G.counterpart[hero:GetTeam()] = -1
	else
		hero:SetHealth(hp)
	end

	SyncHP(hero)
end
--对指定team的棋手造成伤害
function DamageTeam(team, damage, pj)

	local hh = TeamId2Hero(team) 
	if hh ~= nil then
		if damage > 0 then
			SetHeroHP(hh, hh:GetHealth() - damage)
			AMHC:CreateNumberEffect(hh,damage,2,AMHC.MSG_MISS,"red",9)
			local damage_sound = _G.projectile_list[pj]['sound'] or "pj_hit.tower"
			EmitSoundOn(damage_sound,hh)
			-- EmitSoundOn("Frostivus.PointScored.Enemy",hh)
		else
			ShowMiss({
				caster = hh
			})
		end
	end
end
function CourierCP(c1,c2)
	local h1 = c1.onduty_hero
	local h2 = c2.onduty_hero

	if c1.cp_exp == nil then
		c1.cp_exp = 1
	else
		c1.cp_exp = c1.cp_exp + 1
	end
	if c2.cp_exp == nil then
		c2.cp_exp = 1
	else
		c2.cp_exp = c2.cp_exp + 1
	end
	if _G.egg_quest == 'q018' then
		SetQuest(c1:GetTeam(),true)
		SetQuest(c2:GetTeam(),true)
	end

	if h1 ~= h2 and (_G.CP_GROUP[h1] == nil or _G.CP_GROUP[h2] == nil or _G.CP_GROUP[h1] ~= _G.CP_GROUP[h2]) then
		return
	end
	local e1 = c1.onduty_hero_effect
	local e2 = c2.onduty_hero_effect
	local cp_level = -1

	if (_G.CP_GROUP[h1] == _G.CP_GROUP[h2]) or (h1 == h2) then
		cp_level = cp_level + 1
	end
	if e1 == e2 then
		cp_level = cp_level + 1
	end
	if c1.cp_exp >= 5 or c2.cp_exp >= 5 then
		cp_level = cp_level + 1
	end
	if cp_level >= 0 then
		if _G.egg_quest == 'q019' then
			SetQuest(c1:GetTeam(),true)
			SetQuest(c2:GetTeam(),true)
		end
		EmitSoundOn("dac.cpsound",c1)
		EmitSoundOn("dac.cpsound",c2)
		play_particle("effect/cp_heart/"..cp_level..".vpcf",PATTACH_OVERHEAD_FOLLOW,c1,6)
		play_particle("effect/cp_heart/"..cp_level..".vpcf",PATTACH_OVERHEAD_FOLLOW,c2,6)
	end
end
function ShowBattleInfo()
	local battle_table = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
	if _G.battle_boss[_G.battle_round] ~= nil then
		--PVE
		for i=6,13 do
			if IsUnitExist(TeamId2Hero(i)) == true then
				CustomGameEventManager:Send_ServerToTeam(i,"battle_info",{
					key = GetClientKey(i),
					type = "pve",
					text = ''.._G.battle_round,
					round = _G.battle_round,
					history_win = GetHistoryWin(i,4),
	            	history_lose = GetHistoryLose(i,4),
				})
				battle_table[i] = {
					key = GetClientKey(i),
					round = _G.battle_round,
					type = 'pve',
					steam_id = TeamId2Hero(i).steam_id,
					oppo_steam_id = nil,
				}
			end
		end
	else
		--PVP
		if _G.playing_player_count == 1 and _G.cloudlineup[''.._G.battle_round] ~= nil then
			local chesses = nil
			for _,data in pairs(_G.cloudlineup[''.._G.battle_round]) do
				chesses = json.decode(data)
			end
			--打云玩家
			for i=6,13 do
				if IsUnitExist(TeamId2Hero(i)) == true then
					CustomGameEventManager:Send_ServerToTeam(i,"battle_info",{
						key = GetClientKey(i),
						type = "cloud",
						text = chesses.owner,
						round = _G.battle_round,
						history_win = GetHistoryWin(i,5),
	            		history_lose = GetHistoryLose(i,5),
					})
					battle_table[i] = {
						key = GetClientKey(i),
						round = _G.battle_round,
						type = 'cloud',
						steam_id = TeamId2Hero(i).steam_id,
						oppo_steam_id = chesses.owner,
					}
				end
			end
		else
			for i=6,13 do
				if IsUnitExist(TeamId2Hero(i)) == true then
					--打pvp敌人
					--i = 我的teamid
					--v = 我的主场对手的teamid
					--g = 我的客场对手的teamid
					local v = _G.counterpart[i]
					if v ~= nil and v ~= -1 then
						local g = GetMyGuestEnemyTeam(i)
						local enemy_id = TeamId2Hero(v):GetPlayerID()
						local guest_oppo_id = TeamId2Hero(g):GetPlayerID()
						local buffs = nil

						if _G.stat_info[TeamId2Hero(v).steam_id] ~= nil then
							buffs = GetStat(enemy_id,'buff')
						end
						
						CustomGameEventManager:Send_ServerToTeam(i,"battle_info",{
							key = GetClientKey(i),
							type = "pvp",
							text = enemy_id,
							host_oppo_id = enemy_id,
							guest_oppo_id = guest_oppo_id,
							round = _G.battle_round,
							history_win = GetHistoryWin(i,v),
	            			history_lose = GetHistoryLose(i,v),
	            			buffs = buffs,
						})

						battle_table[i] = {
							key = GetClientKey(i),
							round = _G.battle_round,
							type = 'pvp',
							steam_id = TeamId2Hero(i).steam_id,
							oppo_steam_id = TeamId2Hero(v).steam_id,
						}
					end
				end
			end
		end
	end

	UpdatePlayerWorldPanel(battle_table)
end
function AddHistoryWin(team1, team2)
	_G.history_win[team1][team2] = _G.history_win[team1][team2] + 1
end
function AddHistoryLose(team1, team2)
	_G.history_lose[team1][team2] = _G.history_lose[team1][team2] + 1
end
function GetHistoryWin(team1, team2)
	return _G.history_win[team1][team2]
end
function GetHistoryLose(team1, team2)
	return _G.history_lose[team1][team2]
end
function IsAttackLowPriority(unit)
	if unit:FindModifierByName('modifier_dazzle_shallow_grave') ~= nil and unit:GetHealth() < 10 then
		return true
	elseif unit:FindModifierByName('modifier_oracle_mingyunsheling') ~= nil then
		return true
	elseif unit:FindModifierByName('modifier_siren_song_debuff') ~= nil then
		return true
	elseif unit:FindModifierByName('modifier_winter_wyvern_cold_embrace') ~= nil then
		return true
	elseif unit:IsInvulnerable() == true then
		return true
	else
		return false
	end
end
--显示caster头顶的miss，默认是红色
function ShowMiss(keys)
	local u = keys.caster
	local color = keys.color or Vector(255, 32, 32)
	if u == nil then
		return
	end
	if u.miss_particle ~= nil then
		ParticleManager:DestroyParticle(u.miss_particle,true)
		u.miss_particle = nil
		u.miss_particle_id = nil
	end
	local pos = PATTACH_ABSORIGIN_FOLLOW
	local pp = ParticleManager:CreateParticle('effect/miss/1.vpcf', pos, u)

	ParticleManager:SetParticleControl(pp, 0, u:GetOrigin())
    ParticleManager:SetParticleControl(pp, 3, color)
    ParticleManager:SetParticleControl(pp, 4, Vector(5, 0, 0))

    local id = RandomFloat(1,10000)
    u.miss_particle = pp
    u.miss_particle_id = id

	Timers:CreateTimer(5,function()
		if u.miss_particle ~= nil and u.miss_particle_id == id then
			ParticleManager:DestroyParticle(u.miss_particle,true)
			u.miss_particle = nil
    		u.miss_particle_id = nil
		end
	end)

	--9精灵：闪避幻象
	local target = u:GetAttackTarget()
	-- if IsUnitExist(target) == true and target:GetHealth() > 0 and (target.elf_illusion == nil or IsUnitExist(target.elf_illusion) == false ) then
	if IsUnitExist(target) == true and target:GetHealth() > 0 then
		if target:FindModifierByName('modifier_is_elf_buff_plus_plus') ~= nil and target:FindAbilityByName('is_elf_buff_plus_plus') ~= nil and target:FindAbilityByName('is_elf_buff_plus_plus'):IsCooldownReady() == true then
			target.elf_illusion = target
			play_particle("particles/units/heroes/hero_mirana/mirana_moonlight_ray.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,2)
			EmitSoundOn("Hero_Dark_Seer.Ion_Shield_end",target)
			target:FindAbilityByName('is_elf_buff_plus_plus'):StartCooldown(4)

			Timers:CreateTimer(0.1,function()
				if IsUnitExist(target) == true and target:GetHealth() > 0 then
					SummonMinion(target,target:GetUnitName(),1,nil,function(w)
						local hp_set = target:GetHealth()
						if hp_set <= 0 then
							hp_set = 1
						end
						w:SetHealth(hp_set)
						w:AddNewModifier(w,nil,"modifier_illusion",{duration = 8})
						w:SetMaxMana(0)
						target.elf_illusion = w
						FillEmptySlot(w)
						ExtendBeastBuff(w,target)
					end)
				end
			end)
		end
	end
end
function AllocateABattleRoundV3()
	local finished = false
	local trytime = 0

	_G.last_3rd_round = _G.last_2nd_round
	_G.last_2nd_round = _G.last_round
	_G.last_round = _G.current_round

	while trytime < 10000 and finished == false do
		trytime = trytime + 1
		_G.current_round = {}
		
		local alive_player_count = 0
		--统计玩家死活
		for u,v in pairs(_G.counterpart) do
			if TeamId2Hero(u) ~= nil and TeamId2Hero(u):IsNull() == false and TeamId2Hero(u):IsAlive() == true then
				--活玩家
				_G.counterpart[u] = u
				alive_player_count = alive_player_count + 1
			else
				--死玩家
				_G.counterpart[u] = -1
			end
		end

		local rann = 0
		if alive_player_count <= 1 then
			rann = 0
		elseif alive_player_count == 2 then
			rann = 1
		else
			rann = RandomInt(1,alive_player_count-1)
		end
		--给活玩家分配一个随机对手
		for rotate_count = 1,rann do
			for i,j in pairs(_G.counterpart) do
				if j ~= -1 then
					local aliveteam = j

					local try_count = 0
					while (aliveteam == j or _G.counterpart[aliveteam] == nil or _G.counterpart[aliveteam] == -1) and try_count<10000 do
						aliveteam = aliveteam + 1
						if aliveteam > 13 then
							aliveteam = 6
						end
						try_count = try_count + 1
					end
					_G.counterpart[i] = aliveteam
				end
			end
		end

		for ii,jj in pairs(_G.counterpart) do
			if jj ~= -1 then
				table.insert(_G.current_round, ii * 100 + jj)
			end
		end
		
		finished = true
		for i, v in pairs(_G.current_round) do
			if alive_player_count >= 7 then
				if IsValueInTable(v, _G.last_round) == true or IsValueInTable(v, _G.last_2nd_round) == true or IsValueInTable(v, _G.last_3rd_round) == true then
					finished = false
				end
			elseif alive_player_count >= 5 then 
				if IsValueInTable(v, _G.last_round) == true or IsValueInTable(v, _G.last_2nd_round) == true then
					finished = false
				end
			elseif alive_player_count >= 3 then 
				if IsValueInTable(v, _G.last_round) == true then
					finished = false
				end
			elseif alive_player_count >= 1 then 
				finished = true
			else
				return
			end
		end
	end
end
function RemoveMovingModifier(unit)
	if HasMovingModifier(unit) then
		unit:RemoveModifierByName("modifier_jump")
		unit:RemoveModifierByName("modifier_run")
		unit:RemoveModifierByName("modifier_elfrun")
		unit:RemoveModifierByName("modifier_tuitui")
		unit:RemoveModifierByName("modifier_gungun")
		unit:RemoveModifierByName("modifier_toss")
		unit:RemoveModifierByName("modifier_hook")
		unit:RemoveModifierByName("modifier_breaksoil")
	end
end
function HasMovingModifier(unit)
	if unit:HasModifier("modifier_jump") or unit:HasModifier("modifier_run") or unit:HasModifier("modifier_tuitui") or unit:HasModifier("modifier_elfrun") or unit:HasModifier("modifier_gungun") or unit:HasModifier("modifier_toss") or unit:HasModifier("modifier_hook") or unit:HasModifier("modifier_breaksoil") or unit:HasModifier("modifier_primal_beast_pulverize") then
		return true
	else
		return false
	end
end
function ChangeUnitPosition(unit, new_position, is_immediately)
	local team_id = unit.at_team_id or unit.team_id
	local old_position = unit:GetAbsOrigin()
	local old_y = unit.y
	local old_x = unit.x
	local old_y_x = unit.y_x
	local new_y = Vector2Y(new_position,team_id)
	local new_x = Vector2X(new_position,team_id)
	local new_y_x = new_y..'_'..new_x

	_G.unit[team_id][old_y_x] = nil
	_G.unit[team_id][new_y_x] = 1
	unit.y_x = new_y_x
	unit.y = new_y
	unit.x = new_x

	if is_immediately == true then
		RemoveMovingModifier(unit)
		unit:SetAbsOrigin(new_position)
	end
end
function SwapUnitPosition(u1, u2)
	local chessboard_id = u1.at_team_id or u1.team_id
	local pos1 = u1:GetAbsOrigin()
	local pos2 = u2:GetAbsOrigin()
	local x1 = Vector2X(pos1,chessboard_id)
	local y1 = Vector2Y(pos1,chessboard_id)
	local y_x1 = y1..'_'..x1
	local x2 = Vector2X(pos2,chessboard_id)
	local y2 = Vector2Y(pos2,chessboard_id)
	local y_x2 = y2..'_'..x2

	u1.y_x = y_x2
	u1.y = y2
	u1.x = x2

	u2.y_x = y_x1
	u2.y = y1
	u2.x = x1

	RemoveMovingModifier(u1)
	u1:SetAbsOrigin(pos2)

	RemoveMovingModifier(u2)
	u2:SetAbsOrigin(pos1)
end
function GetChessAbilityCD(u)
	local cd = 9999
	if IsUnitExist(u) == false then
		return cd
	end
	local ability_name = GetChessAbility(u)
	if ability_name ~= nil and u:FindAbilityByName(ability_name) ~= nil then
		cd = math.floor(u:FindAbilityByName(ability_name):GetCooldownTimeRemaining())
	end
	return cd
end
function GetChessAbility(u)
	local a = nil
	if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
		a = u.steal_ability
	elseif string.find(u:GetUnitName(),'chess_kael') and (u.kael_ability ~= nil or u.kael_ability_last ~= nil) then
		a = u.kael_ability or u.kael_ability_last	
	else
		a = _G.chess_ability_list[u:GetUnitName()] or _G.summon_ability_list[u:GetUnitName()]
	end
	if u.ice_or_fire == 'fire' then
		a = 'jakiro_macropyre'
	end
	if u.ice_or_fire == 'ice' then
		a = 'jakiro_ice_path'
	end
	return a
end
function ReduceChessAbilityCD(u,sec)
	if IsUnitExist(u) == false then
		return
	end
	if sec == nil then
		return
	end
	local ability_name = _G.chess_ability_list[u:GetUnitName()]
	local ability = u:FindAbilityByName(ability_name)
	if GetChessTypeName(u) == 'chess_rubick' and u.steal_ability ~= nil then
		ability = u:FindAbilityByName(u.steal_ability)
	end
	local cd = ability:GetCooldownTimeRemaining()
	local cd_new = cd - sec
	if cd_new < 0 then
		cd_new = 0
	end
	if cd_new <= 0 then
		ability:EndCooldown()
	else
		ability:EndCooldown()
		ability:StartCooldown(cd_new)
	end
end
function UpdatePlayerWorldPanel(battle_table)
	if battle_table == nil then
		battle_table = {
			[6] = {},
			[7] = {},
			[8] = {},
			[9] = {},
			[10] = {},
			[11] = {},
			[12] = {},
			[13] = {},
		}
		for i=6,13 do
			if TeamId2Hero(i) ~= nil and TeamId2Hero(i).steam_id ~= nil then
				battle_table[i] = {
					steam_id = TeamId2Hero(i).steam_id
				}
			end
		end
	end
	if _G.battle_boss[_G.battle_round] ~= nil then
		battle_table['pve_round'] = _G.battle_round
	end
	for i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(i,"update_player_worldpanel",battle_table)
	end
	CustomGameEventManager:Send_ServerToTeam(1,"update_player_worldpanel",battle_table)
end
function ShowQuest()
	CustomNetTables:SetTableValue( "quest_table", "show_quest", {
		quest = _G.egg_quest,
		status = _G.quest_status, 
		hehe = RandomFloat(0,10000),
	})
end
function SetQuest(team,tf)
	if _G.quest_status[team] ~= -1 then
		_G.quest_status[team] = tf
	end
	
	ShowQuest()
end
function TeamId2PlayerName(team)
	local hero = TeamId2Hero(team)
	local steam_id = hero.steam_id
	local player_name = _G.steamid2name[steam_id] or '未知玩家'
	return player_name
end
--统计本局中一共有多少正在游戏的玩家（观战的不算）
function GetPlayingPlayerCount()
	if _G.playing_player_count > 0 then
		return _G.playing_player_count
	else
		local playing_player_count = 0
		local obing_player_count = 0
		for player_id,_ in pairs(_G.playerid2steamid) do
			if PlayerResource:GetTeam(player_id) >= 6 and PlayerResource:GetTeam(player_id) <= 13 then
				playing_player_count = playing_player_count + 1
			end
			if PlayerResource:GetTeam(player_id) == 1 then
				obing_player_count = obing_player_count + 1
			end
		end
		_G.playing_player_count = playing_player_count
		_G.obing_player_count = obing_player_count
		combat('PLAYER COUNT: '.._G.playing_player_count)
		if _G.obing_player_count > 0 then
			combat('OB COUNT: '.._G.obing_player_count)
			CustomGameEventManager:Send_ServerToAllClients("show_ob_count",{
				count = _G.obing_player_count
			})
		end
		return _G.playing_player_count
	end
end

function InitPlayerIDTable()
	for i=0,11 do
		local hero = PlayerId2Hero(i)
		if hero ~= nil then
			local team_id = hero:GetTeam()
			local player_index = team_id - 6
			local hero_index = hero:entindex()
			_G.teamid2playerid[team_id] = i

			CustomNetTables:SetTableValue( "player_id_table", 'player_'..i, {
				player_id = i,
				team_id = team_id,
				player_index = player_index,
				hero_index = hero_index,
			})
		end
	end
end
function InitChessMana(chess)
	if chess:IsHero() == true then
		return
	end
	local item_mana_list = {
		modifier_item_nengliangqiu = 40,
		modifier_item_zhenhunshi = 40,
		modifier_item_wangyuanjing = 40,
		modifier_item_aoshuxie = 40,
		modifier_item_weishijingjia = 40,
		modifier_item_silingshu = 40,
		modifier_item_silingshu_2 = 40,
		modifier_item_silingshu_3 = 40,
		modifier_item_minglingshu = 40,
		modifier_item_xuejingshi = 80,
		modifier_item_test_dafali = 100,
	}
	local init_mana = 0
	for m,mana in pairs(item_mana_list) do
		if chess:HasModifier(m) then
			init_mana = init_mana + (mana or 40)
		end
	end
	if init_mana > 100 then
		init_mana = 100
	end

	if init_mana > 0 then
		chess:SetMana(init_mana)
		if _G.game_status == 2 then
			AMHC:CreateNumberEffect(chess,init_mana,2,AMHC.MSG_MISS,{128,128,255},0)
		end
	else
		chess:SetMana(0)
	end
end
function Unit2VChess(u)
	local team_id = u:GetTeam()
	if team_id == nil or u.vchess_index == nil then
		return nil
	end
	if _G.mychess[team_id] == nil then
		return nil
	end
	return _G.mychess[team_id][u.vchess_index]
end

function SummonAChess(teamid,position,chessname,at_teamid,health_percent,mana,items,is_tuihua,force_forward,no_ability,ai_delay)
	--生成一个退化的棋子
	if position == nil then
		return
	end
	if teamid == nil then
		return
	end
	if at_teamid == nil then
		return
	end
	--判断英雄是否还活着
	local hero1 = TeamId2Hero(at_teamid)
	if hero1:IsNull() or hero1:IsAlive() == false or hero1.is_battle_completed == true then
		return
	end
	if _G.battle_timer <= 1 then
		return
	end
	
	local x = CreateUnitByName(chessname,position,true,nil,nil,teamid)

	if IsUnitExist(x) then
		table.insert(_G.to_be_destory_list[at_teamid],x)
		AddAbilityAndSetLevel(x,'root_self')
		AddAbilityAndSetLevel(x,'jiaoxie_wudi')
		x.x = Vector2X(position,at_teamid)
		x.y = Vector2Y(position,at_teamid)
		x.y_x = ''..x.y..'_'..x.x
		x.at_team_id = at_teamid
		x.team_id = teamid
		x.is_tuihuaed = true
		x:SetHealth(x:GetMaxHealth()*health_percent)
		x:SetMana(mana or 0)

		if items ~= nil then
			GiveItems2Unit(items,x)
		end
		FillEmptySlot(x)

		_G.unit[at_teamid][x.y..'_'..x.x] = 1

		if force_forward == nil then
			if x:GetTeam() == 4 then
				x:SetForwardVector(Vector(0,-1,0))
			else
				x:SetForwardVector(Vector(0,1,0))
			end
		else
			x:SetForwardVector(force_forward)
		end

		-- if is_tuihua then
		-- 	Timers:CreateTimer(0.1,function()
		-- 		x:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(x,x,'modifier_transfer_debuff',{ duration = 2})
		-- 	end)
		-- else
		-- 	Timers:CreateTimer(0.1,function()
		-- 		local transfer_duration = x:GetLevel()/2
		-- 		x:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(x,x,'modifier_transfer_buff',{ duration = transfer_duration})
		-- 	end)
		-- end

		--添加战斗技能和棋子AI
		Timers:CreateTimer(0.1,function()
			x.is_in_battle = true
			if _G.chess_ability_list[x:GetUnitName()] ~= nil then
				local a = _G.chess_ability_list[x:GetUnitName()]
				local a_level = 1
				if string.find(x:GetUnitName(),'1') then
					a_level = 2
				end
				if string.find(x:GetUnitName(),'11') then
					a_level = 3
				end
				if no_ability ~= true then
					if x:FindAbilityByName(a) == nil then
						AddAbilityAndSetLevel(x,a,a_level)
					else
						x:FindAbilityByName(a):SetLevel(a_level)
					end
				end
				x:RemoveAbility('jiaoxie_wudi')
				x:RemoveModifierByName('modifier_jiaoxie_wudi')
			end
			if ai_delay == nil then
				ai_delay = 0
			end
			Timers:CreateTimer(0.5+ai_delay,function()
				if x == nil or x:IsNull() == true or x:IsAlive() == false or x.alreadywon == true then
					return
				end
				ChessAI(x,0.01)
				return 1
			end)
		end)

		return x
	end
end
--【招募棋子】
--技能：抽
function SummonHero(keys)
	local caster = keys.caster
	local team_id = caster:GetTeam()
	caster.chesslock = false
	AMHC:CreateNumberEffect(caster,2,3,AMHC.MSG_MISS,{80,80,255},3)
	AMHC:CreateParticle("particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ribbon_bright.vpcf",PATTACH_ABSORIGIN_FOLLOW,false,caster.ai_pet or caster,5)
	EmitSoundOn('frostivus_ui_select',caster)
	Draw5ChessAndShow(team_id, true)

	CustomGameEventManager:Send_ServerToTeam(team_id,"show_gold",{
		key = GetClientKey(team_id),
		gold = caster:GetMana(),
		lose_streak = caster.lose_streak or 0,
		win_streak = caster.win_streak or 0,
	})
	--同步ui血量
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = caster:GetPlayerID(),
		hp = caster:GetHealth(),
		hp_max = caster:GetMaxHealth(),
		mp = caster:GetMana(),
		level = caster:GetLevel(),
		win_streak = caster.win_streak,
		unit_index = caster:entindex(),
		courier_id = caster.onduty_hero,
	})
end
function RandomNDrawChessNew(team_id,n,unlock,is_gold)
	--is_gold = 1金色核心，= 2黑暗核心，= 0普通核心 = 3魔法卡牌，上次对手的卡
	local new_chess_list_str = ""
	local new_chess_list_table = {}
	local chess_count = 0
	local meister = nil
	local hh = TeamId2Hero(team_id)
	if hh:HasModifier('modifier_item_shrink_meister') and RandomInt(1,100) <= 75 and is_gold == nil and unlock == true then
		AddMana(hh,1)
		PreviewProjectile(hh, nil,'effect/dabaiyin/tinker_laser.vpcf',true)
		EmitSoundOn('shrink_meister.activate',hh)
		meister = true
	end
	local try_count = 0
	while chess_count < n do
		try_count = try_count + 1
		if try_count < 100 then
			local new_chess,force_price = RandomDrawChessNew(team_id,unlock,is_gold,meister)
			if new_chess ~= nil then
				new_chess_list_str = new_chess_list_str..new_chess..','
				-- table.insert(new_chess_list_table,new_chess)
				chess_count = chess_count + 1

				local price = force_price or _G.chess_2_mana[new_chess] or 1
				hh.level_one_chess = FindLevelOneChess(hh)
				if (string.find(hh.level_one_chess or '',new_chess..',') or string.find(hh.level_one_chess or '',new_chess..'1,') or string.find(hh.level_one_chess or '',new_chess..'11,')) and hh:HasModifier('modifier_item_friends_discount') then
					--亲友折扣
					if RandomInt(1,100) < 50 then
						price = math.floor(price / 2)
					else
						price = math.ceil(price / 2)
					end
					if price < 0 then
						price = 0
					end
				end
				new_chess_list_table[chess_count] = {
					chess = new_chess,
					price = price,
				}
			end
		else
			try_count = 0
			is_gold = 0
		end
	end
	return new_chess_list_table
end
function RandomDrawChessNew(team_id,unlock,is_gold,shrink_meister)
	--is_gold = 1金色核心，= 2黑暗核心
	local h = TeamId2Hero(team_id)
	local this_chess = nil
	local ran = RandomInt(1,100)
	local chess_level = 1
	local curr_per = 0
	local hero_level = h:GetLevel()
	local force_price = nil

	local table_11chess = Get11ChessBaseNameTable(team_id)

	local ran1 = RandomInt(1,10000)
	local ran2 = RandomInt(1,10000)
	local io_chance = 20
	if h:HasModifier('modifier_item_double_io') then
		io_chance = io_chance*5
	end
	local special_draw = false
	if is_gold == 1 or is_gold == 2 or is_gold == 3 then
		special_draw = true
	end
	if h:GetLevel() >= 7 and ran1 <= 1 and ran2 <= 1 and not special_draw then
		this_chess = _G.chess_list_ssr[RandomInt(1,table.maxn(_G.chess_list_ssr))]
	elseif ran1 <= io_chance and not special_draw then
		this_chess = 'chess_io'
	else
		--正常抽牌
		local draw_level = hero_level
		if h:HasModifier('modifier_item_upgrade_roll') then
			draw_level = draw_level + 1
			if draw_level > 16 then
				draw_level = 16
			end
		end
		if shrink_meister == true then
			draw_level = draw_level - 2
			if draw_level < 1 then
				draw_level = 1
			end
		end
		
		if _G.chess_gailv[draw_level] ~= nil then
			for per,lv in pairs(_G.chess_gailv[draw_level]) do
				if ran>per and curr_per<=per then
					curr_per = per
					chess_level = lv
				end
			end
		end
		if is_gold == 1 then
			this_chess = DrawAChessFromGoldPool(chess_level, table_11chess, {}, {},h)
		elseif is_gold == 2 then
			this_chess = DrawAChessFromBlackPool(chess_level, table_11chess, {}, {},h)
		elseif is_gold == 3 then
			--强制抽取敌人的棋子
			local temp_chess_pool = h.last_lose_lineup
			-- local temp_chess_pool = hero.last_opp_lineup
			local draw_available = false
			if temp_chess_pool ~= nil and table.maxn(temp_chess_pool) ~= 0 then
				for _,chess_q in pairs(temp_chess_pool) do
					chess_q = GetChessBaseName(chess_q)
					if FindChessCountInChessPool(chess_q) ~= 0 then
						draw_available = true
						break
					end
				end
			end
			-- if temp_chess_pool ~= nil and table.maxn(temp_chess_pool) > 0 then
			if draw_available == true then
				--可以抽魔术卡牌
				this_chess = DrawAChessFromChessPool(chess_level, table_11chess,{},{},h,temp_chess_pool)
				-- if FindChessCountInChessPool(this_chess) > 0 then
				-- 	--免费
				-- 	force_price = 0
				-- end
			else
				--不能抽魔术卡牌
				if unlock == true then
					this_chess = DrawAChessFromChessPool(chess_level, table_11chess, h.ban_chess_list, h.ban_chess_list2,h)
				else
					this_chess = DrawAChessFromChessPool(chess_level, table_11chess, {}, {},h)
				end
			end
		else
			if unlock == true then
				this_chess = DrawAChessFromChessPool(chess_level, table_11chess, h.ban_chess_list, h.ban_chess_list2,h)
			else
				this_chess = DrawAChessFromChessPool(chess_level, table_11chess, {}, {},h)
			end
		end
	end
	return this_chess,force_price
end
function IsHandFull(team_id)
	if FindEmptyHandSlot(team_id) == nil then
		return true
	else
		return false
	end
end
function FindEmptyHandSlot(team_id)
	local empty_index = nil
	for i=1,8 do
		if _G.hand ~= nil and _G.hand[team_id] ~= nil and _G.hand[team_id][i] == 0 then
			empty_index = i
			break
		end
	end
	return empty_index
end
function CheckEmptyHandSlot(team_id,index)
	if _G.hand ~= nil and _G.hand[team_id] ~= nil and _G.hand[team_id][index] == 0 then
		return true
	else
		return false
	end
end
function ClearHand(team_id)
	local h = TeamId2Hero(team_id)
	if h ~= nil and h:IsNull() ~= true and h.hand_entities ~= nil then
		for _,v in pairs(h.hand_entities) do
			if v ~= nil and v:IsNull() == false then
				v:ForceKill(false)
			end
		end
	end
	_G.population[team_id] = 0
	_G.hand[team_id] = {}
	_G.mychess[team_id] = {}
	ClearARound(team_id)
end
--BattleTable是记录每个场地战斗情况的table，true为正在战斗
function InitBattleTable()
	_G.battle_count = {
		[6] = false,
		[7] = false,
		[8] = false,
		[9] = false,
		[10] = false,
		[11] = false,
		[12] = false,
		[13] = false,
	}
end
function InitDeathTable()
	_G.death = {
		[6] = false,
		[7] = false,
		[8] = false,
		[9] = false,
		[10] = false,
		[11] = false,
		[12] = false,
		[13] = false,
	}
	CustomNetTables:SetTableValue( "game_info", "death_team", _G.death )
end
function SetBattleTable(team_id,value)
	if _G.battle_count ~= nil and _G.battle_count[team_id] ~= nil then
		_G.battle_count[team_id] = value
	end
end
function GetBattleTable(team_id)
	return _G.battle_count[team_id]
end
function GetBattleCount()
	local battle_count = 0
	for _,i in pairs(_G.battle_count) do
		if i == true then
			battle_count = battle_count + 1
		end
	end
	return battle_count
end
function GetChessCountInBattleGround(m)
	local mychess_count = 0
	local enemychess_count = 0
	local my_last_chess = nil
	if _G.to_be_destory_list[m] ~= nil then
		for p,q in pairs(GetValidChessOnBoard(m)) do
			if q:GetUnitName() ~= 'fissure' then
				if q.team_id == m then
					mychess_count = mychess_count + 1
					my_last_chess = q
				else
					enemychess_count = enemychess_count + 1
				end
			end
		end
	end

	return mychess_count,enemychess_count,my_last_chess
end
function GetHitDamage(u)
	local d = math.floor(1+(1.0*u:GetLevel()/3))
	return d
end
--【重建、合成、移动、删除等操作棋子】
function RestoreOneChess(v,teamid)
	--获取出场动画
	local hero = TeamId2Hero(teamid)
	if IsUnitExist(hero) == false then
		return
	end
	local animation_info = GetAnimation(hero.animation or 'n000')

	Timers:CreateTimer(RandomFloat(0,0.9),function()
		--播放起始动画
		local ppp = ShowTPEffectAtPosition(XY2Vector(v.x,v.y,teamid),animation_info.tp_effect)

		Timers:CreateTimer(RandomFloat(0.1,2.1),function()
			if ppp ~= nil then
	            ParticleManager:DestroyParticle(ppp,true)
	        end

			if TeamId2Hero(teamid):IsAlive() ~= true then
				return
			end
			local x = CreateUnitByName(v.chess,XY2Vector(v.x,v.y,teamid),true,nil,nil,teamid)
			--隐藏手牌
			if TeamId2Hero(teamid):HasModifier('modifier_item_conceal_prepare') or x:HasModifier('modifier_is_satyr') then
				ConcealOneChess(x)
			end
			SetChessSpecialLook(x)

			AddAbilityAndSetLevel(x,'root_self')
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			x.y_x = ''..v.y..'_'..v.x
			x.y = v.y
			x.x = v.x
			x.vchess_index = ''..v.y..'_'..v.x
			x.press_count = v.press_count
			x.bh_gold = v.bh_gold
			x.xuejingshi_count = v.xuejingshi_count
			x.track_money_count = v.track_money_count
			x.buy_price = v.buy_price
			x.team_id = teamid
			-- x.is_respawning = true
			local item_table = v.item  
			InitChessRemindedItem(x,item_table)
			if table.maxn(item_table) > 0 then
				for p,vp in pairs (item_table) do
					if vp == 'item_silingshu' or vp == 'item_silingshu_2' or vp == 'item_silingshu_3' then
						vp = GetCurrSilingshuItemName(x)
					end
					x:AddItemByName(vp)
				end
			end
			
			-- Timers:CreateTimer(1,function()
			-- 	x.is_respawning = nil
			-- end)

			if v.y ~= nil and v.y > 4 then
				AddAbilityAndSetLevel(x,'is_enemy')
				x:SetForwardVector(Vector(0,-1,0))
				if _G.yourchess[teamid][''..v.y..'_'..v.x] == nil then
					_G.yourchess[teamid][''..v.y..'_'..v.x] = {}
				end
				_G.yourchess[teamid][''..v.y..'_'..v.x]['index'] = x:entindex()
				_G.yourchess[teamid][''..v.y..'_'..v.x]['lastitem'] = CopyTable(_G.yourchess[teamid][''..v.y..'_'..v.x]['item'])
				_G.yourchess[teamid][''..v.y..'_'..v.x]['item'] = {}
			else
				table.insert(_G.to_be_destory_list[teamid],x)
				x:SetForwardVector(Vector(0,1,0))
				if _G.mychess[teamid][''..v.y..'_'..v.x] == nil then
					_G.mychess[teamid][''..v.y..'_'..v.x] = {}
				end
				_G.mychess[teamid][''..v.y..'_'..v.x]['index'] = x:entindex()
				_G.mychess[teamid][''..v.y..'_'..v.x]['lastitem'] = CopyTable(_G.mychess[teamid][''..v.y..'_'..v.x]['item'])
				_G.mychess[teamid][''..v.y..'_'..v.x]['item'] = {}
			end
			

			_G.unit[teamid][v.y..'_'..v.x] = 1
			--添加战斗技能
			if string.find(v.chess,'rubick') ~= nil and v.rubick_a ~= nil then
				if x:FindAbilityByName(v.rubick_a) == nil then
					AddAbilityAndSetLevel(x,v.rubick_a,0)
					x.steal_ability = v.rubick_a
					if v.rubick_range ~= nil and v.rubick_range > 210 then
						if x:Script_GetAttackRange() > 410 then
							AddAbilityAndSetLevel(x,'attackrange_600',1)
						else
							AddAbilityAndSetLevel(x,'attackrange_400',1)
						end
					end
				end
			elseif _G.chess_ability_list[x:GetUnitName()] ~= nil then
				local a = _G.chess_ability_list[x:GetUnitName()]
				if x:FindAbilityByName(a) == nil then
					AddAbilityAndSetLevel(x,a,0)
				end

				if a == 'lc_qianggong' and x.press_count ~= nil and x.press_count > 0 then
					SetPressStack(x)
				end
				if x.track_money_count ~= nil and x.track_money_count > 0 then
					SetTrackMoneyStack(x)
				end
			end

			--播放后续动画
			if animation_info.tp_sound ~= nil then
				EmitSoundOn(animation_info.tp_sound,x)
			end
			if animation_info.animation_modifier ~= nil then
				BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
			end
			if animation_info.end_effect ~= nil then
				play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,x,3)
			end

			-- CheckChess(teamid)
		end)
	end)
end
function SaveItem(teamid,uindex,cb)
	-- if cb ~= nil then
	-- 	Timers:CreateTimer(0.5,function()
	-- 		cb()
	-- 	end)
	-- end

	local thischess = nil
	if uindex == nil then
		if cb ~= nil then
			cb()
		end
		return
	end
	local unit = EntIndexToHScript(uindex)
	if unit == nil or unit:IsNull() == true or unit.is_tuihuaed == true or unit.is_youhun == true then
		if cb ~= nil then
			cb()
		end
		return
	end
	if _G.mychess[teamid] == nil then
		if cb ~= nil then
			cb()
		end
		return
	end
	--先清空物品table
	for _,c in pairs (_G.mychess[teamid]) do
		if c.index == uindex then
			c.item = {}
		end
	end
	--记录装备情况
	for slot=0,9 do
		if unit:GetItemInSlot(slot)~= nil then
			local item = unit:GetItemInSlot(slot)
			local name = unit:GetItemInSlot(slot):GetAbilityName()
			if name ~= 'item_null' then
				local charges = unit:GetItemInSlot(slot):GetCurrentCharges()
				if unit.is_summoned == true and unit.is_fuhuo ~= true then
					--召唤物
					if item:IsPermanent() == false then
						--消耗品： 按charges个数丢出来
						for i=1,charges do
							local newItem = CreateItem( name, unit, unit )
							local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
							local dropRadius = RandomFloat( 50, 200 )
							newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
						end
					else
						--永久物品： 丢出来
						local newItem = CreateItem( name, unit, unit )
						local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
						local dropRadius = RandomFloat( 50, 200 )
						newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
					end
				else
					--非召唤物
					for i,v in pairs(_G.mychess[teamid]) do
						if v.index == uindex then
							if item:IsPermanent() == false then
								--消耗品： 丢出来
								for i=1,charges do
									if name ~= 'item_null' then
										local newItem = CreateItem( name, unit, unit )
										local drop = CreateItemOnPositionForLaunch(unit:GetAbsOrigin(), newItem )
										local dropRadius = RandomFloat( 50, 200 )
										newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, unit:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
									end
								end
							else
								table.insert(v.item,name)
							end
						end
					end
				end
			end
		end
	end
	if cb ~= nil then
		cb()
	end
end
function TriggerCombineHand(h,chess)
	if string.find(chess,'11') ~= nil or h.is_auto_combine ~= 1 then
		return
	end
	local have_exist_count,chess1,chess2,chess3 = Find2SameChessInHandOrOnBoard(h,chess)
	if have_exist_count >= 3 and chess1 ~= nil and chess2 ~= nil and chess3 ~= nil then
		CombineChessPlus({[1] = chess1,[2] = chess2, [3] = chess3},chess..'1')
	end
end
--在队伍的等待区域创建一个指定的棋子
function CreateChessInHand(h,chess,particle,spawn_dialog,force_index)
	if spawn_dialog == nil then
		spawn_dialog = 'spawn'
	end
	local team_id = h.team_id
	local p = particle or "particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ribbon_bright.vpcf"
	local index = FindEmptyHandSlot(team_id)
	if index == nil then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_hand_full"
		})
		return
	end
	if force_index ~= nil then
		index = force_index
	end
	local x = CreateUnitByName(chess,HandIndex2Vector(team_id,index),true,nil,nil,team_id)
	if x == nil then
		return
	end
	x:SetMana(0)
	SetChessSpecialLook(x)
	if spawn_dialog ~= 'nil' then
		PlayChessDialogue(x,spawn_dialog)
	end

	_G.hand[team_id][index] = 1
	if h.hand_entities == nil then
		h.hand_entities = {}
	end
	h.hand_entities[index] = x

	x:SetForwardVector(Vector(0,1,0))
	x.hand_index = index
	x.team_id = team_id
	
	AddAbilityAndSetLevel(x,'root_self')
	AddAbilityAndSetLevel(x,'jiaoxie_wudi')

	play_particle(p,PATTACH_ABSORIGIN_FOLLOW,x,5)

	--添加战斗技能
	if _G.chess_ability_list[x:GetUnitName()] ~= nil then
		local a = _G.chess_ability_list[x:GetUnitName()]
		if x:FindAbilityByName(a) == nil then
			AddAbilityAndSetLevel(x,a,0)
		end
	end
	return x
end
function RecallChess(keys)
	--撤回手牌
	local picked_chess = keys.target
	local caster = keys.caster
	if IsUnitExist(picked_chess) == false then
		return
	end
	if picked_chess:GetUnitName() == 'placeholder' or picked_chess:GetUnitName() == 'egg' then
		return
	end
	if picked_chess.y ~= nil and picked_chess.y > 4 then
		return
	end
	local team_id = picked_chess.team_id
	local origin_x = picked_chess.x
	local origin_y = picked_chess.y
	
	if picked_chess.is_removing == true then
		return
	end

	CancelPickChess(caster)

	if picked_chess.hand_index ~= nil then
		--跳上去
		local origin_pos = HandIndex2Vector(team_id, picked_chess.hand_index)
		local chess_pos_type,x1,y1,_ = GetTargetPositionType(origin_pos, caster, team_id)

		local target_pos = nil
		for _,j in pairs({0,1,-1,2,-2,3,-3,4,-4}) do
			for i=1,4 do
				if IsBlocked(x1+j,i,team_id) == false and target_pos == nil then
					target_pos = XY2Vector(x1+j,i,team_id)
				end
			end
		end
		if target_pos and caster ~= nil and caster:IsNull() == false and caster:GetOwner() ~= nil then
			caster.picked_chess = picked_chess
			DAC:OnPickChessPosition({
				caster = caster,
				x = target_pos.x,
				y = target_pos.y,
				z = target_pos.z,
				player_id = caster:GetOwner():GetPlayerID(),
				PlayerID = caster:GetOwner():GetPlayerID(),
			})
		end
		return
	end

	local target_index = FindEmptyHandSlot(team_id)
	
	if target_index == nil then
		--手牌已经满了
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_hand_is_full"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end

	_G.mychess[team_id][''..origin_y..'_'..origin_x] = nil
	_G.unit[team_id][''..origin_y..'_'..origin_x] = nil
	_G.hand[team_id][target_index] = 1
	if caster.hand_entities == nil then
		caster.hand_entities = {}
	end

	caster.hand_entities[target_index] = picked_chess
	for p,vp in pairs(GetValidChessOnBoard(team_id)) do
		if vp:entindex() == picked_chess:entindex() then
			table.remove(_G.to_be_destory_list[team_id],p)
		end
	end

	--跳过去	
	picked_chess:SetForwardVector((HandIndex2Vector(team_id,target_index) - Vector(0,1,0)):Normalized())
	picked_chess.hand_index = target_index
	picked_chess.team_id = team_id
	BlinkChessX({p=HandIndex2Vector(team_id,target_index),caster=picked_chess})
	if TeamId2Hero(team_id):HasModifier('modifier_item_conceal_prepare') or picked_chess:HasModifier('modifier_is_satyr') then
		RevealOneChess(picked_chess)
	end
	_G.population[team_id] = _G.population[team_id] - 1
	local position = HandIndex2Vector(team_id,target_index)
	local origin_p = picked_chess:GetAbsOrigin()
	Timers:CreateTimer((position-origin_p):Length2D()/1000+0.5,function()
		if IsUnitExist(picked_chess) == false then return end
		TriggerCombineHand(caster,picked_chess:GetUnitName())
	end)
	CheckChess(team_id)
	RemoveAbilityAndModifier(picked_chess,'is_enemy')

	--同步ui人口
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = _G.population_max[team_id],
		count = _G.population[team_id],
	})
	
	AddAbilityAndSetLevel(picked_chess,'root_self')
	AddAbilityAndSetLevel(picked_chess,'jiaoxie_wudi')

	--战斗技能变0
	if string.find(picked_chess:GetUnitName(),'rubick') ~= nil and picked_chess.steal_ability ~= nil then
		if picked_chess:FindAbilityByName(picked_chess.steal_ability) ~= nil then
			picked_chess:FindAbilityByName(picked_chess.steal_ability):SetLevel(0)
		end
	elseif _G.chess_ability_list[picked_chess:GetUnitName()] ~= nil then
		local a = _G.chess_ability_list[picked_chess:GetUnitName()]
		if picked_chess:FindAbilityByName(a) ~= nil then
			picked_chess:FindAbilityByName(a):SetLevel(0)
		end
	end

	StatClassCount(team_id)
end
function RandomRecallChess()
	for i=6,13 do
		CheckChess(i)
		local teamcount = _G.population[i]
		local teammax = _G.population_max[i]
		if teamcount > 0 and teammax < teamcount then
			local recall_amount = teamcount - teammax
			if recall_amount > 0 then
				CustomGameEventManager:Send_ServerToTeam(i,"mima",{
					key = GetClientKey(i),
					text = "text_mima_chess_max_recall"
				})
			end
			local recalled = 0
			Timers:CreateTimer(function()
				if recalled < recall_amount then
					local smallest_chess = _G.to_be_destory_list[1]
					local smallest_level = 4
					for k,v in pairs(_G.to_be_destory_list[i]) do
						local a_level = 1
						if string.find(v:GetUnitName(),'1') then
							a_level = 2
						end
						if string.find(v:GetUnitName(),'11') then
							a_level = 3
						end
						if a_level < smallest_level and v.combining ~= true then
							smallest_chess = v
							smallest_level = a_level
						end
					end
					local target_index = FindEmptyHandSlot(i)
					if target_index == nil then
						PlayParticleOnUnitUntilDeath({
							caster = smallest_chess,
							p = "particles/killstreak/killstreak_ti10_glitter_burst_hud.vpcf",
						})
						RemoveChess({
							caster = _G.teamid2hero[i],
							target = smallest_chess,
							force_remove = true,
							half_price = true,
						})
					else
						RecallChess({
							caster = _G.teamid2hero[i],
							target = smallest_chess
						})
						smallest_chess.is_in_battle = nil
					end
					recalled = recalled + 1
					return 0.05
				else
					return
				end
			end)
		end
		if GetYourChessCount(i) > 0 then
			ClearAllYourChess(i)
			DAC:OnTesterBoxChooseRound({ round = 4})
		end
	end
end
function PickChess(keys)
	local target = keys.target
	local caster = keys.caster
	local team = target.team_id

	CancelPickChess(caster)
	if target:GetUnitName() == 'placeholder' or target:GetUnitName() == 'egg' then
		return
	end

	if target.is_in_battle == true then
		return
	end

	AddAbilityAndSetLevel(target,'chess_picked')


	caster.picked_chess = target
	EmitSoundOn("ui.browser_click_right",caster)
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_cursor_hero_icon",{
		key = GetClientKey(caster:GetTeam()),
		unit = target:GetUnitName(),
		unit_index = target:entindex(),
	})
	caster:FindAbilityByName('pick_chess'):SetActivated(false)
	caster:FindAbilityByName('recall_chess'):SetActivated(false)
end
function CancelPickChess(u)
	if u.picked_chess ~= nil and u.picked_chess:IsNull() ~= true then
		u.picked_chess:RemoveAbility('chess_picked')
		u.picked_chess:RemoveModifierByName('modifier_chess_picked')
	end
	u.picked_chess = nil
	CustomGameEventManager:Send_ServerToTeam(u:GetTeam(),"show_cursor_hero_icon",{
		key = GetClientKey(u:GetTeam())
	})
	if u:FindAbilityByName('pick_chess') then
		u:FindAbilityByName('pick_chess'):SetActivated(true)
	end
	if GetTime().phase == GAME_PHASE_PREPARE and GetTime().left > 5 then
		if u:FindAbilityByName('recall_chess') then
			u:FindAbilityByName('recall_chess'):SetActivated(true)
		end
	end
end

function CancelPickBattleChess(u)
	if IsUnitExist(u) == false then return end
	if IsUnitExist(u.picked_chess) == false then return end
	if u.picked_chess.hand_index ~= nil then return  end

	if u.picked_chess ~= nil and u.picked_chess:IsNull() ~= true then
		u.picked_chess:RemoveAbility('chess_picked')
		u.picked_chess:RemoveModifierByName('modifier_chess_picked')
	end
	u.picked_chess = nil
	CustomGameEventManager:Send_ServerToTeam(u:GetTeam(),"show_cursor_hero_icon",{
		key = GetClientKey(u:GetTeam())
	})
	if u:FindAbilityByName('pick_chess') then
		u:FindAbilityByName('pick_chess'):SetActivated(true)
	end
	if GetTime().phase == GAME_PHASE_PREPARE and GetTime().left > 5 then
		if u:FindAbilityByName('recall_chess') then
			u:FindAbilityByName('recall_chess'):SetActivated(true)
		end
	end
end

--获取目标位置类型：0=不存在，1=有棋子可以交换位置，2=在场上，3=在蛋巢上
function GetTargetPositionType(pos, caster, team_id)
	local x = Vector2X(pos,team_id)
	local y = Vector2Y(pos,team_id)

	if x < 1 then x = 1 end
	if x > 8 then x = 8 end

	if _G.is_tester_mode == false then
		if y > 4 then y = 4 end
	end

	if y == 0 then y = 1 end
	if y < 0 then y = -1 end

	if x >= 1 and x <= 8 and y == -1 then
		--在手牌
		local target_chess = caster.hand_entities[x] 
		if target_chess ~= nil and target_chess:IsNull() == false and target_chess:GetUnitName() == 'placeholder' then
			return 0,nil,nil
		end
		if target_chess ~= nil and target_chess:IsNull() == false and target_chess:GetUnitName() == 'egg' then
			if target_chess.egg_chess == nil then
				return 3,x,-1,target_chess
			else
				return 0,nil,nil
			end
		end
		
		return 1,x,-1,target_chess
	elseif x >= 1 and x <= 8 and y >= 1 and y <= 8 then
		--在场上
		if y <= 4 then
			if _G.mychess[team_id][''..y..'_'..x] ~= nil then
				local target_chess_index = _G.mychess[team_id][''..y..'_'..x].index
				local target_chess = EntIndexToHScript(target_chess_index)
				return 2,x,y,target_chess
			else
				return 2,x,y,nil
			end
		else
			if _G.yourchess[team_id][''..y..'_'..x] ~= nil then
				local target_chess_index = _G.yourchess[team_id][''..y..'_'..x].index
				local target_chess = EntIndexToHScript(target_chess_index)
				return 2,x,y,target_chess
			else
				return 2,x,y,nil
			end
		end
	else
		return 0,nil,nil
	end
end
function RemoveChessFromHand(chess,caster)
	local team_id = chess.team_id
	local curr_index = chess.hand_index
	_G.hand[team_id][curr_index] = 0
	caster.hand_entities[curr_index] = nil
	chess.hand_index = nil
end
function RemoveChessFromBoard(chess,caster)
	local team_id = chess.team_id
	local x = chess.x
	local y = chess.y
	if x == nil or y == nil then return end
	if _G.is_tester_mode == true and y>4 then
		--单机测试模式的后四排
		_G.yourchess[team_id][''..y..'_'..x] = nil
		_G.unit[team_id][''..y..'_'..x] = nil
		chess.x = nil
		chess.y = nil
		chess.y_x = nil
		RemoveAbilityAndModifier(chess,"is_enemy")
	else
		--正常情况，棋子在前四排
		_G.mychess[team_id][''..y..'_'..x] = nil
		_G.unit[team_id][''..y..'_'..x] = nil
		chess.x = nil
		chess.y = nil
		chess.y_x = nil

		for p,vp in pairs(GetValidChessOnBoard(team_id)) do
			if vp:entindex() == chess:entindex() then
				table.remove(_G.to_be_destory_list[team_id],p)
			end
		end
	end
end
function AddChess2Hand(chess,hand_index,caster)
	if chess == nil or chess:IsNull() == true or caster == nil or caster:IsNull() == true then return end
	local team_id = chess.team_id
	_G.hand[team_id][hand_index] = 1
	chess.hand_index = hand_index
	caster.hand_entities[hand_index] = chess
	chess.y_x = nil
	chess.y = nil
	chess.x = nil
	chess.vchess_index = nil
	AddAbilityAndSetLevel(chess,'root_self')
	AddAbilityAndSetLevel(chess,'jiaoxie_wudi')

	--棋子的技能等级设为0
	if string.find(chess:GetUnitName(),'rubick') ~= nil and chess.steal_ability ~= nil then
		if chess:FindAbilityByName(chess.steal_ability) ~= nil then
			chess:FindAbilityByName(chess.steal_ability):SetLevel(0)
		end
	elseif _G.chess_ability_list[chess:GetUnitName()] ~= nil then
		local a = _G.chess_ability_list[chess:GetUnitName()]
		if chess:FindAbilityByName(a) ~= nil then
			chess:FindAbilityByName(a):SetLevel(0)
		end
	end
end
function AddChess2Board(chess,x,y,caster)
	local team_id = chess.team_id

	if _G.is_tester_mode == true and y>4 then
		--单机测试模式的后四排
		chess.y_x = ''..y..'_'..x
		chess.y = y
		chess.x = x
		chess.vchess_index = ''..y..'_'..x

		_G.unit[team_id][''..y..'_'..x] = 1

		_G.yourchess[team_id][''..y..'_'..x] = {
			index = chess:entindex(),
			chess = chess:GetUnitName(),
			item = {},
			x = x,
			y = y,
			press_count = chess.press_count,
			bh_gold = chess.bh_gold,
			track_money_count = chess.track_money_count,
			xuejingshi_count = chess.xuejingshi_count,
			buy_price = chess.buy_price,
		}
		if string.find(chess:GetUnitName(),'rubick') ~= nil and chess.steal_ability ~= nil then
			_G.yourchess[team_id][''..y..'_'..x]['rubick_a'] = chess.steal_ability
			if chess:FindAbilityByName('attackrange_600') ~= nil then
				_G.yourchess[team_id][''..y..'_'..x]['rubick_range'] = 600
			end
			if chess:FindAbilityByName('attackrange_400') ~= nil then
				_G.yourchess[team_id][''..y..'_'..x]['rubick_range'] = 400
			end
		end
		AddAbilityAndSetLevel(chess,"is_enemy")
	else
		--正常情况，棋子在前四排
		if _G.to_be_destory_list[team_id] == nil then _G.to_be_destory_list[team_id] = {} end
		table.insert(_G.to_be_destory_list[team_id],chess)

		chess.y_x = ''..y..'_'..x
		chess.y = y
		chess.x = x
		chess.vchess_index = ''..y..'_'..x

		_G.unit[team_id][''..y..'_'..x] = 1
		_G.mychess[team_id][''..y..'_'..x] = {
			index = chess:entindex(),
			chess = chess:GetUnitName(),
			item = {},
			x = x,
			y = y,
			press_count = chess.press_count,
			bh_gold = chess.bh_gold,
			track_money_count = chess.track_money_count,
			xuejingshi_count = chess.xuejingshi_count,
			buy_price = chess.buy_price,
		}
		if string.find(chess:GetUnitName(),'rubick') ~= nil and chess.steal_ability ~= nil then
			_G.mychess[team_id][''..y..'_'..x]['rubick_a'] = chess.steal_ability
			if chess:FindAbilityByName('attackrange_600') ~= nil then
				_G.mychess[team_id][''..y..'_'..x]['rubick_range'] = 600
			end
			if chess:FindAbilityByName('attackrange_400') ~= nil then
				_G.mychess[team_id][''..y..'_'..x]['rubick_range'] = 400
			end
		end
	end
end
function ClearAllYourChess(team_id)
	for _,v in pairs(_G.yourchess[team_id]) do
		local unit = EntIndexToHScript(v.index)
		if IsUnitExist(unit) then
			PlayParticleOnUnitUntilDeath({
				caster = unit,
				p = "particles/generic_gameplay/illusion_killed.vpcf",
			})
			_G.yourchess[team_id][''..unit.y..'_'..unit.x]['item'] = GetAllItemsInUnits({[1] = unit})
			_G.yourchess[team_id][''..unit.y..'_'..unit.x]['lastitem'] = GetAllItemsInUnits({[1] = unit})
			RemoveChess({
				caster = unit,
				target = unit,
				force_remove = true,
				is_sell = false,
			})
		end
	end
end
function BlinkChessX(keys)
	local caster = keys.caster
	if caster == nil or caster:IsNull() == true then
		return
	end

	local p = keys.p or caster:GetOrigin()
	local team_id = caster.at_team_id or caster.team_id
	local x = Vector2X(p,team_id)
	local y = Vector2Y(p,team_id)
	local position = p
	if not keys.ignore_grid then
		position = XY2Vector(x,y,team_id)
	end
	local sound = keys.sound
	local animation = keys.animation
	local blink_type = keys.blink_type or 'jump' -- run/jump/...
	local set_forward = keys.set_forward or false


	caster:Stop()

	if set_forward == true then
		caster:SetForwardVector((position - caster:GetAbsOrigin()):Normalized())
		caster:MoveToPosition(position)
	end

	if not keys.ignore_grid then
		caster.y_x = Vector2Y(position,team_id)..'_'..Vector2X(position,team_id)
		caster.y = Vector2Y(position,team_id)
		caster.x = Vector2X(position,team_id)
	end
	

	RemoveMovingModifier(caster)
	RemoveRoot(caster)

	local modifier = caster:AddNewModifier(caster,nil,"modifier_"..blink_type,
	{
		vx = position.x,
		vy = position.y,
		sound = sound,
		animation = animation,
		speed = keys.speed,
	})	

	--容错卡住的情况
	caster.blink_start_p = caster:GetOrigin()
	caster.blink_stop_count = 0
	Timers:CreateTimer(0.1,function()
		if IsUnitExist(caster) == false or caster:GetOrigin() == nil or caster.blink_start_p == nil or caster.is_moving ~= true then
			return
		end
		local blink_p = caster:GetOrigin()
		if (blink_p - caster.blink_start_p):Length2D() < 5 then
			caster.blink_stop_count = caster.blink_stop_count + 1
		else
			caster.blink_stop_count = 0
		end
		caster.blink_start_p = blink_p
		if caster.blink_stop_count > 100 then
			BlinkChessX({
				caster = caster,
				p = p,
				sound = sound,
				animation = animation,
				blink_type = blink_type,
			})
			return
		end
		return 0.1
	end)

	return (position-caster:GetOrigin()):Length2D()/1000
end
function TransferChess(keys)
	local target = keys.target
	local caster = keys.caster
	local position_1 = target:GetAbsOrigin()
	local team_id = target.team_id
	local x_1 = Vector2X(position_1,team_id)
	local y_1 = Vector2Y(position_1,team_id)

	local ally_team_id = GetP2Ally(team_id)
	if ally_team_id == nil then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_find_ally"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end
	if string.find(target:GetUnitName(),'chess_') == nil then
		return
	end
	if target.is_removing == true then
		return
	end
	if target.hand_index == nil then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_transfer_battle_chess"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end
	local ally_hand_index = FindEmptyHandSlot(ally_team_id)
	if ally_hand_index == nil then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_ally_hand_full"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end
	if caster:GetMana() < target:GetLevel()*2 then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_no_mana"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		return
	end

	CancelPickChess(caster)
	target.is_removing = true    
	local mama_cost = target:GetLevel()*2
	CostMana(caster,mama_cost)
	EmitSoundOn("courier.transfer_chess",caster)

	_G.hand[team_id][target.hand_index] = 0
	caster.hand_entities[target.hand_index] = nil

	local position_2 = HandIndex2Vector(ally_team_id,ally_hand_index)
	local x_2 = Vector2X(position_2,ally_team_id)
	local y_2 = Vector2Y(position_2,ally_team_id)
	local ally_hero = TeamId2Hero(ally_team_id)

	_G.hand[ally_team_id][ally_hand_index] = 1
	if ally_hero.hand_entities == nil then
		ally_hero.hand_entities = {}
	end
	ally_hero.hand_entities[ally_hand_index] = target
	target.hand_index = ally_hand_index
	target.team_id = ally_team_id
	target.y_x = nil
	target.y = nil
	target.x = nil
	target:SetTeam(ally_team_id)
	--跳过去
	target.transfer_chess = true
	target:SetForwardVector((HandIndex2Vector(ally_team_id,ally_hand_index) - target:GetAbsOrigin()):Normalized())

	--头上的特效
	play_particle("particles/econ/events/ti9/high_five/high_five_lvl1_overhead.vpcf",PATTACH_OVERHEAD_FOLLOW,target,8)

	BlinkChessX({p=HandIndex2Vector(ally_team_id,ally_hand_index),caster=target})
	AddAbilityAndSetLevel(target,'root_self')
	AddAbilityAndSetLevel(target,'jiaoxie_wudi')

	if IsUnitExist(ally_hero) then
		CourierCP(caster, ally_hero)
	end
	
	CustomGameEventManager:Send_ServerToTeam(ally_team_id,"chat_bubble_player_board",{
		key = GetClientKey(ally_team_id),
		player_from = caster:GetPlayerID(),
		player_to = TeamId2Hero(ally_team_id):GetPlayerID(),
		text = 'DOTA_Tooltip_ability_transfer_chess',
		chess = target:GetUnitName(),
		is_vip = caster.is_vip,
	})
	CustomGameEventManager:Send_ServerToTeam(team_id,"chat_bubble_player_board",{
		key = GetClientKey(team_id),
		player_from = caster:GetPlayerID(),
		player_to = TeamId2Hero(ally_team_id):GetPlayerID(),
		text = 'DOTA_Tooltip_ability_transfer_chess',
		chess = target:GetUnitName(),
		is_vip = caster.is_vip,
	})
end
function RemoveChess(keys)
	local target = keys.target
	local caster = keys.caster
	local position = target:GetAbsOrigin()
	local team_id = target.team_id or target:GetTeam()
	local x = Vector2X(position,team_id)
	local y = Vector2Y(position,team_id)
	if team_id == nil then return end
	local extra_time = 0
	if GetCurrMapInfo().is_2p == true then
		extra_time = 5
	end

	-- if string.find(target:GetUnitName(),'chess_') == nil then
	-- 	return
	-- end

	if IsUnitExist(target) == false or target.is_removing == true then
		return
	end	
	if keys.force_remove ~= true then
		if (GetTime().phase == GAME_PHASE_BATTLE and target.hand_index == nil) or (GetTime().phase == GAME_PHASE_PREPARE and GetTime().left < 2 and target.hand_index == nil) then
			CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
				key = GetClientKey(caster:GetTeam()),
				text = "text_mima_cannot_delete_battle_chess"
			})
			EmitSoundOn("General.CastFail_NoMana",keys.caster)
			return
		end
	end
	if (keys.is_sell == nil or keys.is_sell == true) and target:GetUnitName() ~= 'egg' then
		PlaySendMoneyEffect(target,caster)

		EmitSoundOn("dac.remove_chess",caster)
		if _G.chess_2_mana[GetChessTypeName(target)] == 5 and FindValueInTable(_G.chess_list_by_mana[5],GetChessTypeName(target)) == false then
		else
			AddAChessToChessPool(target:GetUnitName())
		end
	end

	local is_removing_hand = false
	if target.hand_index == nil then
		if target.y ~= nil and target.y > 4 then
			if keys.force_remove ~= true then
				_G.yourchess[team_id][target.y_x] = nil
			end
		else
			if target.y_x ~= nil then
				_G.mychess[team_id][target.y_x] = nil
			end
		end
		if _G.population[team_id] ~= nil then
			_G.population[team_id] = _G.population[team_id] - 1
		end

		CheckChess(team_id)
		--同步ui人口
		CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
			key = GetClientKey(team_id),
			max_count = _G.population_max[team_id],
			count = _G.population[team_id],
		})
	else
		is_removing_hand = true
		_G.hand[team_id][target.hand_index] = 0
		caster.hand_entities[target.hand_index] = nil
	end
	RemoveFromToBeDestroyList(target)
	if target.y_x ~= nil then
		_G.unit[team_id][target.y_x] = nil
	end
	CancelPickChess(caster)

	local children = target:GetChildren()
    for k,child in pairs(children) do
       if child:IsNull() == false and child:GetClassname() == "dota_item_wearable" then
           child:RemoveSelf()
       end
    end
	target.is_removing = true    
    AddAbilityAndSetLevel(target,'no_minimap_icon')
	target:SetModelScale(0.0001)
	AddAbilityAndSetLevel(target,'no_hp_bar')
	RemoveAbilityAndModifier(target,'act_teleport')

	--是蛋，孵化出棋子
	if target:GetUnitName() == 'egg' and target.egg_chess ~= nil then
		local count = target.egg_chess_count or 1
		local egg_chess = target.egg_chess
		local egg_chess_ori = egg_chess
		local left_count = 0

		if string.find(egg_chess,'ssr') == nil then
			left_count = count - 1
			if count >= 3 then
				egg_chess = egg_chess..'1'
				left_count = count - 3
			end
			if count >= 9 then
				egg_chess = egg_chess..'1'
				left_count = count - 9
			end
		end
		if left_count > 0 then
			--把left_count个egg_chess_ori洗回
			for i=1,left_count do
				AddAChessToChessPool(egg_chess_ori)
			end
		end

		if egg_chess == 'chess_io11' then
			egg_chess = _G.chess_list_by_mana_gold[RandomInt(1,table.maxn(_G.chess_list_by_mana_gold))]..'11'
		end

		

		play_particle("effect/egg/break.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
		EmitSoundOn("egg.break",target)

		Timers:CreateTimer(0.1,function()
			local chess = CreateChessInHand(caster,egg_chess,nil,nil,target.hand_index)
			Timers:CreateTimer(1,function()
				if egg_chess == 'chess_meepo11' then
					local chess2 = CreateChessInHand(caster,egg_chess,nil,nil,nil)
				end
			end)
			--发弹幕：孵化棋子
			CustomGameEventManager:Send_ServerToAllClients("bullet",{
				player_id = caster:GetPlayerID(),
				vip = caster.is_vip,
				win_streak = caster.win_streak or 0,
				target = egg_chess,
				pre_item = 'item_egg',
			})
		end)
	end

	if keys.is_sell == nil or keys.is_sell == true then
		local price = target:GetLevel()
		if target.buy_price ~= nil then
			price = target.buy_price
		end

		if keys.half_price ~= nil and keys.half_price == true then
			price = math.floor(price / 2)
		end

		if target.track_money_count ~= nil and target.track_money_count > 0 then
			price = price + tonumber(target.track_money_count)
		end
		
    	AddMana(caster, price)
    	if tonumber(target.track_money_count or 0) > 0 then
	    	AddTotalMoneyStat(caster:GetPlayerID(),tonumber(target.track_money_count))
	    end

		target.track_money_count = 0

	    --装备掉出来
		for slot=0,9 do
			if target:GetItemInSlot(slot)~= nil then
				local name = target:GetItemInSlot(slot):GetAbilityName()
				local charges = target:GetItemInSlot(slot):GetCurrentCharges()
				if target:GetItemInSlot(slot):IsPermanent() == false then
					for i=1,charges do
						if name ~= nil and name ~= 'item_null' then
							if name == 'item_silingshu_2' or name == 'item_silingshu_3' then
								name = 'item_silingshu'
							end
							DropItemAppointed(caster,target,name)
						end
					end
				else
					if name ~= nil and name ~= 'item_null' then
						if name == 'item_silingshu_2' or name == 'item_silingshu_3' then
							name = 'item_silingshu'
						end
						DropItemAppointed(caster,target,name)
					end
				end
			end
		end
	end

	local last_chess = false
	if FindEmptyHandSlot(team_id) == 1 then
		last_chess = true
	end
	Timers:CreateTimer(3,function()
		if target ~= nil and target:IsNull() == false then target:Destroy() end
	end)

	if is_removing_hand == false then
		StatClassCount(team_id)
	end
	local level_one_chess = FindLevelOneChess(caster)

	CustomGameEventManager:Send_ServerToTeam(team_id,"show_gold",{
		key = GetClientKey(team_id),
		gold = caster:GetMana(),
		lose_streak = caster.lose_streak or 0,
		win_streak = caster.win_streak or 0,
		level_one_chess = level_one_chess,
	})
end
--触发team_id的场地中i,j这个格子的棋子合成
function TriggerChessCombineAtGrid(i,j,team_id,is_move)
	--找到这个格子上的棋子（obj）
	local curr_chess = _G.mychess[team_id][j..'_'..i]
	if curr_chess == nil then
		return
	end
	local chess_index = curr_chess.index
	local chess = EntIndexToHScript(chess_index)
	local chess_name = chess:GetUnitName()

	--检测是否有2巫师帮助德鲁伊合成
	local wizard_count = GetWizardCount(team_id)
	--在mychess中找到两个跟chess名字一样的chess obj：u1，u2
	local u1 = nil
	local u2 = nil
	for u,v in pairs(_G.mychess[team_id]) do
		if u1 == nil and v.index ~= chess_index and v.chess == chess_name and v.combining ~= true then
			u1 = v
		elseif u2 == nil and v.index ~= chess_index and v.chess == chess_name and v.combining ~= true then
			u2 = v
		end
	end
	local druid_count = GetDruidCount(team_id)
	if wizard_count >= 2 and druid_count >= 3 then
		druid_count = druid_count + 1
	end
	if wizard_count >= 3 and druid_count == 2 then
		druid_count = druid_count + 1
	end

	--合成
	if u1 ~= nil and chess:FindAbilityByName('is_druid') ~= nil and EntIndexToHScript(u1.index):GetUnitName() == chess_name and string.find(chess_name,'1') == nil and druid_count >= 2 then
		--德鲁伊（2）：两个一样的1星可以合
		if u1.chess == 'chess_eh' and curr_chess.chess == 'chess_eh' then
			AddTotalMoneyStat(TeamId2Hero(team_id):GetPlayerID(),1)
		end
		CombineChessPlus({[1] = curr_chess,[2] = u1})
	elseif u1 ~= nil and EntIndexToHScript(chess_index):FindAbilityByName('is_druid') ~= nil and EntIndexToHScript(u1.index):GetUnitName() == chess_name and string.find(chess_name,'11') == nil and druid_count >= 4 then
		--德鲁伊（4）：两个一样的2星可以合
		-- if u1.chess == 'chess_eh1' and curr_chess.chess == 'chess_eh1' then
		-- 	AddTotalMoneyStat(TeamId2Hero(team_id):GetPlayerID(),1)
		-- end
		CombineChessPlus({[1] = curr_chess,[2] = u1})
	elseif u1 ~=nil and u2 ~=nil and EntIndexToHScript(u2.index):GetUnitName() == chess_name and EntIndexToHScript(u1.index):GetUnitName() == chess_name and string.find(chess_name,'11')  == nil then
		--普通情况：三个一样的可以合
		-- CombineChess(curr_chess,u1,u2)
		CombineChessPlus({[1] = curr_chess,[2] = u1,[3] = u2})
	else
		--不能合成：如果是小精灵，看看能不能合
		if chess_name == 'chess_io' then
			--找两个一样的一星就能合 一星棋子名字..'1'
			local io_u1,io_u2 = Find2SameChessByIO(team_id,1,i,j)

			if io_u1 ~= nil and io_u2 ~= nil then
				-- CombineChess(curr_chess,io_u1,io_u2,(io_u1.chess..'1'))
				CombineChessPlus({[1] = curr_chess,[2] = io_u1,[3] = io_u2},(io_u1.chess..'1'))
			else
				--如果有2德鲁伊，找一个1星德就能合
				if druid_count >= 2 then
					local io_ud1 = Find1ChessByIO(team_id,1,i,j)
					if io_ud1 ~= nil then
						-- CombineChess(curr_chess,io_ud1,nil,(io_ud1.chess..'1'))
						CombineChessPlus({[1] = curr_chess,[2] = io_ud1,},(io_ud1.chess..'1'))
					end
				end
			end
		end
		if chess_name == 'chess_io1' then
			--找两个一样的二星就能合 二星棋子名字..'1'
			local io_u1,io_u2 = Find2SameChessByIO(team_id,2,i,j)
			if io_u1 ~= nil and io_u2 ~= nil then
				-- CombineChess(curr_chess,io_u1,io_u2,(io_u1.chess..'1'))
				CombineChessPlus({[1] = curr_chess,[2] = io_u1,[3] = io_u2,},(io_u1.chess..'1'))
			else
				--如果有4德鲁伊，找一个2星德就能合
				if druid_count >= 4 then
					local io_ud2 = Find1ChessByIO(team_id,2,i,j)
					if io_ud2 ~= nil then
						-- CombineChess(curr_chess,io_ud2,nil,(io_ud2.chess..'1'))
						CombineChessPlus({[1] = curr_chess,[2] = io_ud2},(io_ud2.chess..'1'))
					end
				end
			end
		end
	end
end
--为小精灵找两个指定level星级的相同棋子。如果有多组，优先找小精灵的io_target，其次找费用最高的
function Find2SameChessByIO(team_id,level,x,y)
	local c1,c2
	local max_cost = 0
	local io = EntIndexToHScript(_G.mychess[team_id][''..y..'_'..x].index)

	for _,v1 in pairs(_G.mychess[team_id]) do
		if v1 ~= nil and v1.chess ~= 'chess_io' and v1.chess ~= 'chess_io1' and v1.combining ~= true and GetChessNameStar(v1.chess) == level then
			for _,v2 in pairs(_G.mychess[team_id]) do
				if v2 ~= nil and v2.index ~= v1.index and v2.chess ~= 'chess_io' and v2.chess ~= 'chess_io1' and v2.combining ~= true and GetChessNameStar(v2.chess) == level and v1.chess == v2.chess then

					local v1_chess = EntIndexToHScript(v1.index)
					local v2_chess = EntIndexToHScript(v2.index)
					local v1_cost = _G.chess_2_mana[GetChessTypeName(v1_chess)]
					local v2_cost = _G.chess_2_mana[GetChessTypeName(v2_chess)]
					if io.io_target_index ~= nil and v1.index == io.io_target_index then
						v1_cost = 999
					end
					if io.io_target_index ~= nil and v2.index == io.io_target_index then
						v2_cost = 999
					end

					if max_cost < v1_cost then
						c1 = v1
						c2 = v2
						max_cost = v1_cost
					end
					if max_cost < v2_cost then
						c1 = v1
						c2 = v2
						max_cost = v2_cost
					end
				end
			end
		end
	end
	return c1,c2
end
--为小精灵找一个指定level星级的德鲁伊棋子。如果有多组，优先找小精灵的io_target，其次找费用最高的
function Find1ChessByIO(team_id,level,x,y)
	local c1
	local max_cost = 0
	local io = EntIndexToHScript(_G.mychess[team_id][''..y..'_'..x].index)

	for uuu,v1 in pairs(_G.mychess[team_id]) do
		if v1 ~= nil and v1.index ~= nil and v1.combining ~= true and EntIndexToHScript(v1.index):FindAbilityByName('is_druid') ~= nil then
			local v1_chess = EntIndexToHScript(v1.index)
			if v1 ~= nil and GetChessStar(v1_chess) == level then
				local v1_cost = _G.chess_2_mana[GetChessTypeName(v1_chess)]
				if io.io_target_index ~= nil and v1.index == io.io_target_index then
					v1_cost = 999
				end
				if max_cost < v1_cost then
					c1 = v1
					max_cost = v1_cost
				end
			end
		end
	end
	return c1
end
function DrawAChessFromChessPool(cost, table_11chess, table_ban_chess, table_ban_chess2,h,opp_lineup)
	local chess_name = nil
	local index = nil
	if opp_lineup ~= nil then
		--从招募池opp_lineup抽牌
		chess_name = opp_lineup[RandomInt(1,table.maxn(opp_lineup))]
		chess_name = GetChessBaseName(chess_name)
		if FindChessCountInChessPool(chess_name) ~= 0 then
		-- if chess_name then
			--抽到了
			index = -1
		else
			--没抽到
			return nil
		end
	else
		--初始化1/2/3/4/5费棋子非气值
		if h.cost_n_table == nil then
			h.cost_n_table = {
				[1] = nil,
				[2] = nil,
				[3] = nil,
				[4] = nil,
				[5] = nil,
			}
		end
		for i=1,5 do
			if h.cost_n_table[i] == nil then
				h.cost_n_table[i] = {}
				for _,chess in pairs(_G.chess_list_by_mana[i]) do
					h.cost_n_table[i][chess] = 0
				end
			end
		end

		--检测非气阈值是否达到
		local all_count = 0
		local all_type = 0
		local chess_n_table = h.cost_n_table[cost]
		for _,chess_count in pairs(chess_n_table) do
			all_count = all_count + chess_count
			all_type = all_type + 1 
		end
		local unluckykey = all_count/all_type
		if unluckykey > (_G.CHESS_AFRICA_VALUE[cost] or 1) then
			local least_chess_count = 999
			local least_chess = nil
			local zerocount = 0
			for chess,count in pairs(chess_n_table) do
				if count == 0 then
					zerocount = zerocount + 1
				end
				if count < least_chess_count and (h.synergy_banned == nil or FindValueInTable(_G.chess_list_by_synergy[h.synergy_banned],chess) == false) then
					least_chess = chess
					least_chess_count = count
				end
			end
			h.cost_n_table[cost][least_chess] = h.cost_n_table[cost][least_chess] + 1
			if zerocount <= 1 then
				for chess,_ in pairs(chess_n_table) do
					h.cost_n_table[cost][chess] = 0
				end
			end
			local chess_exist = FindValueInTable(_G.chess_pool[cost],least_chess)
			local check_available = true
			if FindValueInTable(table_11chess,least_chess) == true or FindValueInTable(table_ban_chess,least_chess) == true or FindValueInTable(table_ban_chess2,least_chess) == true then
				check_available = false
			end
			local ban_available = true
			if h.synergy_banned ~= nil and FindValueInTable(_G.chess_list_by_synergy[h.synergy_banned],least_chess) == true then
				ban_available = false
			end
			if chess_exist == true and check_available == true and ban_available == true then
				RemoveOneKeyInTable(_G.chess_pool[cost],least_chess)
				return least_chess
			end			
		end

		if table_11chess == nil then
			table_11chess = {}
		end
		if table_ban_chess == nil then
			table_ban_chess = {}
		end
		if table_ban_chess2 == nil then
			table_ban_chess2 = {}
		end
		if _G.chess_pool[cost] == nil or table.maxn(_G.chess_pool[cost])<1 then
			--棋库空了
			return nil
		end
		index = RandomInt(1,table.maxn(_G.chess_pool[cost]))
		chess_name = _G.chess_pool[cost][index]
	end

	if FindValueInTable(table_11chess,chess_name) == true then
		return nil
	end
	-- D+
	if FindValueInTable(table_ban_chess,chess_name) == true then
		return nil
	end
	-- D++
	-- if FindValueInTable(table_ban_chess2,chess_name) == true then
	-- 	return nil
	-- end

	--屏蔽的种族/职业
	if h.synergy_banned ~= nil and (FindValueInTable(_G.chess_list_by_synergy[h.synergy_banned],chess_name) == true or FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman[h.synergy_banned],chess_name) == true or FindValueInTable(_G.chess_list_by_synergy_ban_unavailable[h.synergy_banned],chess_name) == true) then
		return nil
	end

	--防非值+1
	if cost ~= nil and h.cost_n_table ~= nil and h.cost_n_table[cost] ~= nil and h.cost_n_table[cost][chess_name] ~= nil then
		h.cost_n_table[cost][chess_name] = h.cost_n_table[cost][chess_name] + 1
	end
	if index == -1 then
		--从招募池opp_lineup抽牌
		RemoveChessFromChessPool(chess_name) --从公共卡池扣除
		RemoveOneKeyInTable(opp_lineup,chess_name) --从招募池扣除
	else
		--从公共卡池抽牌
		table.remove(_G.chess_pool[cost],index) --从公共卡池扣除
	end
	return chess_name
end

function DrawAChessFromGoldPool(cost, table_11chess, table_ban_chess, table_ban_chess2, h)
	if table_11chess == nil then
		table_11chess = {}
	end
	if table_ban_chess == nil then
		table_ban_chess = {}
	end
	if table_ban_chess2 == nil then
		table_ban_chess2 = {}
	end

	local index = RandomInt(1,table.maxn(_G.chess_list_by_mana_gold))
	local chess_name = _G.chess_list_by_mana_gold[index]

	if FindValueInTable(table_11chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess2,chess_name) == true then
		return nil
	end
	if h.synergy_banned ~= nil and (FindValueInTable(_G.chess_list_by_synergy[h.synergy_banned],chess_name) == true or FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman[h.synergy_banned],chess_name) == true or FindValueInTable(_G.chess_list_by_synergy_ban_unavailable[h.synergy_banned],chess_name) == true) then
		return nil
	end
	return chess_name
end
function DrawAChessFromBlackPool(cost, table_11chess, table_ban_chess, table_ban_chess2, h)
	if table_11chess == nil then
		table_11chess = {}
	end
	if table_ban_chess == nil then
		table_ban_chess = {}
	end
	if table_ban_chess2 == nil then
		table_ban_chess2 = {}
	end
	local index = RandomInt(1,table.maxn(_G.chess_list_by_mana_black[cost]))
	local chess_name = _G.chess_list_by_mana_black[cost][index]

	if FindValueInTable(table_11chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess,chess_name) == true then
		return nil
	end
	if FindValueInTable(table_ban_chess2,chess_name) == true then
		return nil
	end
	if h.synergy_banned ~= nil and (FindValueInTable(_G.chess_list_by_synergy[h.synergy_banned],chess_name) == true or FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman[h.synergy_banned],chess_name) == true or FindValueInTable(_G.chess_list_by_synergy_ban_unavailable[h.synergy_banned],chess_name) == true) then
		return nil
	end
	return chess_name
end
function GetChessRank1Count(chess)
	local maxcount = 1
	if string.find(chess,'11') ~= nil then
		chess = string.sub(chess,1,-3)
		if FindValueInTable(_G.chess_list_by_druid,chess) then
			maxcount = 4
		else
			maxcount = 9
		end
	end
	if string.find(chess,'1') ~= nil then
		chess = string.sub(chess,1,-2)
		if FindValueInTable(_G.chess_list_by_druid,chess) then
			maxcount = 2
		else
			maxcount = 3
		end
	end
	return maxcount
end
function AddAChessToChessPool(chess)
	if string.find(chess,'ssr') then
		return
	end
	local destroy_info = CustomNetTables:GetTableValue( "chess_pool_table", "destroy_info" ) or {}
	local maxcount = GetChessRank1Count(chess)

	chess = GetChessBaseName(chess)
	
	--三种不会加回的棋子
	if FindValueInTable(destroy_info,chess) == true then
		return
	end
	for _,t in pairs(_G.chess_list_by_mana_black) do
		if FindValueInTable(t,chess) == true then
			return
		end
	end
	if FindValueInTable(_G.chess_list_by_mana_gold,chess) == true and FindValueInTable(_G.chess_list_by_mana[5],chess) == false then
		return
	end

	local special_piece = {'chess_io','chess_io1','chess_ember','chess_ember1','chess_ember11','chess_storm','chess_storm1','chess_storm11','chess_earth','chess_earth1','chess_earth11','chess_void','chess_void1','chess_void11'}
	local is_removed_piece = false
	if FindValueInTable(_G.chess_list_by_mana_gold,chess) ~= nil and FindValueInTable(_G.chess_list_by_mana[5],chess) == nil then
		is_removed_piece = true
	end
	for count = 1,maxcount do
		if _G.chess_2_mana[chess] ~= nil and FindValueInTable(_G.chess_list_ssr,chess) == false and FindValueInTable(special_piece,chess) == false and is_removed_piece == false then
			local cost = _G.chess_2_mana[chess]
			table.insert(_G.chess_pool[cost],chess)
		end
	end
end
--从某个玩家的手牌中寻找两个chess棋子，返回：有几个，第一个，第二个，第三个
function Find2SameChessInHand(caster,chess)
	if chess == 'chess_io1' or chess == 'chess_io' or chess == 'chess_ck_ssr' or chess == 'chess_nec_ssr' or chess == 'chess_ss_ssr' or chess == 'chess_om_ssr' then
		--2星小精灵不参与合成
		return 0,nil,nil,nil
	end
	local count = 0
	local chess1 = nil
	local chess2 = nil
	local chess3 = nil
	if caster ~= nil and caster.hand_entities ~= nil then
		for _,v in pairs(caster.hand_entities) do
			if IsUnitExist(v) == true and v:GetUnitName() == chess and v:FindAbilityByName('is_druid') == nil then
				count = count + 1
				if count == 1 then
					chess1 = v
				end
				if count == 2 then
					chess2 = v
				end
				if count == 3 then
					chess3 = v
				end
			end
		end
		return count,chess1,chess2,chess3
	else
		return 0,nil,nil,nil
	end
end
--进阶的棋子合成
--units是参与合成的棋子列表table，其中每一个棋子可以是unit，也可以是obj
function CombineChessPlus(units, advance_unit_name)
	for i,u in pairs(units) do
		if u.index ~= nil then
			units[i] = EntIndexToHScript(u.index)
		end
		units[i].combining = true
	end
	
	if units == nil or table.maxn(units) <= 1 or units[1] == nil then
		return
	end
	local team_id = units[1].team_id
	local hero = TeamId2Hero(team_id)

	local advance_unit_name = advance_unit_name or (units[1]:GetUnitName()..'1')

	if advance_unit_name == nil or advance_unit_name == 'dummy1' or advance_unit_name == 'placeholder1' or advance_unit_name == 'egg1' then
		return
	end

	if advance_unit_name == 'chess_io11' then
		advance_unit_name = _G.chess_list_by_mana_gold[RandomInt(1,table.maxn(_G.chess_list_by_mana_gold))]..'11'
	end
	
	--is_target_in_hand=true：要合在手牌
	--is_target_in_hand=false：合在unit[0]被视为的位置
	local is_target_in_hand = IsChessInHand(units[1]) 
	local hand_index = units[1].hand_index
	local p = units[1]:GetAbsOrigin()
	if units[1].hand_index == nil then
		p = XY2Vector(units[1].x,units[1].y,team_id)
	else
		p = HandIndex2Vector(team_id, units[1].hand_index)
	end
	local y = units[1].y
	local x = units[1].x

	--进阶合成：检查手牌/场上是否有2个advance_unit_name名字的棋子。
	--如果有，将他们也加入配件，并且合成advance_unit_name1
	local u1 = nil
	local u2 = nil

	--手牌
	local have_exist_count,u2,u1 = Find2SameChessInHandOrOnBoard(hero,advance_unit_name)

	local wizard_count = GetWizardCount(team_id)
	local druid_count = GetDruidCount(team_id)
	if wizard_count >= 2 and druid_count >= 3 then
		druid_count = druid_count + 1
	end
	if wizard_count >= 3 and druid_count == 2 then
		druid_count = druid_count + 1
	end

	if u2 ~= nil and u2:HasAbility('is_druid') and string.find(u2:GetUnitName(),'11') == nil and druid_count >= 4 then
		--德鲁伊（4）：两个一样的2星可以合
		table.insert(units,u2)
		advance_unit_name = advance_unit_name..'1'

		if is_target_in_hand == true and IsChessInHand(u2) == false then
			is_target_in_hand = false
			p = u2:GetAbsOrigin()
			y = u2.y
			x = u2.x
		end
	elseif u1 ~=nil and u2 ~=nil and string.find(u1:GetUnitName(),'11')  == nil then
		--普通情况：三个一样的可以合
		table.insert(units,u1)
		table.insert(units,u2)
		advance_unit_name = advance_unit_name..'1'

		if is_target_in_hand == true and IsChessInHand(u1) == false then
			is_target_in_hand = false
			p = u1:GetAbsOrigin()
			y = u1.y
			x = u1.x
		elseif is_target_in_hand == true and IsChessInHand(u2) == false then
			is_target_in_hand = false
			p = u2:GetAbsOrigin()
			y = u2.y
			x = u2.x
		end
	end

	if string.find(advance_unit_name,'11') ~= nil then
		_G.level3pieces[team_id] = _G.level3pieces[team_id] + 1
	end
	local chess_price = 1
	for k1,v1 in pairs(_G.chess_list_by_mana) do
		for k2,v2 in pairs(v1) do
			if string.find(advance_unit_name,v2) ~= nil then
				chess_price = k1
			end
		end
	end
	if _G.egg_quest == 'q003' and string.find(advance_unit_name,'1') ~= nil and chess_price == 5 then
		SetQuest(team_id,true)
	end
	if _G.egg_quest == 'q004' and string.find(advance_unit_name,'11') ~= nil and chess_price == 4 then
		SetQuest(team_id,true)
	end
	if _G.egg_quest == 'q011' and _G.level3pieces[team_id] >= 4 then
		SetQuest(team_id,true)
	end
	--=====================================================
	--至此已经确定了所有配件棋子，以及最终的合成品。可以开始合成了

	--收集低级棋子的press_count
	local total_press_count = 0
	local max_press_count = 0
	for i,u in pairs(units) do
		if IsUnitExist(u) == true then
			local pc = u.press_count
			if pc ~= nil and pc > 0 then
				total_press_count = total_press_count + pc
			end
			-- if pc ~= nil and pc > 0 and pc > max_press_count then
			-- 	max_press_count = pc
			-- end
		end
	end
	--收集低级棋子的track_money_count
	local total_track_money_count = 0
	for i,u in pairs(units) do
		if IsUnitExist(u) == true then
			local pc = u.track_money_count
			if pc ~= nil and pc > 0 then
				total_track_money_count = total_track_money_count + pc
			end
		end
	end
	--收集低级棋子的xuejingshi_count
	local total_xuejingshi_count = 0
	for i,u in pairs(units) do
		if IsUnitExist(u) == true then
			local pc = u.xuejingshi_count
			if pc ~= nil and pc > 0 then
				total_xuejingshi_count = total_xuejingshi_count + pc
			end
		end
	end

	--收集低级棋子的物品
	local items_table = GetAllItemsInUnits(units)

	--移除低级棋子
	for _,u in pairs(units) do
		if u.hand_index ~= nil then
			--在手牌
			_G.hand[team_id][u.hand_index] = 0
			hero.hand_entities[u.hand_index] = nil
		else
			--在棋盘
			_G.mychess[team_id][u.y_x] = nil
			_G.unit[team_id][u.y_x] = nil
			RemoveFromToBeDestroyList(u)
		end
		DestroyChessDelay(u,RandomFloat(2,3))
		-- if u ~= nil and u:IsNull() == false then u:Destroy() end
	end

	--创建合成的棋子
	local uu = CreateUnitByName(advance_unit_name, p,false,nil,nil,team_id) 
	--添加装备
	InitChessRemindedItem(uu, items_table)

	GiveItems2Unit(items_table,uu)

	SetChessSpecialLook(uu)
	uu:SetMana(0)

	-- RemindChess({
	-- 	caster = uu,
	-- 	big_duration = 0.5,
	-- })
	for _,u in pairs(units) do
		ProjectileManager:CreateTrackingProjectile( {
			Target = uu,
			Source = u,
			Ability = nil,
			EffectName = 'effect/combine_chess/1.vpcf',
			bDodgeable = false,
			bProvidesVision = false,
			iMoveSpeed = 800,
			iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION
		} )
	end


	--米波的特殊逻辑：3星送一只
	-- if IsKobold(advance_unit_name) == true and GetChessNameStar(advance_unit_name) == 3 then
	if advance_unit_name == 'chess_meepo11' then
		PlayChessDialogue(uu,'devided.1')
		Timers:CreateTimer(0.5,function()
			--创建狗棋子，播动画
			local cc = CreateChessInHand(TeamId2Hero(team_id),advance_unit_name,nil,'nil')
			if IsUnitExist(cc) == true then
				BlinkChessX({caster=cc,blink_type="breaksoil"})
				--发弹幕：合成棋子
				CustomGameEventManager:Send_ServerToAllClients("bullet",{
					player_id = TeamId2Hero(team_id):GetPlayerID(),
					vip = TeamId2Hero(team_id).is_vip,
					win_streak = TeamId2Hero(team_id).win_streak or 0,
					target = advance_unit_name,
				})
				Timers:CreateTimer(1,function()
					if IsUnitExist(cc) == true then
						PlayChessDialogue(cc,'devided.2')
					end
				end)
			end
		end)
	else
		PlayChessDialogue(uu,'merge')
	end

	uu.press_count = total_press_count
	uu.track_money_count = total_track_money_count
	uu.xuejingshi_count = total_xuejingshi_count

	-- EmitSoundOn("Loot_Drop_Stinger_Rare",uu)
	PlayCombineSound(uu)
	
	--给高级棋子添加棋子技能
	if _G.chess_ability_list[uu:GetUnitName()] ~= nil then
		local a = _G.chess_ability_list[uu:GetUnitName()]
		if uu:FindAbilityByName(a) == nil then
			AddAbilityAndSetLevel(uu,a,0)
		end
		if a == 'lc_qianggong' and uu.press_count ~= nil and uu.press_count > 0 then
			SetPressStack(uu)
		end
		if uu.track_money_count ~= nil and uu.track_money_count > 0 then
			SetTrackMoneyStack(uu)
		end
	end

	--添加星星特效
	ShowStarsOnChess(uu,5,'')

	if is_target_in_hand == false then
		--在棋盘
		table.insert(_G.to_be_destory_list[team_id],uu)
		_G.mychess[team_id][''..y..'_'..x] = {
			index = uu:entindex(),
			chess = uu:GetUnitName(),
			item = items_table,
			x = x,
			y = y,
			press_count = uu.press_count,
			bh_gold = uu.bh_gold,
			track_money_count = uu.track_money_count,
			xuejingshi_count = uu.xuejingshi_count,
		}
		_G.unit[team_id][''..y..'_'..x] = 1
		uu.y_x = ''..y..'_'..x
		uu.y = y
		uu.x = x
		uu.vchess_index = ''..y..'_'..x

		if TeamId2Hero(team_id):HasModifier('modifier_item_conceal_prepare') or uu:HasModifier('modifier_is_satyr') then
			ConcealOneChess(uu)
		end
	else
		--在手牌
		uu.hand_index = hand_index
		hero.hand_entities[hand_index] = uu
		_G.hand[team_id][hand_index] = 1
	end
	uu.team_id = team_id

	uu:SetForwardVector(Vector(0,1,0))
	
	

	AddAbilityAndSetLevel(uu,'root_self')
	AddAbilityAndSetLevel(uu,'jiaoxie_wudi')
	--合成特效
	play_particle("particles/generic_hero_status/hero_levelup.vpcf",PATTACH_ABSORIGIN_FOLLOW,uu,3)
	-- if string.find(uu:GetUnitName(),'11') then
	-- 	play_particle("particles/econ/events/ti9/ti9_drums_musicnotes.vpcf",PATTACH_OVERHEAD_FOLLOW,uu,3)
	-- else
	-- 	play_particle("particles/econ/events/ti9/ti9_drums_musicnotes_b.vpcf",PATTACH_OVERHEAD_FOLLOW,uu,3)
	-- end

	--重新计算人口
	CheckChess(team_id)

	--同步ui人口
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = _G.population_max[team_id],
		count = _G.population[team_id],
	})

	--发弹幕：合成棋子
	CustomGameEventManager:Send_ServerToAllClients("bullet",{
		player_id = TeamId2Hero(team_id):GetPlayerID(),
		vip = TeamId2Hero(team_id).is_vip,
		win_streak = TeamId2Hero(team_id).win_streak or 0,
		target = advance_unit_name,
	})

	--垄断契约，摧毁剩余同类棋子
	if GetChessNameStar(advance_unit_name) == 3 and TeamId2Hero(team_id):HasModifier('modifier_item_destroy_piece') then
		local base_chess = GetChessBaseName(advance_unit_name)
		MonopolizeAChessPiece(team_id, base_chess, uu)
		EmitGlobalSound("item.destroy_piece")
	end

	StatClassCount(team_id)
end

--【找目标或者格子】
--寻找目标，攻击
function FindAClosestEnemyAndAttack(u)
	if not IsUnitExist(u) then
		return 1
	end
	local current_target = u:GetAttackTarget()
	local new_target = nil
	local team_id = u.at_team_id or u.team_id
	local all_unit = GetValidChessOnBoard(team_id)
	local attack_range = u:Script_GetAttackRange()
	--优先0：触发大圣的技能，直接打完return
	if u:HasModifier('modifier_mk_ruyibangfa_stack') and u:GetAttackTarget() ~= nil then
		--大圣棒鸡
		local attack_count = GetAbilityKV(u:FindAbilityByName("mk_ruyibangfa"), "attack_count") or 4

		local count = u:FindModifierByName('modifier_mk_ruyibangfa_stack'):GetStackCount()
		if count >= attack_count and u:IsSilenced() == false and u:IsStunned() == false and u:IsFrozen() == false and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and u:HasModifier('modifier_vs_swap_debuff') == false and u:IsHexed() == false and u:IsCommandRestricted() == false and u:HasModifier("modifier_axe_berserkers_call") == false then
			u:RemoveModifierByName('modifier_mk_ruyibangfa_stack')
			if u:FindAbilityByName('monkey_king_boundless_strike') ~= nil then
				ExecuteOrderFromTable({
			 		UnitIndex = u:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
			 		TargetIndex = nil, --Optional.  Only used when targeting units
			 		AbilityIndex = u:FindAbilityByName('monkey_king_boundless_strike'):entindex(), --Optional.  Only used when casting abilities
			 		Position = u:GetAttackTarget():GetAbsOrigin(), --Optional.  Only used when targeting the ground
			 		Queue = 0, --Optional.  Used for queueing up abilities
			 	})
			end
			return 1.5
		end
	end
	--优先1：嘲讽
	if u.taunt_target ~= nil and IsUnitExist(u.taunt_target) and IsCanAttackTarget(u,u.taunt_target) then
		--有嘲讽目标，优先打嘲讽目标
		new_target = u.taunt_target
	end
	--优先2：猎人无论如何都找血最少的（排除低优先级）
	if new_target == nil and u:HasAbility('is_hunter') then
		local min_hp = 999999
		for _,v in pairs(all_unit) do
			if IsUnitExist(v) and v.team_id ~= u.team_id and IsCanAttackTarget(u,v)  then
				local h = v:GetHealth()
				if IsAttackLowPriority(v) then
					h = 99999
				end
				if h < min_hp then
					new_target = v
					min_hp = h
				end
			end
		end
	end
	--优先3：已经在打合适的目标
	if new_target == nil and IsUnitExist(current_target) and IsCanAttackTarget(u,current_target) and current_target:HasModifier('modifier_siren_song_debuff') == false and current_target:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(current_target) == false then
		new_target = current_target
	end
	--优先4：找最近的
	if new_target == nil then
		local closest_distance = 9999
		for _,v in pairs(all_unit) do
			if IsUnitExist(v) and v.team_id ~= u.team_id and IsCanAttackTarget(u,v) then
				local d = (v:GetAbsOrigin() - u:GetAbsOrigin()):Length2D()
				if IsAttackLowPriority(v) then
					d = attack_range
				end
				if d < closest_distance then
					new_target = v
					closest_distance = d
				end
			end
		end
	end

	--打	
	if IsUnitExist(new_target) then
		RemoveAbilityAndModifier(u,'jiaoxie')
		local newOrder = {
	 		UnitIndex = u:entindex(), 
	 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
	 		TargetIndex = new_target:entindex(), 
	 		Queue = 0 
	 	}
		ExecuteOrderFromTable(newOrder)
		return 1
	else
		return
	end
end
function GetClosestAvailableArea(x,y,team_id)
	local returnx = x
	local returny = y
	if y>4 then
		returny = 4
	elseif y<1 then
		returny = 1
	end
	if x>8 then
		returnx = 8
	elseif x<1 then
		returnx = 1
	end
	return {x = returnx, y =returny}
end
function GetClosestEmptyArea(x,y,team_id)
	for i=-1,1 do
		for j=-1,1 do
			if IsBlocked(x+i,y+j,team_id) == false then
				return {x = x+i, y = y+j}
			end
		end
	end
	return nil
end
function GetClosestEmptyHandIndex(index,team_id)
	local hero = TeamId2Hero(team_id)
	for _,i in pairs({0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7}) do
		if index+i >= 1 and index+i <= 8 and hero.hand_entities[index+i] == nil then
			return index+i
		end
	end
	return nil
end

--寻找我的下一跳位置
function FindNextSkipPosition(u)
	if HasEnemy(u) == false then
		return nil
	end
	local team_id = u.at_team_id or u.team_id
	local skip_postion = nil
	local skip_postion_alt = nil
	local skip_postion_new = nil
	local length2d = 99999
	local length2d_alt = 99999
	local pos1 = XY2Vector(u.x,u.y,team_id)

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			local priority = CheckPriorityForGrid(x,y,u)
			if priority >= 0 then
				local next_skip = IsGridCanReach(x,y,u)
				local check_length = (pos2-pos1):Length2D()
				if priority == 0 then
					check_length = 99998
				end
				if next_skip ~= nil and check_length < length2d then
					skip_postion = next_skip
					length2d = check_length
					if check_length < 200 then
						return skip_postion
					end
				end
				
				-- if next_skip ~= nil and check_length < length2d_alt and math.abs(u.x-x) == math.abs(u.y-y) and pos2 == IsGridCanReach(x,y,u) then
				-- 	skip_postion_alt = next_skip
				-- 	length2d_alt = check_length
				-- end
			end
		end
	end
	
	-- if skip_postion_alt ~= nil and (skip_postion_alt-skip_postion):Length2D() < 200 and (skip_postion_alt-pos1):Length2D() > 200 then
	-- 	skip_postion_new = skip_postion_alt
	-- else
	-- 	skip_postion_new = skip_postion
	-- end

	-- return skip_postion_new
	return skip_postion
end
function FindNextMonkEscapePosition(u)
	local team_id = u.at_team_id or u.team_id
	local skip_postion = nil
	local length2d = 99999
	local pos1 = XY2Vector(u.x,u.y,team_id)
	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			if IsEmptyGrid(team_id,x,y) and IsGridCanBeAttackedByEnemy(x,y,u) == false then
				if pos2 ~= nil and (pos2-pos1):Length2D() < length2d then
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end
function FindNextPriestEscapePosition(u)
	local team_id = u.at_team_id or u.team_id
	local skip_postion = nil
	local length2d = 99999
	local pos1 = XY2Vector(u.x,u.y,team_id)
	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			local enemy_team_id = 4
			if u:GetTeam() == 4 then
				enemy_team_id = u.at_team_id
			end
			if IsGridLonely4Team(team_id, x, y, enemy_team_id) == true then
				local next_skip = IsGridCanReach(x,y,u)
				if (next_skip ~= nil or (x==u.x and y==u.y)) and (pos2-pos1):Length2D() < length2d then
					skip_postion = next_skip
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end
function FindNearestChannelingWalkPosition(u)
	local team_id = u.at_team_id or u.team_id
	local skip_postion = nil
	local length2d = 99999
	local pos1 = XY2Vector(u.x,u.y,team_id)
	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			local enemy_team_id = 4
			if u:GetTeam() == 4 then
				enemy_team_id = u.at_team_id
			end
			if IsGridLonely4Team(team_id, x, y, enemy_team_id) == false then
				local next_skip = IsGridCanReach(x,y,u)
				if (next_skip ~= nil or (x==u.x and y==u.y))and (pos2-pos1):Length2D() < length2d then
					skip_postion = next_skip
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end

function CheckPriorityForGrid(x,y,u)
	--1是能攻击高优先级，0是能攻击低优先级，-1是不能攻击
	local team_id = u.at_team_id or u.team_id
	local attack_range = u:Script_GetAttackRange() or 210
	--遍历所有单位
	for _,enemy in pairs(GetValidChessOnBoard(team_id)) do
		if IsUnitExist(enemy) == true and enemy.team_id ~= u.team_id and IsCanAttackTarget(u,enemy,x,y) and IsAttackLowPriority(enemy) == false then
			return 1
		end
	end
	for _,enemy in pairs(GetValidChessOnBoard(team_id)) do
		if IsUnitExist(enemy) == true and enemy.team_id ~= u.team_id and IsCanAttackTarget(u,enemy,x,y) then
			return 0
		end
	end
	return -1
end
function IsGridCanReach(x,y,u)
	local team_id = u.at_team_id or u.team_id
	local pos1 = XY2Vector(u.x,u.y,team_id)
	local pos2 = XY2Vector(x,y,team_id)
	local pos = FindPath(pos1,pos2,team_id)
	if pos ~= nil then
		return pos
	else
		return nil
	end
end
function IsGridCanBeAttackedByEnemy(x,y,u)
	local team_id = u.at_team_id or u.team_id
	--遍历所有敌人
	for _,enemy in pairs(GetValidChessOnBoard(team_id)) do
		if IsUnitExist(enemy) == true and enemy.team_id ~= u.team_id and (XY2Vector(x,y,team_id) - enemy:GetAbsOrigin()):Length2D() < enemy:Script_GetAttackRange() + enemy:GetHullRadius() + u:GetHullRadius() then
			return true
		end
	end
	return false
end
function IsEmptyGrid(team,x,y)
	if _G.unit[team][y..'_'..x] == nil then
		return true
	else
		return false
	end
end
function FindCurrColFarthestCanAttackPosition(u)
	local team_id = u.at_team_id or u.team_id
	local y = u.y
	local i = u.x
	if u.team_id ~= 4 then
		for j=8,1,-1 do
			if _G.unit[team_id][j..'_'..i] == nil then
				for _,unit in pairs (GetValidChessOnBoard(team_id)) do
					if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() - unit:GetHullRadius() and j>y then
						return XY2Vector(i,j,team_id)
					end
				end
			end
		end
	else
		for j=1,8 do
			if _G.unit[team_id][j..'_'..i] == nil then
				for _,unit in pairs (GetValidChessOnBoard(team_id)) do
					if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() - unit:GetHullRadius() and j<y then
						return XY2Vector(i,j,team_id)
					end
				end
			end
		end
	end
end
--寻找背刺跳跃的落点
function FindAssassinJumpPosition(u)
	local team_id = u.at_team_id or u.team_id

	--优先选择自己当前排的
	if u.team_id ~= 4 then
		--主场
		local i = u.x
		for j=8,1,-1 do
			if _G.unit[team_id][j..'_'..i] == nil then
				for _,unit in pairs (GetValidChessOnBoard(team_id)) do
					if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(unit) == false then
						return XY2Vector(i,j,team_id)
					end
				end
			end
		end
	else
		--客场
		local i = u.x
		for j=1,8 do
			if _G.unit[team_id][j..'_'..i] == nil then
				for _,unit in pairs (GetValidChessOnBoard(team_id)) do
					if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(unit) == false then
						return XY2Vector(i,j,team_id)
					end
				end
			end
		end
	end

	--随机跳后排
	if u.team_id ~= 4 then
		--主场
		if RandomInt(0,100) > 50 then
			for j=8,1,-1 do
				for i=8,1,-1 do
					if _G.unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GetValidChessOnBoard(team_id)) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		else
			for j=8,1,-1 do
				for i=1,8 do
					if _G.unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GetValidChessOnBoard(team_id)) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		end
	else
		--客场
		if RandomInt(0,100) > 50 then
			for j=1,8 do
				for i=1,8 do
					if _G.unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GetValidChessOnBoard(team_id)) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		else
			for j=1,8 do
				for i=8,1,-1 do
					if _G.unit[team_id][j..'_'..i] == nil then
						for _,unit in pairs (GetValidChessOnBoard(team_id)) do
							if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius() and unit:HasModifier('modifier_winter_wyvern_cold_embrace') == false and IsAttackLowPriority(unit) == false then
								return XY2Vector(i,j,team_id)
							end
						end
					end
				end
			end
		end
	end
	return nil
end
function FindClosestUnluckyDogAvailablePosition(u)
	local team_id = u.at_team_id or u.team_id
	if u.team_id == 4 then
		for j=8,1,-1 do
			for i=8,1,-1 do
				if _G.unit[team_id][j..'_'..i] == nil then
					for _,unit in pairs (GetValidChessOnBoard(team_id)) do
						if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < 192 then
							return XY2Vector(i,j,team_id)
						end
					end
				end
			end
		end
	else
		for j=1,8 do
			for i=1,8 do
				if _G.unit[team_id][j..'_'..i] == nil then
					for _,unit in pairs (GetValidChessOnBoard(team_id)) do
						if unit.team_id ~= u.team_id and (XY2Vector(i,j,team_id) - XY2Vector(unit.x,unit.y,team_id)):Length2D() < 192 then
							return XY2Vector(i,j,team_id)
						end
					end
				end
			end
		end
	end

	return nil
end
function FindEmptyGridAtUnit(u, front_flag,self_only)
	local team_id = u.at_team_id or u.team_id
	if front_flag == nil and self_only == nil then
		front_flag = true
	end

	--优先选取面前的空格子
	local forward_v  = u:GetAbsOrigin() + u:GetForwardVector():Normalized()*128
	local forward_x = Vector2X(forward_v,team_id)
	local forward_y = Vector2Y(forward_v,team_id)
	if IsIn8x8(forward_x,forward_y) == true and IsEmptyGrid(team_id,forward_x,forward_y) == true and front_flag == true then
		return XY2Vector(forward_x,forward_y,team_id)
	end

	--遍历身边的格子
	local random1 = RandomInt(0, 1)
	local random2 = 1
	
	if random1 == 0 then
		random1 = -1
	end
	if u.team_id == 4 then
		random2 = -1
	end
	
	for y = 1*random2,-1*random2,-1*random2 do
		for x = -1*random1,1*random1,random1 do
			if IsEmptyGrid(team_id,u.x+x,u.y+y) == true then
				if self_only then
					if u:GetTeam() ~= 4 then
						if IsInDefendArea(u.x+x,u.y+y) == true then
							return XY2Vector(u.x+x,u.y+y,team_id)
						end
					else
						if IsInAttackArea(u.x+x,u.y+y) == true then
							return XY2Vector(u.x+x,u.y+y,team_id)
						end
					end
				else
					if IsIn8x8(u.x+x,u.y+y) == true then
						return XY2Vector(u.x+x,u.y+y,team_id)
					end
				end
			end
		end
	end

	for xx = -2,2 do
		for yy = -2,2 do
			if IsEmptyGrid(team_id,u.x+xx,u.y+yy) == true then
				if self_only then
					if u:GetTeam() ~= 4 then
						if IsInDefendArea(u.x+xx,u.y+yy) == true then
							return XY2Vector(u.x+xx,u.y+yy,team_id)
						end
					else
						if IsInAttackArea(u.x+xx,u.y+yy) == true then
							return XY2Vector(u.x+xx,u.y+yy,team_id)
						end
					end
				else
					if IsIn8x8(u.x+xx,u.y+yy) == true then
						return XY2Vector(u.x+xx,u.y+yy,team_id)
					end
				end
			end
		end
	end

	return nil
end
function FindEmptyGridAtPosition(team_id,p)
	if p == nil then
		return nil
	end

	local xx = Vector2X(p,team_id)
	local yy = Vector2X(p,team_id)

	--遍历身边的格子
	local random1 = RandomInt(0, 1)
	local random2 = 1
	
	if random1 == 0 then
		random1 = -1
	end
	
	for y = 1*random2,-1*random2,-1*random2 do
		for x = -1*random1,1*random1,random1 do
			if IsIn8x8(xx+x,yy+y) == true and IsEmptyGrid(team_id,xx+x,yy+y) == true then
				return XY2Vector(xx+x,yy+y,team_id)
			end
		end
	end

	for x = -2,2 do
		for y = -2,2 do
			if IsIn8x8(xx+x,yy+y) == true and IsEmptyGrid(team_id,xx+x,yy+y) == true then
				return XY2Vector(xx+x,yy+y,team_id)
			end
		end
	end

	return nil
end
function FindRandomEmptyGridAtUnit(u)
	local team_id = u.at_team_id or u.team_id
	local try_count = 0
	local p = nil

	while try_count < 20 and p == nil do
		local x = RandomInt(-1, 1)
		local y = RandomInt(-1, 1)
		if IsIn8x8(u.x+x,u.y+y) == true and IsEmptyGrid(team_id,u.x+x,u.y+y) == true then
			p = XY2Vector(u.x+x,u.y+y,team_id)
		end
		try_count = try_count + 1
	end

	return p
end
function FindFarthestEmptyGridAtUnit(u,caster)
	local team_id = u.at_team_id or u.team_id
	local max_distance = 0
	local p = nil
	local xx = u.x or Vector2X(u:GetAbsPosition(),team_id)
	local yy = u.y or Vector2Y(u:GetAbsPosition(),team_id)
	for x = -1,1 do
		for y = -1,1 do
			if IsIn8x8(xx+x,yy+y) == true and IsEmptyGrid(team_id,xx+x,yy+y) == true then
				local dis = (XY2Vector(xx+x,yy+y,team_id) - caster:GetAbsOrigin()):Length2D()
				if dis > max_distance then
					max_distance = dis
					p = XY2Vector(xx+x,yy+y,team_id)
				end
			end
		end
	end
	return p
end
--通用方法之寻找一个倒霉蛋
function FindUnluckyDog(u)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 10 do
		local uu = GetValidChessOnBoard(u.at_team_id or u.team_id)[RandomInt(1,table.maxn(GetValidChessOnBoard(u.at_team_id or u.team_id)))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and not uu:HasAbility('is_ward') then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindAllyClosest(u)
	local unluckydog = nil
	local length2d = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		local pos = unit:GetAbsOrigin()
		if (my_pos - pos):Length2D() < length2d and unit.team_id == u.team_id and unit:entindex() ~= u:entindex() and unit:IsInvisible() == false and IsUnitExist(unit) then
			unluckydog = unit
			length2d = (my_pos - pos):Length2D() 
		end
	end
	return unluckydog
end
function FindAllyRandom(u)
	local unluckydog = nil
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	local try_count = 0 

	while unluckydog == nil and try_count < 10000 do
		local random = RandomInt(1,table.maxn(GetValidChessOnBoard(team)))
		local unit = GetValidChessOnBoard(team)[random]
		if unit ~= nil and unit.y_x and unit:IsNull() == false and unit:IsAlive()==true and unit.team_id == u.team_id and unit:IsInvisible() == false and unit:entindex() ~= u:entindex() then
			if unluckydog == nil then
				unluckydog = unit
			end
		end
		try_count = try_count + 1
	end

	return unluckydog
end
function FindWarlock6Luckydog(u)
	local luckydog = nil
	local least_hp = 9999
	local team = u.at_team_id or u.team_id

	if _G.to_be_destory_list[team] then
		for _,unit in pairs (GetValidChessOnBoard(team)) do
			if IsUnitExist(unit) == true and unit.team_id ~= u.team_id and unit:HasModifier('modifier_is_warlock_buff_plus_plus') == true and unit:HasAbility('is_ward') == false and string.find(unit:GetUnitName(),'chess_') ~= nil then

				if unit.warlock_buff_count == nil or unit.warlock_buff_count < 3 then
					local hp = unit:GetHealth()
					if hp < least_hp then
						least_hp = hp
						luckydog = unit
					end
				end
			end
		end
	end
	return luckydog
end
function FindHighLevelUnluckyDog(u, is_force_high_level, is_ignore_nomana, exclude_debuff, is_in_attack_range)
	local unluckydog = nil
	local max_level = 0
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)

	--第二个参数true==是否强制最高等级，否则有30%概率随机
	--第三个参数true==是否排除被动技能的棋子（被动哥视为1级）
	if RandomInt(1,100)<30 and is_force_high_level ~= true then
		--30%概率随机找敌人
		return FindUnluckyDogRandom(u)
	end

	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		local lv = unit:GetLevel()
		if unit:GetMaxMana() <= 0 and is_ignore_nomana == true then
			lv = 1
		end
		local a = unit.steal_ability or _G.chess_ability_list[unit:GetUnitName()]

		if lv > max_level and unit.team_id ~= u.team_id and unit:HasAbility('is_ward') == false then
			if exclude_debuff == nil or unit:HasModifier(exclude_debuff) == false then
				if not is_in_attack_range or (is_in_attack_range and IsUnitInAttackRange(u,unit)) then
					unluckydog = unit
					max_level = lv
				end
			end
		end
	end
	return unluckydog
end
function IsUnitInAttackRange(u,unit)
	return (unit:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() <= (u:Script_GetAttackRange() + u:GetHullRadius() + unit:GetHullRadius())
end
function FindAllUnitsAroundUnluckyDogByRadius(unluckydog, radius)
	local result = {}
	if IsUnitExist(unluckydog) == false then
		return result
	end
	local team = unluckydog.at_team_id or unluckydog.team_id

	for _,unit in pairs (GetValidChessOnBoard(unluckydog.at_team_id or unluckydog.team_id)) do
		if IsUnitExist(unit) == true and unit.team_id == unluckydog.team_id and (unit:GetAbsOrigin() - unluckydog:GetAbsOrigin()):Length2D() < radius then
			table.insert(result, unit)
		end
	end
	return result
end
function FindHighLevelLuckyDog(u)
	local luckydog = nil
	local max_level = 0
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)

	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		local lv = unit:GetLevel()
		if lv > max_level and unit.team_id == u.team_id and unit:entindex() ~= u:entindex() then
			luckydog = unit
			max_level = lv
		end
	end
	return luckydog
end
function FindUnluckyDogRandom(u)
	local unluckydog = nil
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	local try_count = 0 

	while unluckydog == nil and try_count < 10000 do
		local random = RandomInt(1,table.maxn(GetValidChessOnBoard(team)))
		local unit = GetValidChessOnBoard(team)[random]
		if unit ~= nil and unit.y_x and unit:IsNull() == false and unit:IsAlive()==true and unit.team_id ~= u.team_id and unit:IsInvisible() == false then
			if unluckydog == nil then
				unluckydog = unit
			end
		end
		try_count = try_count + 1
	end

	return unluckydog
end
function FindUnluckyDogEnemySameStar(u)
	local unluckydog = nil
	local chessboard_id = u.at_team_id or u.team_id
	local star = GetChessStar(u)
	local top_chess = nil
	local same_star_chess_table = {}
	local low_star_chess_table = {}

	--遍历当前棋盘，找出同星的和低星的敌方棋子列表
	for _,unit in pairs (GetValidChessOnBoard(chessboard_id)) do
		if unit.team_id ~= u.team_id and unit:IsInvisible() == false and IsUnitExist(unit) and unit.is_moving ~= true and HasMovingModifier(unit) == false then
			--排除了各种移动状态的棋子
			local u_star = GetChessStar(unit)
			if u_star == star then
				table.insert(same_star_chess_table, unit:entindex())
			end
			if u_star < star then
				table.insert(low_star_chess_table, unit:entindex())
			end
		end
	end
	if table.maxn(same_star_chess_table) <= 0 then
		--没有同星的，从低星的随机一个
		if table.maxn(low_star_chess_table) <= 0 then
			return nil
		else
			unluckydog = low_star_chess_table[RandomInt(1,table.maxn(low_star_chess_table))]
		end
	else
		-- 有同星的，随机一个
		unluckydog = same_star_chess_table[RandomInt(1,table.maxn(same_star_chess_table))]
	end
	return EntIndexToHScript(unluckydog)
end
function FindUnluckyDogClosest(u)
	local unluckydog = nil
	local length2d = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		local pos = unit:GetAbsOrigin()
		if (my_pos - pos):Length2D() < length2d and unit.team_id ~= u.team_id and unit:IsInvisible() == false and IsUnitExist(unit) then
			unluckydog = unit
			length2d = (my_pos - pos):Length2D() 
		end
	end
	return unluckydog
end
function FindUnluckyDogFarthest(u)
	local unluckydog = nil
	local length2d = 0
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if (u:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D() > length2d and unit.team_id ~= u.team_id and IsUnitExist(unit) and unit:HasAbility('is_ward') == false then
			unluckydog = unit
			length2d = (u:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D() 
		end
	end
	return unluckydog
end
function FindUnluckyDog190(u)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GetValidChessOnBoard(u.at_team_id or u.team_id)[RandomInt(1,table.maxn(GetValidChessOnBoard(u.at_team_id or u.team_id)))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < 205 + u:GetHullRadius() + uu:GetHullRadius() and uu:HasAbility('is_ward') == false then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindUnluckyDog250(u)
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GetValidChessOnBoard(u.at_team_id or u.team_id)[RandomInt(1,table.maxn(GetValidChessOnBoard(u.at_team_id or u.team_id)))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < 205 + u:GetHullRadius() + uu:GetHullRadius() then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindUnluckyDogRandomFriend(u,a,need_has_mana)
	if a == nil then
		a = 'ogre_magi_bloodlust'
	end
	local conf_modifier = 'modifier_'..a 
	local unluckydog = nil
	local try_count = 0
	while unluckydog == nil and try_count < 100 do
		local uu = GetValidChessOnBoard(u.at_team_id or u.team_id)[RandomInt(1,table.maxn(GetValidChessOnBoard(u.at_team_id or u.team_id)))]
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id == u.team_id and uu:FindModifierByName(conf_modifier) == nil and (need_has_mana ~= true or uu:GetMaxMana() > 0) then
			unluckydog = uu
		end
		try_count = try_count + 1
	end
	return unluckydog
end
function FindBestMulticastFriend(u)
	local conf_modifier = 'modifier_om_multi_cast'
	local best_luckydog = nil
	local best_score = -999
	local try_count = 0

	-- if RandomInt(1,100) <= 30 then
	-- 	return FindUnluckyDogRandomFriend(u,'om_multi_cast',true)
	-- end

	for i,v in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) and v.team_id == u.team_id and v:HasModifier(conf_modifier) == false and v:HasAbility('om_multi_cast') == false and v:HasModifier('modifier_illusion') == false then
			local score = -999
			if v:GetMaxMana() > 0 then
				score = v:GetLevel() - GetChessAbilityCD(v)
			end
			if score > best_score then
				best_luckydog = v
				best_score = score
			end
		end
	end

	return best_luckydog
end
function FindHighestCostAlly(u)
	local dog = nil
	local cost_max = 0
	local try_count = 0
	for i,v in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		local b_name = GetUnitBaseName(v)
		local cost = _G.chess_2_mana[b_name]
		if b_name ~= 'chess_chen' and v.team_id == u.team_id and cost > cost_max and v:FindModifierByName('modifier_chen_fuhuo') == nil then
			dog = v
			cost_max = cost
		end
	end
	return dog
end
function FindNeedShieldFriend(u)
	--寻找最需要护盾的目标，不满血但血量较多的优先
	local unluckydog = u
	local hp_per = 100
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id == u.team_id and unit:HasAbility('is_ward') == false then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100
			
			if per > 50 then
				per = per - 50
			else
				per = 50 - per
			end

			if per < hp_per then
				unluckydog = unit
				hp_per = per
			end
		end
	end
	return unluckydog
end
--为暗牧寻找目标
function FindShallowGraveFriend(u)
	local unluckydog = u
	local hp_per = 101
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id == u.team_id then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100

			if per < hp_per and unit:FindModifierByName('modifier_dazzle_shallow_grave') == nil and unit.is_youhun ~= true and unit:HasModifier("modifier_illusion") == false and unit:HasAbility('is_ward') == false then
				unluckydog = unit
				hp_per = per
			end
		end
	end
	if hp_per > 50 then
		return nil
	else
		return unluckydog
	end
end
function FindShallowGraveFriendInner(u)
	local unluckydog = u
	local hp_per = 101
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id == u.team_id then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100

			if per < hp_per and unit:FindModifierByName('modifier_dazzle_shallow_grave') == nil and unit:HasAbility('is_ward') == false then
				unluckydog = unit
				hp_per = per
			end
		end
	end
	return unluckydog
end
--为全能寻找目标
function FindPurificationFriend(u)
	local unluckydog = nil
	local check_score = 101
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id == u.team_id and unit:HasAbility('is_ward') == false then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100
			local enemy_around = FindUnitsInRadiusByTeam({
				team = unit.team_id,
				role = 2,
				position = unit:GetAbsOrigin(),
				radius = 260,
			})
			local score = per - table.maxn(enemy_around)*30
			if score < check_score then
				unluckydog = unit
				check_score = score
			end
		end
	end
	return unluckydog
end
--为TB换血寻找最佳队友
function FindBestSunderFriend(u)
	local unluckydog = u
	local hp_per_best = 0
	local hp_best = 0
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id == u.team_id and unit:entindex() ~= u:entindex() and unit:HasAbility('is_ward') == false then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100

			if per > hp_per_best then
				unluckydog = unit
				hp_per_best = per
				hp_best = hp
			end
			if per == hp_per_best and hp < hp_best then
				unluckydog = unit
				hp_per_best = per
				hp_best = hp
			end
		end
	end
	return unluckydog
end
--跳刀和投掷选最远目标
function FindFarthestCanAttackEnemyEmptyGrid(u,max_distance)
	local team_id = u.at_team_id or u.team_id
	local length2d = 0
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil
	if not max_distance then
		max_distance = 9999
	end

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			local priority = CheckPriorityForGrid(x,y,u)
			if IsEmptyGrid(team_id,x,y) and priority >= 0 then
				local distance = (pos2-pos1):Length2D()
				if priority == 0 then
					distance = 1
				end
				if distance <= max_distance and distance > length2d then
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end
--滚滚用的
function FindRandomCanAttackEnemyEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil
	local try_count = 0

	while try_count < 100 do
		x = RandomInt(1,8)
		y = RandomInt(1,8)
		local pos2 = XY2Vector(x,y,team_id)
		local priority = CheckPriorityForGrid(x,y,u)
		if IsEmptyGrid(team_id,x,y) and priority >= 0 then
			skip_postion = pos2
			return skip_postion
		end
		try_count = try_count + 1
	end

	return nil
end
function FindRandomEnemyEmptyGrid(warlock)
	local team_id = warlock.at_team_id or warlock.team_id
	local try_count = 0
	while try_count < 100 do
		x = RandomInt(1,8)
		y = RandomInt(1,8)
		local pos = XY2Vector(x,y,team_id)
		if IsEmptyGrid(team_id,x,y) then
			for p,vp in pairs(GetValidChessOnBoard(team_id)) do
				if vp:GetTeam() ~= warlock:GetTeam() and (vp:GetAbsOrigin() - pos):Length2D() <= 205 then
					return pos
				end
			end
		end
		try_count = try_count + 1
	end

	return nil
end
function FindClosestEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local length2d = 9999
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			if IsEmptyGrid(team_id,x,y) == true then
				if (pos2-pos1):Length2D() < length2d then
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
			end
		end
	end

	return skip_postion
end
function FindUnluckyPoint(u, chessbosrd_id)
	local p = nil
	local try_count = 0
	local team_id = nil
	if chessbosrd_id ~= nil then
		team_id = chessbosrd_id
	else
		if u ~= nil then
			team_id = u.at_team_id or u.team_id
		end
	end
	if team_id == nil then
		return 
	end

	local x = nil
	local y = nil
	while p==nil and try_count<100 do
		if RandomInt(0,100)>50 then
			if RandomInt(0,100)>50 then
				x = 1
				y = RandomInt(1,8)
			else
				x = 8
				y = RandomInt(1,8)
			end
		else
			if RandomInt(0,100)>50 then
				y = 1
				x = RandomInt(1,8)
			else
				y = 8
				x = RandomInt(1,8)
			end
		end
		-- if _G.unit[team_id][y..'_'..x] == nil then
		if IsEmptyGrid(team_id,x,y) == true then
			if u == nil or (XY2Vector(x,y,team_id) - u:GetAbsOrigin()):Length2D() > 256 then
				p = XY2Vector(x,y,team_id)
			end
		end

		try_count = try_count + 1
	end
	return p
end
function FindRandomEmptyGrid(u)
	local p = nil
	local try_count = 0
	local team_id = u.at_team_id or u.team_id
	local x = nil
	local y = nil
	while p==nil and try_count<100 do
		x = RandomInt(1,8)
		y = RandomInt(1,8)
		if _G.unit[team_id][y..'_'..x] == nil then
			if (XY2Vector(x,y,team_id) - u:GetAbsOrigin()):Length2D() < 200 then
				p = XY2Vector(x,y,team_id)
			end
		end
		try_count = try_count + 1
	end
	return p
end
function FindARandomDogInAtTeam(team,is_host_dog)
	--在指定场地随便找只狗(场地，找主场狗？)
	local unluckydog = nil
	local try_count = 0
	if GetValidChessOnBoard(team) ~= nil then
		while unluckydog == nil and try_count < 100 do
			local uu = GetValidChessOnBoard(team)[RandomInt(1,table.maxn(GetValidChessOnBoard(team)))]
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= 4 and is_host_dog == true then
				unluckydog = uu
			end
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id == 4 and is_host_dog ~= true then
				unluckydog = uu
			end
			try_count = try_count + 1
		end
		return unluckydog
	end
	return nil
end
function FindAHighLevelDogInAtTeam(team,is_host_dog)
	--在指定场地随便找只高等级狗(场地，主场狗？找)
	local unluckydog = nil
	local try_count = 0
	local max_level = 0

	if _G.to_be_destory_list[team] ~= nil then
		while unluckydog == nil and try_count < 100 do
			local uu = GetValidChessOnBoard(team)[RandomInt(1,table.maxn(GetValidChessOnBoard(team)))]
			local lv = uu:GetLevel()
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= 4 and is_host_dog == true and lv > max_level then
				unluckydog = uu
				max_level = lv
			end
			if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id == 4 and is_host_dog ~= true and lv > max_level then
				unluckydog = uu
				max_level = lv
			end
			try_count = try_count + 1
		end
		return unluckydog
	end
	return nil
end
function FindFarthestEmptyGrid(u)
	local team_id = u.at_team_id or u.team_id
	local result_postion = nil
	local length2d = 0
	for x=1,8 do
		for y=1,8 do
			local pos = XY2Vector(x,y,team_id)
			if _G.unit[team_id][y..'_'..x] == nil then
				if (u:GetAbsOrigin() - pos):Length2D() > length2d then
					result_postion = pos
					length2d = (u:GetAbsOrigin() - pos):Length2D()
				end
			end
		end
	end
	return result_postion
end
function FindFarthestEmptyGridByForwardVector(u,p)
	local chessboard_id = u.at_team_id or u.team_id
	local v = (p-u:GetAbsOrigin()):Normalized()
	local result_postion = nil

	for i=1,100 do
		p = p + v*64
		local x = Vector2X(p,chessboard_id)
		local y = Vector2Y(p,chessboard_id)
		if IsIn8x8(x,y) == false then
			break
		end
		if IsEmptyGrid(chessboard_id,x,y) == true then
			result_postion = p
		end
	end

	return result_postion
end
function FindAJumpPosition(caster,target)
	local team = caster.at_team_id or caster.team_id
	local pc = caster:GetAbsOrigin()
	local pt = target:GetAbsOrigin()
	local d = (pt-pc):Normalized()
	local p = pt+d*128
	local x = Vector2X(p,team)
	local y = Vector2Y(p,team)
	if IsIn8x8(x,y) == true and IsEmptyGrid(team,x,y) == true then
		return p
	else
		return nil
	end
end
function FindSlarkJumpUnluckyDogClosest(u)
	local unluckydog = nil
	local length2d = 99999
	local team = u.at_team_id or u.team_id
	local my_pos = XY2Vector(u.x,u.y,team)
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		local pos = unit:GetAbsOrigin()
		if (my_pos - pos):Length2D() < length2d and unit.team_id ~= u.team_id and unit:IsInvisible() == false and FindAJumpPosition(u,unit) then
			unluckydog = unit
			length2d = (my_pos - pos):Length2D() 
		end
	end
	return unluckydog
end
function FindUnluckyDogInRange(u, range, dup_debuff)
	if u:GetAttackTarget() ~= nil then
		return u:GetAttackTarget()
	end
    local unluckydog = nil
    local try_count = 0
    while unluckydog == nil and try_count < 100 do
        local uu = GetValidChessOnBoard(u.at_team_id or u.team_id)[RandomInt(1,table.maxn(GetValidChessOnBoard(u.at_team_id or u.team_id)))]
        if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < range + u:GetHullRadius() + uu:GetHullRadius() and uu:HasAbility('is_ward') == false then
        	-- if dup_debuff == nil or uu:FindModifierByName(dup_debuff) == nil then
            	unluckydog = uu
            -- end
        end
        try_count = try_count + 1
    end
    return unluckydog
end
function FindMaxHPUnluckyDogInRange(u, range, dup_debuff)
	-- if u:GetAttackTarget() ~= nil then
	-- 	return u:GetAttackTarget()
	-- end
    local unluckydog = nil
    local try_count = 0
	local max_hp = 0

	for _,uu in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if uu ~= nil and uu:IsNull() == false and uu:IsAlive() == true and uu.team_id ~= u.team_id and (uu:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() < range + u:GetHullRadius() + uu:GetHullRadius() and uu:HasAbility('is_ward') == false then
        	if dup_debuff == nil or uu:HasModifier(dup_debuff) == false then
				local hp = uu:GetHealth()
				if hp > max_hp then
            		unluckydog = uu
					max_hp = hp
				end
            end
        end
	end
    return unluckydog
end
--寻找血量与技能伤害量最相近的棋子
function FindUnluckyDogByAbilityDamage(u,ability)
	local unluckydog = nil
	local hp_abs = 999999
	local hp_estimate = u:FindAbilityByName(ability):GetAbilityDamage()
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id ~= u.team_id and unit:IsNull() == false and unit:IsAlive() == true and unit:HasAbility('is_ward') == false then
			--魔法伤害，引入魔抗系数进行计算
			if u:FindAbilityByName(ability):GetAbilityDamageType() == 2 then
				local hp_abs_temp = math.abs(unit:GetHealth() - hp_estimate * (1 - unit:GetMagicalArmorValue()))
				if string.find(unit:GetUnitName(),'ward') ~= nil then
					hp_abs_temp = hp_abs_temp * 100
				end
				if hp_abs_temp < hp_abs and unit:GetMagicalArmorValue() < 1 then
					unluckydog = unit
					hp_abs = hp_abs_temp
				end
			--物理及纯粹伤害
			else
				if math.abs(unit:GetHealth() - hp_estimate) < hp_abs then
					unluckydog = unit
					hp_abs = math.abs(unit:GetHealth() - hp_estimate)
				end
			end
		end
	end
	return unluckydog
end
-- 寻找一个技能伤害最多敌人的最远格子
function FindFarthestGridForAbility(u,a)
	local team_id = u.at_team_id or u.team_id
	local length2d = 0
	local pos1 = u:GetAbsOrigin()
	local skip_postion = nil
	local target_enemy = nil
	local range = 100
	local target_count = 0

    -- 水人技能宽度
 	if u:FindAbilityByName(a):GetSpecialValueFor('width') > 0 then
 		range = u:FindAbilityByName(a):GetSpecialValueFor('width')
 	-- 沙王技能宽度
 	elseif u:FindAbilityByName(a):GetSpecialValueFor('burrow_width') > 0 then
 		range = u:FindAbilityByName(a):GetSpecialValueFor('burrow_width')
 	-- 光法、蝙蝠技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('radius') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('radius')
	-- 风行技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('arrow_width') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('arrow_width')
	-- 陨石技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('area_of_effect') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('area_of_effect')	
	-- 双头龙冰火技能宽度
	elseif u:FindAbilityByName(a):GetSpecialValueFor('path_radius') > 0 then
		range = u:FindAbilityByName(a):GetSpecialValueFor('path_radius')	
	end

	for x=1,8 do
		for y=1,8 do
			local pos2 = XY2Vector(x,y,team_id)
			local find_table = TargetCountForMorph(x,y,u,range)
			local count_temp = find_table['count']
			local target = find_table['target']
			if _G.ability_behavior_list[a] == 11 or _G.ability_behavior_list[a] == 19 then
				local priority = CheckPriorityForGrid(x,y,u)
				-- 水人、沙王、蝙蝠等需要占用格子的技能
				if IsEmptyGrid(team_id,x,y) and priority >= 0 and count_temp > 0 then
					-- 伤害更多单位优先
					if count_temp > target_count then
						target_count = count_temp
						target_enemy = target
						skip_postion = pos2
						length2d = (pos2-pos1):Length2D()
					-- 在伤害单位数相同的情况下，距离更远优先
					elseif count_temp == target_count and (pos2-pos1):Length2D() > length2d and target_count then
						target_enemy = target
						skip_postion = pos2
						length2d = (pos2-pos1):Length2D()
					end
				end
			else
				-- 其他有宽度属性的线性AOE技能
				-- 伤害更多单位优先
				if count_temp > target_count then
					target_count = count_temp
					target_enemy = target
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				-- 在伤害单位数相同的情况下，距离更远优先
				elseif count_temp == target_count and (pos2-pos1):Length2D() > length2d and target_count > 1 then
					target_enemy = target
					skip_postion = pos2
					length2d = (pos2-pos1):Length2D()
				end
				-- 避免光法波空（光法伤害起始位置在正面前方一段距离）
				if target_count == 1 and target ~= nil then
					skip_postion = target:GetAbsOrigin()
				end
			end
		end
	end

	return {
		skip_postion = skip_postion,
		target_enemy = target_enemy
	}
end	
-- 计算位移到目标格时，能伤害到的单位个数
function TargetCountForMorph(x,y,u,range)
	local team_id = u.at_team_id or u.team_id
	local count = 0
	local ability_distance = (u:GetAbsOrigin() - XY2Vector(x,y,team_id)):Length2D()
	local nearest_distance = 9999
	local nearest_enemy = nil
	local all_enemy = {}
	--遍历所有单位
	for _,enemy in pairs (GetValidChessOnBoard(team_id)) do
		if IsUnitExist(enemy) == true and enemy.team_id ~= u.team_id and enemy:IsInvisible() == false and IsAttackLowPriority(enemy) == false then
			local enemy_to_startpoint = (enemy:GetAbsOrigin() - u:GetAbsOrigin()):Length2D()
			local enemy_to_endpoint = (enemy:GetAbsOrigin() - XY2Vector(x,y,team_id)):Length2D()
			local p = (ability_distance + enemy_to_startpoint + enemy_to_endpoint) / 2
			local shortest_distance = 9999
			-- 三个点为钝角三角形，取最短距离
			if math.pow(enemy_to_startpoint, 2) >= math.pow(ability_distance, 2) + math.pow(enemy_to_endpoint, 2) then
		    	shortest_distance = enemy_to_endpoint
		    elseif math.pow(enemy_to_endpoint, 2) >= math.pow(ability_distance, 2) + math.pow(enemy_to_startpoint, 2) then
		    	shortest_distance = enemy_to_startpoint
		    -- 利用海伦公式计算敌方单位到施法路径间的最短距离
		    else
			    shortest_distance = math.sqrt(p * math.abs(p - ability_distance) * math.abs(p - enemy_to_startpoint) * math.abs(p - enemy_to_endpoint)) * 2 / ability_distance
			end
			-- 此处距离判断没有加上施法单位的半径，因为从沙王的实测来看位移技能用下面的公式更合理
		    if shortest_distance <= range + enemy:GetHullRadius() then
		    	table.insert(all_enemy,enemy)
		    	count = count + 1
		    	--比较记录最近的敌人
				if enemy_to_startpoint + shortest_distance * 3 < nearest_distance and shortest_distance <= range then
					nearest_distance = enemy_to_startpoint + shortest_distance * 3
					nearest_enemy = enemy
				end
		    end

		end
	end
	return {
		count = count,
		target = nearest_enemy,
		all_enemy = all_enemy,
	}
end
function FindMaxManaUnluckydog(u)
	local unluckydog = nil
	local max_mana = -1
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit:GetMana() > max_mana and unit.team_id ~= u.team_id and unit:FindModifierByName('modifier_mana_drain_datadriven') == nil then
			unluckydog = unit
			max_mana = unit:GetMana()
		end
	end
	return unluckydog
end
function FindMingyunShelingTarget(u)
	local unluckydog = u
	local hp_per = 0
	local un_chiling_enemy_count = 0
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id == u.team_id then
			local hp = unit:GetHealth()
			local hp_max = unit:GetMaxHealth()
			local per = 1.0*hp/hp_max*100
			local level = unit:GetLevel()

			if unit.has_mingyun_sheling == nil then
				un_chiling_enemy_count = un_chiling_enemy_count + 1
			end

			if per+level > hp_per and unit.has_mingyun_sheling == nil then
				unluckydog = unit
				hp_per = per+level
			end
		end
	end
	if un_chiling_enemy_count <= 1 then
		unluckydog = nil
	end
	return unluckydog
end
--获取场上存活的同名友方棋子数量
function GetSameNameFriendChessCount(u)
	local same_count = 0
	for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) then
			same_count = same_count + 1
		end
	end

	return same_count
end
--获取场上存活的同名友方棋子星级之和
function GetSameNameFriendChessTotalStars(u)
	local stars = 0
	for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) then
			stars = stars + GetChessStar(v)
		end
	end

	return stars
end
function FindClosestWarlock6Enemy(u)
	local closest_enemy = nil
	local closest_distance = 9999
	for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) == true and v.team_id ~= u.team_id and v:HasModifier('modifier_is_warlock_buff_plus_plus') == true then
			local distance = (v:GetAbsOrigin()-u:GetAbsOrigin()):Length2D()
			if distance < closest_distance then
				closest_distance = distance
				closest_enemy = v
			end
		end
	end
	return closest_enemy
end
function GetSameNameFriendChess(u,count)
	local same_index_list = {}
	local result_list = {}
	local all_chess = GetValidChessOnBoard(u.at_team_id or u.team_id)
	local try_count = 500
	local same_count = 0

	while (same_count < count and try_count > 0) do
		local v = all_chess[RandomInt(1,table.maxn(all_chess))]
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) and FindValueInTable(same_index_list, v:entindex()) == false then
			table.insert(same_index_list,v:entindex())
			same_count = same_count + 1
		end
		try_count = try_count - 1
	end

	-- for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
	-- 	if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) then
	-- 		table.insert(all_list,v)
	-- 	end
	-- end

	for i=1,count do
		if same_index_list[i] then
			local entity = EntIndexToHScript(same_index_list[i])
			if IsUnitExist(entity) then
				table.insert(result_list,entity)
			end
		end
	end

	return result_list
end
function GetSameNameFriendChessMaxLevel(u, filter_modifier)
	local max_level = 0
	local max_level_chess = nil
	local is_aqir = false
	if IsHexxed(u) == true then
		return 0
	end
	
	for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) and v:GetLevel() > max_level then
			if filter_modifier == nil or v:HasModifier(filter_modifier) then
				max_level = v:GetLevel()
				max_level_chess = v
			end
		end
	end

	if max_level < 0 then
		max_level = 0
	end
	if max_level > 9 then
		max_level = 9
	end

	return max_level,max_level_chess
end
function HasSameNameFriendChess(u)
	if IsHexxed(u) == true then
		return false
	end
	
	for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and GetUnitBaseName(u) == GetUnitBaseName(v) and IsHexxed(v) == false then
			return true
		end
	end

	return false
end
function FindAnEmptyGridByIteration(team_id,at_team_id,direction,direction_x)
	--1是从边缘向中间，-1是中间向边缘
	local search_table = {4,5,3,6,2,7,1,8}
	if team_id ~= at_team_id and direction_x ~= nil then
		--客场，反过来
		direction_x = -direction_x
	end

	if direction_x == 1 then
		search_table = {1,2,3,4,5,6,7,8}
	elseif direction_x == -1 then
		search_table = {8,7,6,5,4,3,2,1}
	end
	if team_id == at_team_id and direction == 1 then
		for y = 1,4 do
			for _,x in pairs(search_table) do
				if _G.unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
	if team_id == at_team_id and direction == -1 then
		for y = 4,1,-1 do
			for _,x in pairs(search_table) do
				if _G.unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
	if team_id ~= at_team_id and direction == 1 then
		for y = 8,5,-1 do
			for _,x in pairs(search_table) do
				if _G.unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
	if team_id ~= at_team_id and direction == -1 then
		for y = 5,8 do
			for _,x in pairs(search_table) do
				if _G.unit[at_team_id][y..'_'..x] == nil then
					return XY2Vector(x,y,at_team_id)
				end
			end
		end
	end
end


--【获取棋子各种属性】
function GetChessClass(base_name)
	if base_name == nil then
		return nil
	end
	local class = nil
	for kk,vv in pairs(_G.chess_list_by_synergy) do
		if FindValueInTable(vv,base_name) == true and _G.combo_ability_type[kk]['is_race'] ~= true then
			class = kk
		end
	end
	--特殊的不在卡池的
	for kk,vv in pairs(_G.chess_list_by_synergy_black_and_pandaman) do
		if FindValueInTable(vv,base_name) == true and _G.combo_ability_type[kk]['is_race'] ~= true then
			class = kk
		end
	end
	--特殊的不在卡池的
	for kk,vv in pairs(_G.chess_list_by_synergy_ban_unavailable) do
		if FindValueInTable(vv,base_name) == true and _G.combo_ability_type[kk]['is_race'] ~= true then
			class = kk
		end
	end
	return class
end
function GetChessRace(base_name)
	if base_name == nil then
		return nil
	end
	local race = nil
	local race2 = nil
	for kk,vv in pairs(_G.chess_list_by_synergy) do
		if FindValueInTable(vv,base_name) == true and _G.combo_ability_type[kk]['is_race'] == true then
			if race == nil then
				race = kk
			else
				race2 = kk
			end
		end
	end
	--特殊的不在卡池的
	for kk,vv in pairs(_G.chess_list_by_synergy_black_and_pandaman) do
		if FindValueInTable(vv,base_name) == true and _G.combo_ability_type[kk]['is_race'] == true then
			if race == nil then
				race = kk
			else
				race2 = kk
			end
		end
	end
	--特殊的不在卡池的
	for kk,vv in pairs(_G.chess_list_by_synergy_ban_unavailable) do
		if FindValueInTable(vv,base_name) == true and _G.combo_ability_type[kk]['is_race'] == true then
			if race == nil then
				race = kk
			else
				race2 = kk
			end
		end
	end
	return race,race2
end
function FindLevelOneChess(hero)
	local level_one_chess = ''
	if hero ~= nil then
		for _,v in pairs(_G.mychess[hero.team_id]) do
			if v.chess ~= nil then
				level_one_chess = level_one_chess..v.chess..','
			end
		end
		if hero.hand_entities ~= nil then
			for k,v in pairs(hero.hand_entities) do
				if IsUnitExist(v) then
					level_one_chess = level_one_chess..v:GetUnitName()..','
				end
			end
		end
	end
	return level_one_chess
end
--找到某玩家的所有三星棋子，去重
function FindStar3Chess(team_id)
	local star3_chess_list = {}
	local hero = TeamId2Hero(team_id)
	
	if hero ~= nil then
		for _,v in pairs(_G.mychess[hero.team_id]) do
			if GetChessNameStar(v.chess) == 3 then
				if FindValueInTable(star3_chess_list,v.chess) ~= true then
					table.insert(star3_chess_list,v.chess)
				end
			end
		end
		if hero.hand_entities ~= nil then
			for k,v in pairs(hero.hand_entities) do
				if IsUnitExist(v) and GetChessStar(v) == 3 then
					if FindValueInTable(star3_chess_list,v:GetUnitName()) ~= true then
						table.insert(star3_chess_list,v:GetUnitName())
					end
				end
			end
		end
	end
	return star3_chess_list
end
function Get11ChessBaseNameTable(team_id)
	local table_11chess = {}
	for _,chess in pairs(_G.mychess[team_id]) do
		if chess ~= nil and chess.chess ~= nil and string.find(chess.chess,'11') then
			table.insert(table_11chess,string.sub(chess.chess,1,-3))
		end
	end
	return table_11chess
end
function GetMinionManaCost(u)
	local mana = 0
	if u:FindAbilityByName('mana_cost1') ~= nil then
		mana = 1
	end
	if u:FindAbilityByName('mana_cost2') ~= nil then
		mana = 2
	end
	if u:FindAbilityByName('mana_cost3') ~= nil then
		mana = 3
	end
	if u:FindAbilityByName('mana_cost4') ~= nil then
		mana = 4
	end
	if u:FindAbilityByName('mana_cost5') ~= nil then
		mana = 5
	end
	return mana
end
--获取棋子的不带1和11的名字，如chess_wr
function GetChessTypeName(chess)
	local find_name = chess:GetUnitName()
	if string.find(find_name,'11') ~= nil then
		find_name = string.sub(find_name,1,-3)
	end
	if string.find(find_name,'1') ~= nil then
		find_name = string.sub(find_name,1,-2)
	end
	return find_name
end
--获取棋子是几星的
function GetChessStar(chess)
	if IsUnitExist(chess) == false then
		return 1
	end
	local find_name = chess:GetUnitName()
	if string.find(find_name,'chess_') == nil then
		return 1
	end
	if string.find(find_name,'_ssr') ~= nil then
		return 3
	end
	
	if string.find(find_name,'11') ~= nil then
		return 3
	end
	if string.find(find_name,'1') ~= nil then
		return 2
	end
	return 1
end
function GetChessNameStar(chess_name)
	--找不到的一律按1星处理
	if chess_name == nil then
		return 1
	end
	if string.find(chess_name,'11') ~= nil then
		return 3
	end
	if string.find(chess_name,'1') ~= nil then
		return 2
	end
	return 1
end
function IsChessInHand(chess)
	if chess.hand_index ~= nil then
		return true
	else
		return false
	end
end
function Find2SameChessInHandOrOnBoard(caster,chess)
	if chess == 'chess_io1' or chess == 'chess_io' then
		--2星小精灵不参与合成
		return 0,nil,nil,nil
	end
	local count = 0
	local chess1 = nil
	local chess2 = nil
	local chess3 = nil
	if caster ~= nil and caster.hand_entities ~= nil then
		if GetTime().left > 5 then  
			-- 准备回合结束后，不再寻找场上棋子做为合成材料，避免一些未知的BUG。
			for _,v in pairs(_G.to_be_destory_list[caster.team_id]) do
				local kobold_or_druid = false
				if v ~= nil and v:IsNull() == false then
					if v:FindAbilityByName('is_druid') ~= nil or v:FindAbilityByName('is_kobold') ~= nil then
						kobold_or_druid = true
					end
					if IsUnitExist(v) == true and v:GetUnitName() == chess and (kobold_or_druid == false or (kobold_or_druid == true and GetChessStar(v) == 2)) and v.is_in_battle ~= true and v.is_moving ~= true and v.team_id == caster.team_id then
						count = count + 1
						if count == 1 then
							chess1 = v
						end
						if count == 2 then
							chess2 = v
						end
						if count == 3 then
							chess3 = v
						end
					end
				end
			end
		end
		for _,v in pairs(caster.hand_entities) do
			if IsUnitExist(v) == true and v:GetUnitName() == chess and v:FindAbilityByName('is_druid') == nil and v:FindAbilityByName('is_kobold') == nil and v.is_moving ~= true then
				count = count + 1
				if count == 1 then
					chess1 = v
				end
				if count == 2 then
					chess2 = v
				end
				if count == 3 then
					chess3 = v
				end
			end
		end
		return count,chess1,chess2,chess3
	else
		return 0,nil,nil,nil
	end
end 
--获得棋子名字的基础部分（去掉1和11）
function GetUnitBaseName(u)
	local unit_name = u:GetUnitName() 
	if _G.chess_transform_list[unit_name] then
		--处理变身后棋子的不规则命名
		unit_name = _G.chess_transform_list[unit_name]
	end
	if string.find(unit_name,'chess_') ~= nil then
		if string.find(unit_name,'11') ~= nil then
			unit_name = string.sub(unit_name,1,-3)
		end
		if string.find(unit_name,'1') ~= nil then
			unit_name = string.sub(unit_name,1,-2)
		end
	end
	return unit_name
end


--【羁绊】
function GetYourChessCount(team_id)
	local count = 0
	for _,v in pairs(_G.yourchess[team_id]) do
		if v and v.chess then
			count = count + 1
		end
	end
	return count
end
function GetHumanCount(team_id)
	local human_table = {}
	for w,vw in pairs(_G.mychess[team_id]) do
		local find_name = vw.chess
		if string.find(find_name,'11') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if string.find(find_name,'1') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if (FindValueInTable(_G.chess_list_by_synergy['is_human'],find_name) == true or FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman['is_human'],find_name) == true or FindValueInTable(_G.chess_list_by_synergy_ban_unavailable['is_human'],find_name) == true) and FindValueInTable(human_table,find_name) ~= true then
			table.insert(human_table,find_name)
		end
	end
	local human_count = table.maxn(human_table) or 0
	local wizard_count = GetWizardCount(team_id)
	if wizard_count >= 2 and human_count >= 3 then
		human_count = human_count + 1
	end
	if TeamId2Hero(team_id).the_only_combo_self ~= nil and TeamId2Hero(team_id).the_only_combo_self == 'is_human' and wizard_count >= 3 then
		human_count = 6
	end
	return human_count
end
function GetDruidCount(team_id)
	--德鲁伊种族技能,统计有多少不同的德鲁伊
	local druid_table = {}
	for w,vw in pairs(_G.mychess[team_id]) do
		local find_name = vw.chess or ''
		if string.find(find_name,'11') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if string.find(find_name,'1') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if FindValueInTable(_G.chess_list_by_druid,find_name) == true and FindValueInTable(druid_table,find_name) ~= true then
			table.insert(druid_table,find_name)
		end
	end
	return table.maxn(druid_table) or 0
end
function GetPandamanCount(team_id)
	--获取当前熊猫人数量，最多为5
	-- local pandaman_set = {
	-- 	[1] = 'chess_ember',
	-- 	[2] = 'chess_brew',
	-- 	[3] = 'chess_storm',
	-- 	[4] = 'chess_earth',
	-- 	-- [5] = 'chess_void',
	-- }
	local pandaman_set = _G.pandaman_list
	local pandaman_table = {}
	for w,vw in pairs(_G.mychess[team_id]) do
		local find_name = vw.chess
		if string.find(find_name,'11') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if string.find(find_name,'1') ~= nil then
			find_name = string.sub(find_name,1,-2)
		end
		if FindValueInTable(pandaman_set,find_name) == true and FindValueInTable(pandaman_table,find_name) ~= true then
			table.insert(pandaman_table,find_name)
		end
	end
	local wizard_count = GetWizardCount(team_id)
	local panda_count = table.maxn(pandaman_table) or 0

	if wizard_count >= 2 and panda_count >= 3 then
		panda_count = panda_count + 1
	end
	-- if panda_count > 3 then
	-- 	panda_count = 3
	-- end
	if panda_count > 4 then
		panda_count = 4
	end
	if TeamId2Hero(team_id).the_only_combo_self ~= nil and TeamId2Hero(team_id).the_only_combo_self == 'is_pandaman' and wizard_count >= 3 then
		panda_count = 4
	end
	return panda_count
end
function GetWizardCount(team_id)
	if _G.game_status ~= 2 or team_id == nil or _G.mychess == nil or _G.mychess[team_id] == nil then
		return 0
	end
	local rubick = 0
	local gs = 0
	local lion = 0
	local dw = 0
	for x,y in pairs(_G.mychess[team_id]) do
		if y.chess == nil then
			if string.find(y.chess,'chess_rubick') ~= nil then
				rubick = 1
			end
			if string.find(y.chess,'chess_gs') ~= nil then
				gs = 1
			end
			if string.find(y.chess,'chess_lion') ~= nil then
				lion = 1
			end
			if string.find(y.chess,'chess_dw') ~= nil then
				dw = 1
			end
		end
	end
	local count = 0
	if rubick == 1 then
		count = count + 1
	end
	if lion == 1 then
		count = count + 1
	end
	if gs == 1 then
		count = count + 1
	end
	if dw == 1 then
		count = count + 1
	end
	return count
end

function HoorayAndMechHuman(team)
	--显示胜利！
	local hero = TeamId2Hero(team)
	if hero == nil or hero:IsNull() == true or hero:IsAlive() == false then
		return
	end
	EmitSoundOn("dac.round.win",hero)
	
	play_particle("effect/winaround/1/shovel_baby_roshan_spawn.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,3)
	play_particle("particles/units/heroes/hero_legion_commander/legion_commander_duel_victory.vpcf",PATTACH_OVERHEAD_FOLLOW,hero,3)
	local alive_units = GetValidChessOnBoard(team)
	local alive_mech = {}
	local mech_level = 0
	local alive_human = {}
	local human_level = 0
	local alive_draenei = {}
	for _,unit in pairs(alive_units) do
		--德莱尼技能
		if unit:HasAbility('is_draenei') and unit:HasModifier('modifier_is_draenei_buff') then
			table.insert(alive_draenei,unit)
		end
	end
	for _,unit in pairs(alive_units) do
		if unit:HasAbility('lc_qianggong') == true then
			--军团永久加攻击力
			AddAbilityAndSetLevel(unit,'act_victory_lc')
			EmitSoundOn("chess_lc.qianggong",unit)
			AddPressCount(unit)
		-- elseif unit:HasModifier('modifier_is_draenei_buff') then
		elseif table.maxn(alive_draenei) > 0 then
			--德莱尼：看看能不能传送到客场/主场助战
			if DraeneiAssist(unit) == true then
				--助战
			else
				--不助战，照常欢呼
				AddAbilityAndSetLevel(unit,'act_victory')
			end
		else
			AddAbilityAndSetLevel(unit,'act_victory')
		end
		unit.alreadywon = true

		--工匠技能
		if unit:FindAbilityByName('is_mech') ~= nil then
			table.insert(alive_mech,unit)
			if hero.combo_self ~= nil and hero.combo_self['is_mech'] ~= nil and hero.combo_self['is_mech'] >= 3 then
				mech_level = 1
			end
			if hero.combo_self ~= nil and hero.combo_self['is_mech1'] ~= nil and hero.combo_self['is_mech1'] >= 6 then
				mech_level = 2
			end
		end
		--人类技能
		if unit:FindAbilityByName('is_human') ~= nil then
			table.insert(alive_human,unit)
			if hero.combo_self ~= nil and hero.combo_self['is_human'] ~= nil and hero.combo_self['is_human'] >= 3 then
				human_level = 1
			end
			if hero.combo_self ~= nil and hero.combo_self['is_human1'] ~= nil and hero.combo_self['is_human1'] >= 6 then
				human_level = 2
			end
		end
		
	end
	--工匠发明
	if table.maxn(alive_mech) >= 1 and mech_level == 1 then
		-- hero:AddItemByName('item_jixiezhixin')
		-- if hero:HasModifier('modifier_item_black_gear') == false then
		-- 	AddItemPlus(hero,'item_jixiezhixin')
		-- else
		-- 	AddItemPlus(hero,'item_jixiezhixin_black')
		-- end
		AddItemPlus(hero,'item_jixiezhixin')
		for _,unit in pairs(alive_mech) do
			play_particle("particles/econ/items/dazzle/dazzle_ti6/dazzle_ti6_shallow_grave_glyph_flare.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,2)
		end
		EmitSoundOn("item.jixiezhixin.get",hero)
		-- sounds/weapons/hero/techies/land_mine_primed.vsnd
		-- sounds/weapons/hero/techies/remote_mine_activate.vsnd
	end
	if table.maxn(alive_mech) >= 1 and mech_level == 2 then
		AddItemPlus(hero,'item_jixiezhixin_gold')
		for _,unit in pairs(alive_mech) do
			play_particle("particles/econ/items/dazzle/dazzle_ti6_gold/dazzle_ti6_shallow_grave_gold_glyph_flare.vpcf",PATTACH_OVERHEAD_FOLLOW,unit,2)
		end
		EmitSoundOn("item.jixiezhixin.get",hero)
	end
	--人类思想火花
	if table.maxn(alive_human) >= 1 and human_level == 2 then
		AddItemPlus(hero,'item_zhishizhishu')
		-- AddItemPlus(hero,'item_zhishizhishu')
		for _,unit in pairs(alive_human) do
			play_particle("particles/units/heroes/hero_wisp/wisp_death.vpcf",PATTACH_ABSORIGIN_FOLLOW,unit,2)
		end
		EmitSoundOn("is_human.magic",hero)
	end
	--相位异变齿轮
	if hero:HasModifier('modifier_item_black_gear') then
		AddItemPlus(hero,'item_jixiezhixin_black')
		EmitSoundOn("item.jixiezhixin.get",hero)
	end
end
--钓鱼
function Fish(hero)
	local team_id = hero:GetTeam()
	local pandaman_count = GetPandamanCount(team_id)
	local fish_dice_table = {
		-- [1] = 10,
		-- [2] = 25,
		-- [3] = 50,
		[1] = 10,
		[2] = 25,
		[4] = 15,
	}
	local fish_pandaman_dice = 70
	-- local pandaman_set = {
	-- 	[1] = 'chess_ember',
	-- 	[2] = 'chess_brew',
	-- 	[3] = 'chess_storm',
	-- 	[4] = 'chess_earth',
	--  [5] = 'chess_void',
	-- } --TODO:紫猫上线后改用_G.pandaman_list
	local pandaman_set = {}

	for _,p in pairs(_G.pandaman_list) do
		if p ~= 'chess_brew' then
			table.insert(pandaman_set,p)
		end
	end
	--非气值只有1/2合并使用
	local a_value = GetFishAfricaValue(hero)
	--整理base table，统计场上已有棋子
	local other_chess_base_table = {}
	local pandaman_chess_base_table = {}
	for _,chess in pairs(_G.mychess[team_id]) do
		local base_name = chess.chess
		if string.find(base_name,'11') ~= nil then
			base_name = string.sub(base_name,1,-2)
		end
		if string.find(base_name,'1') ~= nil then
			base_name = string.sub(base_name,1,-2)
		end
		if FindValueInTable(_G.pandaman_list,base_name) == true then
			table.insert(pandaman_chess_base_table,base_name)
		else
			table.insert(other_chess_base_table,base_name)
		end
	end
	--1熊猫人钓随机熊猫人或者同种族
	if pandaman_count >= 1 then
		if RandomInt(1,100) <= fish_dice_table[1]*a_value then
			if RandomInt(1,100) <= fish_pandaman_dice and hero.synergy_banned ~= 'is_pandaman' then
				RandomAFish(team_id,pandaman_set)
			else
				RandomAFish(team_id,other_chess_base_table)
			end
		else
			AddFishAfricaValue(hero)
		end
	end
	--2熊猫人钓随机熊猫人
	if pandaman_count >= 2 then
		if RandomInt(1,100) <= fish_dice_table[2] and hero.synergy_banned ~= 'is_pandaman' then
			Timers:CreateTimer(0.3,function()
				RandomAFish(team_id,pandaman_set)
			end)
		end
	end

	-- --12熊猫人钓随机熊猫人或者同种族
	-- if pandaman_count >= 1 then
	-- 	local check_count = pandaman_count
	-- 	if check_count >= 2 then
	-- 		check_count = 2
	-- 	end
	-- 	if check_count == 2 then
	-- 		fish_pandaman_dice = 85
	-- 	end
	-- 	if RandomInt(1,100) <= fish_dice_table[check_count]*a_value then
	-- 		if RandomInt(1,100) <= fish_pandaman_dice and hero.synergy_banned ~= 'is_pandaman' then
	-- 			RandomAFish(team_id,pandaman_set)
	-- 		else
	-- 			RandomAFish(team_id,other_chess_base_table)
	-- 		end
	-- 	else
	-- 		AddFishAfricaValue(hero)
	-- 	end
	-- end
	-- --3熊猫人
	-- if pandaman_count >= 3 then
	-- 	if RandomInt(1,100) <= fish_dice_table[3] and hero.synergy_banned ~= 'is_pandaman' then
	-- 		Timers:CreateTimer(0.5,function()
	-- 			RandomAFish(team_id,pandaman_set)
	-- 		end)
	-- 	end
	-- end
	--4熊猫人每个都钓自己
	if pandaman_count >= 4 then
		for _,pm in pairs(pandaman_chess_base_table) do
			if RandomInt(1,100) <= fish_dice_table[4] and hero.synergy_banned ~= 'is_pandaman' then
				Timers:CreateTimer(RandomFloat(0.6,1.5),function()
					RandomAFish(team_id,pm)
				end)
			end
		end
	end
end
--有鱼上钩了，选一条鱼
function RandomAFish(team_id,fisher)
	--fisher传进来table是钓种族（包括熊猫人种族），字符串名字就是钓自己
	local v = TeamId2Hero(team_id)
	local ran_chess = nil
	if fisher == nil then
		return
	end
	local fish_count = 0
	while fish_count < 100 and ran_chess == nil do
		fish_count = fish_count + 1
		if type(fisher) == 'table' and table.maxn(fisher) > 0 then
			local trytime = 0
			while trytime < 100 and ran_chess == nil do
				trytime = trytime + 1
				local ran_host = fisher[RandomInt(1,table.maxn(fisher))]
				local ran_race,ran_race2 = GetChessRace(ran_host)
				if ran_race2 ~= nil and RandomInt(1,100) < 50 then
					--用种族2
					ran_race = ran_race2
				end
				if ran_race ~= v.synergy_banned then
					local race_table = _G.chess_list_by_synergy[ran_race]
					if ran_race == 'is_pandaman' then
						race_table = fisher
					end
					local ran_a_chess = race_table[RandomInt(1,table.maxn(race_table))]
					ran_chess = ran_a_chess
				end
			end
			if ran_chess ~= nil then
				InitFishAfricaValue(v)			
			end
		elseif type(fisher) == 'string' then
			ran_chess = fisher
		end
		local destroy_info = CustomNetTables:GetTableValue( "chess_pool_table", "destroy_info" ) 
		local table_11chess = Get11ChessBaseNameTable(team_id)
		local ran_race_check,ran_race2_check = GetChessRace(ran_chess)
		if v.synergy_banned ~= nil and (ran_race_check == v.synergy_banned or ran_race2_check == v.synergy_banned) then
			--排除ban的种族
			ran_chess = nil
		end
		if GetChessClass(ran_chess) == v.synergy_banned then
			--排除ban的职业
			ran_chess = nil
		end
		if FindValueInTable(table_11chess,ran_chess) == true then
			--排除已经三星的棋子
			ran_chess = nil
		end
		if FindValueInTable(destroy_info,ran_chess) == true then
			ran_chess = nil
		end
	end
	if ran_chess ~= nil then
		PlayRandomFishDiague(team_id,ran_chess)
		local cost = GetChessCostByName(ran_chess)
		if cost ~= nil and cost > 0 then
			--从棋库中移除
			RemoveOneKeyInTable(_G.chess_pool[cost],ran_chess)
		end
		Timers:CreateTimer(2,function()
			--创建鱼棋子，播动画
			local cc = CreateChessInHand(v,ran_chess)
			BlinkChessX({caster=cc,blink_type="fall"})
			--发弹幕：钓鱼
			CustomGameEventManager:Send_ServerToAllClients("bullet",{
				player_id = v:GetPlayerID(),
				vip = v.is_vip,
				win_streak = v.win_streak or 0,
				target = ran_chess,
				pre_ability = 'is_pandaman',
			})
		end)
	end

	return ran_chess
end
--钓鱼防非概率
function GetFishAfricaValue(hero)
	if hero.fish_africa_value == nil then
		hero.fish_africa_value = -4
	end
	return math.pow(1.1, hero.fish_africa_value) 
end
function InitFishAfricaValue(hero)
	hero.fish_africa_value = -4
end
function AddFishAfricaValue(hero)
	if hero.fish_africa_value == nil then
		hero.fish_africa_value = -4
	end
	hero.fish_africa_value = hero.fish_africa_value + 1
end
function PlayRandomFishDiague(team_id,fish_chess)
	local u = FindRandomChessSpeak(team_id,fish_chess)
	if IsUnitExist(u) == true then
		PlayChessDialogue(u,'fish')
	end
end
function RandomEvolveChess(seed,delta)
	if table.maxn(_G.chess_list_by_level) == 0 then
		InitChessListByLevel()
	end
	local level = seed:GetLevel()
	local elevel = level + delta
	if elevel > 9 then
		elevel = 9
	end
	if elevel < 1 then
		elevel = 1
	end
	local chesstable = _G.chess_list_by_level[elevel]
	local chessname = chesstable[RandomInt(1,table.maxn(chesstable))]
	return chessname
end
function RandomStarEvolveChess(seed,delta)
	local star = GetChessNameStar(seed:GetUnitName())
	local cost = _G.chess_2_mana[GetUnitBaseName(seed)]
	local c = cost
	if c == nil or c < 1 then
		c = 1
	end
	if c > 5 then
		c = 5
	end
	
	local t = _G.chess_list_by_mana[c]
	local uname = t[RandomInt(1,table.maxn(t))]
	local name_suffix = ''
	if star == 2 then
		name_suffix = '1'
	elseif star == 3 then
		name_suffix = '11'
	end
	return uname..name_suffix
end
function EvolveAChess(u)
	if u.evolve_result == nil and u.evolve_result_6 == nil then
		return
	end
	-- local transfer_duration = RandomFloat(0.1,0.5)
	-- u:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(u,u,'modifier_transfer_buff',{ duration = transfer_duration})
	-- play_particle("effect/evolve.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,transfer_duration)
	local shaman_6 = u:HasModifier('modifier_is_shaman_buff_plus_plus')
	TransformAChess(u,u.evolve_result or u.evolve_result_6,false,function(x)
		if IsUnitExist(x) then
			if shaman_6 then
				AddAbilityAndSetLevel(x,'is_shaman_buff_plus_plus')
			end
			EmitSoundOn("shaman.evolve",x)
			play_particle("particles/econ/events/ti10/hero_levelup_ti10.vpcf",PATTACH_ABSORIGIN_FOLLOW,x,3)
			AddShaman({caster = x})
			x:AddNewModifier(x,nil,"modifier_kill",{duration = 25})
		end
	end)
end
function DevolveAChess(u)
	FillEmptySlot(u)
	local transfer_duration = RandomFloat(0.5,1)
	u:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(u,u,'modifier_transfer_debuff',{ duration = transfer_duration})
	AddAbilityAndSetLevel(u,'jiaoxie')
	RemoveAbilityAndModifier(u,'jiaoxie_wudi')
	Timers:CreateTimer(transfer_duration,function()
		TransformAChess(u,u.devolve_result,true,function(x)
			if IsUnitExist(x) then
				EmitSoundOn("shaman.devolve",x)
				play_particle("particles/units/heroes/hero_lion/lion_spell_voodoo.vpcf",PATTACH_ABSORIGIN_FOLLOW,x,3)
			end
		end)
	end)
end
--召唤物继承野兽buff
function ExtendBeastBuff(unit,owner)
	if owner:FindAbilityByName('is_beast_buff')~=nil then
		AddAbilityAndSetLevel(unit,'is_beast_buff')
	end
	if owner:FindAbilityByName('is_beast_buff_plus')~=nil then
		AddAbilityAndSetLevel(unit,'is_beast_buff_plus')
	end
	if owner:FindAbilityByName('is_beast_buff_plus_plus')~=nil then
		AddAbilityAndSetLevel(unit,'is_beast_buff_plus_plus')
	end

	if owner:FindModifierByName('modifier_item_zhaohuanshenshi') ~= nil or owner:FindModifierByName('modifier_item_minglingshu') ~= nil then
		AddAbilityAndSetLevel(unit,'zhaohuanshenshi')
		play_particle('effect/zhaohuanshenshi/fallback_low.vpcf',PATTACH_ABSORIGIN_FOLLOW,unit,3)
		ChangeModelScale({
			caster = unit,
			x = 1.1, 
		})
	end
end
function ConcealToggle(team,conceal)
	if team ~= nil and conceal == 1 and _G.game_status == 1 then
		HidePrepare(team)
	end
	if team ~= nil and conceal == -1 then
		ShowPrepare(team)
	end
end
function ConcealOneChess(chess)
	AddAbilityAndSetLevel(chess,'invisible_to_enemy')
end
function RevealOneChess(chess)
	RemoveAbilityAndModifier(chess,'invisible_to_enemy')
end
function HideBench(team)
	if TeamId2Hero(team).hand_entities ~= nil then
		for _,ent in pairs(TeamId2Hero(team).hand_entities) do
			AddAbilityAndSetLevel(ent,'invisible_to_enemy')
		end
	end
end
function ShowBench(team)
	if TeamId2Hero(team).hand_entities ~= nil then
		for _,ent in pairs(TeamId2Hero(team).hand_entities) do
			RemoveAbilityAndModifier(ent,'invisible_to_enemy')
		end
	end
end
function HidePrepare(team)
	if GetValidChessOnBoard(team) ~= nil then
		for _,ent in pairs(GetValidChessOnBoard(team)) do
			AddAbilityAndSetLevel(ent,'invisible_to_enemy')
		end
	end
end
function ShowPrepare(team)
	if GetValidChessOnBoard(team) ~= nil then
		for _,ent in pairs(GetValidChessOnBoard(team)) do
			RemoveAbilityAndModifier(ent,'invisible_to_enemy')
		end
	end
end
function OnKnightBuffCreate(keys)
	local caster = keys.caster
	if IsHexxed(caster) == true then
		RemoveAllKnightBuff(caster)
		return
	end

	--如果有6骑士buff，给予治疗
	if caster:HasModifier('modifier_is_knight_buff_plus_plus') then
		caster:Heal(200, caster)
	end
end
function RemoveAllKnightBuff(u)
	if u:FindModifierByName('modifier_is_knight_buff_2') ~= nil then
		u:RemoveModifierByName('modifier_is_knight_buff_2')
	end
	if u:FindModifierByName('modifier_is_knight_buff_2_plus') ~= nil then
		u:RemoveModifierByName('modifier_is_knight_buff_2_plus')
	end
	if u:FindModifierByName('modifier_is_knight_buff_2_plus_plus') ~= nil then
		u:RemoveModifierByName('modifier_is_knight_buff_2_plus_plus')
	end
end
function HunterKnockBack(keys)
	local caster = keys.caster
	local target = keys.target
	local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
	local deltax = math.floor(vec.x+0.5)
	local deltay = math.floor(vec.y+0.5)

	local team_id = target.at_team_id or target.team_id

	local y = target.y
	local x = target.x
	if x ~= nil and y ~= nil and IsIn8x8(x+deltax,y+deltay) == true and IsEmptyGrid(team_id,x+deltax,y+deltay) == true and not target:HasModifier('modifier_tuitui') and target:HasMovementCapability() == true then
		local target_pos = XY2Vector(x+deltax,y+deltay,team_id)
		local stun_duration = ((target_pos-target:GetAbsOrigin()):Length2D()/1000)
		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+0.1})

		if IsUnitExist(target) then
			_G.unit[team_id][(y+deltay)..'_'..(x+deltax)] = 1
		end
		target.is_moving = true
		BlinkChessX({p=target_pos,caster=target,blink_type='tuitui'})
		target.y_x = (y+deltay)..'_'..(x+deltax)
		target.y = y+deltay
		target.x = x+deltax
		_G.unit[team_id][y..'_'..x] = nil
	end
end
--亡语
function DeathRattle(u,attacker)
	if u.no_death_rattle then
		return
	end
	if u.killer ~= nil then
		attacker = u.killer
	end
	if IsUnitExist(attacker) then
		--三叉戟
		if attacker:HasModifier('modifier_item_sanchaji') then
			local unluckydogs = GetSameNameFriendChess(u,2)
			if unluckydogs and table.maxn(unluckydogs) > 0 then
				for _,dog in pairs(unluckydogs) do
					play_particle("particles/econ/items/phantom_assassin/phantom_assassin_arcana_elder_smith/pa_arcana_phantom_strike_start.vpcf",PATTACH_ABSORIGIN_FOLLOW,dog,2)
				    -- EmitSoundOn("Hero_MonkeyKing.Strike.Cast",dog)
				    -- dog:ForceKill(false)
					-- play_particle("particles/units/heroes/hero_siren/naga_siren_riptide_foam.vpcf",PATTACH_ABSORIGIN_FOLLOW,dog,2)
					ApplyDamage({
						victim=dog,
						attacker=dog,
						damage_type=DAMAGE_TYPE_PURE,
						damage= dog:GetMaxHealth()*0.3,
						ability = FindItemInInventory(attacker,'item_sanchaji'),
					})
				end
			end
		end

		--血精石的使用和充能
		--使用
		if u:HasModifier('modifier_item_xuejingshi') then
			local xuejingshi_count = LoseXuejingshiCount(u) or 1

			EmitSoundOn('DOTA_Item.Bloodstone.Cast',u)
			--血精石治疗
			play_particle("particles/items_fx/bloodstone_heal.vpcf",PATTACH_OVERHEAD_FOLLOW,u,5)
			local units = FindUnitsInRadiusOnTeamGround({
				team = u:GetTeam(),
				at_team = u.at_team_id or u.team_id,
				role = 1,
				position = u:GetAbsOrigin(),
				radius = 400,
			})
			for _,luckydog in pairs(units) do
				if IsUnitExist(luckydog) then
					ModMaxHP({
						caster = luckydog,
						const = xuejingshi_count*500,
						is_heal = true,
					})
					ChessAddMana(luckydog,xuejingshi_count*50)
				end
				play_particle("particles/items_fx/bloodstone_heal_start.vpcf",PATTACH_ABSORIGIN_FOLLOW,luckydog,3)
			end
		end
		--充能
		local xuejingshi_adds = FindUnitsInRadiusOnTeamGround({
			team = u:GetTeam(),
			at_team = u.at_team_id or u.team_id,
			role = 2,
			position = u:GetAbsOrigin(),
			radius = 9999,
		})
		for _,x in pairs(xuejingshi_adds) do
			if x:HasModifier("modifier_item_xuejingshi") then
				AddXuejingshiCount(x)
			end
		end
		--6亡灵亡语：幽魂形态（如成功则return，不触发后面的）
		if attacker:HasModifier('modifier_is_undead_buff_plus_plus') == true and u.is_youhun ~= true and ((u.at_team_id or u.team_id) == (attacker.at_team_id or attacker.team_id)) and u:HasAbility('is_ward') == false and string.find(u:GetUnitName(),'chess_') ~= nil and u.is_summoned ~= true then
			local items = GetAllItemsInUnits({[1] = u})

			SummonMinion(u,u:GetUnitName(),1,nil,function(w)
				if items ~= nil then
					GiveItems2Unit(items,w)
				end
				w.is_youhun = true
				FillEmptySlot(w)
				w:AddNewModifier(w,nil,"modifier_skeleton_king_reincarnation_scepter_active",{duration = 5})
				w:SetMaxMana(0)
				Timers:CreateTimer(6,function()
					if IsUnitExist(w) == true then
						w:ForceKill(false)
					end
				end)
			end,u:GetAbsOrigin())
			return
		end
		--6术士灵魂榨取亡语：最近的术士吸取（优先级最高，不影响其他）
		local Warlock6_enemy = FindWarlock6Luckydog(u)
		if IsUnitExist(Warlock6_enemy) == true and u:HasModifier('modifier_illusion') == false and u.last_damage_ability ~= 'is_monk_buff' then

			if Warlock6_enemy:FindModifierByName("modifier_is_warlock_buff_plus_plus_buff") == nil then
				Warlock6_enemy:FindAbilityByName("is_warlock_buff_plus_plus"):ApplyDataDrivenModifier(Warlock6_enemy,Warlock6_enemy,'modifier_is_warlock_buff_plus_plus_buff',{})
				Warlock6_enemy.warlock_buff_count = 1
			else
				Warlock6_enemy.warlock_buff_count = Warlock6_enemy.warlock_buff_count + 1
				Warlock6_enemy:FindModifierByName('modifier_is_warlock_buff_plus_plus_buff'):SetStackCount(Warlock6_enemy.warlock_buff_count)
			end

			local hh = u:GetMaxHealth()*0.5
			local mm = u:GetMana()*0.5
			play_particle("particles/units/heroes/hero_dark_seer/dark_seer_surge.vpcf",PATTACH_ABSORIGIN_FOLLOW,Warlock6_enemy,3)
			ModMaxHP({
				caster = Warlock6_enemy,
				const = hh,
				is_heal = true,
			})
			ChessAddMana(Warlock6_enemy,mm)
			EmitSoundOn('warlock.brainsap',Warlock6_enemy)
			Warlock6_enemy:SetRenderColor(255-(Warlock6_enemy:GetMaxHealth()/100), 255, 255-(Warlock6_enemy:GetMaxHealth()/100))
		end

		--近战棋子亡语：所有食人魔变胖（不影响其他）
		if u:IsRangedAttacker() == false then
			for _,v in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
				if IsUnitExist(v) == true and v.team_id == u.team_id and v:entindex() ~= u:entindex() and v:HasModifier('modifier_is_ogre_buff') == true then
					if v.ogre_buff_count == nil or (v.ogre_buff_count ~= nil and v.ogre_buff_count < 10) then
						ModMaxHP({
							caster = v,
							per = 25,
						})
						ChangeModelScale({
							caster = v,
							x = 1.1, 
						})
						if v:FindModifierByName("modifier_ogre_25_attack_damage") == nil then
							AddAbilityAndSetLevel(v,"ogre_25_attack_damage",1)
							EmitSoundOn('ogre.fat',v)
							v.ogre_buff_count = 1
						else
							v:FindAbilityByName("ogre_25_attack_damage"):ApplyDataDrivenModifier(v,v,'modifier_ogre_25_attack_damage',{})
							EmitSoundOn('ogre.fat',v)
							v.ogre_buff_count = v.ogre_buff_count + 1
						end
					end
				end
			end
		end

		--亚基虫族亡语：生虫（如成功则return，不触发后面的）
		if u:HasModifier('modifier_is_aqir_buff') == true and attacker:entindex() ~= u:entindex() then
			AqirDeathRattle(u)
		end
		
		--在蛛网中死亡：诞生小蜘蛛（如成功则return，不触发后面的）
		if u:HasModifier('modifier_br_web_debuff') == true then			
			if u:FindModifierByName('modifier_br_web_debuff') == nil or u:FindModifierByName('modifier_br_web_debuff'):GetAbility() == nil then
				return
			end
			local level = u:FindModifierByName('modifier_br_web_debuff'):GetAbility():GetLevel() or 1
			local spider_name = 'br_spider'..level
			play_particle('particles/units/heroes/hero_broodmother/broodmother_spiderlings_spawn.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
			EmitSoundOn('Hero_LifeStealer.Infest',u)
			if attacker:entindex() ~= u:entindex() then
				SummonMinion(attacker,spider_name,1,nil,function(w)
					if w ~= nil then
						w:SetMana(0)
						FillEmptySlot(w)
						ExtendBeastBuff(w,attacker)
						AddAbilityAndSetLevel(w,'jiaoxie_wudi')
					end
				end,u:GetAbsOrigin())
			end
			return
		end
		local inferno = EnemyExistInferno(u)
		--概率生地狱火
		if inferno ~= nil and RandomInt(1,100) < 7 then
			SummonAnInferno(inferno)
		end
	end
end
function AqirDeathRattle(u)
	Timers:CreateTimer(0.5,function()
		local AQIR_CHESS_LIST = {
			[1] = {},
			[2] = {},
			[3] = {},
			[4] = {},
			[5] = {},
			[6] = {},
			[7] = {},
			[8] = {},
			[9] = {},
		}
		if _G.chess_list_by_synergy['is_aqir'] ~= nil then
			for _,chess_name in pairs(_G.chess_list_by_synergy['is_aqir']) do
				local mana = _G.chess_2_mana[chess_name] or 1
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name)
				mana = mana + 2
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name..'1')
				mana = mana + 2
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name..'11')
			end
		end
		if _G.chess_list_by_synergy_black_and_pandaman['is_aqir'] ~= nil then
			for _,chess_name in pairs(_G.chess_list_by_synergy_black_and_pandaman['is_aqir']) do
				local mana = _G.chess_2_mana[chess_name] or 1
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name)
				mana = mana + 2
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name..'1')
				mana = mana + 2
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name..'11')
			end
		end
		local wangchongtui_list = FindAllWangchongtuiChessByTeam((u.at_team_id or u.team_id),u.team_id)
		if wangchongtui_list ~= nil then
			for _,chess_name in pairs(wangchongtui_list) do
				local mana = _G.chess_2_mana[chess_name] or 1
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name)
				mana = mana + 2
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name..'1')
				mana = mana + 2
				if mana > 9 then mana = 9 end
				table.insert(AQIR_CHESS_LIST[mana],chess_name..'11')
			end
		end
	
		if table.maxn(AQIR_CHESS_LIST[1]) == 0 then
			AQIR_CHESS_LIST[1] = { 'chess_sk', 'chess_veno' }
		end
		if table.maxn(AQIR_CHESS_LIST[2]) == 0 then
			AQIR_CHESS_LIST[2] = { 'chess_sk', 'chess_veno' }
		end
		if table.maxn(AQIR_CHESS_LIST[9]) == 0 then
			AQIR_CHESS_LIST[9] = { 'chess_na11', 'chess_br11', }
		end
	
		local max_level,max_level_chess 
		if u:HasAbility('is_aqir') == true then
			--4虫
			max_level,max_level_chess = GetSameNameFriendChessMaxLevel(u)
		else
			--2虫，需要有感染debuff
			max_level,max_level_chess = GetSameNameFriendChessMaxLevel(u,'modifier_is_aqir_buff')
		end
	
		-- local dead_level = u:GetLevel()
	
		if max_level > 0 then
			if u:HasAbility('is_aqir') == true then
				--4虫
				-- if RandomInt(1,100) > 90 then
				-- 	max_level = max_level + 2
				-- elseif RandomInt(1,100) > 70 then
				-- 	max_level = max_level + 1
				-- end
				max_level = max_level + 1
				if RandomInt(1,100) > 93 then
					max_level = max_level + 1
				end
			else
				--2虫
				-- if RandomInt(1,100) > 75 then
				-- 	max_level = max_level + 1
				-- end
				max_level = max_level
			end
			if max_level > 9 then
				max_level = 9
			end
	
			local random_pool = AQIR_CHESS_LIST[max_level]
			local random_aqir = random_pool[RandomInt(1,table.maxn(random_pool))]
			local aqir_level = GetChessNameStar(random_aqir)
	
			if aqir_level == 1 then
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_emerge_clean_low.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
			elseif aqir_level == 2 then
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_emerge_clean_low.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
			elseif aqir_level >= 3 then
				play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_emerge_bloody.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
			end
			EmitSoundOn('Hero_LifeStealer.Infest',u)
			SummonMinion(u,random_aqir,1,nil,function(w)
				w:SetMana(0)
				FillEmptySlot(w)
				AddChessAbility(w,aqir_level)
				AddAbilityAndSetLevel(w,'jiaoxie_wudi')
				if max_level_chess ~= nil then
					LinkEffect(w,max_level_chess)
				end
				w:AddNewModifier(w,nil,"modifier_kill",{duration = 20})
			end,u:GetAbsOrigin())
		else
			play_particle('particles/units/heroes/hero_life_stealer/life_stealer_infest_cast.vpcf',PATTACH_ABSORIGIN_FOLLOW,u,5)
			EmitSoundOn('Hero_LifeStealer.Infest',u)
		end
	end)
end
function FindAllWangchongtuiChessByTeam(chessboard_id, team_id)
	local chess_list = {}
	for _,v in pairs(GetValidChessOnBoard(chessboard_id)) do
		if IsUnitExist(v) == true and v.team_id == team_id and v:HasModifier('modifier_item_wangchongtui') then
			table.insert(chess_list,GetChessBaseName(v:GetUnitName()))
		end
	end
	return chess_list
end
function GainNraqiEffect(keys)
	--无面者：获得变黑buff
	play_particle('particles/units/heroes/hero_void_spirit/astral_step/void_spirit_astral_step_dmg_burst.vpcf',PATTACH_ABSORIGIN_FOLLOW,keys.target,5)
	EmitSoundOn("Hero_Bane.BrainSap",keys.target)
	-- AddAbilityAndSetLevel(keys.target,'faceless_void_time_lock')

	--驱散一下debuff
	for _,m in pairs(keys.target:FindAllModifiers()) do
		if m:IsDebuff() and IsModifierInNraqiWhiteList(m:GetName()) ~= true then
			keys.target:RemoveModifierByName(m:GetName())
		end
	end
end
function IsModifierInNraqiWhiteList(modifier)
	local nraqi_debuff_whitelist = {
		"modifier_is_mage_buff",
		"modifier_is_mage_buff_plus",
		"modifier_is_mage_buff_plus_plus",
		"modifier_is_undead_buff",
		"modifier_is_undead_buff_plus",
		"modifier_is_undead_buff_plus_plus",
		"modifier_kill",
		"modifier_illusion",
		"modifier_marci_unleash_flurry_cooldown",
		"modifier_primal_beast_pulverize",
		"modifier_primal_beast_pulverize_self",
	}
	return FindValueInTable(nraqi_debuff_whitelist,modifier)
end

--【棋子技能】
function CopyArcWarden(team)
	local aw_table = {}
	for i,v in pairs(GetValidChessOnBoard(team)) do
		if string.find(v:GetUnitName(),'chess_aw') ~= nil then
			table.insert(aw_table,v)
		end
	end
	for ii,vv in pairs(aw_table) do
		--复制本尊
		local aposition = FindEmptyGridAtUnit(vv,nil,true)
		local team_id = vv:GetTeam()
		local at_team_id = vv.at_team_id or vv.team_id
		local items = GetAllItemsInUnits({[1] = vv})
		local x = SummonAChess(vv:GetTeam(),aposition,vv:GetUnitName(),at_team_id,100,0,items,false,nil,nil,2)
		BlinkChessX({caster=x,blink_type="fall"})
		
		x.is_copied_aw = true
		vv.is_copied_aw = true
		vv.is_self_aw = true

		local chess_star = GetChessStar(x) or 1
		-- AddAbilityAndSetLevel(x,'no_hp_bar')
		x:AddNewModifier(x,nil,"modifier_kill",{duration = 10*chess_star})
		-- vv:AddNewModifier(x,nil,"modifier_kill",{duration = 20*chess_star})
	end
end
function RefreshKaelOrbandAbility(kael,find_combo)

	if kael:HasModifier('modifier_om_multi_cast') == true and kael.is_multi_cast_enable == true then
		--多重施法，不切
		return
	end
	if kael:HasAbility("invoke") == false then
		--没invoke技能，不切
		return
	end
	if kael:FindAbilityByName("invoke"):IsCooldownReady() == false then
		--invoke技能没冷却好，不切
		return
	end

	local a_level = kael:FindAbilityByName("invoke"):GetLevel() or 1
	-- if string.find(kael:GetUnitName(),'1') then
	-- 	a_level = 2
	-- end
	-- if string.find(kael:GetUnitName(),'11') then
	-- 	a_level = 3
	-- end
	local a_list = {
		is_warrior = 'forge_spirit',
        is_assassin = 'invoker_deafening_blast_datadriven',
        is_mage = 'invoker_emp',
        is_hunter = 'invoker_deafening_blast_datadriven',
        is_elf = 'chaos_meteor_datadriven',
        is_warlock = 'alacrity',
        is_troll = 'invoker_deafening_blast_datadriven',
        is_beast = 'chaos_meteor_datadriven',
        is_human = 'invoker_sun_strike',
        is_undead = 'chaos_meteor_datadriven',
        is_orc = 'forge_spirit',
        is_goblin = 'forge_spirit',
        is_mech = 'invoker_sun_strike',
        is_knight = 'invoker_sun_strike',
        is_dragon = 'invoker_tornado_datadriven',
        is_shaman = 'invoker_tornado_datadriven',
        is_druid = 'chaos_meteor_datadriven',
        is_wizard = 'alacrity',
        is_naga = 'alacrity',
        is_element = 'forge_spirit',
        is_god = 'invoker_emp',
        is_pandaman = 'invoker_emp',
        is_aqir = 'chaos_meteor_datadriven',
        is_priest = 'invoker_sun_strike',
        is_dwarf = 'invoker_deafening_blast_datadriven',
        is_demonhunter = 'invoker_deafening_blast_datadriven',
        is_ogre = 'forge_spirit',
        is_demon = 'invoker_sun_strike',
        is_monk = 'invoker_tornado_datadriven',
        is_tauren = 'alacrity',
        is_kobold = 'chaos_meteor_datadriven',
        is_nraqi = 'invoker_sun_strike',
        is_satyr = 'invoker_tornado_datadriven',
        is_draenei = 'forge_spirit',
	}
	local aa_list = {
		[1] = 'is_warrior',
        [2] = 'is_assassin',
        [3] = 'is_mage',
        [4] = 'is_hunter',
        [5] = 'is_elf',
        [6] = 'is_warlock',
        [7] = 'is_troll',
        [8] = 'is_beast',
        [9] = 'is_human',
        [10] = 'is_undead',
        [11] = 'is_orc',
        [12] = 'is_goblin',
        [13] = 'is_mech',
        [14] = 'is_knight',
        [15] = 'is_dragon',
        [16] = 'is_shaman',
        [17] = 'is_druid',
        [18] = 'is_wizard',
        [19] = 'is_naga',
        [20] = 'is_element',
        [21] = 'is_god',
        [22] = 'is_pandaman',
        [23] = 'is_aqir',
        [24] = 'is_priest',
        [25] = 'is_dwarf',
        [26] = 'is_demonhunter',
        [27] = 'is_ogre',
        [28] = 'is_demon',
        [29] = 'is_monk',
        [30] = 'is_tauren',
        [31] = 'is_kobold',
        [32] = 'is_nraqi',
        [33] = 'is_satyr',
        [34] = 'is_draenei',
	}
	local kael_ability = a_list[aa_list[RandomInt(1,table.maxn(aa_list))]]
	local try_count = 0
	if find_combo ~= nil and a_list[find_combo] ~= nil then
		kael_ability = a_list[find_combo]
	end
	while kael.kael_ability_last ~= nil and kael.kael_ability_last == kael_ability and try_count < 100 do
		try_count = try_count + 1
		kael_ability = a_list[aa_list[RandomInt(1,table.maxn(aa_list))]]
	end
	
	local orb_table = {
		forge_spirit = {'invoker_exort','invoker_exort','invoker_quas'},
		invoker_ice_wall = {'invoker_exort','invoker_quas','invoker_quas'},
		invoker_sun_strike = {'invoker_exort','invoker_exort','invoker_exort'},
		chaos_meteor_datadriven = {'invoker_exort','invoker_exort','invoker_wex'},
		alacrity = {'invoker_exort','invoker_wex','invoker_wex'},
		invoker_emp = {'invoker_wex','invoker_wex','invoker_wex'},
		invoker_cold_snap = {'invoker_quas','invoker_quas','invoker_quas'},
		invoker_tornado_datadriven = {'invoker_quas','invoker_wex','invoker_wex'},
		invoker_deafening_blast_datadriven = {'invoker_quas','invoker_wex','invoker_exort'},
	}
	-- AddAbilityAndSetLevel(kael,'invoker_quas',a_level)
	-- AddAbilityAndSetLevel(kael,'invoker_wex',a_level)
	-- AddAbilityAndSetLevel(kael,'invoker_exort',a_level)
	AddAbilityAndSetLevel(kael,'invoker_invoke',a_level)

	kael:RemoveModifierByName("modifier_invoker_exort_instance")
	kael:RemoveModifierByName("modifier_invoker_quas_instance")
	kael:RemoveModifierByName("modifier_invoker_wex_instance")
	kael:RemoveModifierByName("modifier_invoker_exort_instance")
	kael:RemoveModifierByName("modifier_invoker_quas_instance")
	kael:RemoveModifierByName("modifier_invoker_wex_instance")
	kael:RemoveModifierByName("modifier_invoker_exort_instance")
	kael:RemoveModifierByName("modifier_invoker_quas_instance")
	kael:RemoveModifierByName("modifier_invoker_wex_instance")
	-- if kael:HasModifier("modifier_invoker_quas_instance") == false then
	-- 	kael:AddNewModifier(kael,kael:FindAbilityByName("invoker_quas"),"modifier_invoker_quas_instance",nil)
	-- 	kael:AddNewModifier(kael,kael:FindAbilityByName("invoker_wex"),"modifier_invoker_wex_instance",nil)
	-- 	kael:AddNewModifier(kael,kael:FindAbilityByName("invoker_exort"),"modifier_invoker_exort_instance",nil)
	-- end

	play_particle("particles/units/heroes/hero_invoker/invoker_invoke.vpcf",PATTACH_ABSORIGIN_FOLLOW,kael,3)
	for iii,vvv in pairs(orb_table[kael_ability]) do
		kael:AddNewModifier(kael,kael:FindAbilityByName(vvv),"modifier_"..vvv.."_instance",nil)
	end
	kael.kael_ability = kael_ability

	-- kael:RemoveAbility('invoke')
	kael:RemoveAbility('forge_spirit')
	kael:RemoveAbility('invoker_ice_wall')
	kael:RemoveAbility('invoker_sun_strike')
	kael:RemoveAbility('chaos_meteor_datadriven')
	kael:RemoveAbility('alacrity')
	kael:RemoveAbility('invoker_emp')
	kael:RemoveAbility('invoker_cold_snap')
	kael:RemoveAbility('invoker_tornado_datadriven')
	kael:RemoveAbility('invoker_deafening_blast_datadriven')

	AddAbilityAndSetLevel(kael,kael_ability,a_level)

	local cd = kael:FindAbilityByName("invoke"):GetCooldown(a_level-1) or 1
	if kael:HasAbility('is_god_buff_plus') then
		kael:FindAbilityByName("invoke"):StartCooldown(cd*0.25)
	elseif kael:HasAbility('is_god_buff') then
		kael:FindAbilityByName("invoke"):StartCooldown(cd*0.5)
	else
		kael:FindAbilityByName("invoke"):StartCooldown(cd)
	end

	kael.kael_ability_refresh = nil
	return kael_ability
end
--TK：热导飞弹
function RandomMissileStart(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()

	--三连发
	RandomMissileOne({ caster = keys.caster, ability = keys.ability })
	Timers:CreateTimer(0.3,function()
		RandomMissileOne({ caster = keys.caster, ability = keys.ability })
		Timers:CreateTimer(0.3,function()
			RandomMissileOne({ caster = keys.caster, ability = keys.ability })
			if ability_level >= 3 then
				Timers:CreateTimer(0.3,function()
					RandomMissileOne({ caster = keys.caster, ability = keys.ability })
				end)
			end
		end)
	end)
end
function RandomMissileOne(keys)
	--对一个随机的unluckydog发射导弹
	local unlucky_dog = FindUnluckyDog(keys.caster)
	if unlucky_dog ~= nil then
		if (unlucky_dog:GetAbsOrigin() - keys.caster:GetAbsOrigin()):Length2D() < 1500 then
		    ProjectileManager:CreateTrackingProjectile({
		        Target = unlucky_dog,
		        Source = keys.caster,
		        Ability = keys.ability,
		        EffectName = "particles/units/heroes/hero_tinker/tinker_missile.vpcf",
		        bDodgeable = false,
		        iMoveSpeed = 500,
		        bProvidesVision = false,
		        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
		    })
		    EmitSoundOn("Hero_Tinker.Heat-Seeking_Missile",caster)
		end
	end
end
function RandomMissileDamage(keys)
	--导弹伤害
	if keys.target:IsMagicImmune() == false then
	    ApplyDamage({
	    	victim = keys.target,
	    	attacker = keys.caster,
	    	damage_type = DAMAGE_TYPE_MAGICAL,
	    	damage = keys.damage_per_missile,
			ability = keys.ability,
	    })
	end
    EmitSoundOn("Hero_Rattletrap.Rocket_Flare.Explode",keys.target)
    play_particle("particles/units/heroes/hero_gyrocopter/gyro_guided_missile_explosion.vpcf",PATTACH_OVERHEAD_FOLLOW,keys.target,3)
end
function Bump(keys)
	local p = keys.target_points[1]
	local caster = keys.caster
	local team_id = caster.at_team_id or caster.team_id
	local position = p

	_G.unit[team_id][caster.y_x] = nil
	_G.unit[team_id][Vector2Y(position,team_id)..'_'..Vector2X(position,team_id)] = 1
	InvisibleUnitCast({
		caster = caster,
		ability = 'sandking_burrowstrike',
		level = 1,
		unluckydog = nil,
		position = position,
	})

	Timers:CreateTimer(0.3,function()
		caster:SetAbsOrigin(position)
	end)
end
function CmManaAura(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id
	local radius = keys.radius or 800
	local mana = keys.mana or 5

	for _,unit in pairs(GetValidChessOnBoard(at_team_id)) do
		if IsUnitExist(unit) and unit.team_id == team_id and unit:GetMaxMana() ~= 0 then
			play_particle('particles/units/heroes/hero_obsidian_destroyer/obsidian_destroyer_matter_manasteal.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,3)
			if unit:GetMana() < 100 then
				AMHC:CreateNumberEffect(unit,mana,2,AMHC.MSG_MISS,{128,128,255},0)
			end
			unit:GiveMana(mana)
		end
	end
end
--萨满的羊
function TriggerFrogGua(u)
	if u:FindAbilityByName("frog_voodoo") == nil then
		return 
	end
	local dog = FindUnluckyDog(u)
	if dog ~= nil and u:FindAbilityByName("frog_voodoo"):IsCooldownReady() == true then
		local newOrder = {
	 		UnitIndex = u:entindex(), 
	 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
	 		TargetIndex = dog:entindex(), 
	 		AbilityIndex = u:FindAbilityByName("frog_voodoo"):entindex(), 
	 		Position = nil, 
	 		Queue = 0 
	 	}
		ExecuteOrderFromTable(newOrder)

		if dog:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
			CopyAbility2FuhunUnit(u,dog,"frog_voodoo")
		end
		if dog:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
			CopyAbility2QinglianbaozhuUnit(u,dog,a)
		end

		TriggerHex({
			target = dog
		})
		-- u:FindAbilityByName("frog_voodoo"):StartCooldown(60)
		-- Timers:CreateTimer(2,function()
		-- 	u:RemoveAbility("frog_voodoo")
		-- end)
		return 0.5
	end
end
function ChessTechBomb(keys)
	local caster = keys.caster
	local p = keys.target_points[1]
	local explode_time = keys.explode_time or 5
	local damage = keys.damage or 800
	local scale = keys.scale or 1.2
	local range = keys.range or 400
	local at_team = caster.at_team_id or caster.team_id
	local team = caster:GetTeam()

	local y = Vector2Y(p,at_team)
	local x = Vector2X(p,at_team)

	if (_G.unit[at_team][y..'_'..x] ~= nil) then
		p = FindEmptyGridAtUnit(caster)
	end

	if p == nil or team == nil then
		return
	end

	--创建一个炸弹
	_G.unit[at_team][y..'_'..x] = 1
	local u = CreateUnitByName('enemy_bomb',p,true,nil,nil,team)
	u:SetModelScale(0.5)
	u.target_scale = 0.5
	
	AddModelScalePlus(u, scale*0.8)

	u.team_id = caster.team_id
	u.at_team_id = caster.at_team_id
	u.y_x = y..'_'..x
	u.y = y
	u.x = x

	if scale > 1.5 then
		u:SetOriginalModel('models/items/techies/crazy_night_of_magic_mines/crazy_night_of_magic_mines.vmdl')
		u:SetModel('models/items/techies/crazy_night_of_magic_mines/crazy_night_of_magic_mines.vmdl')
	elseif scale > 1.2 then
		u:SetOriginalModel('models/heroes/techies/fx_techies_remotebomb_underhollow.vmdl')
		u:SetModel('models/heroes/techies/fx_techies_remotebomb_underhollow.vmdl')
	end
	EmitSoundOn("dac.tech.plantbomb",u)
	-- play_particle("particles/units/heroes/hero_techies/techies_remote_mine.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,3)
	local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_techies/techies_remote_mine.vpcf", PATTACH_ABSORIGIN_FOLLOW, u)
	ParticleManager:SetParticleControl(pp,0,u:GetAbsOrigin())

	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)

	Timers:CreateTimer(explode_time-0.5, function()
		AddModelScalePlus(u, scale*1.2)
	end)

	Timers:CreateTimer(explode_time, function()
		_G.unit[at_team][y..'_'..x] = nil
		--爆炸
		EmitSoundOn("dac.tech.explode",u)
		play_particle("particles/dac/zhayaotong/zhayaotong.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,2)
		--伤害
		ApplyDamageInRadius({
			caster = caster,
			team = team,
			radius = range,
			role = 2,
			position = u:GetAbsOrigin(),
			damage = damage,
			damage_type = DAMAGE_TYPE_PHYSICAL,
			ability = 'chess_tech_bomb',
		})
		u:SetModelScale(0.001)
		u.target_scale = 0.001
		Timers:CreateTimer(2,function()
			if u ~= nil and u:IsNull() == false then u:Destroy() end
		end)
	end)
end
function LycSummonWolf(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local hp_per = keys.hp_per
	play_particle("particles/units/heroes/hero_lycan/lycan_shapeshift_cast.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)
	EmitSoundOn("Hero_Lycan.Shapeshift.Cast",caster)

	local name_list = {
		[1] = 'chess_lyc_wolf',
		[2] = 'chess_lyc1_wolf',
		[3] = 'chess_lyc11_wolf',
	}

	TransformAChess(caster,name_list[level],true,function(x)
		if IsUnitExist(x) then
			ModMaxHP({
				caster = x,
				per = hp_per,
				is_heal = true,
			})
			x.is_shifted = true
			local children = x:GetChildren()
				for k,child in pairs(children) do
				if child:GetClassname() == "dota_item_wearable" then
					child:RemoveSelf()
				end
			end
		end
	end)

	SummonMinion(caster,'lyc_wolf'..level,({2,2,3})[level])
end
function VisageSummonBabyDragon(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	-- play_particle("particles/units/heroes/hero_lycan/lycan_shapeshift_cast.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)
	EmitSoundOn("visage.baby",caster)
	local unluckydog_1 = nil
	local min_speed_1 = 999
	local unluckydog_2 = nil
	local min_speed_2 = 999
	-- local unluckydog_3 = nil
	-- local min_speed_3 = 999
	for i1,v1 in pairs(GetValidChessOnBoard(caster.at_team_id or caster.team_id)) do
		if v1:GetAttackSpeed() < min_speed_1 and v1.team_id ~= caster.team_id then
			min_speed_1 = v1:GetAttackSpeed()
			unluckydog_1 = v1
		end
	end
	if unluckydog_1 ~= nil then
		for i2,v2 in pairs(GetValidChessOnBoard(caster.at_team_id or caster.team_id)) do
			if v2:GetAttackSpeed() < min_speed_2 and v2.team_id ~= caster.team_id and v2:entindex() ~= unluckydog_1:entindex() then
				min_speed_2 = v2:GetAttackSpeed()
				unluckydog_2 = v2
			end
		end
	end

	Timers:CreateTimer(0.1,function()
		if _G.restore_check == false then 
			SummonMinion(caster,'visage_dragon_'..level,({1,1,2})[level],'particles/units/heroes/hero_visage/visage_summon_familiars.vpcf',function(w)
				AddAbilityAndSetLevel(w,'visage_grave_chill',level)
			end)
		end
	end)
end
function TransformAMohuaChess(u,demon_buff)
	local has_demon_buff = false
	if demon_buff ~= nil and u:HasAbility('is_demonhunter') == true then
		has_demon_buff = true 
	end
	local k_m,k_d = GetKillModifierAndDuration(u)
	if not (k_m ~= nil and k_d == 0) then
		local star = GetChessStar(u)
		local new_chess_name = 'chess_tb_mohua'..star
		TransformAChess(u,new_chess_name,true,function(x)
			if IsUnitExist(x) then
				play_particle("particles/units/heroes/hero_terrorblade/terrorblade_metamorphosis_transform.vpcf",PATTACH_ABSORIGIN_FOLLOW,x,3)
				EmitSoundOn("Hero_Terrorblade.Metamorphosis",x)
				if has_demon_buff then
					local aa = AddAbilityAndSetLevel(x,demon_buff)
					aa:ApplyDataDrivenModifier(x,x,'modifier_'..demon_buff,{})
				end
				PlayParticleOnUnitUntilDeath({
					caster = x,
					p = "particles/units/heroes/hero_terrorblade/terrorblade_metamorphosis.vpcf",
				})
				if k_m ~= nil then
					x:AddNewModifier(x,nil,k_m,{duration = k_d})
				end
			end
		end)
	end
end
function TbMohuaNew(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local p = caster:GetAbsOrigin()
	EmitSoundOn('Hero_Terrorblade.Sunder.Cast',caster)
	local team_id = caster:GetTeam()
	local at_team_id = caster.at_team_id or caster.team_id
	local exclude_entindex = caster:entindex()

	local demon_buff = nil
	if caster:HasModifier('modifier_is_demon_buff') then
		demon_buff = 'is_demon_buff'
	end
	if caster:HasModifier('modifier_is_demon_buff_plus') then
		demon_buff = 'is_demon_buff_plus'
	end
	TransformAMohuaChess(caster)

	if level > 1 then
		local luckydog1 = FindMohuaFriend(team_id, at_team_id, p, exclude_entindex)
		if luckydog1 ~= nil then
			local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_terrorblade/terrorblade_sunder.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
			ParticleManager:SetParticleControl(pp,0,caster:GetAbsOrigin())
			ParticleManager:SetParticleControl(pp,1,luckydog1:GetAbsOrigin())
			Timers:CreateTimer(2,function()
				if pp ~= nil then
					ParticleManager:DestroyParticle(pp,true)
				end
			end)
			luckydog1.is_mohua = true
			luckydog1.demon_buff = demon_buff
		end
	end

	if level > 2 then
		Timers:CreateTimer(0.4, function()
			local luckydog2 = FindMohuaFriend(team_id, at_team_id, p, exclude_entindex)
			if luckydog2 ~= nil then
				local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_terrorblade/terrorblade_sunder.vpcf", PATTACH_ABSORIGIN_FOLLOW, caster)
				ParticleManager:SetParticleControl(pp,0,caster:GetAbsOrigin())
				ParticleManager:SetParticleControl(pp,1,luckydog2:GetAbsOrigin())
				Timers:CreateTimer(2,function()
					if pp ~= nil then
						ParticleManager:DestroyParticle(pp,true)
					end
				end)
				luckydog2.is_mohua = true
				luckydog2.demon_buff = demon_buff
			end
		end)
	end
end
function FindMohuaFriend(team_id, chessboard_id, p, exclude_entindex)
	local luckydog = nil
	local distance_min = 9999
	for _,unit in pairs (GetValidChessOnBoard(chessboard_id)) do
		if unit:GetTeam() == team_id and unit:HasAbility('is_ward') == false and string.find(unit:GetUnitName(), 'mohua') == nil and unit.is_mohua ~= true and (exclude_entindex == nil or unit:entindex() ~= exclude_entindex) then
			local distance = (unit:GetAbsOrigin() - p):Length2D()
			if distance < distance_min then
				distance_min = distance
				luckydog = unit
			end
		end
	end
	return luckydog
end
function VenoSummonWard(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local p = keys.target_points[1]

	SummonMinion(caster,'veno_ward'..level,({1,1,2})[level])
end
function InvokerSpirit(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	SummonMinion(caster,'invoker_spirit'..level,2)
end
function FurTree(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local p = keys.target_points[1]

	SummonMinion(caster,'fur_tree'..level,({1,2,2})[level],"particles/units/heroes/hero_furion/furion_force_of_nature_cast.vpcf",nil,'random')
end
function LdBear(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	SummonMinion(caster,'ld_bear'..level,1)
end
function BmBeast(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1

	SummonMinion(caster,'bm_beast'..level,1,nil,function(w)
		if w == nil or w:IsNull() == true then return end
		if w:GetUnitName() == 'bm_beast3' then
			--3级熊，嘲讽
			Timers:CreateTimer(0.3,function()
				ExecuteOrderFromTable({
			 		UnitIndex = w:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
			 		TargetIndex = nil, --Optional.  Only used when targeting units
			 		AbilityIndex = w:FindAbilityByName('bm_bear_taunt'):entindex(), --Optional.  Only used when casting abilities
			 		Position = nil, --Optional.  Only used when targeting the ground
			 		Queue = 0 --Optional.  Used for queueing up abilities
			 	})
			end)
		end
	end)
end
function BmBearTaunt(keys)
	local caster = keys.caster
	local position = caster:GetAbsOrigin()
	local team = caster.team_id
	local unlucky_dogs = FindUnitsInRadiusByTeam({
		team = team,
		role = 2,
		position = position,
		radius = 205,
	})

	for _,u in pairs(unlucky_dogs) do 
		ExecuteOrderFromTable({
	 		UnitIndex = u:entindex(), 
	 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
	 		TargetIndex = caster:entindex(), 
	 		Queue = 0
	 	})
	end
end
function CKillusion(keys)
	local caster = keys.caster
	play_particle("particles/units/heroes/hero_chaos_knight/chaos_knight_phantasm.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,3)
	EmitSoundOn("Hero_ChaosKnight.Phantasm",caster)

	SummonMinion(caster,'chess_ck_ssr_illusion',3,nil,function(w)
		w:AddNewModifier(w,nil,"modifier_illusion",{duration=60})
		w:SetMaxMana(0)
		FillEmptySlot(w)
	end)
end
function NecSSRScythe(keys)
	local target = keys.target
	local caster = keys.caster
	local damage = 99999

	play_particle_controlIndex("particles/econ/items/necrolyte/necro_sullen_harvest/necro_ti7_immortal_scythe_start.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3,1)
	EmitSoundOn("Hero_Necrolyte.ReapersScythe.Target",target)

	EmitSoundOn("necrolyte_necr_kill_10",target)

	-- --如果目标受伤 就斩杀
	-- if target:GetHealth() < target:GetMaxHealth() then
	-- 	damage = 9999
	-- end

	Timers:CreateTimer(1.5,function()
		local damageTable = {
	    	victim=target,
	    	attacker=caster,
	    	damage_type=DAMAGE_TYPE_PURE,
	    	damage=damage
	    }
	    ApplyDamage(damageTable)
	end)
end
function TinyTouzhi(keys)
	local p = keys.target_points[1]
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	
	local radius = keys.radius or 200
	local damage = keys.damage or 100
	local stun_duration = keys.stun or 1

	local target = FindUnluckyDog190(caster)
	if target == nil or target.stop_moving == true or target.is_moving == true then
		return
	end

	local team_id = target.at_team_id or target.team_id
	local v = FindFarthestCanAttackEnemyEmptyGrid(caster)
	-- if v == nil or (v-target:GetAbsOrigin()):Length2D() < 400 then
	-- 	v = FindFarthestEmptyGrid(target)
	-- end
	if v == nil or (v-target:GetAbsOrigin()):Length2D() < 400 or target:HasMovementCapability() == false then
		v = target:GetAbsOrigin()
	end

	local yy = target.y
	local xx = target.x

	local y = Vector2Y(v,team_id)
	local x = Vector2X(v,team_id)
	-- local stun_duration = 1 --((v-target:GetAbsOrigin()):Length2D()/1000)


	Timers:CreateTimer(1+0.1,function()
		ApplyDamageInRadius({
			caster = caster,
			team = caster.team_id,
			radius = radius,
			role = 2,
			position = target:GetAbsOrigin(),
			damage = damage,
			damage_type = DAMAGE_TYPE_PHYSICAL,
			stun_duration = stun_duration,
			stun_partical = "particles/units/heroes/hero_tiny/tiny_toss_impact.vpcf",
			ability = 'tiny_touzhi',
		})
		play_particle("particles/units/heroes/hero_tiny/tiny_toss_impact.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
		EmitSoundOn('Ability.TossImpact',target)
	end)

	target:AddNewModifier(target,nil,"modifier_stunned",{ duration = 1+stun_duration })
	--先清除再添加，投掷原地后格子仍然可以占用
	_G.unit[team_id][yy..'_'..xx] = nil
	_G.unit[team_id][y..'_'..x] = 1

	BlinkChessX({p=v,caster=target,blink_type='toss'})
	target.y_x = y..'_'..x
	target.y = y
	target.x = x
end
function QiquWaibiao(keys)
	local attacker = keys.attacker
	local caster = keys.caster
	local duration = keys.duration or 3

	if attacker:Script_GetAttackRange() < 250 or keys.ranged_enable ~= nil then  
		--近战
		EmitSoundOn("Hero_Tiny.CraggyExterior",attacker)
		attacker:AddNewModifier(attacker,nil,"modifier_stunned",{ duration = duration })
		attacker:AddNewModifier(attacker,nil,"modifier_medusa_stone_gaze_stone",{ duration = duration })
	end
end
function AcidSpray(keys)
	local caster = keys.caster
	local ability_level = keys.ability_level

	InvisibleUnitCast({
		caster = caster,
		ability = 'ability_acid_spray',
		level = ability_level,
		unluckydog = nil,
		position = caster:GetAbsOrigin(),
		ignore_nether_ward = true,
	})
end
function ZeusThunder(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel() or 1
	local damage = keys.damage or 100
	local damage_per = keys.damage_per or 10

	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	EmitSoundOn("Hero_Zuus.GodsWrath",caster)
	local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_zuus/zuus_thundergods_wrath_start.vpcf",PATTACH_ABSORIGIN_FOLLOW, caster)
	ParticleManager:SetParticleControlEnt( pp, 0, u, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, u, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)
	
	local thunder_count = 0
	for _,v in pairs(GetValidChessOnBoard(at_team_id)) do
		if v ~= nil and v:IsNull() == false and v:IsAlive() == true and v.x and v.y and caster.x and caster.y then
			if v.team_id ~= caster.team_id and (v.x+v.y) % 2 == (caster.x+caster.y) % 2 then
			-- if v.team_id ~= caster.team_id and RandomInt(0,100) >= 50 then
				ZeusThunderOne({
					caster = caster,
					victim = v,
					damage = math.floor(v:GetHealth()*damage_per/100 + damage),
					ability = ability,
				})
				thunder_count = thunder_count + 1
			end
		end
	end

	if thunder_count == 0 then
		--空大
		play_particle('particles/econ/events/fall_2021/deny_fall_2021.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)
	end

	-- if thunder_count == 0 then
	-- 	local v = FindUnluckyDog(caster)
	-- 	if v ~= nil then
	-- 		ZeusThunderOne({
	-- 			caster = caster,
	-- 			victim = v,
	-- 			damage = math.floor(v:GetHealth()*damage_per/100 + damage),
	-- 			ability = ability,
	-- 		})
	-- 	end
	-- end
end
function ZeusThunderOne(keys)
	local caster = keys.caster
	local victim = keys.victim
	local damage = keys.damage
	EmitSoundOn('Hero_Zuus.GodsWrath.Target',victim)
    local pp = ParticleManager:CreateParticle("particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_strike.vpcf",PATTACH_ABSORIGIN_FOLLOW, victim)
	ParticleManager:SetParticleControlEnt( pp, 0, victim, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, victim, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true );
	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)

	if victim:IsMagicImmune() == false then
		ApplyDamageDelay({
			caster = caster,
			victim = victim,
			damage = damage,
			damage_type = DAMAGE_TYPE_MAGICAL,
			delay = 0.5,
			p = "particles/units/heroes/hero_stormspirit/stormspirit_overload_discharge.vpcf",
			ability = keys.ability,
		})
	end
end
function ZeusThunderCourier(zeus,courier,level)
	local caster = zeus
	local target = courier
	local damage_courier_per = 5.0+ 5*level

	local damage = math.floor(target:GetHealth() * damage_courier_per / 100)

	local after_hp = target:GetHealth() - damage
	if after_hp <= 0 then
		after_hp = 0
	end
	
	PlayParticleOnUnitUntilDeath({
		caster = caster,
		p = "particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_bolt_child.vpcf",
	})
	play_particle('particles/units/heroes/hero_stormspirit/stormspirit_overload_discharge.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)

	Timers:CreateTimer(RandomFloat(0.3,0.8),function()
		if target:IsHero() == true and after_hp <= 0 then
			target:ForceKill(false)
			_G.counterpart[target:GetTeam()] = -1
			SyncHP(target)
			target:SetMana(0)
			AMHC:CreateNumberEffect(target,damage_all,2,AMHC.MSG_MISS,"red",9)
			return
		end
		target:SetHealth(after_hp)
		SyncHP(target)
		AMHC:CreateNumberEffect(target,damage,2,AMHC.MSG_MISS,"red",9)
		EmitSoundOn("Frostivus.PointScored.Enemy",damage)
	end)
end
function MarsShieldDamage(keys)
	local caster = keys.caster
	local radius = 200
	local ability = keys.ability
	local attack_damage = keys.damage
	local damage_table = {
		[1] = 200,
		[2] = 250,
		[3] = 350,
	}
	local damage = damage_table[ability:GetLevel()]

	ApplyDamageInRadius({
		delay = 0.4,
		caster = caster,
		team = caster.team_id,
		radius = 225,
		role = 2,
		position = caster:GetAbsOrigin()+caster:GetForwardVector()*175,
		damage = damage,
		damage_type = DAMAGE_TYPE_PHYSICAL,
		ability = 'mars_bulwark_attack',
		knockback = true,
	})
end
function StartMarsShieldCD(caster)
	if caster:HasAbility("mars_bulwark_attack") then
		if caster:HasAbility('is_god_buff_plus') then
			caster:FindAbilityByName("mars_bulwark_attack"):StartCooldown(8*0.25)
		elseif caster:HasAbility('is_god_buff') then
			caster:FindAbilityByName("mars_bulwark_attack"):StartCooldown(8*0.5)
		else
			caster:FindAbilityByName("mars_bulwark_attack"):StartCooldown(8)
		end
	end
end
function ShallowGrave(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local duration = ability:GetLevelSpecialValueFor( "duration", level - 1 )

	if IsUnitExist(caster) == false then 
		return
	end
	local u1 = FindShallowGraveFriendInner(caster)
	if u1 ~= nil then
		if u1:FindModifierByName("modifier_dazzle_shallow_grave") == nil then
			u1:AddNewModifier(u1,nil,"modifier_dazzle_shallow_grave",{duration=duration})
			EmitSoundOn("Hero_Dazzle.Shallow_Grave",u1)
		end
		if level >= 2 then
			Timers:CreateTimer(0.5,function()
				if IsUnitExist(caster) == false then 
					return
				end
				local u2 = FindShallowGraveFriendInner(caster)
				if u2 ~= nil then
					if u2:FindModifierByName("modifier_dazzle_shallow_grave") == nil then
						u2:AddNewModifier(u2,nil,"modifier_dazzle_shallow_grave",{duration=duration})
						EmitSoundOn("Hero_Dazzle.Shallow_Grave",u2)
					end
					if level >= 3 then
						Timers:CreateTimer(0.5,function()
							if IsUnitExist(caster) == false then 
								return
							end
							local u3 = FindShallowGraveFriendInner(caster)
							if u3 ~= nil then
								if u3:FindModifierByName("modifier_dazzle_shallow_grave") == nil then
									u3:AddNewModifier(u3,nil,"modifier_dazzle_shallow_grave",{duration=duration})
									EmitSoundOn("Hero_Dazzle.Shallow_Grave",u3)
								end
							end
						end)
					end
				end
			end)
		end
	end
end
function LichBingjia(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()

	InvisibleUnitCast({
		caster = caster,
		ability = 'lich_frost_shield',
		level = level,
		unluckydog = target,
	})
	
	InvisibleUnitCast({
		caster = caster,
		ability = 'give_bingjia',
		level = level,
		unluckydog = target,
	})
end
function CastGodsStrength(u)
	local team_id = u.team_id
	local at_team_id = u.at_team_id or u.team_id
	local level = u:FindAbilityByName("sven_gods_strength"):GetLevel()

	--统计有多少个恶魔
	local demon_table = {}
	local demon_count = 0
	for _,unit in pairs (GetValidChessOnBoard(at_team_id)) do
		if unit.team_id == u.team_id and unit:HasAbility('is_demon') then
			demon_count = demon_count + 1
		end
	end
	for _,unit in pairs (GetValidChessOnBoard(at_team_id)) do
		if unit.team_id == u.team_id and unit:HasAbility('is_demon') and unit:HasModifier('modifier_is_demon_buff') and unit.sven_buffed ~= true then
			unit.sven_buffed = true
			for i=1,demon_count do
				InvisibleUnitCast({
					caster = unit,
					ability = 'give_shenli',
					level = level,
					unluckydog = unit,
					ignore_nether_ward = true,
				})
			end
		end
	end
end
function GsMoji(keys)
	InvisibleUnitCast({
		caster = keys.caster,
		ability = 'grimstroke_dark_artistry',
		level = keys.ability:GetLevel(),
		position = keys.target_points[1],
	})
	keys.ability.stack = 0
end
function GsMojiHit(keys)
	local caster = keys.caster
	local target = keys.target
	local stack = keys.ability.stack or 0
	local count = keys.ability:GetLevelSpecialValueFor( "fuhun_stack_count", keys.ability:GetLevel() - 1)
	if caster:GetTeam() ~= target:GetTeam() and target:FindModifierByName('modifier_gs_give_fuhun') == nil and stack < count then
		keys.ability:ApplyDataDrivenModifier(caster, target, 'modifier_gs_give_fuhun', nil)
		keys.ability.stack = stack + 1
	end
end
function AddFuhunDebuffParticle(keys)
	local u = keys.target
	local pp = ParticleManager:CreateParticle("effect/gs_fuhun/debuffdebuff.vpcf", PATTACH_ABSORIGIN_FOLLOW, u)
	ParticleManager:SetParticleControlEnt( pp, 0, u, PATTACH_ABSORIGIN_FOLLOW, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 1, u, PATTACH_ABSORIGIN_FOLLOW, nil, u:GetOrigin(), true );
	ParticleManager:SetParticleControlEnt( pp, 2, u, PATTACH_ABSORIGIN_FOLLOW, nil, u:GetOrigin(), true );

	u.fuhun_debuff_particle = pp

	u:FindModifierByName("modifier_gs_give_fuhun"):SetStackCount(1)
end
function RemoveFuhunDebuffParticle(keys)
	local target = keys.target
	if target ~= nil and target.fuhun_debuff_particle ~= nil then
		ParticleManager:DestroyParticle(target.fuhun_debuff_particle,true)
	end
end
function CopyAbility2FuhunUnit(unit,unluckydog,ability)
	if unit:IsSilenced() == true or unit:HasModifier('modifier_silencer_global_silence') then
		return
	end
	if unit == nil or unit:FindAbilityByName(ability) == nil then
		return
	end
	local level = unit:FindAbilityByName(ability):GetLevel()
	for _,u in pairs(GetValidChessOnBoard(unit.at_team_id or unit.team_id)) do
		if IsUnitExist(u) == true and u:GetTeam() ~= unit:GetTeam() and u:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
			local l = u:FindModifierByName("modifier_gs_give_fuhun"):GetStackCount()
			l = l - 1
			if l == 0 then
				u:RemoveModifierByName('modifier_gs_give_fuhun')
			else
				u:FindModifierByName("modifier_gs_give_fuhun"):SetStackCount(l)
			end
			if u:entindex() ~= unluckydog:entindex() then
				Timers:CreateTimer(RandomFloat(0.1,0.5),function()
					if unit:IsSilenced() == true or unit:HasModifier('modifier_silencer_global_silence') then
						return
					end
					InvisibleUnitCast({
						caster = unit,
						ability = ability,
						level = level,
						unluckydog = u,
						force_unluckydog = u,
						origin_unluckydog = unluckydog,
					})
					if u:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
						CopyAbility2QinglianbaozhuUnit(u,unit,ability)
					end
				end)
			end
		end
	end
end
function CopyAbility2QinglianbaozhuUnit(unit,unluckydog,ability)
	local level = unit:FindAbilityByName(ability):GetLevel()
	for slot=0,5 do
		if unluckydog:GetItemInSlot(slot)~= nil then
			local qinglian_ability = unluckydog:GetItemInSlot(slot)
			local name = qinglian_ability:GetAbilityName()
			if name == 'item_qinglianbaozhu' and qinglian_ability:IsCooldownReady() == true then
				qinglian_ability:StartCooldown(3)
				Timers:CreateTimer(0.5,function()
					InvisibleUnitCast({
						caster = unluckydog,
						ability = ability,
						level = level,
						unluckydog = unit,
						force_unluckydog = unit,
					})

					play_particle('particles/items3_fx/lotus_orb_reflect.vpcf',PATTACH_ABSORIGIN_FOLLOW,unluckydog,3)
					EmitSoundOn("item.lianhua",unluckydog)
					if unit:FindModifierByName('modifier_gs_give_fuhun') ~= nil then
						CopyAbility2FuhunUnit(unluckydog,unit,ability)
					end
					if unit:FindModifierByName('modifier_item_qinglianbaozhu') ~= nil then
						CopyAbility2QinglianbaozhuUnit(unit,unluckydog,ability)
					end
				end)
			end
		end
	end
end
function SlarkNengliangzhuanyi(keys)
	local ability = keys.ability
	local level = ability:GetLevel()
	local caster = keys.caster
	local target = keys.target
	local max_stack_count = keys.max_stack_count
	if IsUnitExist(caster) == false or IsUnitExist(target) == false then return end
	local pervious_buff_count = 0
	local pervious_debuff_count = 0
	if caster:HasModifier("modifier_slark_nengliangzhuanyi_buff_counter") == true then
		pervious_buff_count = caster:GetModifierStackCount("modifier_slark_nengliangzhuanyi_buff_counter", caster)
	end
	if target:HasModifier("modifier_slark_nengliangzhuanyi_debuff_counter") == true then
		pervious_debuff_count = target:GetModifierStackCount("modifier_slark_nengliangzhuanyi_debuff_counter", caster)
	end

	if pervious_buff_count == 0 then
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_slark_nengliangzhuanyi_buff_counter", nil)
		caster:SetModifierStackCount("modifier_slark_nengliangzhuanyi_buff_counter", caster, 1)
	end
	if pervious_debuff_count == 0 then
		ability:ApplyDataDrivenModifier(caster, target, "modifier_slark_nengliangzhuanyi_debuff_counter", nil)
		target:SetModifierStackCount("modifier_slark_nengliangzhuanyi_buff_counter", caster, 1)
	end

	if pervious_buff_count < max_stack_count and pervious_debuff_count < max_stack_count and caster:FindModifierByName("modifier_slark_nengliangzhuanyi_buff_counter") ~= nil then
		caster:FindModifierByName("modifier_slark_nengliangzhuanyi_buff_counter"):IncrementStackCount()
		if target ~= nil and target:FindModifierByName("modifier_slark_nengliangzhuanyi_debuff_counter") ~= nil then
			target:FindModifierByName("modifier_slark_nengliangzhuanyi_debuff_counter"):IncrementStackCount()
		end
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_slark_nengliangzhuanyi_buff", nil)
		ability:ApplyDataDrivenModifier(caster, target, "modifier_slark_nengliangzhuanyi_debuff", nil)

		local effect_list = {
			[1] = 'particles/econ/items/slark/slark_ti6_blade/slark_ti6_blade_essence_shift_gold_swipe_dark.vpcf',
			[2] = 'particles/econ/items/slark/slark_ti6_blade/slark_ti6_blade_essence_shift_swipe.vpcf',
			[3] = 'particles/econ/items/slark/slark_ti6_blade/slark_ti6_blade_essence_shift_gold.vpcf',
		}
		play_particle(effect_list[level],PATTACH_ABSORIGIN_FOLLOW,target,2)
	end
end
function TrollRexuezhanhun(keys)
	local ability = keys.ability
	local caster = keys.caster
	local max_stack_count = keys.max_stack_count

	local pervious_buff_count = 0
	if caster ~= nil and caster:HasModifier("modifier_troll_rexuezhanhun_counter") == true then
		pervious_buff_count = caster:GetModifierStackCount("modifier_troll_rexuezhanhun_counter", caster)
	end
	if caster ~= nil and ability ~= nil and pervious_buff_count == 0 then
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_troll_rexuezhanhun_counter", nil)
		caster:SetModifierStackCount("modifier_troll_rexuezhanhun_counter", caster, 1)
	end

	if caster ~= nil and ability ~= nil and pervious_buff_count < max_stack_count and caster:FindModifierByName("modifier_troll_rexuezhanhun_counter") ~= nil then
		caster:FindModifierByName("modifier_troll_rexuezhanhun_counter"):IncrementStackCount()
		ability:ApplyDataDrivenModifier(caster, caster, "modifier_troll_rexuezhanhun_buff", nil)
	end
end
function FingerOfDeathDamage(keys)
	local caster = keys.caster
	local target = keys.target	
end
function LionManaDrainStart(keys)
	local caster = keys.caster
	local target = keys.target
end
function LionManaDrainEnd(keys)
	local caster = keys.caster
	local target = keys.target
	local ability_level = keys.ability:GetLevel()
	-- local cd_reduce = caster:FindAbilityByName('lion_mana_drain_datadriven'):GetSpecialValueFor('cd_reduce')

	if IsUnitExist(caster) == true and caster:GetMana() >= 0 and caster.is_comboing ~= true then
		caster.is_comboing = true
		caster:SwapAbilities('lion_mana_drain_datadriven','keeper_of_the_light_chakra_magic', false, true)
		Timers:CreateTimer(1.5,function()
			if IsUnitExist(caster) == true then
		 		caster:SwapAbilities('keeper_of_the_light_chakra_magic','lion_mana_drain_datadriven', false, true)
				caster.is_comboing = nil
			end
	 	end)
		Timers:CreateTimer(0.1,function()
			if caster:FindAbilityByName('keeper_of_the_light_chakra_magic') ~= nil then
				--找三个队友
				local luckydog_1 = nil
				local level_1 = -999
				local luckydog_2 = nil
				local level_2 = -999
				local luckydog_3 = nil
				local level_3 = -999
				for i1,v1 in pairs(GetValidChessOnBoard(caster.at_team_id or caster.team_id)) do
					if v1:GetMaxMana() > 0 and v1:GetMana() < 100 and v1:GetLevel() - GetChessAbilityCD(v1) > level_1 and v1.team_id == caster.team_id and v1:entindex() ~= caster:entindex() then
						level_1 = v1:GetLevel() - GetChessAbilityCD(v1)
						luckydog_1 = v1
					end
				end
				if luckydog_1 ~= nil and ability_level >= 2 then
					for i2,v2 in pairs(GetValidChessOnBoard(caster.at_team_id or caster.team_id)) do
						if v2:GetMaxMana() > 0 and v2:GetMana() < 100 and v2:GetLevel() - GetChessAbilityCD(v2) > level_2 and v2.team_id == caster.team_id and v2:entindex() ~= luckydog_1:entindex() and v2:entindex() ~= caster:entindex() then
							level_2 = v2:GetLevel() - GetChessAbilityCD(v2)
							luckydog_2 = v2
						end
					end
				end
				if luckydog_1 ~= nil and luckydog_2 ~= nil and ability_level >= 3 then
					for i3,v3 in pairs(GetValidChessOnBoard(caster.at_team_id or caster.team_id)) do
						if v3:GetMaxMana() > 0 and v3:GetMana() < 100 and v3:GetLevel() - GetChessAbilityCD(v3) > level_3 and v3.team_id == caster.team_id and v3:entindex() ~= luckydog_2:entindex() and v3:entindex() ~= luckydog_1:entindex() and v3:entindex() ~= caster:entindex() then
							level_3 = v3:GetLevel() - GetChessAbilityCD(v3)
							luckydog_3 = v3
						end
					end
				end

				if luckydog_1 == nil then
					return
				end

				ExecuteOrderFromTable({
			 		UnitIndex = caster:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
			 		TargetIndex = luckydog_1:entindex(), --Optional.  Only used when targeting units
			 		AbilityIndex = caster:FindAbilityByName('keeper_of_the_light_chakra_magic'):entindex(), --Optional.  Only used when casting abilities
			 		Position = nil, --Optional.  Only used when targeting the ground
			 		Queue = 0 --Optional.  Used for queueing up abilities
			 	})
			 	Timers:CreateTimer(0.3,function()
					local give_mana = caster:GetMana()
					caster:SetMana(0)

					if IsUnitExist(luckydog_1) == true then
						luckydog_1:GiveMana(give_mana)
						-- ReduceChessAbilityCD(luckydog_1,cd_reduce)
						AMHC:CreateNumberEffect(luckydog_1,give_mana,2,AMHC.MSG_MISS,{128,128,255},0)
					end
					if IsUnitExist(luckydog_2) == true then
						local pp2 = ParticleManager:CreateParticle('particles/units/heroes/hero_keeper_of_the_light/keeper_of_the_light_chakra_magic.vpcf', PATTACH_ABSORIGIN_FOLLOW, luckydog_2)
						ParticleManager:SetParticleControlEnt( pp2, 0, luckydog_2, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_2:GetOrigin(), true );
						ParticleManager:SetParticleControlEnt( pp2, 1, luckydog_2, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_2:GetOrigin(), true );
						Timers:CreateTimer(3,function()
							if pp2 ~= nil then
								ParticleManager:DestroyParticle(pp2,true)
							end
						end)

						luckydog_2:GiveMana(give_mana)
						-- ReduceChessAbilityCD(luckydog_2,cd_reduce)
						AMHC:CreateNumberEffect(luckydog_2,give_mana,2,AMHC.MSG_MISS,{128,128,255},0)
					end
					if IsUnitExist(luckydog_3) == true then
						local pp3 = ParticleManager:CreateParticle('particles/units/heroes/hero_keeper_of_the_light/keeper_of_the_light_chakra_magic.vpcf', PATTACH_ABSORIGIN_FOLLOW, luckydog_3)
						ParticleManager:SetParticleControlEnt( pp3, 0, luckydog_3, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_3:GetOrigin(), true );
						ParticleManager:SetParticleControlEnt( pp3, 1, luckydog_3, PATTACH_ABSORIGIN_FOLLOW, nil, luckydog_3:GetOrigin(), true );
						Timers:CreateTimer(3,function()
							if pp3 ~= nil then
								ParticleManager:DestroyParticle(pp3,true)
							end
						end)

						luckydog_3:GiveMana(give_mana)
						-- ReduceChessAbilityCD(luckydog_3,cd_reduce)
						AMHC:CreateNumberEffect(luckydog_3,give_mana,2,AMHC.MSG_MISS,{128,128,255},0)
					end
			 	end)
			 	
			end
		end)
	end
end
--其实命运敕令第三个字应该都chi，但是语死早的代码里有很多mingyunsheling，懒得改了...囧
function OracleMingyunSheling(keys)
	local caster = keys.caster
	local u1 = keys.target
	local level = keys.ability:GetLevel() or 1
	if IsUnitExist(caster) == false or IsUnitExist(u1) == false then 
		return
	end
	local sub_ability_name = 'oracle_mingyunsheling_one'

	local u0 = FindMingyunShelingTarget(u1)
	if u0 == nil then
		return
	end

	if u1 ~= nil then
		u1.has_mingyun_sheling = true
		InvisibleUnitCast({
			caster = caster,
			ability = sub_ability_name,
			level = level,
			unluckydog = u1,
		})

		if level >= 2 then
			Timers:CreateTimer(0.1,function()
				if IsUnitExist(caster) == false then 
					return
				end
				local u2 = FindMingyunShelingTarget(u1)
				if u2 ~= nil then
					u2.has_mingyun_sheling = true
					InvisibleUnitCast({
						caster = caster,
						ability = sub_ability_name,
						level = level,
						unluckydog = u2,
						ignore_nether_ward = true,
					})
					if level >= 3 then
						Timers:CreateTimer(0.1,function()
							if IsUnitExist(caster) == false then 
								return
							end
							local u3 = FindMingyunShelingTarget(u2)
							if u3 ~= nil then
								u3.has_mingyun_sheling = true
								InvisibleUnitCast({
									caster = caster,
									ability = sub_ability_name,
									level = level,
									unluckydog = u3,
									ignore_nether_ward = true,
								})
							end
						end)
					end
				end
			end)
		end
	end
end
function AddMingyunShelingDebuff(keys)
	local target = keys.target
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local jingu_duration = ability:GetLevelSpecialValueFor( "jingu_duration", level - 1 )	

	if BlockByLinken(target) == false then
		ability:ApplyDataDrivenModifier(target,target,'modifier_oracle_mingyunsheling',{ duration = jingu_duration})
	end
end
function RemoveMingyunSheling(keys)
	local target = keys.target
	target.has_mingyun_sheling = nil
end
function EnemyExistInferno(e)
	for _,v in pairs(GetValidChessOnBoard(e.at_team_id or e.team_id)) do
		if IsUnitExist(v) == true and v.team_id ~= e.team_id and v:GetUnitName() == 'wl_golem' then
			return v
		end
	end
	return nil
end
function OmMultiCast(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local target = keys.target

	local u1 = target
	if IsUnitExist(u1) ~= true then
		u1 = FindBestMulticastFriend(caster)
	end
	if u1 ~= nil then
		ability:ApplyDataDrivenModifier(u1,u1,'modifier_om_multi_cast',{ duration = 60 })
		EmitSoundOn('om.multi_cast',u1)
		PlayParticleOnUnitUntilDeath({
			caster = u1,
			p = 'effect/pray/blue_pray.vpcf',
		})
	end

	if level >= 2 then
		Timers:CreateTimer(0.1,function()
			u2 = FindBestMulticastFriend(caster)
			if u2 ~= nil then
				ability:ApplyDataDrivenModifier(u2,u2,'modifier_om_multi_cast',{ duration = 60 })
				EmitSoundOn('om.multi_cast',u2)
				PlayParticleOnUnitUntilDeath({
					caster = u2,
					p = 'effect/pray/blue_pray.vpcf',
				})

				if level >= 3 then
					Timers:CreateTimer(0.1,function()
						u3 = FindBestMulticastFriend(caster)
						if u3 ~= nil then
							ability:ApplyDataDrivenModifier(u3,u3,'modifier_om_multi_cast',{ duration = 60 })
							EmitSoundOn('om.multi_cast',u3)
							PlayParticleOnUnitUntilDeath({
								caster = u3,
								p = 'effect/pray/blue_pray.vpcf',
							})
						end

						-- Timers:CreateTimer(0.1,function()
						-- 	u4 = FindBestMulticastFriend(caster)
						-- 	if u4 ~= nil then
						-- 		ability:ApplyDataDrivenModifier(u4,u4,'modifier_om_multi_cast',{ duration = 60 })
						-- 		EmitSoundOn('om.multi_cast',u4)
						-- 		PlayParticleOnUnitUntilDeath({
						-- 			caster = u4,
						-- 			p = 'effect/pray/blue_pray.vpcf',
						-- 		})
						-- 	end
						-- end)
					end)
				end
			end
		end)
	end
end
function MultiCast(u)
	if u:HasModifier('modifier_om_multi_cast') == true and u.is_multi_cast_enable == true and HasAbilityBuff(u) == false then
		local a = nil
		if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
			a = u.steal_ability
		elseif string.find(u:GetUnitName(),'chess_kael') and (u.kael_ability ~= nil or u.kael_ability_last ~= nil) then
			a = u.kael_ability or u.kael_ability_last
		else
			a = _G.chess_ability_list[u:GetUnitName()] or _G.summon_ability_list[u:GetUnitName()]
		end
		if u.ice_or_fire == 'fire' then
			a = 'jakiro_macropyre'
		end
		if u.ice_or_fire == 'ice' then
			a = 'jakiro_ice_path'
		end
		if a ~= nil and u:FindAbilityByName(a) ~= nil and u:FindAbilityByName(a):IsCooldownReady() == false then
			
			PlayMultiCastParticle({
				p = 'effect/multicast/1.vpcf',
				caster = u,
			})

			u:FindAbilityByName(a):EndCooldown()
			EmitSoundOn("om.multi_cast2",u)
			u:RemoveModifierByName('modifier_om_multi_cast')
			u:SetMana(GetManaCostX(u,a))
			u.is_multi_cast_enable = false
		else
			return
		end
		return 0.1
	else
		return
	end
end
--棋子施法（false为施法失败，true为施法成功）
function OnChessCastStart(u)
	--触发啄木鸟图腾
	local ward_nether_result = WardNether({
		caster = u,
	})
	if ward_nether_result == true then
		--如果施法被啄木鸟图腾沉默了，就不进行后面的逻辑
		return false
	end

	if u:HasModifier('modifier_om_multi_cast') == true then
		u.is_multi_cast_enable = true
	else
		if string.find(u:GetUnitName(),'chess_kael') ~= nil then
			u.kael_ability_refresh = true
			u.kael_ability_last = u.kael_ability
			u.kael_ability = nil
		end
	end
	if u:HasModifier('modifier_is_shaman_buff_plus_plus') == true then
		--6萨满施法进化
		u.evolve_result_6 = RandomEvolveChess(u,2)
		AddAbilityAndSetLevel(u,'evolve_immediate')
	end	
	return true
end
function PlayMultiCastParticle(keys)
	local p = keys.p
	local u = keys.caster
	local multi = keys.multi or 2
	if u == nil then
		return
	end
	local pos = keys.pos or PATTACH_OVERHEAD_FOLLOW
	local pp = ParticleManager:CreateParticle(p, pos, u)
	-- ParticleManager:SetParticleControlEnt( pp, 0, u, pos, nil, Vector(multi,1,1), true )
	-- ParticleManager:SetParticleControlEnt( pp, 1, u, pos, nil, Vector(multi,1,1), true )

	Timers:CreateTimer(0.1,function()
		if u == nil or u:IsNull() == true or u:IsAlive() == false then
			if pp ~= nil then
				ParticleManager:DestroyParticle(pp,true)
			end
			return
		end
		if pp == nil then
			return
		end
		return 0.1
	end)

	return pp
end
function AdjustHuskarBuff(keys)
	local caster = keys.caster
	local ability = keys.ability
	local ability_level = ability:GetLevel()

	if IsUnitExist(caster) == false then
		return
	end

	local hp_per = 1.0 * caster:GetHealth() / caster:GetMaxHealth()
	local hp_lose_per = (1-hp_per)*100
	local hp_lose_level = math.floor(hp_lose_per / 10)

	AddAbilityAndSetLevel(caster,'huskar_buff'..ability_level,hp_lose_level)
end
function EnigmaCastPoint(keys)
	local p = keys.target_points[1]
	keys.ability.p = p
end
function EnigmaPulseDamage(keys)

	if keys.ability == nil or keys.ability.p == nil then
		return
	end

	local p = keys.ability.p
	local caster = keys.caster
	local radius = keys.radius or 450

	
	local level = keys.ability:GetLevel()
	local damage_per_tick = tonumber(GetAbilityKV(keys.ability, "damage_per"))/2 or 2.5

	ApplyDamageInRadius({
		caster = caster,
		team = caster.team_id,
		radius = radius,
		role = 2,
		position = p,
		damage = damage_per_tick,
		damage_per = damage_per_tick,
		damage_type = DAMAGE_TYPE_PURE,
		ability = "midnight_pulse_datadriven",
		ability_entity = keys.ability,
	})
end
function BrWeb(keys)
	local r = keys.radius
	local p = keys.target_points[1]
	local caster = keys.caster
	local ability = keys.ability

	if ability == nil then
		return
	end

	if caster == nil and ability.team == nil then
		return
	end
	local team = ability.team or caster:GetTeam()
	if team == nil then
		return
	end
	ability.team = team

	local unlucky_dogs = FindUnitsInRadiusByTeam({
		team = team,
		role = 2,
		position = p,
		radius = r,
	})

	for _,u in pairs(unlucky_dogs) do 
		-- if u:FindModifierByName('modifier_br_web_debuff') == nil then
			ability:ApplyDataDrivenModifier(u,u,'modifier_br_web_debuff',{
				duration = 1,
			})
		-- end
	end
end
--强攻
function AddPressCount(u)
	if u:GetTeam() == 4 then
		return
	end
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local press_count = v_chess['press_count']
	if press_count == nil then
		v_chess['press_count'] = 0
		press_count = 0
	end

	local press_level = u:FindAbilityByName('lc_qianggong'):GetLevel()
	if press_level == nil or press_level == 0 then
		return
	end
	local add_count = 1 --press_level

	if GetChessStar(u) >= 3 then
		add_count = 2
		PlayParticleOnUnitUntilDeath({
			caster = u,
			p = "particles/econ/items/legion/legion_fallen/legion_fallen_press.vpcf",
		})
	else
		PlayParticleOnUnitUntilDeath({
			caster = u,
			p = "particles/units/heroes/hero_legion_commander/legion_commander_press.vpcf",
		})
	end

	v_chess['press_count'] = v_chess['press_count'] + add_count
end
function GetPressCount(u)
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local press_count = v_chess['press_count']
	if press_count == nil then
		v_chess['press_count'] = 0
		press_count = 0
	end

	return press_count
end
function SetPressStack(x)
	Timers:CreateTimer(0.5,function()
		if x:FindAbilityByName('lc_qianggong') == nil or x.press_count == nil or x.press_count <= 0 then
			return
		end
		if x:FindModifierByName("modifier_lc_qianggong_count") ~= nil then
			return
		end
		for ii=1,x.press_count do
			x:FindAbilityByName('lc_qianggong'):ApplyDataDrivenModifier(x,x,'modifier_lc_qianggong',{ })
		end
		x:FindAbilityByName('lc_qianggong'):ApplyDataDrivenModifier(x,x,'modifier_lc_qianggong_count',{ })
		x:FindModifierByName("modifier_lc_qianggong_count"):SetStackCount(x.press_count)
	end)
end
--赏金猎人：追踪术
function BhTrack(keys)
	local caster = keys.caster
	local target = keys.target
	
	if caster.damage_owner ~= nil then
		target.tracker = caster.damage_owner
	else
		target.tracker = caster
	end
end
function AddTrackMoneyCount(u,money)
	if u:GetTeam() == 4 then
		return
	end
	local track_level = 1

	local track_money_count = u.track_money_count
	if track_money_count == nil then
		track_money_count = 0
	end

	track_money_count = track_money_count + money
	u.track_money_count = track_money_count
	SetTrackMoneyStack(u)
	return track_money_count
end
function GetTrackMoneyCount(u)
	local track_money_count = u.track_money_count
	if track_money_count == nil then
		track_money_count = 0
	end

	return track_money_count
end
function SetTrackMoneyStack(x)

	if not x:HasAbility('bh_zhuizongshu') then
		AddAbilityAndSetLevel(x,'bh_zhuizongshu')
	end

	Timers:CreateTimer(0.5,function()
		if x.track_money_count == nil or x.track_money_count <= 0 then
			return
		end

		if x:HasModifier("modifier_bh_zhuizongshu_shangjin_count") then
			x:RemoveModifierByName("modifier_bh_zhuizongshu_shangjin_count")
		end

		x:FindAbilityByName("bh_zhuizongshu"):ApplyDataDrivenModifier(x,x,'modifier_bh_zhuizongshu_shangjin_count',{})
		x:FindModifierByName("modifier_bh_zhuizongshu_shangjin_count"):SetStackCount(x.track_money_count)
	end)
	local v_chess = Unit2VChess(x)
	if v_chess == nil then
		return
	end
	v_chess['track_money_count'] = x.track_money_count or 0
end
function BsDelaySilenceEnemy(u,level)
	--血魔的原版血祭客场对敌人没有沉默特效，只能出此下策，补上沉默
	local team_id = u.team_id
	local p = u:GetAbsOrigin()
	local radius = 250
	local duration = 2.5
	if level == 2 then
		radius = 350
		duration = 3
	elseif level == 3 then
		radius = 500
		duration = 4
	end
	Timers:CreateTimer(3,function()
		local unlucky_dogs = FindUnitsInRadiusByTeam({
			team = team_id,
			role = 2,
			position = p,
			radius = radius,
		})
		for _,v in pairs(unlucky_dogs) do
			if IsUnitExist(v) then
				if duration > 0 and v:HasModifier('modifier_is_nraqi_buff') == false then
					play_particle("particles/generic_gameplay/generic_silence.vpcf",PATTACH_OVERHEAD_FOLLOW,v,duration)
				end
			end
		end 
	end)
end
function SsSSrWards(keys)
	local caster = keys.caster
	local target = keys.target
	EmitSoundOn("chess_ss_ssr.wards",caster)
	for i=1,8 do
		SummonOneSnakeWard(i,caster,target)
	end
end
function SummonOneSnakeWard(index,caster,target)
	Timers:CreateTimer(0.2*index,function()
		local p = FindRandomEmptyGridAtUnit(target)
		if p ~= nil then
			SummonMinion(caster,'ss_ssr_ward',1,nil,function(w)
				ExecuteOrderFromTable({
			 		UnitIndex = w:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
			 		TargetIndex = w:GetAttackTarget():entindex(), 
			 		Queue = 0 
			 	})
			end,p)
		end
	end)
end
function SetWard(w)
	if w:HasAbility('is_ward') == false then
		return
	end
	
	local all_enemy_chess = GetAllEnemyChess(w)
	local enemy_chess_count = table.maxn(all_enemy_chess)
	local size = enemy_chess_count
	if size > 8 then size = 8 end
	if w:GetUnitName() == 'taunt_ward' then
		size = math.floor(size * 2.5)
	end
	if size <= 0 then
		size = 1
	end
	w:SetBaseMaxHealth(size)
	w:SetMaxHealth(size)
	w:SetHealth(size)
	local size_base = {
		disarm_ward = 1.0,
		taunt_ward = 1.4,
		nether_ward = 1.1,
	}
	w:SetModelScale(size_base[w:GetUnitName()]+enemy_chess_count/20.0)

	EmitSoundOn("chess_es.taunt_ward",w)
	Timers:CreateTimer(1,function()
		if IsUnitExist(w) == true then
			w:StartGesture(ACT_DOTA_IDLE)
		end
	end)
end
function SummonTaurenWard(caster,level)
	local at_team_id = caster.at_team_id or caster.team_id
	local p = {}
	local ward = {}
	--嘲讽图腾
	if level == 1 then
		local p = FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,-1)
		Timers:CreateTimer(RandomFloat(0.1,0.2),function()
			local w = SummonOneMinion(caster,'taunt_ward',p)
			SetWard(w)
		end)
		return
	end
	if level == 2 then
		Timers:CreateTimer(RandomFloat(0.1,0.15),function()
			local w1 = SummonOneMinion(caster,'taunt_ward',FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,-1))
			SetWard(w1)
		end)
		Timers:CreateTimer(RandomFloat(0.2,0.25),function()
			local w2 = SummonOneMinion(caster,'nether_ward',FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,1,1))
			SetWard(w2)
		end)
		Timers:CreateTimer(RandomFloat(0.3,0.35),function()
			local w3 = SummonOneMinion(caster,'disarm_ward',FindAnEmptyGridByIteration(caster:GetTeam(),at_team_id,1,-1))
			SetWard(w3)
		end)
		return
	end
end
--【装备】
--递归寻找物品配方列表的最底层配方列表
function Items2Recipe(items)
	local str = ''
	local item_table = string.split(items,';')
	for _,i in pairs(item_table) do
		if i then
			if _G.basic_recipe[i] then
				--如果有合成配方，递归拆分
				str = str..Items2Recipe(_G.basic_recipe[i])
			else
				--如果没有配方，直接加入单件
				str = str..i..';'
			end
		end
	end
	return str
end
--递归判断a是不是b的配件
function IsRecipe(a,b)
	local recipe_str = _G.item_recipe[b]
	if recipe_str ~= nil then
		local recipe_table = string.split(recipe_str,';')
		for _,v in pairs(recipe_table) do
			if a == v then
				return true
			else
				if IsRecipe(a,v) == true then
					return true
				end
			end
		end
	end
	return false
end
--判断装备a是不是b的一部分
function IsAPartOfB(a,b)
	local recipe_str_a = _G.basic_recipe[a]
	local recipe_str_b = _G.basic_recipe[b]
	if not recipe_str_a or not recipe_str_b then
		return false
	end
	local recipe_a = string.split(recipe_str_a,';')
	local recipe_b = string.split(recipe_str_b,';')
	if recipe_a ~= nil and recipe_b ~= nil then
		for i=1,table.maxn(recipe_a) do
			local r = recipe_a[i]
			local b_has_r = false
			for j=1,table.maxn(recipe_b) do
				if recipe_b[j] == r then
					table.remove(recipe_b,j)
					b_has_r = true
					break
				end
			end
			if not b_has_r then
				return false
			end
		end
	end
	return true
end
--刃甲：反弹伤害
function RenJia(keys)
	local caster = keys.caster
	local attacker = keys.attacker
	local damage = math.floor(keys.damage)
	if damage <= 0 then
		return
	end
	Timers:CreateTimer(0.1,function()
		EmitSoundOn('DOTA_Item.BladeMail.Damage',caster)
		ApplyDamage({
	    	victim=attacker,
	    	attacker=caster,
	    	damage_type=DAMAGE_TYPE_PURE,
	    	damage=damage
	    })
	end)
end
function RenJiaDamaged(keys)
	local caster = keys.caster
	local attacker = keys.attacker
	local damage = math.floor(keys.DamageTaken)
	if damage <= 0 then
		return
	end

	caster.is_renjia_damaged = true
	caster.is_bkb_damaged = true
	--caster.is_xiwa_damaged= true
	caster.is_pipe_damaged = true
	caster.is_hudie_damaged = true
	caster.is_sadan_damaged = true
	caster.is_chihongjia_damaged = true
end
function TuiTuiAttacked(keys)
	local caster = keys.caster
	local attacker = keys.attacker

	if IsUnitExist(attacker) == true and (attacker:GetAbsOrigin() - caster:GetAbsOrigin()):Length2D() <= 205 + attacker:GetHullRadius() + caster:GetHullRadius() then
		caster.is_tuitui_damaged = attacker
	end
end
function DianChui(event)
	local caster = event.caster
	local target = event.target
	local ability = event.ability
	local targets = event.targets
	local damage = event.damage
	local particle = event.particle or "particles/units/heroes/hero_shadowshaman/shadowshaman_ether_shock.vpcf"

	-- if ability:IsCooldownReady() == false and ability:GetCooldownTimeRemaining() <= 1 then
	if caster:HasModifier('modifier_dianchui_inner_cd') then
		--内置cd
		return
	end
	-- ability:StartCooldown(1)
	ability:ApplyDataDrivenModifier(caster,caster,'modifier_dianchui_inner_cd',{ duration = 1, })

	-- Make sure the main target is damaged
	local lightningBolt = ParticleManager:CreateParticle(particle, PATTACH_WORLDORIGIN, caster)
	ParticleManager:SetParticleControl(lightningBolt,0,Vector(caster:GetAbsOrigin().x,caster:GetAbsOrigin().y,caster:GetAbsOrigin().z + caster:GetBoundingMaxs().z ))	
	ParticleManager:SetParticleControl(lightningBolt,1,Vector(target:GetAbsOrigin().x,target:GetAbsOrigin().y,target:GetAbsOrigin().z + target:GetBoundingMaxs().z ))
	if target:IsMagicImmune() == false then
		ApplyDamage({ 
			victim = target, 
			attacker = caster, 
			damage = damage, 
			damage_type = DAMAGE_TYPE_MAGICAL,
			ability = ability,
		})
	end
	EmitSoundOn("Hero_Zuus.ArcLightning.Cast",caster)

	-- local cone_units = GetEnemiesInCone( caster, start_radius, end_radius, end_distance )
	local range = caster:Script_GetAttackRange()+500 or 500
	if range < 500 then
		range = 500
	end
	local cone_units = FindUnitsInRadiusOnTeamGround({
			team = caster:GetTeam(),
			at_team = caster.at_team_id or caster.team_id,
			role = 2,
			position = caster:GetAbsOrigin(),
			radius = range,
		})
	local targets_shocked = 1 --Is targets=extra targets or total?
	local try_count = 0
	while targets_shocked < targets and try_count < 100 do
		try_count = try_count +1
		local unit_index = RandomInt(1,table.maxn(cone_units))
		local unit = cone_units[unit_index]
		if IsUnitExist(unit) and unit:entindex() ~= target:entindex() then
			if unit.player == nil or unit.player == caster:GetOwner():GetPlayerID() then
				table.remove(cone_units,unit_index)
				-- Particle
				local origin = unit:GetAbsOrigin()

				local lightningBolt1 = ParticleManager:CreateParticle(particle, PATTACH_WORLDORIGIN, caster)
				ParticleManager:SetParticleControl(lightningBolt1,0,Vector(caster:GetAbsOrigin().x,caster:GetAbsOrigin().y,caster:GetAbsOrigin().z + caster:GetBoundingMaxs().z ))	
				ParticleManager:SetParticleControl(lightningBolt1,1,Vector(origin.x,origin.y,origin.z + unit:GetBoundingMaxs().z ))
			
				-- Damage
				if unit:IsMagicImmune() == false then
					ApplyDamage({ 
						victim = unit, 
						attacker = caster, 
						damage = damage, 
						damage_type = DAMAGE_TYPE_MAGICAL,
						ability = ability,
					})
				end
				-- Increment counter
				targets_shocked = targets_shocked + 1
			end
		end
	end
end
function TriggerRefreshOrb(u)
	if u:FindModifierByName("modifier_item_shuaxinqiu") == nil or HasAbilityBuff(u) == true then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			local a = nil
			if string.find(u:GetUnitName(),'chess_rubick') and u.steal_ability ~= nil then
				a = u.steal_ability
			elseif string.find(u:GetUnitName(),'chess_kael') and (u.kael_ability ~= nil or u.kael_ability_last ~= nil) then
				a = u.kael_ability or u.kael_ability_last
			else
				a = _G.chess_ability_list[u:GetUnitName()] or _G.summon_ability_list[u:GetUnitName()]
			end
			if u.ice_or_fire == 'fire' then
				a = 'jakiro_macropyre'
			end
			if u.ice_or_fire == 'ice' then
				a = 'jakiro_ice_path'
			end



			if name == 'item_shuaxinqiu' and ability:IsCooldownReady() == true then
				--刷新球不在冷却，判断是否需要刷
				local is_need_refresh = false
				if a == nil or _G.ability_behavior_list[a] == 0 then
					--被动哥
					for s=0,5 do
						if u:GetItemInSlot(s)~= nil then
							local aa = u:GetItemInSlot(s)
							local nn = aa:GetAbilityName()
							if nn ~= 'item_shuaxinqiu' and aa:IsCooldownReady() == false then
								is_need_refresh = true
							end
						end
					end
				else
					--主动哥
					if a ~= nil and u:FindAbilityByName(a):IsCooldownReady() == false then
						is_need_refresh = true
					end
				end
				

				if is_need_refresh == true then
					--刷新！！
					ability:StartCooldown(20)
					if a ~= nil then
						u:FindAbilityByName(a):EndCooldown()
					end

					--刷新非刷新球的物品
					for s=0,5 do
						if u:GetItemInSlot(s)~= nil then
							local aa = u:GetItemInSlot(s)
							local nn = aa:GetAbilityName()
							if nn ~= 'item_shuaxinqiu' and aa:IsCooldownReady() == false then
								aa:EndCooldown()
							end
						end
					end

					play_particle("particles/items2_fx/refresher.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,5)
					EmitSoundOn("DOTA_Item.Refresher.Activate",u)

					return 0.5
				end
			end
		end
	end
end
function TriggerSheepStick(u)
	if u:FindModifierByName("modifier_item_yangdao") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_yangdao' and ability:IsCooldownReady() == true then
				local dog = FindHighLevelUnluckyDog(u,true,false,'modifier_shadow_shaman_voodoo')
				if u:IsNull() ~= true and dog ~= nil and dog:IsNull() ~= true then
					--有羊的目标！
					if dog:IsMagicImmune() == true then
						return
					end
					if BlockByLinken(dog) == false then
						dog:AddNewModifier(
							dog,
							nil,
							"modifier_shadow_shaman_voodoo",
							{ duration = 8 }
						)
					end
					ability:StartCooldown(15)

					Timers:CreateTimer(0.3,function()
						if dog:HasModifier('modifier_shadow_shaman_voodoo') then
							RemoveAllKnightBuff(dog)
						end
					end)
					return 0.5
				else
					return
				end
				
			end
		end
	end
end
function TriggerSilingshu(u)
	if u:FindModifierByName("modifier_item_silingshu") == nil and u:FindModifierByName("modifier_item_silingshu_2") == nil and u:FindModifierByName("modifier_item_silingshu_3") == nil and u:FindModifierByName("modifier_item_minglingshu") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if (name == 'item_silingshu' or name == 'item_silingshu_2' or name == 'item_silingshu_3' or name == 'item_minglingshu') and ability:IsCooldownReady() == true then
				--召唤1死灵战士1死灵射手
				SummonMinion(u,'necro_warrior',1,"particles/items_fx/necronomicon_spawn_warrior.vpcf",function(w)
					FillEmptySlot(w)
				end)
				Timers:CreateTimer(0.1,function()
					SummonMinion(u,'necro_archer',1,"particles/items_fx/necronomicon_spawn.vpcf",function(w)
						FillEmptySlot(w)
					end)
				end)

				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerJurenzhijie(u)
	if u:FindModifierByName("modifier_item_jurenzhijie") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_jurenzhijie' and ability:IsCooldownReady() == true then
				ability:ApplyDataDrivenModifier(u,u,'modifier_jurenzhijie_buff',{ duration = 6, })
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerShenjingdun(u)
	if u:FindModifierByName("modifier_item_shenjingdun") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_shenjingdun' and ability:IsCooldownReady() == true then
				ability:ApplyDataDrivenModifier(u,u,'modifier_shenjingdun_buff',{ duration = 6, })
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end

function TriggerYonghengzhipan(u)
	if u:FindModifierByName("modifier_item_yonghengzhipan") == nil then
		return 
	end
	if u.is_bkb_damaged == nil then 
		return
	end
	u.is_bkb_damaged = nil

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_yonghengzhipan' and ability:IsCooldownReady() == true then
				ability:ApplyDataDrivenModifier(u,u,'modifier_yonghengzhipan_buff',{ duration = 5, })
				EmitSoundOn('DOTA_Item.BlackKingBar.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_bkb_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				u:Purge(false, true, false, false, false) --净化

				ability:StartCooldown(60)
				return 0.5
			end
		end
	end
end

function TriggerAtuosi(u)
	if u:FindModifierByName("modifier_item_atuosi") == nil and u:FindModifierByName("modifier_item_wangchongtui") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if (name == 'item_atuosi' or name == 'item_wangchongtui') and ability:IsCooldownReady() == true then

				local dog = FindHighLevelUnluckyDog(u,true,false,'modifier_item_atuosi_debuff')
				if u:IsNull() ~= true and dog ~= nil and dog:IsNull() ~= true then

					if dog:IsMagicImmune() == true then
						return
					end

					if BlockByLinken(dog) == false then
						ability:ApplyDataDrivenModifier(dog,dog,'modifier_item_atuosi_debuff',{ duration = 5, })
						EmitSoundOn("item.atuosi",dog)
					end
					ability:StartCooldown(15)
					return 0.5
				else
					return
				end
			end
		end
	end
end
function TriggerFulingsuo(u)
	if IsUnitExist(u) == false or u:FindModifierByName("modifier_item_fulingsuo") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_fulingsuo' and ability:IsCooldownReady() == true then

				local dog = FindHighLevelUnluckyDog(u,true,false,'modifier_item_fulingsuo_debuff')
				if IsUnitExist(dog) == true then
					local dogs = FindAllUnitsAroundUnluckyDogByRadius(dog, 300) or {}
					for _,d in pairs(dogs) do
						if d:IsMagicImmune() ~= true then
							if BlockByLinken(d) == false then
								ability:ApplyDataDrivenModifier(d,d,'modifier_item_fulingsuo_debuff',{ duration = 7, })
								ApplyDamage({ 
									victim = d, 
									attacker = u, 
									damage = 100, 
									damage_type = DAMAGE_TYPE_MAGICAL,
									ability = ability,
								})
							end
							PlayLightningParticle(u,d,1)
						end
					end
					EmitSoundOn("Hero_Zuus.ArcLightning.Cast",u)
					ability:StartCooldown(15)
					return 0.5
				else
					return
				end
			end
		end
	end
end
function PlayLightningParticle(u,d,duration)
	local lightningBolt = ParticleManager:CreateParticle("particles/units/heroes/hero_zuus/zuus_arc_lightning.vpcf", PATTACH_WORLDORIGIN, u)
	ParticleManager:SetParticleControl(lightningBolt,0,Vector(u:GetAbsOrigin().x,u:GetAbsOrigin().y,u:GetAbsOrigin().z + u:GetBoundingMaxs().z ))	
	ParticleManager:SetParticleControl(lightningBolt,1,Vector(d:GetAbsOrigin().x,d:GetAbsOrigin().y,d:GetAbsOrigin().z + d:GetBoundingMaxs().z ))
	Timers:CreateTimer(duration,function()
		if lightningBolt ~= nil then
			ParticleManager:DestroyParticle(lightningBolt,true)
		end
	end)
end
function TriggerRenjia(u)
	if u:FindModifierByName("modifier_item_renjia") == nil then
		return 
	end
	if u:FindModifierByName("modifier_renjia_buff") ~= nil then
		return 
	end
	if u.is_renjia_damaged == nil then 
		return
	end
	u.is_renjia_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_renjia' and ability:IsCooldownReady() == true then
				EmitSoundOn('DOTA_Item.BladeMail.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_renjia_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerHudie(u)
	if u:FindModifierByName("modifier_item_hudie") == nil then
		return 
	end
	if u:FindModifierByName("modifier_give_hudie_buff") ~= nil then
		return 
	end
	if u.is_hudie_damaged == nil then 
		return
	end
	u.is_hudie_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_hudie' and ability:IsCooldownReady() == true then
				-- EmitSoundOn('DOTA_Item.BladeMail.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_hudie_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerSadan(u)
	if u:FindModifierByName("modifier_item_sadan") == nil then
		return 
	end
	if u:FindModifierByName("modifier_give_sadan_buff") ~= nil then
		return 
	end

	if u.is_sadan_damaged == nil then 
		return
	end
	u.is_sadan_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_sadan' and ability:IsCooldownReady() == true then
				-- EmitSoundOn('DOTA_Item.BladeMail.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_sadan_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerXiwa(u)
	if u:FindModifierByName("modifier_item_xiwa") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_xiwa' and ability:IsCooldownReady() == true then
				ItemXiWa({
					caster = u,
				})
				ability:StartCooldown(20)
				return 0.5
			end
		end
	end
end
function TriggerPipe(u)
	if u:FindModifierByName("modifier_item_dongchayandou") == nil then
		return 
	end
	if u:FindModifierByName("modifier_pipe_buff") ~= nil then
		return 
	end
	if u.is_pipe_damaged == nil then 
		return
	end
	u.is_pipe_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_dongchayandou' and ability:IsCooldownReady() == true then
				ItemPipe({
					caster = u,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerChihongjia(u)
	if u:FindModifierByName("modifier_item_chihongjia") == nil then
		return 
	end
	if u:FindModifierByName("modifier_chihongjia_buff") ~= nil then
		return 
	end

	if u.is_chihongjia_damaged == nil then 
		return
	end
	u.is_chihongjia_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_chihongjia' and ability:IsCooldownReady() == true then
				ItemChihongjia({
					caster = u,
				})
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerFengKuangMianJu(u)
	if u:FindModifierByName("modifier_item_fengkuangmianju") == nil then
		return 
	end

	if u:HasModifier("modifier_fengkuangmianju") == true then
		return
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_fengkuangmianju' and ability:IsCooldownReady() == true then
				EmitSoundOn('DOTA_Item.MaskOfMadness.Activate',u)
				InvisibleUnitCast({
					caster = u,
					ability = 'give_fengkuangmianju_buff',
					level = 1,
					unluckydog = u,
					ignore_nether_ward = true,
				})
				ability:StartCooldown(20)
				return 0.5
			end
		end
	end
end
function TriggerMiFaXie(u)
	if u:FindModifierByName("modifier_item_aoshuxie") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_aoshuxie' and ability:IsCooldownReady() == true then
				local max_distance = GetAbilityKV(ability,'max_distance') or 9999
				play_particle("particles/items_fx/arcane_boots.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,5)
				EmitSoundOn('DOTA_Item.ArcaneBoots.Activate',u)
				for _,unit in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
					if unit.team_id == u.team_id and unit:GetMaxMana() ~= 0 then
						if (unit:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() <= max_distance then
							play_particle('particles/items_fx/arcane_boots_recipient.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,3)
							if unit:GetMana() < 100 and unit:GetMaxMana() > 0 then
								AMHC:CreateNumberEffect(unit,20,2,AMHC.MSG_MISS,{128,128,255},0)
							end
							ChessAddMana(unit,20)
						end
					end
				end
				ability:StartCooldown(30)
				return 0.5
			end
		end
	end
end
function TriggerMeiken(u)
	if u:FindModifierByName("modifier_item_meiken") == nil then
		return 
	end

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_meiken' and ability:IsCooldownReady() == true then
				local max_distance = GetAbilityKV(ability,'max_distance') or 9999
				if u:GetHealth() < u:GetMaxHealth()/2 or GetMeikenHealAmount(u,max_distance) >= 500 then
					EmitSoundOn("item.meiken",u)
					for _,unit in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
						if unit.team_id == u.team_id then
							play_particle('particles/items2_fx/mekanism.vpcf',PATTACH_ABSORIGIN_FOLLOW,unit,3)
							unit:Heal(500,unit)
						end
					end
					ability:StartCooldown(30)
					return 0.5
				end
			end
		end
	end
end
function TriggerWeishijingjia(u)
	if u:FindModifierByName("modifier_item_weishijingjia") == nil then
		return 
	end
	
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_weishijingjia' and ability:IsCooldownReady() == true then
				local max_distance = GetAbilityKV(ability,'max_distance') or 9999
				if u:GetHealth() < u:GetMaxHealth()/2 or GetMeikenHealAmount(u,max_distance) >= 500 then
					EmitSoundOn("item.weishijingjia",u)

					local units = FindUnitsInRadiusOnTeamGround({
						team = u:GetTeam(),
						at_team = u.at_team_id or u.team_id,
						role = 1,
						position = u:GetAbsOrigin(),
						radius = 500,
					})
					for _,unit in pairs(units) do
						if unit.team_id == u.team_id then
							play_particle('particles/items3_fx/warmage_recipient.vpcf',PATTACH_ABSORIGIN_FOLLOW,unit,3)
							unit:Heal(500,unit)
							if unit:GetMana() < 100 and unit:GetMaxMana() > 0 then
								AMHC:CreateNumberEffect(unit,20,2,AMHC.MSG_MISS,{128,128,255},0)
							end
							ChessAddMana(unit,20)
							--驱散一下debuff
							for _,m in pairs(unit:FindAllModifiers()) do
								if m:IsDebuff() and IsModifierInNraqiWhiteList(m:GetName()) ~= true then
									unit:RemoveModifierByName(m:GetName())
								end
							end
						end
					end
					ability:StartCooldown(20)
					return 0.5
				end
			end
		end
	end
end
function GetMeikenHealAmount(u,max_distance)
	local heal_amount = 0
	if not max_distance then
		max_distance = 9999
	end
	for _,unit in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(unit) and unit.team_id == u.team_id and (unit:GetAbsOrigin()-u:GetAbsOrigin()):Length2D() <= max_distance then
			local amount = unit:GetMaxHealth() - unit:GetHealth()
			if amount > 500 then
				amount = 500
			end
			heal_amount = heal_amount + amount
		end
	end
	return heal_amount
end
function TriggerTuiTui(u)
	--如果1格内有可以移动的敌人，就推
	local unluckydog = FindUnluckyDogInRange(u, 205)
	if unluckydog == nil or IsUnitExist(unluckydog) == false or unluckydog:IsMagicImmune() == true or unluckydog:HasMovementCapability() == false or unluckydog.stop_moving == true or unluckydog.is_moving == true or unluckydog:HasAbility('jiaoxie_wudi') then 
		return
	end
	local target = unluckydog

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_yuanlifazhang' and ability:IsCooldownReady() == true then
				local chessboard_id = target.at_team_id or target.team_id
				local mana_transfer = 20
				--对敌人的效果
				if BlockByLinken(target) == false then
					local v = FindFarthestEmptyGridByForwardVector(u,target:GetAbsOrigin())
					if v ~= nil then
						local yy = target.y
						local xx = target.x

						local y = Vector2Y(v,chessboard_id)
						local x = Vector2X(v,chessboard_id)

						local stun_duration = ((v-target:GetAbsOrigin()):Length2D()/1000)
						target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+1 })

						_G.unit[chessboard_id][y..'_'..x] = 1
						target.is_moving = true
						BlinkChessX({p=v,caster=target,blink_type='tuitui'})
						EmitSoundOn("DOTA_Item.ForceStaff.Activate",target)

						target.y_x = y..'_'..x
						target.y = y
						target.x = x
						_G.unit[chessboard_id][yy..'_'..xx] = nil
					end
					if target:GetMana() < 20 then
						mana_transfer = target:GetMana()
					end
					target:GiveMana(-mana_transfer)
				end
				--对自己的效果
				local vv = FindFarthestEmptyGridByForwardVector(target,u:GetAbsOrigin())
				if vv ~= nil then
					local yy = u.y
					local xx = u.x
					local y = Vector2Y(vv,chessboard_id)
					local x = Vector2X(vv,chessboard_id)
					_G.unit[chessboard_id][y..'_'..x] = 1
					u.is_moving = true
					BlinkChessX({p=vv,caster=u,blink_type='tuitui'})
					EmitSoundOn("DOTA_Item.ForceStaff.Activate",target)
					u.y_x = y..'_'..x
					u.y = y
					u.x = x
					_G.unit[chessboard_id][yy..'_'..xx] = nil
				end
				u:GiveMana(mana_transfer)
				-- if u:IsRangedAttacker() == true then
				-- 	ability:ApplyDataDrivenModifier(u,u,'modifier_item_jufengchangji_buff',{ duration = 5, })
				-- 	u:FindModifierByName('modifier_item_jufengchangji_buff'):SetStackCount(5)
				-- 	EmitSoundOn("item.jufengchangji",u)
				-- 	ExecuteOrderFromTable({
				--  		UnitIndex = u:entindex(), 
				--  		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
				--  		TargetIndex = target:entindex(), 
				--  		Queue = 0
				--  	})
				-- 	u.jufeng_target_index = target:entindex()
				-- end

				ability:StartCooldown(15)
				return 0.5
			end
		end
	end
end
function TriggerJuFeng(u)
	--如果1格内有可以移动的敌人，就推
	local unluckydog = FindUnluckyDogInRange(u, 205)
	if unluckydog == nil or IsUnitExist(unluckydog) == false or unluckydog:IsMagicImmune() == true or unluckydog:HasMovementCapability() == false or unluckydog.stop_moving == true or unluckydog.is_moving == true or unluckydog:HasAbility('jiaoxie_wudi') then 
		return
	end
	local target = unluckydog

	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_jufengchangji' and ability:IsCooldownReady() == true then
				local chessboard_id = target.at_team_id or target.team_id
				--对敌人的效果
				if BlockByLinken(target) == false then
					local v = FindFarthestEmptyGridByForwardVector(u,target:GetAbsOrigin())
					if v ~= nil then
						local yy = target.y
						local xx = target.x

						local y = Vector2Y(v,chessboard_id)
						local x = Vector2X(v,chessboard_id)

						local stun_duration = ((v-target:GetAbsOrigin()):Length2D()/1000)
						target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+1 })

						_G.unit[chessboard_id][y..'_'..x] = 1
						target.is_moving = true
						BlinkChessX({p=v,caster=target,blink_type='tuitui'})
						EmitSoundOn("DOTA_Item.ForceStaff.Activate",target)

						target.y_x = y..'_'..x
						target.y = y
						target.x = x
						_G.unit[chessboard_id][yy..'_'..xx] = nil
					end
				end
				--对自己的效果
				local vv = FindFarthestEmptyGridByForwardVector(target,u:GetAbsOrigin())
				if vv ~= nil then
					local yy = u.y
					local xx = u.x
					local y = Vector2Y(vv,chessboard_id)
					local x = Vector2X(vv,chessboard_id)
					_G.unit[chessboard_id][y..'_'..x] = 1
					u.is_moving = true
					BlinkChessX({p=vv,caster=u,blink_type='tuitui'})
					EmitSoundOn("DOTA_Item.ForceStaff.Activate",target)
					u.y_x = y..'_'..x
					u.y = y
					u.x = x
					_G.unit[chessboard_id][yy..'_'..xx] = nil
				end
				if u:IsRangedAttacker() == true then
					ability:ApplyDataDrivenModifier(u,u,'modifier_item_jufengchangji_buff',{ duration = 5, })
					u:FindModifierByName('modifier_item_jufengchangji_buff'):SetStackCount(5)
					EmitSoundOn("item.jufengchangji",u)
					ExecuteOrderFromTable({
				 		UnitIndex = u:entindex(), 
				 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
				 		TargetIndex = target:entindex(), 
				 		Queue = 0
				 	})
					u.jufeng_target_index = target:entindex()
				end

				ability:StartCooldown(10)
				return 0.5
			end
		end
	end
end
function LetJuFengAttack(keys)
	local caster = keys.caster
	if caster.jufeng_target_index == nil then
		return
	end
	ExecuteOrderFromTable({
 		UnitIndex = caster:entindex(), 
 		OrderType = DOTA_UNIT_ORDER_ATTACK_TARGET,
 		TargetIndex = caster.jufeng_target_index, 
 		Queue = 1,
 	})
end
function JuFengAttack(keys)
	local caster = keys.caster
	local target = caster:GetAttackTarget()
	local modifier = caster:FindModifierByName('modifier_item_jufengchangji_buff')
	if modifier == nil then
		return
	end

	local stack = modifier:GetStackCount()
	if stack <= 1 then
		caster:RemoveModifierByName('modifier_item_jufengchangji_buff')
		caster.jufeng_target_index = nil
	end
	if target:entindex() ~= caster.jufeng_target_index then
		caster:RemoveModifierByName('modifier_item_jufengchangji_buff')
		caster.jufeng_target_index = nil
	end
	modifier:SetStackCount(stack-1)
end
function TriggerBKB(u)
	if u:FindModifierByName("modifier_item_bkb") == nil then
		return 
	end
	if u:FindModifierByName("modifier_bkb_buff") ~= nil then
		return 
	end
	if u.is_bkb_damaged == nil then 
		return
	end
	u.is_bkb_damaged = nil
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_bkb' and ability:IsCooldownReady() == true then
				EmitSoundOn('DOTA_Item.BlackKingBar.Activate',u)
				u:Purge(false, true, false, false, false) --净化
				ability:ApplyDataDrivenModifier(u, u, 'modifier_bkb_buff', {duration = 4})
				ability:StartCooldown(60)
				return 0.5
			end
		end
	end
end
function TriggerTiaodao(u)
	if u:FindModifierByName("modifier_item_tiaodao") == nil then
		return 
	end
	if not IsChessCanMove(u) then
		return
	end
	RemoveAbilityAndModifier(u,'jiaoxie_wudi')
	RemoveAbilityAndModifier(u,'jiaoxie')
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_tiaodao' and ability:IsCooldownReady() == true then
				find_ok = FindFarthestCanAttackEnemyEmptyGrid(u,GetAbilityKV(ability,'max_blink_distance') or 800)
				if find_ok ~= nil then
					local x = Vector2X(find_ok,u.at_team_id or u.team_id)
					local y = Vector2Y(find_ok,u.at_team_id or u.team_id)
					local xx = u.x
					local yy = u.y
					_G.unit[u.at_team_id or u.team_id][y..'_'..x] = 1
					u:SetAbsOrigin(find_ok)
					u.y_x = y..'_'..x
					u.y = y
					u.x = x
					_G.unit[u.at_team_id or u.team_id][yy..'_'..xx] = nil

					AMHC:CreateNumberEffect(u,20,2,AMHC.MSG_MISS,{128,128,255},0)
					u:GiveMana(20)
					
					play_particle("particles/items_fx/blink_dagger_end.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,3)
					EmitSoundOn("DOTA_Item.BlinkDagger.Activate",u)

					ability:StartCooldown(15)
				else
					return
				end
				return 0.5
			end
		end
	end
end
function TriggerDagon(u)
	if u:FindModifierByName("modifier_item_hongzhang_1") == nil and u:FindModifierByName("modifier_item_hongzhang_2") == nil and u:FindModifierByName("modifier_item_hongzhang_3") == nil and u:FindModifierByName("modifier_item_hongzhang_4") == nil and u:FindModifierByName("modifier_item_hongzhang_5") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			local name_table = string.split(name,'_')
			local dog = FindUnluckyDog(u)
			if dog ~= nil and name_table[2] == 'hongzhang' and ability:IsCooldownReady() == true then
				ability:StartCooldown(18-tonumber(name_table[3])*3)
				EmitSoundOn("DOTA_Item.Dagon.Activate",u)
				local victim = dog
				local info = {
			        Target = victim,
			        Source = u,
			        Ability = nil,
			        EffectName = "particles/econ/events/ti5/dagon_ti5.vpcf",
			        bDodgeable = false,
			        iMoveSpeed = 3000,
			        bProvidesVision = false,
			        iVisionRadius = 0,
			        iVisionTeamNumber = u:GetTeamNumber(),
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    }
				projectile = ProjectileManager:CreateTrackingProjectile(info)
				if victim:IsMagicImmune() == false then
					if BlockByLinken(victim) == false then
						ApplyDamage({
					    	victim=victim,
					    	attacker=u,
					    	damage_type=DAMAGE_TYPE_MAGICAL,
					    	damage=300+100*tonumber(name_table[3]),
							ability = ability,
					    })
					end
				end
				return 0.5
			end
		end
	end
end
function TriggerXueji(u)
	if u:FindModifierByName("modifier_item_xueji") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_xueji' and ability:IsCooldownReady() == true then
				local dog = FindHighLevelUnluckyDog(u, true, false, 'modifier_item_xueji_debuff', true)
				if IsUnitExist(dog) then
					ability:StartCooldown(15)
					if BlockByLinken(dog) == false then
						ability:ApplyDataDrivenModifier(u, dog, 'modifier_item_xueji_debuff', {duration = 7})
						EmitSoundOn('DOTA_Item.Bloodthorn.Activate',dog)
						
						TauntEnemy({
							caster = dog
						})
					end
					return 0.5
				end
			end
		end
	end
end
function CheckXuejiDebuff(keys)
	local caster = keys.caster
	local target = keys.target
	if not target:HasModifier('modifier_item_xueji_debuff') then
		caster:RemoveModifierByName('modifier_item_xueji_crit_buff')
	end
end
function AddXuejiBuff2AllEnemy(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	for _,unit in pairs (GetValidChessOnBoard(target.at_team_id or target.team_id)) do
		if IsUnitExist(unit) and unit:GetTeam() ~= target:GetTeam() then
			ability:ApplyDataDrivenModifier(unit,unit,'modifier_item_xueji_crit_buff',{})
		end
	end
end
function TriggerHuanyingfu(u)
	if u:FindModifierByName("modifier_item_huanyingfu") == nil then
		return 
	end
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			if ability:GetAbilityName() == 'item_huanyingfu' and ability:IsCooldownReady() == true then
				ability:StartCooldown(15)

				EmitSoundOn("DOTA_Item.Manta.Activate",u)
				play_particle("particles/generic_gameplay/illusion_killed.vpcf",PATTACH_ABSORIGIN_FOLLOW,u,3)

				SummonMinion(u,u:GetUnitName(),2,"particles/generic_gameplay/illusion_killed.vpcf",function(w)
					if IsUnitExist(w) == false then
						return
					end
					local hp_set = u:GetHealth()
					if hp_set <= 0 then
						hp_set = 1
					end
					w:SetHealth(hp_set)
					w:AddNewModifier(w,nil,"modifier_illusion",{duration = 10})
					w:SetMaxMana(0)
					FillEmptySlot(w)
					ExtendBeastBuff(w,u)
				end)

				return 0.5
			end
		end
	end
end
function DropShengJian(team)
	for _,obj in pairs(_G.mychess[team]) do
		local items = obj['item']

		for item_index,item in pairs(items) do
			if item == 'item_shengjian' then
				local lucky_team = RandomDropOneGGItem('item_shengjian',TeamId2Hero(team),team)
				--圣剑掉落消息通知
				if lucky_team ~= nil then
					table.remove(items,item_index)
					ShowCombat({
						t = 'drop_shengjian',
						player = TeamId2Hero(team):GetPlayerID(),
						player2 = TeamId2Hero(lucky_team):GetPlayerID(),
					})
				end
			end
		end
	end
end
function GetCurrRelicByTeam(team)
	local hero = TeamId2Hero(team)
	if IsUnitExist(hero) and hero:GetItemInSlot(16) and hero:GetItemInSlot(16):GetAbilityName() then
		return hero:GetItemInSlot(16):GetAbilityName()
	else
		return nil
	end
end
--收集多个棋子的装备
function GetAllItemsInUnits(units)
	--收集棋子的物品
	local items_table = {}
	for _,vv in pairs(units) do
		if IsUnitExist(vv) == true then
			--记录装备情况
			for slot=0,9 do
				if vv:GetItemInSlot(slot)~= nil then
					local item_name = vv:GetItemInSlot(slot):GetAbilityName()
					if item_name == 'item_silingshu_2' or item_name == 'item_silingshu_3' then
						--三种死灵书等价
						item_name = 'item_silingshu'
					end
					if item_name ~= 'item_null' then
						table.insert(items_table,item_name)
					end
				end
			end
		end
	end
	return items_table
end
--收集多个棋子的装备
function GetAllItemsAndCDInUnits(units)
	--收集棋子的物品
	local items_table = {}
	for _,vv in pairs(units) do
		if IsUnitExist(vv) == true then
			--记录装备情况
			for slot=0,9 do
				if vv:GetItemInSlot(slot)~= nil then
					local item = vv:GetItemInSlot(slot)
					local name = item:GetAbilityName()
					local charges = item:GetCurrentCharges()
					local cd = item:GetCooldownTimeRemaining()
					-- if item:IsPermanent() == false then
					-- 	--消耗品： 丢出来
					-- 	for i=1,charges do
					-- 		local newItem = CreateItem( name, vv, vv )
					-- 		local drop = CreateItemOnPositionForLaunch(vv:GetAbsOrigin(), newItem )
					-- 		local dropRadius = RandomFloat( 50, 200 )
					-- 		newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, vv:GetAbsOrigin() + RandomVector(dropRadius ))
					-- 	end
					-- else
						local item_name = vv:GetItemInSlot(slot):GetAbilityName()

						if item_name == 'item_silingshu_2' or item_name == 'item_silingshu_3' then
							item_name = 'item_silingshu'
						end

						if item_name ~= 'item_null' then
							table.insert(items_table,{
								item = item_name,
								charges = charges,
								cd = cd,
							})
						end
					-- end
				end
			end
		end
	end
	return items_table
end
--把装备给棋子
function GiveItems2Unit(items,unit)
	if IsUnitExist(unit) == false then
		return
	end
	for _,v in pairs(items) do
		local item_name = v.item or v
		local charges = v.charges or 1
		local cd = v.cd or 0
		if item_name == 'item_silingshu' or item_name == 'item_silingshu_2' or item_name == 'item_silingshu_3' then
			item_name = GetCurrSilingshuItemName(unit)
		end
	
		unit:AddItemByName(item_name)

		for slot=0,8 do
			if unit:GetItemInSlot(slot)~= nil then
				local i = unit:GetItemInSlot(slot)
				local n = i:GetAbilityName()
				if item_name == n then
					if cd > 0 then
						i:StartCooldown(cd)
					end
				end
			end
		end
	end
end
function DropMoneyBag(from_position, to_position, radius, money, height)
	local newItem = CreateItem( "item_money", nil, nil )
	newItem:SetPurchaseTime( 0 )
	newItem:SetCurrentCharges( 1)
	newItem.money = money or 1

	local drop = CreateItemOnPositionSync( from_position, newItem )
	newItem:GetContainer():SetModelScale(1.4+( money or 1 )/15)

	local gg_item_dis = (to_position-from_position):Length2D()
	local gg_item_t = gg_item_dis/800
	if gg_item_t < 1 then gg_item_t = 1 end
	newItem:LaunchLoot( false, height or 600, gg_item_t, to_position )
end
function RandomDropOneGGItem(gg_item_one,gg_item_hero, my_team, is_auto_pick)
	if not is_auto_pick then
		is_auto_pick = false
	end
	local lucky_team = nil
	local try_count = 0
	while lucky_team == nil and try_count < 100 do 
		local random_team = RandomInt(6,13)
		local hero = TeamId2Hero(random_team)
		if hero ~= nil and hero:IsAlive() == true and random_team ~= my_team then
			lucky_team = random_team
		end
		try_count = try_count + 1
	end
	if lucky_team ~= nil then
		local newItem = CreateItem( gg_item_one, gg_item_hero, gg_item_hero )
		CreateItemOnPositionForLaunch(Vector(0,0,128), newItem )
		local gg_item_v = CenterVector(lucky_team) + Vector(RandomInt(-512,512),RandomInt(-512,512),0)
		local gg_item_dis = (gg_item_v-Vector(0,0,128)):Length2D()
		local gg_item_t = gg_item_dis/800
		newItem:LaunchLootInitialHeight( is_auto_pick, 0, 400, gg_item_t, gg_item_v)
	end
	return lucky_team
end
function DropOneGGItem(gg_item_one, gg_item_hero, lucky_team, is_auto_pick)
	if not is_auto_pick then
		is_auto_pick = false
	end

	if lucky_team ~= nil then
		local newItem = CreateItem( gg_item_one, gg_item_hero, gg_item_hero )
		CreateItemOnPositionForLaunch(Vector(0,0,128), newItem )
		local gg_item_v = CenterVector(lucky_team) + Vector(RandomInt(-512,512),RandomInt(-512,512),0)
		local gg_item_dis = (gg_item_v-Vector(0,0,128)):Length2D()
		local gg_item_t = gg_item_dis/1000
		newItem:LaunchLootInitialHeight( is_auto_pick, 0, 400, gg_item_t, gg_item_v)
	end
	return lucky_team
end
function TriggerHex(keys)
	local target = keys.target
	if IsUnitExist(target) then
		RemoveAllKnightBuff(target)
	end
end
function ItemMoney(keys)
	local caster = keys.caster
	local ability = keys.ability

	if ability.money ~= nil and ability.money > 0 then
		AddMana(caster, ability.money)
		AddTotalMoneyStat(caster:GetPlayerID(),ability.money)
	end
	ability:SpendCharge()
end
--吸血鬼吸血
function ValdmirRestore(hero,heal)
	--如果玩家已经死亡，就不吸血了
	if _G.death[hero:GetTeam()] == true then
		return
	end

	local hp = hero:GetHealth()
	if _G.p2_mode == true then
		heal = math.floor(heal/2)
	end
	hp = hp + heal
	if hp > 100 then
		hp = 100
	end

	if _G.p2_mode == true and GetP2Ally(hero:GetTeam()) ~= nil then
		local hh = TeamId2Hero(GetP2Ally(hero:GetTeam())) 
		if hh ~= nil then
			hh:SetHealth(hp)
			SyncHP(hh)
			AMHC:CreateNumberEffect(hh,heal,3,AMHC.MSG_MISS,{0,128,0},0)
			EmitSoundOn("item.lifesteal",hh)
			play_particle('particles/generic_gameplay/generic_lifesteal.vpcf',PATTACH_OVERHEAD_FOLLOW,hh,3)
		end
	end
	hero:SetHealth(hp)
	SyncHP(hero)
	AMHC:CreateNumberEffect(hero,heal,3,AMHC.MSG_MISS,{0,128,0},0)
	EmitSoundOn("item.lifesteal",hero)
	play_particle('particles/generic_gameplay/generic_lifesteal.vpcf',PATTACH_OVERHEAD_FOLLOW,hero,3)
end
function ItemChishu(keys)
	local caster = keys.caster
	local target = keys.target
	if target ~= nil then
		target:CutDown(caster:GetTeam())
	end
	ItemSpendCharge(keys)
	--第二次机会
	if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 40 then
		caster:AddItemByName('item_chishu')
		PlayItemMultiCastParticle(caster)
	end
	local hp = caster:GetHealth()
	local heal = RandomInt(1,7)
	if _G.p2_mode == true then
		heal = RandomInt(1,4)
	end
	hp = hp + heal
	if hp > 100 then
		hp = 100
	end

	if _G.p2_mode == true and GetP2Ally(caster:GetTeam()) ~= nil then
		local hh = TeamId2Hero(GetP2Ally(caster:GetTeam())) 
		if hh ~= nil then
			hh:SetHealth(hp)
			SyncHP(hh)
			AMHC:CreateNumberEffect(hh,heal,3,AMHC.MSG_MISS,{0,128,0},0)
			EmitSoundOn("DOTA_Item.Tango.Activate",hh)
		end
	end
	caster:SetHealth(hp)
	SyncHP(caster)
	AMHC:CreateNumberEffect(caster,heal,3,AMHC.MSG_MISS,{0,128,0},0)
	EmitSoundOn("DOTA_Item.Tango.Activate",caster)
end
function ItemPingguo(keys)
	local caster = keys.caster
	AddAbilityAndSetLevel(caster,'is_priest_buff_plus_plus')
	EmitSoundOn("Hero_Abaddon.AphoticShield.Cast",caster)

	if GetP2Ally(caster:GetTeam()) ~= nil and TeamId2Hero(GetP2Ally(caster:GetTeam())) ~= nil then
		local hh = TeamId2Hero(GetP2Ally(last_hero:GetTeam()))
		if IsUnitExist(hh) == true then
			AddAbilityAndSetLevel(hh,'is_priest_buff_plus_plus')
			EmitSoundOn("Hero_Abaddon.AphoticShield.Cast",hh)
		end
	end
end
function ItemFengwangjiang(keys)
	local caster = keys.caster
	AddAbilityAndSetLevel(caster,'is_priest_buff')
	EmitSoundOn("Hero_Abaddon.AphoticShield.Cast",caster)
end
function ItemMangguo(keys)
	local caster = keys.caster
	local add_mana = RandomInt(1,caster:GetLevel())

	ItemSpendCharge(keys)
	--第二次机会
	if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
		caster:AddItemByName('item_mangguo')
		PlayItemMultiCastParticle(caster)
	end
	AddMana(caster, add_mana)
	ExpBook({
		caster = caster,
		xpadd = add_mana,
		disable_quick_lvl_up = true,
		cost = 0,
	})

	AddTotalMoneyStat(caster:GetPlayerID(),add_mana)
	EmitSoundOn("DOTA_Item.Mango.Activate",caster)
	play_particle('particles/items3_fx/mango_active.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)
	play_particle('particles/generic_gameplay/outpost_reward.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster,3)
end
function ItemZhishizhishu(keys)
	local caster = keys.caster
	local team_id = caster:GetTeam()
	local is_gold = keys.is_gold
	local lv = caster:GetLevel()
	ItemSpendCharge(keys)
	--第二次机会
	if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
		caster:AddItemByName('item_zhishizhishu')
		PlayItemMultiCastParticle(caster)
	end
	local exp_require = (_G.HeroExpTable[lv+1] or 0) - (_G.HeroExpTable[lv] or 0)
	local exp = math.floor(exp_require/16)
	if exp <= 0 then
		exp = 1
	end
	if exp > 0 then
		caster:AddExperience(exp,0,false,false)
	end
	AMHC:CreateNumberEffect(caster,exp,3,AMHC.MSG_MISS,{255,255,128},0)
	EmitSoundOn("item.exp2",caster)
	--同步ui血量和等级
	CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
		player_id = caster:GetPlayerID(),
		hp = caster:GetHealth(),
		hp_max = caster:GetMaxHealth(),
		mp = caster:GetMana(),
		level = caster:GetLevel(),
		win_streak = caster.win_streak,
		unit_index = caster:entindex(),
		courier_id = caster.onduty_hero,
	})
end
function ItemJixiezhixin(keys)
	local caster = keys.caster
	local team_id = caster:GetTeam()
	local is_gold = keys.is_gold
	local is_black = keys.is_black
	local is_magic = keys.is_magic
	caster.chesslock = false
	AMHC:CreateParticle("particles/econ/items/antimage/antimage_ti7/antimage_blink_start_ti7_ribbon_bright.vpcf",PATTACH_ABSORIGIN_FOLLOW,false,caster,5)
	EmitSoundOn("item.jixiezhixin.open",caster)
	ItemSpendCharge(keys)
	if is_gold ~= nil then
		Draw5ChessAndShow(team_id, true, 1)
		--第二次机会
		if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
			caster:AddItemByName('item_jixiezhixin_gold')
			PlayItemMultiCastParticle(caster)
		end
	elseif is_black ~= nil then
		Draw5ChessAndShow(team_id, true, 2)
		--第二次机会
		if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
			caster:AddItemByName('item_jixiezhixin_black')
			PlayItemMultiCastParticle(caster)
		end
	elseif is_magic ~= nil then
		Draw5ChessAndShow(team_id, true, 3)
		--第二次机会
		if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
			caster:AddItemByName('item_magic_card')
			PlayItemMultiCastParticle(caster)
		end
	else
		Draw5ChessAndShow(team_id, true, 0)
		--第二次机会
		if caster:HasModifier('modifier_item_second_chance') and RandomInt(1,100) < 35 then
			caster:AddItemByName('item_jixiezhixin')
			PlayItemMultiCastParticle(caster)
		end
	end
end
--垄断一种棋子
function MonopolizeAChessPiece(team_id,chess,uu)
	local result = DestroyChessPieceFromChessPool(chess)
	if result ~= true then
		--垄断没成功
		return
	end

	--垄断收税
	local destroy_count = 0

	for i=6,13 do
		-- if team_id ~= i then  --排除自己的
			local hhh = TeamId2Hero(i)
			if hhh ~= nil then
				--手牌
				if hhh.hand_entities ~= nil then
					for _,ent in pairs(hhh.hand_entities) do
						if ent ~= nil and ent:IsNull() == false and GetUnitBaseName(ent) == chess then
							-- destroy_tax = destroy_tax + ent:GetLevel()
							destroy_count = destroy_count + 1
						end
					end
				end
				--场上棋子
				for j,v in pairs(_G.mychess[i]) do
					if v ~= nil and GetChessBaseName(v.chess) == chess then
						-- local level = 1
						-- for u,t in pairs(_G.chess_list_by_level) do
						-- 	if FindValueInTable(t,v.chess) == true then
						-- 		level = u
						-- 	end
						-- end
						-- destroy_tax = destroy_tax + level
						destroy_count = destroy_count + 1
					end
				end
			end
		-- end
	end
	destroy_tax = (destroy_count or 1) * (GetChessCostByName(chess) or 1) * 2

	--发个通知
	CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
		player_id = TeamId2Hero(team_id):GetPlayerID(),
		win_streak = TeamId2Hero(team_id).win_streak or 0,
		vip = TeamId2Hero(team_id).is_vip,
		onduty_hero = TeamId2Hero(team_id).onduty_hero,
		text = "notice_chess_destroyed",
		time_stamp = math.floor(GameRules:GetGameTime()),
		chess = chess,
		type = 'chess_event',
	})

	--如果获得金币，发combat
	if destroy_tax > 0 then
		-- ShowCombat({
		-- 	t = 'destroy_piece',
		-- 	player = TeamId2Hero(team_id):GetPlayerID(),
		-- 	num = destroy_tax,
		-- })

		ShowCombat({
			t = 'item_get_money',
			player = TeamId2Hero(team_id):GetPlayerID(),
			item = 'item_destroy_piece',
			num = destroy_tax,
		})
		
		--获得destroy_tax金币
		local position_to = CenterVector(team_id) + Vector(RandomInt(-400,400),RandomInt(-400,400),0)
		DropMoneyBag(Vector(0,0,128), position_to, 300, ( destroy_tax or 1 ))
	end
end
--摧毁棋库中所有base_chess的同名棋子
function DestroyChessPieceFromChessPool(base_chess)
	local destroy_info = CustomNetTables:GetTableValue( "chess_pool_table", "destroy_info" ) or {}
	if FindValueInTable(destroy_info, base_chess) == true then
		return false
	end
	if IsSpecialChess(base_chess) == true then
		return false
	end
	local chess_cost = _G.chess_2_mana[base_chess]
	for i=table.maxn(_G.chess_pool[chess_cost]),1,-1 do
		if _G.chess_pool[chess_cost][i] == base_chess then
			table.remove(_G.chess_pool[chess_cost],i)
		end
	end
	--在chess_pool_table维护本局中已被摧毁的棋子，用于UI显示。
	--为防止误导，除非未来增加棋子剩余数量的显示，灰掉的橙卡和摧毁棋子即使再被卖回棋库一些，也不会再显示为亮起来
	local new_destroy_info = {}
	table.insert(new_destroy_info,base_chess)
	for i,v in pairs(destroy_info) do
		table.insert(new_destroy_info,v)
	end
	CustomNetTables:SetTableValue( "chess_pool_table", "destroy_info", new_destroy_info)
	return true
end

--寻找棋库中有多少个chess_name棋子
--如果棋库中永远不会有，但会以特殊方式获得（如，蓝猫，io，ssr），返回-1
--如果棋库中可能有，但本局没随到的橙，或者已经被抽完了的棋子，返回0
function FindChessCountInChessPool(chess_name)
	if IsSpecialChess(chess_name) == true then
		return -1
	end
	local chess_cost = _G.chess_2_mana[chess_name] or 1
	local chess_count = 0
	for i=table.maxn(_G.chess_pool[chess_cost]),1,-1 do
		if _G.chess_pool[chess_cost][i] == chess_name then
			chess_count = chess_count + 1
		end
	end
	
	return chess_count
end

--从棋库移除count个chess_name棋子
function RemoveChessFromChessPool(chess_name, count)
	local chess_cost = _G.chess_2_mana[chess_name]
	if count == nil then 
		count = 1
	end
	if chess_cost > 5 then
		return
	end
	for i=table.maxn(_G.chess_pool[chess_cost]),1,-1 do
		if _G.chess_pool[chess_cost][i] == chess_name then
			table.remove(_G.chess_pool[chess_cost],i)
			count = count - 1
			if count <= 0 then
				return true
			end
		end
	end
	return false
end

--开战利品宝箱
function ItemBaoxiang(keys)
	local caster = keys.caster
	local lv = keys.lv
	
	keys.ability_name = keys.ability_name or keys.ability:GetAbilityName()

	if caster.loot_table ~= nil and table.maxn(caster.loot_table) == 3 then
		-- Timers:CreateTimer(1,function()
		-- 	ItemBaoxiang(keys)
		-- end)
		
		--已经有正在打开的箱子了还没选
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_open_more_lootbox"
		})
		EmitSoundOn("General.CastFail_NoMana",caster)
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"confirm_close_loot_box",{
			key = GetClientKey(caster:GetTeam()),
		})
		
		return
	end

	play_particle("effect/loot_box/econ/events/ti9/shovel_revealed_loot_variant_0.vpcf",PATTACH_OVERHEAD_FOLLOW,caster,8)

	caster.loot_table = {}
	if keys.ability_name == 'item_relicbox' then
		while table.maxn(caster.loot_table)<3 do
			local loot = RandomARelic()
			if FindValueInTable(caster.loot_table,loot) ~= true then
				table.insert(caster.loot_table,loot)
			end
		end
	else
		while table.maxn(caster.loot_table)<3 do
			local loot = RandomALoot(lv,caster)
			if FindValueInTable(caster.loot_table,loot) ~= true then
				table.insert(caster.loot_table,loot)
			end
		end
	end

	ItemSpendCharge(keys)


	local result_table = {}
	if caster.loot_table then
		for index,v in pairs(caster.loot_table) do
			result_table[index] = {}
			table.insert(result_table[index],{
				item = v,
			})
		end
	end
	--先发给UI可供选择的物品，避免因为下面的智能分析报错了而什么也不显示
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_loot_box",{
		key = GetClientKey(caster:GetTeam()),
		loot_list = result_table,
	})

	
	--智能分析可以合成的物品
	Timers:CreateTimer(0.1,function()
		if caster.loot_table then
			for index,v in pairs(caster.loot_table) do
	
				--信使身上的智能合成
				local more_item_table = FindMoreItemsByUnitAndTable(caster, {[1] = v})
				for i=1,table.maxn(more_item_table) do
					table.insert(result_table[index],{
						item = more_item_table[i],
						is_courier = true,
						onduty_hero = caster.onduty_hero,
						unit_index = caster:entindex(),
					})
				end
	
				--手牌棋子的智能合成
				if caster.hand_entities then
					for _,ent in pairs(caster.hand_entities) do
						--手牌一定有实体化的棋子，可以直接操作
						if IsUnitExist(ent) then 
							local more_item_table = FindMoreItemsByUnitAndTable(ent, {[1] = v})
							for i=1,table.maxn(more_item_table) do
								table.insert(result_table[index],{
									item = more_item_table[i],
									is_courier = false,
									unit_index = ent:entindex(),
									unit_name = ent:GetUnitName(),
									base_unit_name = GetUnitBaseName(ent),
								})
							end
						end
					end
				end
	
				--场上棋子的智能合成
				for _,vchess in pairs(_G.mychess[caster:GetTeam()]) do
					--vchess不一定有实体化的棋子。有的话会记录index，从而获取实体化的棋子
					local chess = EntIndexToHScript(vchess.index)
					if chess and IsUnitExist(chess) then
						--有实体棋子
						local more_item_table = FindMoreItemsByUnitAndTable(chess, {[1] = v})
						for i=1,table.maxn(more_item_table) do
							table.insert(result_table[index],{
								item = more_item_table[i],
								is_courier = false,
								unit_index = vchess.index,
								unit_name = vchess.chess,
								base_unit_name = GetChessBaseName(vchess.chess),
							})
						end
					else
						--没有实体棋子，用vchess判断
						local more_item_table = FindMoreItemsByTableAndTable(vchess.item, {[1] = v})
						for i=1,table.maxn(more_item_table) do
							table.insert(result_table[index],{
								item = more_item_table[i],
								is_courier = false,
								unit_index = vchess.index,
								unit_name = vchess.chess,
								base_unit_name = GetChessBaseName(vchess.chess),
							})
						end
					end
				end
			end
		end
	
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_loot_box",{
			key = GetClientKey(caster:GetTeam()),
			loot_list = result_table,
			skip_open_box = true,
		})
	end)
end
function RandomARelic()
	return _G.DROP_RELIC_LIST[RandomInt(1,table.maxn(_G.DROP_RELIC_LIST))]
end
function RandomALoot(level,caster)
	local ran = RandomInt(1,100)
	local item_level = 0
	local curr_per = 0
	if _G.drop_loot_gailv[level] ~= nil then
		for per,lv in pairs(_G.drop_loot_gailv[level]) do
			if ran >= per and curr_per<=per then
				curr_per = per
				item_level = lv
			end
		end
	end
	if IsUnitExist(caster) and caster:HasModifier('modifier_item_upgrade_lootbox') and RandomInt(1,100) < 50 then
		item_level = item_level + 1
		if item_level > 3 then
			item_level = 3
		end
	end
	local i = _G.DROP_ITEM_LIST[item_level][RandomInt(1,table.maxn(_G.DROP_ITEM_LIST[item_level]))]

	return i
end 
function GiveALootBox(hero)
	local item_name = _G.wave_2_lootbox[_G.battle_round - 1]
	if item_name == nil then
		return
	end
	GiveASingleLootBox(hero,item_name)
	if hero:HasModifier('modifier_item_more_creep') then
		Timers:CreateTimer(0.4,function()
			GiveASingleLootBox(hero,item_name)
		end)	
	end
end
function GiveASingleLootBox(hero,item_name)
	AddItemPlus(hero,item_name,0.8)
	ShowCombat({
		t = 'player_get_lootbox',
		player = hero:GetPlayerID(),
	})
	EmitSoundOn("dac.loot.drop",hero)
end
function AddItemPlus(hero,item_name,delay)
	if delay == nil then
		delay = 0
	end
	
	Timers:CreateTimer(delay,function()
		local has_enemy_slot = false
		--普通物品
		for slot=0,8 do
			if hero:GetItemInSlot(slot) == nil or (hero:GetItemInSlot(slot):GetAbilityName() == item_name and hero:GetItemInSlot(slot):IsStackable()) then
				has_enemy_slot = true
			end
		end
		--中立物品必替换（圣物）
		if FindValueInTable(_G.DROP_RELIC_LIST,item_name) then
			has_enemy_slot = true
		end
		if has_enemy_slot == true then
			if item_name == 'item_silingshu' or item_name == 'item_silingshu_2' or item_name == 'item_silingshu_3' then
				item_name = GetCurrSilingshuItemName(hero)
			end
			hero:AddItemByName(item_name)
		else
			DropItemAppointed(hero,hero,item_name)
		end
	end)
end
function FillEmptySlot(x)
	--用空物品塞满剩下的格子，避免物品放进来丢失
	if not IsUnitExist(x) then
		return
	end
	local slot_count = 9
	for slot=0,8 do
		if x:GetItemInSlot(slot)~= nil then
			slot_count = slot_count - 1
		end
	end
	if slot_count > 0 then
		for i=1,slot_count do
			x:AddItemByName('item_null')
		end
	end
end
function ItemXiWa(keys)
	play_particle("particles/econ/events/ti7/shivas_guard_active_ti7.vpcf",PATTACH_ABSORIGIN_FOLLOW,keys.caster,6)
	EmitSoundOn("DOTA_Item.ShivasGuard.Activate",keys.caster)

	local units = FindUnitsInRadiusByTeam({
		team = keys.caster.team_id,
		role = 2,
		radius = 1000,
		position = keys.caster:GetAbsOrigin()
	})
	
	for _,unluckydog in pairs(units) do
		local delay = 1.0* (unluckydog:GetAbsOrigin() - keys.caster:GetAbsOrigin()):Length2D() / 350
		ItemXiWaOne(delay,keys.caster,unluckydog)
	end
end
function ItemXiWaOne(delay,caster,unluckydog)
	Timers:CreateTimer(delay,function()
		InvisibleUnitCast({
			caster = caster,
			ability = 'shiva_give_debuff',
			level = 1,
			unluckydog = unluckydog,
			ignore_nether_ward = true,
		})
	end)
end

function ItemPipe(keys)
	local caster = keys.caster
	play_particle("particles/items2_fx/pipe_of_insight_launch.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,6)
	EmitSoundOn("DOTA_Item.Pipe.Activate",caster)

	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 1,
		position = caster:GetAbsOrigin(),
		radius = 500,
	})
	
	for _,unluckydog in pairs(units) do
		InvisibleUnitCast({
			caster = caster,
			ability = 'give_pipe_buff',
			level = 1,
			unluckydog = unluckydog,
			ignore_nether_ward = true,
		})
	end
end

function ItemChihongjia(keys)
	local caster = keys.caster
	EmitSoundOn("Item.CrimsonGuard.Cast",caster)

	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 1,
		position = caster:GetAbsOrigin(),
		radius = 400,
	})
	
	for _,unluckydog in pairs(units) do
		-- if unluckydog:IsRangedAttacker() == false then
			InvisibleUnitCast({
				caster = caster,
				ability = 'give_chihongjia_buff',
				level = 1,
				unluckydog = unluckydog,
				ignore_nether_ward = true,
			})
		-- end
	end
end
function GetCurrSilingshuItemName(u)
	--动态显示死灵书的等级
	local silingshu_table = {
		[1] = 'item_silingshu',
		[2] = 'item_silingshu_2',
		[3] = 'item_silingshu_3',
	}
	local need_silingshu_level = nil

	if u:IsHero() == true then
		need_silingshu_level = 1
	else
		if u:GetLevel() <= 3 then
			need_silingshu_level = 1
		end
		if u:GetLevel() >= 4 and u:GetLevel() <= 6 then
			need_silingshu_level = 2
		end
		if u:GetLevel() >= 7 then
			need_silingshu_level = 3
		end
	end

	return silingshu_table[need_silingshu_level]
end
--兼容不能吃树的bug，把吃树换成即食的item_chishu_new
function MakeTangoEatable(player_id,slot)
	local hero = PlayerId2Hero(player_id)
	local item = hero:GetItemInSlot(slot)
	if item:GetAbilityName() == 'item_chishu' then 
		local count = item:GetCurrentCharges()
		hero:RemoveItem(item)
		for i=1,count do
			hero:AddItemByName('item_chishu_new')
		end
	end 
end
function HuiyaoTang(keys)
	local caster = keys.caster
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id
	local radius = keys.radius or 400
	local damage = keys.damage or 30
	local p = caster:GetAbsOrigin()
	local ability = keys.ability

	if caster:IsHero() == true then
		return
	end

	for _,unit in pairs(GetValidChessOnBoard(at_team_id)) do
		if unit.team_id ~= team_id and (unit:GetAbsOrigin() - p):Length2D() < radius and unit:IsInvulnerable() == false then
			ApplyDamage({
		    	victim=unit,
		    	attacker=caster,
		    	damage_type=DAMAGE_TYPE_PURE,
		    	damage=damage,
				ability = keys.ability,
		    })
		    ability:ApplyDataDrivenModifier(unit,unit,'modifier_item_huiyao_debuff',{ duration = 2, })
		    ShowHuiyaoEffect({
		    	caster = caster,
		    	target = unit,
		    })
		end
	end
end
function ShowHuiyaoEffect(keys)
	local unit = keys.target
	local huiyao_unit = keys.caster
	local e = ParticleManager:CreateParticle('effect/huiyao/2.vpcf', PATTACH_ABSORIGIN_FOLLOW, unit)

	ParticleManager:SetParticleControl(e, 0, unit:GetOrigin())
	ParticleManager:SetParticleControl(e, 1, huiyao_unit:GetOrigin())
	Timers:CreateTimer(1.9,function()
		if e ~= nil then
			ParticleManager:DestroyParticle(e,true)
		end
	end)
end
function RemindItem(caster, modifier_name) 
	if _G.game_status ~= 2 then
		if caster:IsHero() == false then
			InitChessMana(caster)
		end
	end
	Timers:CreateTimer(0.1,function()
		if IsUnitExist(caster) == false or caster.is_fuhuo == true or caster.is_tuihuaed == true or caster.is_youhun == true or caster.team_id == 4 or caster:HasModifier("modifier_illusion") then
			--这些情况不做特殊处理
			return
		end
		local modifier = caster:FindModifierByName(modifier_name)
		if modifier == nil then
			return
		end
		local item = modifier:GetAbility()
		
		if item == nil then
			return
		end
		local item_name = item:GetAbilityName()
		if caster:IsHero() == true then
			if FindValueInTable(_G.DROP_RELIC_LIST,item_name) == true then
				--获取圣物的提醒
				CustomGameEventManager:Send_ServerToAllClients("bullet",{
					player_id = caster:GetPlayerID(),
					win_streak = caster.win_streak or 0,
					vip = caster.is_vip,
					target = nil,
					item = item_name,
					item_level = 6,
				})
			end
		end
		if modifier_name ~= ('modifier_'..item_name) or string.find(item_name,'item_') == nil then
			return
		end
		if FindChessRemindedItem(caster,item_name) == false then
			AddChessRemindedItem(caster,item_name)
			local item_level = IsCombinedItem(item_name)
			if item_level ~= nil and item_level > 0 then
				--说谢谢
				if RandomInt(1,50) < (item_level*10) then
					PlayChessDialogue(caster,'thanks')
				end
				--发弹幕：获得物品
				local team_id = caster.team_id
				local hero = TeamId2Hero(team_id)
				if hero ~= nil then
					if caster:IsHero() ~= true then
						CustomGameEventManager:Send_ServerToAllClients("bullet",{
							player_id = hero:GetPlayerID(),
							win_streak = hero.win_streak or 0,
							vip = hero.is_vip,
							target = caster:GetUnitName(),
							item = item_name,
							item_level = item_level,
						})
					end

					if item_level == 5 and _G.egg_quest == 'q022' then
						SetQuest(hero.team_id,true)
					end
					if item_level == 4 and _G.egg_quest == 'q032' then
						SetQuest(hero.team_id,true)
					end
				end
			end
		end
	end)
end
--棋子装备提醒
function InitChessRemindedItem(chess, items)
	if items == nil then
		items = {}
	end
	chess.reminded_item = items
end
function AddChessRemindedItem(chess, item)
	if chess.reminded_item == nil then
		chess.reminded_item = {}
	end
	table.insert(chess.reminded_item, item)
end
function FindChessRemindedItem(chess, item)
	if chess.reminded_item == nil then
		return false
	end
	return FindValueInTable(chess.reminded_item, item)
end
function AddXuejingshiCount(u)
	if u:GetTeam() == 4 then
		--客场不加减血精石点数
		return
	end

	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local xuejingshi_count = v_chess['xuejingshi_count']
	if xuejingshi_count == nil then
		v_chess['xuejingshi_count'] = 1
		xuejingshi_count = 1
	end

	if RandomInt(1,100) <= 20 then
		v_chess['xuejingshi_count'] = v_chess['xuejingshi_count'] + 1
		u.xuejingshi_count = (u.xuejingshi_count or 0) + 1
	end
	SyncXuejingshiCount({caster = u})
end
function LoseXuejingshiCount(u)
	if u:GetTeam() == 4 then
		--客场不加减血精石点数
		return math.floor((u.xuejingshi_count or 1)/2)
	end

	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local xuejingshi_count = v_chess['xuejingshi_count']
	if xuejingshi_count == nil then
		v_chess['xuejingshi_count'] = 1
		xuejingshi_count = 1
	end

	v_chess['xuejingshi_count'] = math.ceil(v_chess['xuejingshi_count'] / 2)
	return math.floor((xuejingshi_count or 1)/2)
end
function GetXuejingshiCount(u)
	local v_chess = Unit2VChess(u)
	if v_chess == nil then
		return
	end
	local xuejingshi_count = v_chess['xuejingshi_count']
	if xuejingshi_count == nil then
		v_chess['xuejingshi_count'] = 1
		xuejingshi_count = 1
	end

	return xuejingshi_count
end
function SyncXuejingshiCount(keys)
	local u = keys.caster
	if u:IsHero() then
		return
	end
	Timers:CreateTimer(0.5,function()
		local count = u.xuejingshi_count or GetXuejingshiCount(u) or 1
		FindItemInInventory(u,'item_xuejingshi'):SetCurrentCharges(count)
		u.xuejingshi_count = count
	end)
end

--【装饰】
function MakeGreevil(unit,is_flying)
	-- if unit.courier_name == 'h276' or unit.courier_name == 'h277' or unit.courier_name == 'h378' or unit.courier_name == 'h379' or unit.courier_name == 'h473' then
	-- 	local pos = PATTACH_OVERHEAD_FOLLOW
	-- 	local pp = ParticleManager:CreateParticle('effect/shayu/3old.vpcf', pos, unit)
	-- 	ParticleManager:SetParticleControlEnt( pp, 0, unit, pos, nil, unit:GetOrigin(), true );
	-- end

	if unit.part1 ~= nil and unit.part1:IsNull() == false then
		unit.part1:Kill()
	end
	if unit.part2 ~= nil and unit.part2:IsNull() == false then
		unit.part2:Kill()
	end
	if unit.part3 ~= nil and unit.part3:IsNull() == false then
		unit.part3:Kill()
	end
	if unit.part4 ~= nil and unit.part4:IsNull() == false then
		unit.part4:Kill()
	end
	if unit.part5 ~= nil and unit.part5:IsNull() == false then
		unit.part5:Kill()
	end
	if unit.part6 ~= nil and unit.part6:IsNull() == false then
		unit.part6:Kill()
	end
	if unit.part7 ~= nil and unit.part7:IsNull() == false then
		unit.part7:Kill()
	end
	if unit.part8 ~= nil and unit.part8:IsNull() == false then
		unit.part8:Kill()
	end

	if unit == nil or (unit.courier_name == nil and unit.onduty_hero == nil) then
		return
	end
	local greevil_info = _G.greevil_list[unit.courier_name or unit.onduty_hero]
	if greevil_info == nil then
		return
	end


	local skin = greevil_info.skin or 0
	unit:SetSkin(skin)
	--眼睛
	local part1 = greevil_info.part1
	if part1 ~= nil then
		unit.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part1})
		unit.part1:FollowEntity(unit,true)
		unit.part1:SetSkin(skin)
	end
	--耳朵
	local part2 = greevil_info.part2
	if part2 ~= nil then
		unit.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part2})
		unit.part2:FollowEntity(unit,true)
		unit.part2:SetSkin(skin)
		
		if part2 == "models/items/courier/catakeet/catakeet_tail_sly.vmdl" and skin == 9 then
			--特例
			unit.part2:SetSkin(8)
		end
	end
	--角
	local part3 = greevil_info.part3
	if part1 ~= nil then
		unit.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part3})
		unit.part3:FollowEntity(unit,true)
		unit.part3:SetSkin(skin)
	end
	--鼻子
	local part4 = greevil_info.part4
	if part4 ~= nil then
		unit.part4 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part4})
		unit.part4:FollowEntity(unit,true)
		unit.part4:SetSkin(skin)
	end
	--尾巴
	local part5 = greevil_info.part5
	if part5 ~= nil then
		unit.part5 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part5})
		unit.part5:FollowEntity(unit,true)
		unit.part5:SetSkin(skin)
	end
	--牙齿
	local part6 = greevil_info.part6
	if part6 ~= nil then
		unit.part6 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part6})
		unit.part6:FollowEntity(unit,true)
		unit.part6:SetSkin(skin)
	end
	--翅膀
	if is_flying == true then
		local part7 = greevil_info.part7
		if part7 ~= nil then
			unit.part7 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part7})
			unit.part7:FollowEntity(unit,true)
			unit.part7:SetSkin(skin)
		end
	end
	if is_flying == true then
		local part8 = greevil_info.part8
		if part8 ~= nil then
			unit.part8 = SpawnEntityFromTableSynchronous('prop_dynamic',{model=part8})
			unit.part8:FollowEntity(unit,true)
			unit.part8:SetSkin(skin)
		end
	end
end
--设置棋子的特殊外观（原MakeTiny）
function SetChessSpecialLook(x)
	if not IsUnitExist(x) then
		return
	end

	if x:GetUnitName() == 'chess_db' then
		x:AddActivityModifier('attack_long_range')
	end
	if x:GetUnitName() == 'chess_db1' then
		x:AddActivityModifier('attack_long_range')
	end
	if x:GetUnitName() == 'chess_db11' then
		x:AddActivityModifier('attack_long_range')
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
		})
	end

	-- if x:GetUnitName() == 'chess_ts11' then
	-- 	x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/leshrac/frostivus2018_leshrac_frost_unicorn_weapon/frostivus2018_leshrac_frost_unicorn_weapon.vmdl"})
	-- 	x.part1:FollowEntity(x,true)
	-- end

	if x:GetModelName() == "models/heroes/mirana_persona/mirana_persona_base.vmdl" then
		x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_armor.vmdl"})
		x.part1:FollowEntity(x,true)
		x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_arrow.vmdl"})
		x.part2:FollowEntity(x,true)
		x.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_back.vmdl"})
		x.part3:FollowEntity(x,true)
		x.part4 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_base_arrow.vmdl"})
		x.part4:FollowEntity(x,true)
		x.part5 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_head.vmdl"})
		x.part5:FollowEntity(x,true)
		x.part6 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_mount.vmdl"})
		x.part6:FollowEntity(x,true)
		x.part7 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/heroes/mirana_persona/mirana_persona_weapon.vmdl"})
		x.part7:FollowEntity(x,true)
	end

	if x:GetModelName() == "models/items/spectre/spectre_arcana/spectre_arcana_base.vmdl" then
        -- 幽鬼至宝，把五把刀设置出来
        x:SetBodygroupByName("blade_01", 1)
        x:SetBodygroupByName("blade_02", 1)
        x:SetBodygroupByName("blade_03", 1)
        x:SetBodygroupByName("blade_04", 1)
        x:SetBodygroupByName("blade_05", 1)
    end
	if x:GetUnitName() == 'chess_tiny1' then
		x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny_03/glacial/glacial_tiny_03_body.vmdl"})
		x.part2:FollowEntity(x,true)
	end
	if x:GetUnitName() == 'chess_tiny11' then
		x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_back/tiny_bad_to_the_bone_back.vmdl"})
		x.part1:FollowEntity(x,true)
		x.part2 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_belt/tiny_bad_to_the_bone_belt.vmdl"})
		x.part2:FollowEntity(x,true)
		x.part3 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_neck/tiny_bad_to_the_bone_neck.vmdl"})
		x.part3:FollowEntity(x,true)
		x.part4 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/items/tiny/tiny_bad_to_the_bone_shoulder/tiny_bad_to_the_bone_shoulder.vmdl"})
		x.part4:FollowEntity(x,true)

		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/tiny3/tiny_bad_to_the_bone_back.vpcf",
		})
	end

	if x:GetUnitName() == 'pve_roshan' then
		x.part1 = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/creeps/roshan_halloween/roshan_halloween_angel.vmdl"})
		x.part1:FollowEntity(x,true)
	end

	-- if x:GetUnitName() == 'chess_hw1' then
	-- 	PlayParticleOnUnitUntilDeath({
	-- 		caster = x,
	-- 		p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
	-- 	})		
	-- end
	if x:GetUnitName() == 'chess_chen11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
		})		
	end
	if x:GetUnitName() == 'chess_veno11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
		})		
	end
	if x:GetUnitName() == 'chess_pangolier11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
		})		
	end
	if x:GetUnitName() == 'chess_hw1' or x:GetUnitName() == 'chess_hw11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_2.vpcf",
		})
	end

	if x:GetUnitName() == 'chess_marci1' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/marci_v2/1.vpcf",
		})		
	end
	if x:GetUnitName() == 'chess_marci11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/marci_v2/2.vpcf",
		})
	end

	if x:GetUnitName() == 'chess_pb1' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
		})		
	end
	if x:GetUnitName() == 'chess_pb11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/courier_greevil_green/courier_greevil_green_ambient_1.vpcf",
		})	
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/huangsha/roushanbaby_roshan_desert_sands_ambient.vpcf",
		})
	end

	

	if x:GetUnitName() == 'chess_brew11' then
		PlayParticleOnUnitUntilDeath({
			caster = x,
			p = "effect/chess_brew11/1.vpcf",
		})		
	end

	if x:GetModelName() == 'models/items/windrunner/windrunner_arcana/wr_arcana_base.vmdl' then
		--风行至宝：设置款式二
		x:SetMaterialGroup('1')
		local children = x:GetChildren()
	    for k,child in pairs(children) do
	       if child ~= nil and child:IsNull() ~= true and child:GetClassname() == "dota_item_wearable" then
	           child:SetBodygroupByName('arcana', 2)
	       end
	    end
	end
	if x:GetModelName() == "models/items/drow/drow_arcana/drow_arcana.vmdl" then
		--小黑至宝：设置款式二
		x:SetMaterialGroup('1')
		local children = x:GetChildren()
	    for k,child in pairs(children) do
	       if child ~= nil and child:IsNull() ~= true and child:GetClassname() == "dota_item_wearable" then
	           child:SetBodygroupByName('arcana', 2)
	       end
	    end
	end

	if x.bh_bag ~= nil then
		x.bh_bag:Destroy()
	end
	PlaySpawnAnimation(x)
end
function ChangeFlyingCourierModel(opp_model, force_model)
	local new_m = string.sub(opp_model,1,string.len(opp_model)-5)..'_flying.vmdl'

	if force_model then
		new_m = force_model
	end

	if opp_model == "models/courier/mighty_boar/mighty_boar.vmdl" then
		new_m = "models/courier/mighty_boar/mighty_boar_wings.vmdl"
	end
	if opp_model == "models/courier/yak/yak.vmdl" then
		new_m = "models/courier/yak/yak_wings.vmdl"
	end
	if opp_model == "models/props_gameplay/donkey_dire.vmdl" then
		new_m = "models/props_gameplay/donkey_dire_wings.vmdl"
	end
	if opp_model == "models/props_gameplay/donkey.vmdl" then
		new_m = "models/props_gameplay/donkey_wings.vmdl"
	end
	if opp_model == "models/courier/juggernaut_dog/juggernaut_dog.vmdl" then
		new_m = "models/courier/juggernaut_dog/juggernaut_dog_wings.vmdl"
	end
	if opp_model == "models/items/juggernaut/ward/fortunes_tout/fortunes_tout.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant_flower_1.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant/hallowed_horde/hallowed_horde.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant/furion_treant_nelum_red/furion_treant_nelum_red.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/items/furion/treant/ravenous_woodfang/ravenous_woodfang.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/shudaixiong/model/shudaixiong/shudaixiong.vmdl" then
		new_m = "models/shudaixiong/model/shudaixiong_flying/shudaixiong_flying.vmdl"
	end 
	if opp_model == "models/rongyanquan/rongyanquan.vmdl" then
		new_m = opp_model
	end
	if opp_model == "models/drodo/drodo.vmdl" then
		new_m = opp_model
	end

	return new_m
end
function ShowCrown(hero,crown_level)
	if crown_level == nil then
		crown_level = 1
	end
	if not IsUnitExist(hero) then
		return
	end
	if hero.crown_p ~= nil then
		ParticleManager:DestroyParticle(hero.crown_p,true)
	end
	if hero.is_crown ~= true then
		return
	end
	-- if crown_level == 1 then
	-- 	hero.crown_p = PlayParticleOnUnitUntilDeath({
	-- 		caster = hero,
	-- 		p = "effect/crown/1.vpcf",
	-- 		pos = PATTACH_ABSORIGIN_FOLLOW,
	-- 	})
	-- end
	-- if crown_level == 2 then
	-- 	hero.crown_p = PlayParticleOnUnitUntilDeath({
	-- 		caster = hero,
	-- 		p = "effect/crown/2.vpcf",
	-- 		pos = PATTACH_OVERHEAD_FOLLOW,
	-- 	})
	-- end
	if crown_level == 1 then
		hero.crown_p = PlayParticleOnUnitUntilDeath({
			caster = hero,
			p = "effect/crown_s3/1.vpcf",
			pos = PATTACH_OVERHEAD_FOLLOW,
		})
	end
	if crown_level == 2 then
		hero.crown_p = PlayParticleOnUnitUntilDeath({
			caster = hero,
			p = "effect/crown_s3/2.vpcf",
			pos = PATTACH_OVERHEAD_FOLLOW,
		})
	end
end
function ShowCourierEffect(hero,type)
	if hero.flyup_effect ~= nil then
		ParticleManager:DestroyParticle(hero.flyup_effect,true)
	end
	if hero.ground_effect ~= nil then
		ParticleManager:DestroyParticle(hero.ground_effect,true)
	end
	if type == 1 then
		--陆地特效
		if hero.onduty_hero ~= nil and _G.courier_ground_effect_list[hero.onduty_hero] ~= nil then
			--陆地特效
			local ground_effect = _G.courier_ground_effect_list[hero.onduty_hero]
			hero.ground_effect = PlayParticleOnUnitUntilDeath({
				caster = hero,
				p = ground_effect,
			})
		end
	end
	if type == 2 then
		--飞行特效
		if hero.onduty_hero ~= nil and _G.courier_flyup_effect_list[hero.onduty_hero] ~= nil then
			--飞行特效
			local flyup_effect = _G.courier_flyup_effect_list[hero.onduty_hero]
			hero.flyup_effect = PlayParticleOnUnitUntilDeath({
				caster = hero,
				p = flyup_effect,
			})
		end
	end
end
function ShowStarsOnAllChess(team)
	for _,u in pairs(GetValidChessOnBoard(team)) do
		u.is_in_battle = true
		ShowStarsOnChess(u,nil,'teleport')
	end
end

function ShowStarsOnChess(unit,duration,gesture)
	Timers:CreateTimer(0.5,function()
		if IsUnitExist(unit) == false then
			return
		end
		local unit_name = unit:GetUnitName()
		if duration == nil then
			duration = 3
		end
		local star = 1
		if string.find(unit_name,'11') ~= nil then
			unit_name = string.sub(unit_name,1,-3)
			star = 3
		end
		if string.find(unit_name,'1') ~= nil then
			unit_name = string.sub(unit_name,1,-2)
			star = 2
		end

		local cost = _G.chess_2_mana[unit_name]

		if cost == nil then
			return
		end
		if cost > 5 then
			play_particle('effect/arrow/ssr/star1.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,duration)
		else
			play_particle('effect/arrow/'..cost..'/star'..star..'.vpcf',PATTACH_OVERHEAD_FOLLOW,unit,duration)
		end

		-- unit:StartGesture(gesture or ACT_DOTA_TELEPORT)

		local m = "modifier_ready"
		if gesture ~= nil then
			m = "modifier_"..gesture
		end
		unit:AddNewModifier(unit,nil,m,{ duration = duration,})
	end)
end
function PlayCombineSound(u)
	local level = u:GetLevel()
	if level == nil or level < 3 then
		level = 3
	end
	if level >9 then
		level = 9
	end
	EmitSoundOn("dac.combine."..level,u)
end
function PlaySendMoneyEffect(hhh,uu)
	local pp = ParticleManager:CreateParticle("effect/remove_chess/1.vpcf", PATTACH_ABSORIGIN_FOLLOW, hhh)
	ParticleManager:SetParticleControlEnt( pp, 1, uu, PATTACH_ABSORIGIN_FOLLOW, nil, uu:GetOrigin(), true );
	Timers:CreateTimer(3,function()
		if pp ~= nil then
			ParticleManager:DestroyParticle(pp,true)
		end
	end)
end
function RefreshPets(hero_new,old_pet,new_pet_name, name_suffix)
	if name_suffix == nil then
		name_suffix = 1
	end
	if old_pet ~= nil and old_pet:IsNull() ~= true then
		old_pet:Destroy()
	end
	--生成宠物
	local pet = nil
	if new_pet_name ~= nil then
		pet = new_pet_name
	end
	if pet ~= nil and _G.pet_list[pet] ~= nil then
		local ran1 = RandomInt(50,200)
		local ran11 = RandomInt(0,1)
		if ran11 == 0 then 
			ran1 = -ran1
		end
		local ran2 = RandomInt(50,200)
		local ran22 = RandomInt(0,1)
		if ran22 == 0 then 
			ran2 = -ran2
		end

		if name_suffix == 2 then
			ran1 = 100
			ran2 = -50
		end
		local my_pet = CreateUnitByName("gemtd_pet", hero_new:GetAbsOrigin()+Vector(ran1,ran2,0),true,nil,nil, DOTA_TEAM_GOODGUYS)
		my_pet.ftd = 2009
		my_pet:SetOwner(hero_new)
		hero_new.pet_entity = my_pet
		my_pet.pet_name = pet
		AddAbilityAndSetLevel(my_pet,'no_collision')

		if pet == 't305' then
			PlayParticleOnUnitUntilDeath({
				caster = my_pet,
				p = "effect/bose_hand/bose.vpcf",
			})
		end

		local onduty_pet_model = _G.pet_list[pet]
		local onduty_pet_skin = 0 --_G.sm_hero_list_skin[pet] or 0
		my_pet:SetOriginalModel(onduty_pet_model)
		my_pet:SetModel(onduty_pet_model)
		my_pet:SetSkin(onduty_pet_skin)
		my_pet:SetModelScale(_G.pet_size_list[pet] or 1)

		-- BlinkChessX({caster=my_pet,blink_type="fall"})

		hero_new['pet'..name_suffix] = my_pet
		hero_new['pet_name'..name_suffix] = pet
		my_pet.owner = hero_new

		if name_suffix ~= 2 then
			PlayPetDialogue(my_pet,false,hero_new.language)
		end

		Timers:CreateTimer(1,function()
			if my_pet == nil or my_pet.owner == nil or my_pet:IsNull() == true or my_pet:IsAlive() == false then
				return
			end
			if my_pet.owner == nil or my_pet.owner:IsNull() == true or my_pet.owner:IsAlive() == false then
				my_pet:Destroy()
				return
			end
			if my_pet.owner.ai_synergy ~= nil and my_pet.owner.stop_ai ~= true then
				return 1
			end
			
			if (my_pet:GetAbsOrigin() - my_pet.owner:GetAbsOrigin()):Length2D() >200 then
				local ran1 = RandomInt(50,200)
				local ran11 = RandomInt(0,1)
				if ran11 == 0 then 
					ran1 = -ran1
				end
				local ran2 = RandomInt(50,200)
				local ran22 = RandomInt(0,1)
				if ran22 == 0 then 
					ran2 = -ran2
				end
				FindClearSpaceForUnit(my_pet, my_pet:GetAbsOrigin(), true)
				my_pet:MoveToPosition(my_pet.owner:GetAbsOrigin()+Vector(ran1,ran2,0))
				return 1
			else
				return 1
			end
		end)

		return my_pet
	else
		hero_new['pet'..name_suffix] = nil
		hero_new['pet_name'..name_suffix] = nil
	end
end
function LinkEffect(u1,u2)
	local p = ParticleManager:CreateParticle("particles/units/heroes/hero_warlock/warlock_fatal_bonds_base.vpcf",PATTACH_CUSTOMORIGIN,u1)
    ParticleManager:SetParticleControlEnt(p,0,u1,5,"attach_hitloc",u1:GetOrigin(),true)
    ParticleManager:SetParticleControlEnt(p,1,u2,5,"attach_hitloc",u2:GetOrigin(),true)
    Timers:CreateTimer(0.5,function()
		if p ~= nil then
        	ParticleManager:DestroyParticle(p,true)
		end
    end)
end
function PreviewProjectile(hero, pj, pj_model,is_random)
	local uu = nil
	if is_random == true then
		uu = CreateUnitByName("invisible_unit", Entities:FindByName(nil,"center"..(hero:GetTeam()-6)):GetAbsOrigin()+Vector(0,128*5,256)+RandomVector(128) ,false,nil,nil, hero:GetTeam())
	else
		uu = CreateUnitByName("invisible_unit", Entities:FindByName(nil,"center"..(hero:GetTeam()-6)):GetAbsOrigin()+RandomVector(512) ,false,nil,nil, hero:GetTeam())
	end

	Timers:CreateTimer(5,function()
		uu:ForceKill(false)
		uu:Destroy()
	end)

	local info =
    {
        Target = hero,
        Source = uu,
        Ability = nil,
        EffectName = pj_model,
        bDodgeable = false,
        iMoveSpeed = 1000,
        bProvidesVision = false,
        iVisionRadius = 0,
        iVisionTeamNumber = hero:GetTeam(),
        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
    }
	projectile = ProjectileManager:CreateTrackingProjectile(info)

	local delay_time = (hero:GetAbsOrigin() - uu:GetAbsOrigin()):Length2D() / 1000
	Timers:CreateTimer(delay_time, function()
		if pj ~= nil then
			local damage_sound = _G.projectile_list[pj]['sound']
			EmitSoundOn(damage_sound,hero)
		end
	end)	
end
function SetSpecialProjectile(keys)
	local pp = keys.projectile
	local caster = keys.caster
	if caster.projectile_priority == nil then
		caster.projectile_priority = {}
		table.insert(caster.projectile_priority,caster:GetRangedProjectileName())
	end
	table.insert(caster.projectile_priority,pp)
	caster:SetRangedProjectileName(caster.projectile_priority[table.maxn(caster.projectile_priority)])
end
function RemoveSpecialProjectile(keys)
	local pp = keys.projectile
	local caster = keys.caster
	if caster.projectile_priority == nil then
		caster.projectile_priority = {}
	end
	RemoveOneKeyInTable(caster.projectile_priority,pp)
	caster:SetRangedProjectileName(caster.projectile_priority[table.maxn(caster.projectile_priority)])
end

--【触发监听事件】
--英雄升级
function DAC:OnPlayerGainedLevel(keys)
	local i = 0
	for i = 6, 13 do
		_G.population_max[i] = GetMaxChessCount(i)
		if _G.egg_quest == 'q013' and _G.population_max[i] >= 10 then
			SetQuest(i,true)
		end

		local hero = TeamId2Hero(i)

		if hero ~= nil then 
			hero:SetAbilityPoints(0)
			local level = hero:GetLevel()
			SetStat(hero:GetPlayerID(),'hero_level',level)
			-- for j=1,10 do
			-- 	if hero:FindAbilityByName('hero_level_'..j) ~= nil then
			-- 		hero:RemoveAbility('hero_level_'..j)
			-- 		hero:RemoveModifierByName('modifier_hero_level'..j)
			-- 	end
			-- end
			local summon_level = level
			if summon_level > 10 then
				summon_level = 10
			end
			AddAbilityAndSetLevel(hero,'summon_hero',summon_level)
		end

		--同步ui人口
		CustomGameEventManager:Send_ServerToTeam(i,"population",{
			key = GetClientKey(i),
			max_count = _G.population_max[i],
			count = _G.population[i],
		})

	end
end

--有玩家连入游戏
function DAC:OnPlayerConnectFull(keys)
	--因为只能获得userid（没什么用）
	--干脆直接遍历全部的PlayerID，保存PlayerID、SteamID的对应关系
	for i=0,20 do
		local player = PlayerResource:GetPlayer(i)
		if player then
			SetPlayerConnectedInfo({
				PlayerID = i,
				PlayerName = PlayerResource:GetPlayerName(i),
				SteamID = tostring(PlayerResource:GetSteamID(i)),
			})
		end
	end
end

function SetPlayerConnectedInfo(keys)
	_G.playerid2steamid[keys.PlayerID] = keys.SteamID
	_G.steamid2playerid[keys.SteamID] = keys.PlayerID
	_G.steamid2name[keys.SteamID] = keys.PlayerName
	_G.connect_state[keys.PlayerID] = true
end

function DAC:OnPlayerReconnected(keys)
	--重连
	CustomGameEventManager:Send_ServerToAllClients("player_reconnect",{
		id = keys.PlayerID,
		hehe = RandomFloat(1,10000),
	})

	local hero = PlayerId2Hero(keys.PlayerID)
	if hero ~= nil then
		hero.is_auto_combine = 1
	end

	--显示传说棋子和圣物池
	Timers:CreateTimer(4,function()
		CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(keys.PlayerID),'show_legendary_and_ban',{
			key = GetClientKey(_G.playerid2team[keys.PlayerID]),
		})
	end)

	if hero ~= nil and hero.loot_table ~= nil then
		--如果有弹出的战利品选择，重新显示它
		local result_table = {}
		if hero.loot_table then
			for index,v in pairs(hero.loot_table) do
				result_table[index] = {}
				table.insert(result_table[index],{
					item = v,
				})
			end
		end
		
		Timers:CreateTimer(2,function()
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_loot_box",{
				key = GetClientKey(hero:GetTeam()),
				loot_list = result_table,
			})
		end)
	end
	if hero ~= nil then
		--恢复记住的设置选项
		Timers:CreateTimer(6,function()
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"update_config",{
				key = GetClientKey(hero:GetTeam()),
				hehe = RandomInt(1,100000),
			})
		end)
	end
	if hero ~= nil then
		--发一条全体消息，告诉大家我连回来了
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_reconnect",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})
	end

	Timers:CreateTimer(1.5,function()
		--显示姓名牌子
		UpdatePlayerWorldPanel()
	end)
	
	Timers:CreateTimer(1,function()
		--显示血量和排名
		CustomNetTables:SetTableValue( "dac_table", "player_info", {info = _G.user_info, hehe = RandomInt(1,1000)})
		if hero ~= nil then
			Timers:CreateTimer(1,function()
				SetStat(hero:GetPlayerID(),'hp',hero:GetHealth())
				UpdatePlayerCurrRank()
				CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = _G.stat_info, hehe = RandomInt(1,1000)})

				--同步ui血量
				CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
					player_id = hero:GetPlayerID(),
					hp = hero:GetHealth(),
					hp_max = hero:GetMaxHealth(),
					mp = hero:GetMana(),
					level = hero:GetLevel(),
					win_streak = hero.win_streak,
					unit_index = hero:entindex(),
					courier_id = hero.onduty_hero,
					sync_hp_bar = true,
				})
			end)
		end
	end)
	Timers:CreateTimer(1,function()
		UpdatePlayerCurrRank()
		CustomNetTables:SetTableValue( "dac_table", "user_panel_ranking", {table = _G.stat_info, hehe = RandomInt(1,1000)})

		--同步ui血量
		for i=0,_G.playing_player_count-1 do
			local h = PlayerId2Hero(i)
			if h ~= nil and h:IsNull() == false and h:IsAlive() == true then
				CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"sync_hp",{
					player_id = i,
					hp = h:GetHealth(),
					hp_max = h:GetMaxHealth(),
					mp = h:GetMana(),
					level = h:GetLevel(),
					win_streak = h.win_streak,
					unit_index = h:entindex(),
					courier_id = h.onduty_hero,
					sync_hp_bar = true,
				})
			else
				CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"sync_hp",{
					player_id = i,
					hp = 0,
					hp_max = 100,
					mp = h:GetMana(),
					level = h:GetLevel(),
					win_streak = h.win_streak,
					unit_index = h:entindex(),
					courier_id = h.onduty_hero,
					sync_hp_bar = true,
				})
			end
		end
	end)
	if hero == nil then
		--OB
		return
	end

	_G.population_max[hero:GetTeam()] = hero:GetLevel()
	
	--同步ui人口
	CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"population",{
		key = GetClientKey(hero:GetTeam()),
		max_count = _G.population_max[hero:GetTeam()],
		count = _G.population[hero:GetTeam()],
	})
	Timers:CreateTimer(0.5,function()
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_gold",{
			key = GetClientKey(hero:GetTeam()),
			gold = hero:GetMana(),
			lose_streak = hero.lose_streak or 0,
			win_streak = hero.win_streak or 0,
		})
		--同步ui血量
		CustomGameEventManager:Send_ServerToAllClients("sync_hp",{
			player_id = hero:GetPlayerID(),
			hp = hero:GetHealth(),
			hp_max = hero:GetMaxHealth(),
			mp = hero:GetMana(),
			level = hero:GetLevel(),
			win_streak = hero.win_streak,
			unit_index = hero:entindex(),
			courier_id = hero.onduty_hero,
			sync_hp_bar = true,
		})
	end)
	Timers:CreateTimer(3,function()
		--重新显示招募面板
		if hero ~= nil and hero.curr_chess_table then
			local level_one_chess = FindLevelOneChess(hero)
			hero.level_one_chess = level_one_chess
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_draw_card",{
				key = GetClientKey(hero:GetTeam()),
				chesses = hero.curr_chess_table,
				curr_money = hero:GetMana(),
				key = GetClientKey(hero:GetTeam()),
			})
		end
	end)

	Timers:CreateTimer(2.5,function()
		if hero ~= nil then
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"update_ranking_top",{})
		end
	end)

	if hero ~= nil then
		hero.isDisconnected = false
	end

	if _G.is_tester_mode == true then
		CustomGameEventManager:Send_ServerToAllClients("show_tester_box",{
			hehe = RandomFloat(1,10000),
		}) 
	end

	-- --为重连的玩家重新加载资源（已废弃）
	-- Timers:CreateTimer(30,function()
	-- 	local units_kv = LoadKeyValues("scripts/npc/npc_units_custom.txt")
	-- 	for k, v in pairs(units_kv) do
	-- 		if k ~= "Version" and v["Model"] then
	-- 			PrecacheResource( "model",  v["Model"], context)
	-- 		end
	-- 	end
	-- 	for i=1,5 do
	-- 		for k,v in pairs(_G.chess_list_by_mana[i]) do
	-- 			PrecacheAUnit(k,v)
	-- 			PrecacheAUnit(k,v..'1')
	-- 			PrecacheAUnit(k,v..'11')
	-- 		end
	-- 	end
	-- 	for i=1,5 do
	-- 		for k,v in pairs(_G.chess_list_by_mana_black[i]) do
	-- 			PrecacheAUnit(k,v)
	-- 			PrecacheAUnit(k,v..'1')
	-- 			PrecacheAUnit(k,v..'11')
	-- 		end
	-- 	end
	-- 	for k,v in pairs(_G.chess_list_by_mana_gold) do
	-- 		PrecacheAUnit(k,v)
	-- 		PrecacheAUnit(k,v..'1')
	-- 		PrecacheAUnit(k,v..'11')
	-- 	end
	-- end)
end

--断线
function DAC:OnPlayerDisconnect(keys)
	if IsServer() then
		local hero = PlayerId2Hero(keys.PlayerID)
		if hero == nil then
			return
		end
		hero.isDisconnected = true
		_G.connect_state[keys.PlayerID] = false
		CustomNetTables:SetTableValue( "dac_table", "disconnect", 
			{ 
				table = _G.connect_state,
				hehe = RandomInt(1,100000)
			} 
		)

		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_disconnect",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})

		-- CustomGameEventManager:Send_ServerToAllClients("player_disconnect",{
		-- 	disconnectid = keys.PlayerID
		-- })
	end
end
function DAC:OnSuggestLiuju(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)

	if hero == nil then
		return
	end

	if _G.battle_round > 3 then
		return
	end

	if keys.player_id ~= keys.PlayerID then
		hero.is_banned = true
		return
	end

	if hero == nil or hero:IsNull() == true then
		return
	end
	if hero.isSuggestLiuju == nil then
		
		hero.isSuggestLiuju = true

		--更新流局人数
		local liuju_player_count = 0
		for _,h in pairs(_G.hero) do
			if h == nil or h:IsNull() == true or h:IsAlive() == false or h.isDisconnected == true or h.isSuggestLiuju == true then
				if h.is_top_3 ~= nil then
					liuju_player_count = liuju_player_count + 2
				else
					liuju_player_count = liuju_player_count + 1
				end
			end
		end

		local half_player_count = math.ceil(_G.playing_player_count/2)
		if liuju_player_count > half_player_count then
			liuju_player_count = half_player_count
		end

		if hero.steam_id ~= nil then
			prt(_G.steamid2name[hero.steam_id]..' SUGGESTED END GAME. ('..liuju_player_count..'/'..half_player_count..')')
		end

		-- for team_i=6,13 do
		-- 	CustomGameEventManager:Send_ServerToTeam(team_i,"update_liuju",{
		-- 		key = GetClientKey(team_i),
		-- 		count = liuju_player_count,
		-- 		total = math.ceil(_G.playing_player_count/2),
		-- 		hehe = RandomInt(1,100000) 
		-- 	})
		-- end
	
		if liuju_player_count >= math.ceil(_G.playing_player_count/2) then
			--流局
			prt('#txt_liuju_go')
			--EmitGlobalSound("Frostivus.PointScored.Enemy")
			EmitGlobalSound("dac.liuju")
			_G.is_game_ended = true
			prt('GAME OVER')
			PostGame()
			Timers:CreateTimer(3,function()
				GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)
			end)
			return
		end
	end
end
function DAC:OnEntityKilled(keys)
	local u = EntIndexToHScript(keys.entindex_killed)
	local attacker = nil
	if keys.entindex_attacker ~= nil then
		attacker = EntIndexToHScript(keys.entindex_attacker)
		attacker = attacker.damage_owner or attacker
	end
	
	if u == nil or u:IsNull() == true then
		return
	end
	if u:IsHero() == true then
		return
	end
	if u:GetUnitName() == "invisible_unit" then
		return
	end
	if u:GetUnitName() == "enemy_bomb" then
		return
	end
	if u:GetUnitName() == "player_image" then
		return
	end
	if u:GetUnitName() == "cheer_courier" then
		return
	end
	if u:GetUnitName() == "gemtd_pet" then
		return
	end
	if u:GetUnitName() == "mango_tree" then
		return
	end
	if u:GetUnitName() == "great_vault" then
		return
	end

	RemoveInvisibleUnitTable(u)
	

	if _G.game_status == 2 then
		--战斗阶段
		if u.team_id == 4 and string.find(u:GetUnitName(),'pve') ~= nil and u.is_summoned ~= true then  
		    --pve敌人掉宝
			DropItem(u)
			--pve敌人击杀者得钱
			local drop_money = GetHitDamage(u)
			if TeamId2Hero(u.at_team_id) ~= nil then
				AddMana(TeamId2Hero(u.at_team_id), drop_money, false)
				AddTotalMoneyStat(TeamId2Hero(u.at_team_id):GetPlayerID(), drop_money)
				AMHC:CreateNumberEffect(u,drop_money,3,AMHC.MSG_MISS,{255,255,0},0)
				AMHC:CreateParticle("particles/generic_gameplay/rune_bounty_owner.vpcf",PATTACH_OVERHEAD_FOLLOW,false,u,5)
			end
		end
		local xx = Vector2X(u:GetAbsOrigin(),u.at_team_id or u.team_id)
		local yy = Vector2Y(u:GetAbsOrigin(),u.at_team_id or u.team_id)

		if u.is_evolving ~= true and u.transforming ~= true then
			if u.at_team_id ~= nil or u.team_id ~= nil then
				if u.y_x ~= nil then
					_G.unit[u.at_team_id or u.team_id][u.y_x] = nil
				end
			end
		end
		RemoveFromToBeDestroyList(u)
		
		--龙骑士的龙阵亡，变换模型（因为龙模型没有死亡动画）
		if u:GetUnitName() == "chess_dk_dragon" or u:GetUnitName() == "chess_dk1_dragon" or u:GetUnitName() == "chess_dk11_dragon" then
			u:SetOriginalModel("models/heroes/dragon_knight/dragon_knight.vmdl")
			u:SetModel("models/heroes/dragon_knight/dragon_knight.vmdl")
		end
		--进坟场
		if u:HasAbility('is_ward') == false and u.no_death_rattle ~= true then
			local chess_name = u:GetUnitName()
			if _G.chess_transform_list[chess_name] ~= nil then
				chess_name = _G.chess_transform_list[chess_name]
			end

			local chess_base_name = GetChessBaseName(chess_name)
			AddChess2DeadChessList({
				at_team_id = u.at_team_id or u.team_id,
				chess_base_name = chess_base_name,
				items = GetAllItemsInUnits({[1] = u}),
				level = u:GetLevel(),
			})
		end
		if IsUnitExist(attacker) then

			RefreshAssassinJump({
				caster = attacker
			})

			--蓝猫/火猫/土猫/紫猫 击杀重置cd
			if IsUnitExist(attacker) and GetChessAbility(attacker) == 'storm_spirit_ball_lightning_datadriven' or GetChessAbility(attacker) == 'sleight_of_fist_datadriven' or GetChessAbility(attacker) == 'earth_rock_roll' or GetChessAbility(attacker) == 'void_astralstep' then
				local a = GetChessAbility(attacker)
				if attacker:FindAbilityByName(a) ~= nil then
					attacker:FindAbilityByName(a):EndCooldown()
				end
			end

			--赏金猎人 击杀获得赏金
			if IsUnitExist(attacker) and attacker:HasAbility('bh_shuriken') == true and attacker.bh_gold == nil and attacker:GetTeam() ~= 4 and string.find(u:GetUnitName(),'pve') == nil then
				attacker.bh_gold = 1
				local v_chess = Unit2VChess(attacker)
				if v_chess ~= nil then
					v_chess['bh_gold'] = 1
				end
				attacker:RemoveModifierByName('modifier_bh_gold')
				local money = attacker:GetLevel()
				DropMoneyBag(u:GetAbsOrigin(), u:GetAbsOrigin(), 300, money, 200)
				-- AddTrackMoneyCount(attacker,1)
			end
		end

		if u.no_death_rattle then
			return
		end

		--亡语
		DeathRattle(u,attacker)

		if u.team_id ~= 4 then
			SaveItem(u.team_id,u:entindex())
		end

		if u.at_team_id ~= nil then
			if string.find(u:GetUnitName(),'pve') == nil then
				AddStat(TeamId2Hero(u.at_team_id):GetPlayerID(),'kills')
			end
		end
	end
	

	if IsUnitExist(attacker) == false then
		return
	end
	-- if string.find(attacker:GetUnitName(),'pve') ~= nil then
	-- 	return
	-- end
	-- if string.find(u:GetUnitName(),'pve') ~= nil then
	-- 	return
	-- end

	--连杀数
	if attacker.killing_spree_time == nil or GameRules:GetGameTime() - attacker.killing_spree_time < 3 then
		attacker.killing_spree_time = GameRules:GetGameTime()
		-- +1
		if attacker.killing_spree_count == nil then
			attacker.killing_spree_count = 1
		else
			attacker.killing_spree_count = attacker.killing_spree_count + 1
		end
	else
		-- =1
		attacker.killing_spree_time = GameRules:GetGameTime()
		attacker.killing_spree_count = 1
	end

	if attacker.killing_spree_count == 3 then
		--三杀
		play_particle("effect/3sha/vr_killbanner_triplekill.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,5)
		EmitSoundOn("announcer_killing_spree_announcer_kill_triple_01",attacker)
	end
	if attacker.killing_spree_count == 5 then
		--暴走
		play_particle("effect/5sha/vr_killbanner_rampage.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,5)
		EmitSoundOn("announcer_killing_spree_announcer_kill_rampage_01",attacker)

		attacker.is_baozou = true

		if attacker.team_id == 4 then
			if attacker.from_team_id ~= nil then
				ShowCombat({
					t = 'killing_spree_5_creep',
					player = _G.team2playerid[attacker.from_team_id],
					text = attacker:GetUnitName(),
					hero = 'npc_dota_hero_wisp',
				})
			else
				ShowCombat({
					t = 'killing_spree_5_creep',
					player = _G.team2playerid[4],
					text = attacker:GetUnitName(),
					hero = 'npc_dota_hero_wisp',
				})
			end
		else
			ShowCombat({
				t = 'killing_spree_5',
				player = _G.team2playerid[attacker.from_team_id or attacker.team_id],
				text = attacker:GetUnitName(),
				hero = 'npc_dota_hero_wisp',
			})
		end
	end 

	if attacker.killing_spree_count > 5 then
		local chess_team = attacker.team_id
		if chess_team == 4 then
			if attacker.from_team_id ~= nil then
				chess_team = attacker.from_team_id
			else
				chess_team = nil
			end
		end
		if _G.egg_quest == 'q005' and chess_team ~= nil then
			SetQuest(chess_team,true)
		end
		--暴走
		play_particle("effect/5sha/vr_killbanner_rampage.vpcf",PATTACH_OVERHEAD_FOLLOW,attacker,5)
		EmitSoundOn("announcer_killing_spree_announcer_kill_rampage_01",attacker)
	end
end
function DAC:OnRequestBuyChess(keys)
	local buy_index = keys.buy_index

	local team_id = _G.playerid2team[keys.PlayerID]
	local h = TeamId2Hero(team_id)
	if _G.team2playerid == nil or _G.team2playerid[team_id] == nil or PlayerResource:GetPlayer(_G.team2playerid[team_id]) == nil then
		return
	end
	if h == nil or h:IsNull() == true or h:IsAlive() == false or h.curr_chess_table == nil or h.curr_chess_table[buy_index] == nil then
		return
	end

	local chess = h.curr_chess_table[buy_index].chess
	local price = h.curr_chess_table[buy_index].price

	--判断能不能买得起
	if price > h:GetMana() then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_no_mana"
		})
		return
	end

	--判断手牌里是否有两个一样的，有的话直接合成
	local have_exist_count,chess1,chess2,chess3 = Find2SameChessInHandOrOnBoard(h,chess)

	--寻找手牌空位
	local index = FindEmptyHandSlot(team_id)
	if index == nil and have_exist_count < 2 and h.is_auto_combine == 1 then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_hand_full"
		})
		return
	end
	if index == nil and h.is_auto_combine ~= 1 then
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_hand_full"
		})
		return
	end

	CustomGameEventManager:Send_ServerToTeam(team_id,"request_buy_chess_cb",{
		key = GetClientKey(team_id),
		buy_index = buy_index,
	})

	if chess == 'chess_io' then
		--小精灵发弹幕
		CustomGameEventManager:Send_ServerToAllClients("bullet",{
			player_id = h:GetPlayerID(),
			win_streak = h.win_streak or 0,
			vip = h.is_vip,
			target = chess,
		})
	end

	--验证完毕，可以购买
	h.curr_chess_table[buy_index] = nil
	CostMana(h,price)

	--直接合成一个2星的 或者 添加一个1星的
	local have_exist_count,chess1,chess2 = Find2SameChessInHandOrOnBoard(h,chess)
	if have_exist_count >= 2 and chess1 ~= nil and chess2 ~= nil and h.is_auto_combine == 1 then
		-- CombineChessPlus({[1] = chess1,[2] = chess2},(chess..'1'))
		-- local advanve_chess = chess..'1'
		-- local advanve_have_exist_count,advanve_chess1,advanve_chess2 = Find2SameChessInHandOrOnBoard(h,advanve_chess)
		-- if advanve_have_exist_count >= 2 then
		-- 	CombineChessPlus({[1] = chess1,[2] = chess2,[3] = advanve_chess1,[4] = advanve_chess2},(chess..'11'))
		-- else
			CombineChessPlus({[1] = chess1,[2] = chess2},(chess..'1'))
		-- end
	else
		local x = CreateChessInHand(h,chess)
		x.buy_price = price
	end
end
function DAC:OnCancelPickChessPosition(keys)
	local caster = PlayerId2Hero(keys.PlayerID)

	if caster == nil or caster:IsNull() == true then
		return
	end

	CancelPickChess(caster)
end
function IsBattleTime()
	--判断现在是不是正在战斗的时间（不允许做战斗回合的操作）
	if GetTime().phase == GAME_PHASE_BATTLE then
		return true
	end
	if GetTime().phase == GAME_PHASE_PREPARE and (GetTime().left < 5 or GetTime().elapsed < 2) then
		return true
	end
	
	return false
end
function DAC:OnPickChessPosition(keys)
	local caster = PlayerId2Hero(keys.PlayerID)
	if caster == nil or caster:IsNull() == true then
		return
	end
	local picked_chess = caster.picked_chess
	if IsUnitExist(picked_chess) == false or picked_chess.is_removing == true then
		--picked_chess不存在
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_must_select_a_chess"
		})
		EmitSoundOn("General.CastFail_NoMana",keys.caster)
		if GetTime().phase == GAME_PHASE_PREPARE and GetTime().left > 5 then
			caster:FindAbilityByName('pick_chess'):SetActivated(true)
			caster:FindAbilityByName('recall_chess'):SetActivated(true)
		end
		return
	end
	if keys.player_id ~= keys.PlayerID then
		--防止伪造的假消息祸害他人
		caster.is_banned = true
		return
	end
	local target_pos = Vector(keys.x,keys.y,keys.z)

	local team_id = picked_chess.team_id
	CancelPickChess(caster)
	picked_chess.io_target = nil

	local origin_pos = nil
	if picked_chess.hand_index == nil then
		origin_pos = XY2Vector(picked_chess.x, picked_chess.y,team_id)
	else
		origin_pos = HandIndex2Vector(team_id, picked_chess.hand_index)
	end

	local chess_pos_type,x1,y1,_ = GetTargetPositionType(origin_pos, caster, team_id)
	local target_pos_type,x2,y2,target_chess = GetTargetPositionType(target_pos, caster, team_id)

	if chess_pos_type == 0 or target_pos_type == 0 or (target_pos_type == 3 and chess_pos_type == 2) then
		--无效地点
		return
	end
	if x1 == x2 and y1 == y2 then
		return
	end

	local blink_duration = 0
	if target_pos_type == 3 and target_chess ~= nil then
		if IsSpecialChess(GetChessBaseName(picked_chess:GetUnitName())) == true or (FindValueInTable(_G.chess_list_by_mana[5],GetChessBaseName(picked_chess:GetUnitName())) == false and FindValueInTable(_G.chess_list_by_mana_gold,GetChessBaseName(picked_chess:GetUnitName())) == true) then
			CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
				key = GetClientKey(caster:GetTeam()),
				text = "text_mima_egg_unavailable",
			})
			return
		else
			--把棋子picked_chess丢进蛋巢target_chess
			BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
			RemoveChessFromHand(picked_chess,caster)
			local blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })

			Timers:CreateTimer(blink_duration,function()
				target_chess.egg_chess = GetChessBaseName(picked_chess:GetUnitName())
				local star = GetChessStar(picked_chess) or 1

				if star == 1 then
					target_chess.egg_chess_count = 1
				elseif star == 2 then
					target_chess.egg_chess_count = 3
				elseif star == 3 then
					target_chess.egg_chess_count = 9
				end

				if RandomInt(1,100) <= 60 and FindChessCountInChessPool(target_chess.egg_chess) > 0 then
					target_chess.egg_chess_count = target_chess.egg_chess_count + 1
					RemoveChessFromChessPool(target_chess.egg_chess)
					-- CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
					-- 	unit_index = target_chess:entindex(),
					-- 	text = '+1',
					-- })
				end

				if target_chess.egg_chess_count > 9 then
					target_chess.egg_chess_count = 9
				end

				CustomNetTables:SetTableValue( "unit_table", 'egg_'..target_chess:entindex(), {
					chess = target_chess.egg_chess,
					count = target_chess.egg_chess_count,
				})

				target_chess:SetOriginalModel('models/egg.vmdl')
				target_chess:SetModel('models/egg.vmdl')
				target_chess:SetModelScale(1.3)
				local scale = target_chess.egg_chess_count
				AddModelScalePlus(target_chess, 1.4+scale*0.2)
				target_chess:SetBaseMaxHealth(9)
				target_chess:SetMaxHealth(9)
				target_chess:SetHealth(scale)
				AddAbilityAndSetLevel(target_chess,'no_hp_add')
				picked_chess.buy_price = 0

				--装备掉出来
				for slot=0,9 do
					if picked_chess:GetItemInSlot(slot)~= nil then
						local name = picked_chess:GetItemInSlot(slot):GetAbilityName()
						local charges = picked_chess:GetItemInSlot(slot):GetCurrentCharges()
						if picked_chess:GetItemInSlot(slot):IsPermanent() == false then
							for i=1,charges do
								if name ~= nil and name ~= 'item_null' then
									if name == 'item_silingshu_2' or name == 'item_silingshu_3' then
										name = 'item_silingshu'
									end
									DropItemAppointed(caster,picked_chess,name)
								end
							end
						else
							if name ~= nil and name ~= 'item_null' then
								if name == 'item_silingshu_2' or name == 'item_silingshu_3' then
									name = 'item_silingshu'
								end
								DropItemAppointed(caster,picked_chess,name)
							end
						end
					end
				end
				RemoveChess({
					caster = caster,
					target = picked_chess,
					is_sell = false,
					force_remove = true,
				})
			end)
			return
		end
	end
	if chess_pos_type == 1 then
		--选中的棋子在手牌	
		if target_pos_type == 1 then
			--选中的棋子在手牌，目标位置在手牌
			RemoveChessFromHand(picked_chess,caster)
			if target_chess ~= nil then
				--目标位置有棋子target_chess，交换
				RemoveChessFromHand(target_chess,caster)
				AddChess2Hand(target_chess,x1,caster)
				BlinkChessX({ p = HandIndex2Vector(team_id,x1), caster = target_chess, set_forward = true, })
			end
			AddChess2Hand(picked_chess,x2,caster)
			blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
		elseif target_pos_type == 2 and IsBattleTime() == false then
			--选中的棋子在手牌，目标位置在场上
			if TeamId2Hero(team_id):HasModifier('modifier_item_conceal_prepare') or picked_chess:HasModifier('modifier_is_satyr') then
				ConcealOneChess(picked_chess)
			end
			if target_chess ~= nil then
				--目标位置有棋子target_chess，找个附近的空格子跳，不交换
				local closest_xy = GetClosestEmptyArea(x2,y2,team_id)
				if closest_xy ~= nil then
					x2 = closest_xy.x
					y2 = closest_xy.y
					RemoveChessFromHand(picked_chess,caster)
					AddChess2Board(picked_chess,x2,y2,caster)
					blink_duration = BlinkChessX({ p = XY2Vector(x2,y2,team_id), caster = picked_chess, set_forward = true, })
				end
				picked_chess.io_target_index = target_chess:entindex()
				-- RemoveChessFromBoard(target_chess,caster)
				-- AddChess2Hand(target_chess,x1,caster)
				-- BlinkChessX({ p = HandIndex2Vector(team_id,x1), caster = target_chess, set_forward = true, })
			else
				RemoveChessFromHand(picked_chess,caster)
				AddChess2Board(picked_chess,x2,y2,caster)
				blink_duration = BlinkChessX({ p = XY2Vector(x2,y2,team_id), caster = picked_chess, set_forward = true, })
			end
		end
	elseif chess_pos_type == 2 then
		--选中的棋子在场上
		if target_pos_type == 1 and IsBattleTime() == false then
			--选中的棋子在场上，目标位置在手牌
			if TeamId2Hero(team_id):HasModifier('modifier_item_conceal_prepare') or picked_chess:HasModifier('modifier_is_satyr') then
				RevealOneChess(picked_chess)
			end
			if target_chess ~= nil then
				--目标位置有棋子target_chess，找个附近的手牌位置跳，不交换
				local closest_empty_hand_index = GetClosestEmptyHandIndex(x2,team_id)
				if closest_empty_hand_index ~= nil then
					x2 = closest_empty_hand_index
					RemoveChessFromBoard(picked_chess,caster)
					AddChess2Hand(picked_chess,x2,caster)
					blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
				end
				-- RemoveChessFromHand(target_chess,caster)
				-- AddChess2Board(target_chess,x1,y1,caster)
				-- BlinkChessX({ p = XY2Vector(x1,y1,team_id), caster = target_chess, set_forward = true, })
			else
				RemoveChessFromBoard(picked_chess,caster)
				AddChess2Hand(picked_chess,x2,caster)
				blink_duration = BlinkChessX({ p = HandIndex2Vector(team_id,x2), caster = picked_chess, set_forward = true, })
			end
		elseif target_pos_type == 2 and IsBattleTime() == false then
			--选中的棋子在场上，目标位置在场上
			RemoveChessFromBoard(picked_chess,caster)
			if target_chess ~= nil then
				--目标位置有棋子target_chess，交换
				RemoveChessFromBoard(target_chess,caster)
				AddChess2Board(target_chess,x1,y1,caster)
				BlinkChessX({ p = XY2Vector(x1,y1,team_id), caster = target_chess, set_forward = true, })
				picked_chess.io_target_index = target_chess:entindex()
			end
			AddChess2Board(picked_chess,x2,y2,caster)
			blink_duration = BlinkChessX({ p = XY2Vector(x2,y2,team_id), caster = picked_chess, set_forward = true, })
		end
	end

	--统计场上羁绊
	StatClassCount(team_id)
	--同步ui人口
	CheckChess(team_id)
	CustomGameEventManager:Send_ServerToTeam(team_id,"population",{
		key = GetClientKey(team_id),
		max_count = _G.population_max[team_id],
		count = _G.population[team_id],
	})
	if blink_duration > 0 then
		if y2 == -1 then
			Timers:CreateTimer(blink_duration+0.1,function()
				if IsUnitExist(picked_chess) == true then
					TriggerCombineHand(caster,picked_chess:GetUnitName())
				end
			end)
		else
			Timers:CreateTimer(blink_duration+0.1,function()
				TriggerChessCombineAtGrid(x2,y2,team_id)
			end)
		end
	end
end
function DAC:OnPlayerChat(keys)
	-- print('===OnPlayerChat===')
	-- for k,v in pairs(keys) do
	-- 	print(k..' = '..v)
	-- end

	-- DeepPrintTable(_G.userid2player)

	local tokens = string.split(string.lower(keys.text))
	-- local player = _G.userid2player[keys.userid]
	-- local player_entity = EntIndexToHScript(player)
	-- local player_id = player_entity:GetPlayerID()
	local player_id = keys.playerid
	local team_id = _G.playerid2team[player_id] or 1
	if team_id == 1 then
		prt((PlayerResource:GetPlayerName(player_id) or '')..': '..(tokens[1]or ''))
		return
	end

	-- local hero = player_entity:GetAssignedHero()
	local hero = PlayerId2Hero(player_id)
	if hero == nil then
		return
	end
	local heroindex = hero:GetEntityIndex()
	local team = hero:GetTeam()
	

	if (
		tokens[1] == "-lvlup" or
		tokens[1] == "-createhero" or
		tokens[1] == "-item" or
		tokens[1] == "-refresh" or
		tokens[1] == "-startgame" or 
		tokens[1] == "-killcreeps" or
		tokens[1] == "-wtf" or 
		tokens[1] == "-disablecreepspawn" or
		tokens[1] == "-gold" or 
		tokens[1] == "-lvlup" or
		tokens[1] == "-refresh" or
		tokens[1] == "-respawn" or
		tokens[1] == "dota_create_unit" or 
		tokens[1] == "-teleport" or 
		tokens[1] == "-ggsimida"
		) then
		if IsUnitExist(hero) == true then
			KillSelfTeam(team)
		end
		return
	end
	if string.find(keys.text,"^%w%w%w%w%w%p%w%w%w%w%w%p%w%w%w%w%w$") ~= nil then
		local key = string.upper(keys.text)
		local steamid = EntIndexToHScript(heroindex).steam_id
		CustomNetTables:SetTableValue( "dac_table", "cdkey", {
			player_id = player,
			steam_id = steamid,
			text = key,
			hehe = RandomInt(1,10000)
		})
		return
	end
	if tokens[1] == '-tp' then
		DAC:OnCourierTP({
			PlayerID = hero:GetPlayerID()
		})
		-- local p = Entities:FindByName(nil,'center'..(team-6)):GetAbsOrigin()
		-- FindClearSpaceForUnit(hero,p,true)
	end
	-- if tokens[1] == '-cp' and _G.myself == true then
	-- 	CourierCP(hero,hero)
	-- end

	--测试命令
	if string.find(keys.text,"^e%w%w%w$") ~= nil and _G.myself == true then
		if hero.effect ~= nil then
			hero:RemoveAbility(hero.effect)
			hero:RemoveModifierByName('modifier_texiao_star')
		end
		hero:AddAbility(keys.text)
		hero:FindAbilityByName(keys.text):SetLevel(1)
		hero.effect = keys.text
	end

	if (tokens[1] == '-crab' or tokens[1] == '-chess') and _G.myself == true then
		combat('TEST CODE: +CHESSES')
		if tokens[2] ~= nil and tokens[3] == nil then
			_G.next_crab = 'chess_'..tokens[2]
			prt(_G.next_crab)
			for i=1,3 do
				local x = nil
				local this_chess = nil
				if i == 1 then
					this_chess = _G.next_crab
				elseif i == 2 then
					this_chess = _G.next_crab..'1'
				elseif i == 3 then
					this_chess = _G.next_crab..'11'
				end
				CreateChessInHand(hero,this_chess)
			end
			_G.next_crab = nil
		else
			local u_index = 2
			while tokens[u_index] ~= nil and u_index <= 9 do
				CreateChessInHand(hero,'chess_'..tokens[u_index])
				u_index = u_index + 1
			end
			_G.next_crab = nil
		end
	end
	if (tokens[1] == '-c') and _G.myself == true then
		combat('TEST CODE: +CHESSES')
		if tokens[2] ~= nil and tokens[3] == nil then
			_G.next_crab = tokens[2]
			prt(_G.next_crab)
			CreateChessInHand(hero,_G.next_crab)
			_G.next_crab = nil
		else
			local u_index = 2
			while tokens[u_index] ~= nil and u_index <= 9 do
				CreateChessInHand(hero,tokens[u_index])
				u_index = u_index + 1
			end
			_G.next_crab = nil
		end
	end
	if tokens[1] == '-lua' and _G.myself == true then
		local f1 = GetFrameCount()
		Timers:CreateTimer(1,function()
			local f2 = GetFrameCount()
			local fps = f2-f1
			local memory = math.floor(collectgarbage("count")/1000)
			local entities_table = Entities:FindAllInSphere(Vector(0,0,0), 99999.9)
			local entities = table.maxn(entities_table)
			prt('Lua内存: '..memory..'M, 实体数量:'..entities..', 每秒帧数:'..fps)
			-- CustomGameEventManager:Send_ServerToAllClients("show_lua_ping",{
			-- 	fps = fps,
			-- 	memory = memory,
			-- 	entities = entities,
			-- })

			print('entities============='..entities)
			for _,u in pairs(entities_table) do
				print(u:GetClassname())
			end
		end)
	end
	if tokens[1] == '-timers' and _G.myself == true then
		Timers:CreateTimer(function()
			local count = 0
			for _,t in pairs(Timers.timers) do
				count = count + 1
			end
			prt('Timers总计：'..count..'个')
		end)
	end
	if (tokens[1] == '-drop' or tokens[1] == '-item') and _G.myself == true then
		local u_index = 2
		combat('TEST CODE: +ITEM')
		-- while tokens[u_index] ~= nil and u_index <= 9 do
			local i = 'item_'..tokens[u_index]
			local newItem = CreateItem( i, hero, hero )
			local drop = CreateItemOnPositionForLaunch(hero:GetAbsOrigin(), newItem )
			local dropRadius = RandomFloat( 50, 200 )
			newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, hero:GetAbsOrigin()+RandomVector(dropRadius))
		-- end
	end
	if tokens[1] == '-removeitem' and _G.myself == true then
		for i=0,16 do
			if hero:GetItemInSlot(i) then
				hero:RemoveItem(hero:GetItemInSlot(i))
			end
		end
	end
	if (tokens[1] == "-choose" or tokens[1] == '-round') and _G.myself == true then
		DAC:OnTesterBoxChooseRound({ round = tonumber(tokens[2])})
	end
	if (tokens[1] == '-mana' or tokens[1] == '-money') and _G.myself == true then
		DAC:OnTesterBoxGiveMoney({ PlayerID = hero:GetPlayerID(), money = tonumber(tokens[2] or 100) })
	end
	if tokens[1] == '-exp' and _G.myself == true then
		local exp = tonumber(tokens[2] or 9999) 
		combat('TEST CODE: +'..exp..' EXP')
		ExpBook({
			caster = hero,
			xpadd = exp,
			cost = 0,
		})
	end
	
	if tokens[1] == '-ws' and _G.myself == true then
		local win_count = tonumber(tokens[2] or '1')
		combat('TEST CODE: +'..win_count..' WIN STREAK')
		for i=1,win_count do
			AddWinStreak(hero:GetTeam())
		end
	end
	if tokens[1] == "-a" and _G.myself == true then
		local level = tonumber(tokens[3]) or 3
		local aaa = tokens[2] or 'nec_ssr_scythe'
		combat('TEST CODE: +ABILITY '..aaa..', LEVEL = '..level)
		hero:AddAbility(aaa)
		hero:FindAbilityByName(aaa):SetLevel(level)
	end
	if (tokens[1] == "-effect" or tokens[1] == "-e") and _G.myself == true then
		combat('TEST CODE: +EFFECT '..tokens[2])
		play_particle(tokens[2],PATTACH_ABSORIGIN_FOLLOW,hero,10)
		return
	end
	if tokens[1] == "-hero" and _G.myself == true then
		--装饰信使
		SetCourier(hero, tokens[2], 'e000')

		hero.onduty_hero = tokens[2]
		hero.courier_name = tokens[2]
		combat('TEST CODE: COURIER = '..tokens[2])
		RemoveAbilityAndModifier(hero,'courier_fly')
		if hero.flyup_effect ~= nil then
			ParticleManager:DestroyParticle(hero.flyup_effect,true)
		end
	end
	if tokens[1] == "-size" and _G.myself == true then
		hero.init_model_scale = tokens[2]+0
		hero:SetModelScale(hero.init_model_scale)
		combat('TEST CODE: COURIER SIZE = '..tokens[2])
	end
	if tokens[1] == "-crown" and _G.myself == true then
		local crown_level = tonumber(tokens[2] or 1)
		combat('TEST CODE: CROWN = '..crown_level)
		hero.is_crown = true
		ShowCrown(hero,crown_level)
	end
	if tokens[1] == "-miss" and _G.myself == true then
		combat('TEST CODE: MISS')
		ShowMiss({caster = hero})
	end
	if tokens[1] == "-fish" and _G.myself == true then
		combat('TEST CODE: FISH')
		Fish(hero)
	end
	if tokens[1] == "-ci" and _G.myself == true then
		combat('TEST CODE: FIND COMBINE ITEM')
		FindCombinableItemByCourier(hero)
	end

	
	if tokens[1] == "-2p" and _G.myself == true then
		_G.p2_mode = true
		combat('TEST CODE: 2P MODE')
		SetP2Team(6,1)
		SetP2Team(7,1)
		SetP2Team(8,2)
		SetP2Team(9,2)
		SetP2Team(10,3)
		SetP2Team(11,3)
		SetP2Team(12,4)
		SetP2Team(13,4)
	end
	if tokens[1] == "-1p" and _G.myself == true then
		_G.p2_mode = false
		combat('TEST CODE: 1P MODE')
		SetP2Team(6,1)
		SetP2Team(7,1)
		SetP2Team(8,2)
		SetP2Team(9,2)
		SetP2Team(10,3)
		SetP2Team(11,3)
		SetP2Team(12,4)
		SetP2Team(13,4)
	end
	if tokens[1] == '-damage' and GetPlayingPlayerCount() == 1 then
		DAC:OnTesterBoxShowDamage({ is_show_damage = 1 })
	end
	if tokens[1] == '-undamage' and GetPlayingPlayerCount() == 1 then
		DAC:OnTesterBoxShowDamage({ is_show_damage = 0 })
	end
	if tokens[1] == '-debug' and _G.myself == true then
		combat('TEST CODE: DEBUG ON!')
		_G.is_debug = true
	end
	if tokens[1] == '-gaussrandom' and _G.myself == true then
		for i = 1,100 do
			local ran = GaussRandom()
		end
	end
	if tokens[1] == '-undebug' and _G.myself == true then
		combat('TEST CODE: DEBUG OFF!')
		_G.is_debug = false
	end
	if tokens[1] == '-pause' and _G.myself == true then
		PauseGame(not GameRules:IsGamePaused())
	end
	if tokens[1] == '-star' and _G.myself == true then
		ShowStarsOnAllChess(hero:GetTeam())
	end
	if tokens[1] == '-cele' and _G.myself == true then
		Celebrate(hero)
	end
	-- if tokens[1] == '-export' and _G.myself == true then
	-- 	DAC:RequestExportLineup({
	-- 		PlayerID = player_id,
	-- 	})
	-- end
	-- if tokens[1] == '-import' and _G.myself == true then
	-- 	DAC:RequestImportLineup({
	-- 		PlayerID = player_id,
	-- 		data = string.upper(tokens[2]) or '',
	-- 	})
	-- end
	if (tokens[1] == "-animation" or tokens[1] == "-n") and _G.myself == true then
		combat('TEST CODE: +ANIMATION '..tokens[2])
		hero.animation = tokens[2] or 'n000'
		return
	end

	-- if tokens[1] == '-test_wangchongtui' and _G.myself == true then
	-- 	hero.wangchongtui = SpawnEntityFromTableSynchronous('prop_dynamic',{model="models/props_gameplay/item_spider_legs.vmdl",DefaultAnim=ACT_DOTA_RUN})
	-- 	-- hero.wangchongtui:FollowEntity(hero,true)
	-- 	hero.wangchongtui:SetAbsOrigin(hero:GetAbsOrigin())
	-- 	hero.wangchongtui:SetForwardVector(hero:GetForwardVector())
	-- 	-- hero.wangchongtui:StartGesture(ACT_DOTA_RUN)
	-- end
	if tokens[1] == '-test' and _G.myself == true then
		hero.last_lose_lineup = {'chess_sk','chess_pom','chess_pom','chess_pom','chess_pom','chess_pb'}
	end
	if tokens[1] == '-makebug' and _G.myself == true then
		ParticleManager:DestroyParticle(nil,true)
	end
	if tokens[1] == '-makebug2' and _G.myself == true then
		_G.stat_info = json.decode(nil)
	end

	if tokens[1] == '-test_end' and _G.myself == true then
		SetPlayerDead(hero)
		-- _G.stat_info = json.decode('{"76561198090931971":{"mmr_level":15,"zhugong_model":"models/bilibilitv/model/tv.vmdl","lose_round":0,"hp":0,"win_round":0,"round":1,"hero_level":0,"chess_lineup":"chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_tiny,chess_troll,chess_huskar11,","player_id":0,"duration":11.233161926269531,"p2team":1,"hero_damage":0,"is_vip":1,"kills":0,"is_author":1,"buff":"is_warrior:1,is_element:1,","zhugong":"h341","deaths":0,"gold":1,"candy":0,"biscuit":1,"zhugong_effect":"e000","draw_round":0,"steamid":"76561198090931971"},"76561198101849234":{"mmr_level":15,"zhugong_model":"models/bilibilitv/model/tv.vmdl","lose_round":0,"hp":0,"win_round":0,"round":1,"hero_level":0,"chess_lineup":"chess_tiny,","player_id":0,"duration":11.233161926269531,"p2team":1,"hero_damage":0,"is_vip":1,"kills":0,"is_author":1,"buff":"is_warrior:1,is_element:1,","zhugong":"h341","deaths":0,"gold":1,"biscuit":0,"candy":12,"zhugong_effect":"e000","draw_round":0,"steamid":"76561198101849234"}}')
		-- PostGame()
		-- combat('TEST CODE: END GAME!')

		-- _G.is_game_ended = true
		-- combat('GAME OVER')

		-- Timers:CreateTimer(3,function()
		-- 	GameRules:SetGameWinner(DOTA_TEAM_BADGUYS)	
		-- end)
	end
	if tokens[1] == '-test_dropmoney' and _G.myself == true then
		combat('TEST CODE: DROP MONEY x'..( tonumber(tokens[2]) or 1 ))

		DropMoneyBag(hero:GetAbsOrigin(), hero:GetAbsOrigin(), 300, ( tonumber(tokens[2]) or 1 ))
	end
	if tokens[1] == '-test_cheer' and _G.myself == true then
		-- local cheer_index = tonumber(tokens[2]) or FindAvailableCheerIndex(hero:GetTeam())
		-- local courier_name = tokens[3] or RandomACourierFromCourierTable(hero:GetTeam())
		-- if courier_id ~= nil then
		-- 	prt('TEST CODE: CHEER COURIER at '..cheer_index..' --> '..courier_id)
		-- 	SpawnCheerCourier(hero:GetTeam(), cheer_index, courier_name)
		-- else
		-- 	prt('TEST CODE: NO AVAILABLE CHEER COURIER!')
		-- end
		combat('TEST CODE: CHEER COURIER')
		SummonCheerCourier(hero:GetTeam(), tonumber(tokens[2]) or 1)
	end

	if tokens[1] == '-remove_cheer' and _G.myself == true then
		combat('TEST CODE: REMOVE CHEER COURIER')
		RemoveCheerCourier(hero:GetTeam(), tonumber(tokens[2]) or nil)
	end

	if tokens[1] == '-test_cheer_bubble' and _G.myself == true then
		combat('TEST CODE: CHEER COURIER BUBBLE')
		-- local cheer_courier = GetCheerCourier(hero:GetTeam())
		-- CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
		-- 	unit_index = cheer_courier:entindex(),
		-- 	text = "hahahaha",
		-- })
		SayCheerBubble(hero:GetTeam())
	end

	if tokens[1] == '-show_cheer' and _G.myself == true then
		combat('TEST CODE: SHOW COURIER('..table.maxn(hero.courier_table or {})..')')
		print('--------------------------------------')
		print('COURIER('..table.maxn(hero.courier_table or {})..')')
		if hero.courier_table ~= nil then
			for _,v in pairs(hero.courier_table) do
				print(v)
			end
		end
		print('--------------------------------------')
		print('CHEER COURIER')
		if hero.cheer_courier_list ~= nil then
			for i,v in pairs(hero.cheer_courier_list) do
				print('['..i..'] = '..v.courier_name)
			end
		end
		print('--------------------------------------')
	end

	-- if tokens[1] == '-test_guancaiben' and _G.myself == true then
	-- 	local try_count = 0
	-- 	local alive_player_count = GetAlivePlayerCount()
	-- 	local guancai_money = math.floor(hero:GetMana()*(alive_player_count*10)/100)
	-- 	local lucky_team_table = {
	-- 		[6] = 0,
	-- 		[7] = 0,
	-- 		[8] = 0,
	-- 		[9] = 0,
	-- 		[10] = 0,
	-- 		[11] = 0,
	-- 		[12] = 0,
	-- 		[13] = 0,
	-- 	}
	-- 	local money_left = ( tonumber(tokens[2]) or 100 )
	-- 	while try_count < 10000 and money_left > 0 do 
	-- 		local random_team = RandomInt(6,13)
	-- 		local h = TeamId2Hero(random_team)
	-- 		if h ~= nil and h:IsAlive() == true then --and random_team ~= hero:GetTeam() then
	-- 			lucky_team_table[random_team] = lucky_team_table[random_team] + 1
	-- 			money_left = money_left - 1
	-- 		end
	-- 		try_count = try_count + 1
	-- 	end

	-- 	for t,count in pairs(lucky_team_table) do
	-- 		local position_to = CenterVector(t) + Vector(RandomInt(-512,512),RandomInt(-512,512),0)
	-- 		DropMoneyBag(hero:GetAbsOrigin(), position_to, 300, ( count or 1 ))
	-- 	end 
	-- end
	if tokens[1] == '-test_gameover' and _G.myself == true then
		CustomGameEventManager:Send_ServerToTeam(team,"show_gameover",{
			rank = 1,
			key = GetClientKey(team),
			candy = 10,
			biscuit = 1,
			quest_id = 'q001',
			quest_status = true,
			exp_info = {
				user='76561198090931971',
				courier= 'h239',
				exp_old= 29.5,
				exp_new= 30,
				level_old = 29,
				level_new = 30,
				level_delta = 1,
			},
			hehe = RandomInt(1,100000) 
		})
	end
	if tokens[1] == '-test_legendary' and _G.myself == true then
		combat('TEST LEGENDARY')
		CustomGameEventManager:Send_ServerToAllClients("test_legendary",{
			hehe = RandomInt(1,10000)
		})
	end
	
	if tokens[1] == '-skin' and _G.myself == true then
		hero:SetSkin(tonumber(tokens[2]))
		combat('TEST CODE: COURIER SKIN = '..tokens[2])
	end
	if tokens[1] == '-setting' and _G.myself == true then
		combat(json.encode(_G.user_setting))
	end
	if tokens[1] == '-big_damage' and _G.myself == true then
		combat('TEST CODE: BIG DAMAGE x '..tokens[2])
		_G.big_damage = tonumber(tokens[2])
	end
	if tokens[1] == '-popup_box' and _G.myself == true then
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_popup_box",{
			key = GetClientKey(hero:GetTeam()),
			round = _G.battle_round,
		})
	end
	if tokens[1] == '-test_worldpanel' and _G.myself == true then
		combat('TEST CODE: TEST WORLDPANEL')
		UpdatePlayerWorldPanel({
			[6] = { steam_id = hero.steam_id, oppo_steam_id = '76561198101849234' },
		})
	end
	if tokens[1] == '-go' and _G.myself == true then
		DAC:OnTesterBoxStartBattle({PlayerID = player_id})
	end
	if tokens[1] == '-pj' and _G.myself == true then
		local pj_model = nil
		local pj = nil
		if #tokens[2] == 4 then
			pj_model = _G.projectile_list[tokens[2] or 'p000']['effect']
			pj = tokens[2]
			hero.projectile = pj
			combat('TEST PROJECTILE: '..pj..' ('..pj_model..')')
		else
			pj_model = tokens[2]
			combat('TEST PROJECTILE: '..pj_model)
		end
		PreviewProjectile(hero,pj,pj_model)
	end

	if tokens[1] == '-line' and _G.myself == true then
		-- create projectile
		local uu = CreateUnitByName("invisible_unit", Entities:FindByName(nil,"center"..hero:GetPlayerID()):GetAbsOrigin()+Vector(0,128*5,256)+RandomVector(128) ,false,nil,nil, hero:GetTeam()) 

		Timers:CreateTimer(10,function()
			uu:ForceKill(false)
			uu:Destroy()
		end)

		local info = {
			Source = uu,
			Ability = nil,
			EffectName = tokens[2],
			vSpawnOrigin = uu:GetOrigin(),
			fDistance = 1000,
			vVelocity = (hero:GetAbsOrigin()-uu:GetAbsOrigin()):Normalized() * 500,
			fStartRadius = 100,
			fEndRadius = 200,
			iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
			iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_SPELL_IMMUNE_ENEMIES,
			iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
			bReplaceExisting = false,
			bProvidesVision = false,
		}
		ProjectileManager:CreateLinearProjectile( info )
	end

	if tokens[1] == '-pet' and _G.myself == true then
		combat('TEST CODE: PET = '..tokens[2])
		RefreshPets(hero,hero["pet1"],tokens[2])
	end

	if tokens[1] == '-round_time' and _G.myself == true then
		combat('TEST CODE: CUSTOM ROUND TIME '..tokens[2])
		_G.custom_round_time = tonumber(tokens[2]) 
		_G.prepare_timer_ingame = _G.custom_round_time
	end

	if (tokens[1] == "-stub" or tokens[1] == "-grid") and _G.myself == true then
		local team_id = hero:GetTeam()
		StartShowGrid(team_id)
	end
	if (tokens[1] == "-unstub" or tokens[1] == "-ungrid") and _G.myself == true then
		local team_id = hero:GetTeam()
		StopShowGrid(team_id)
	end

	if tokens[1] == '-print_chesspool' and _G.myself then
		PrintChessPool()
	end

	if tokens[1] == '-ai' and _G.myself == true then
		if hero.pet_entity ~= nil then
			CourierAI(hero)
		else
			CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
				key = GetClientKey(team_id),
				text = "text_mima_no_pet"
			})
		end
		
		return
	end
	if tokens[1] == '-noai' and _G.myself == true then
		hero.ai_synergy = {}
		hero.stop_ai = true
		hero.ai_pet = nil
		return
	end
	if tokens[1] == '-tbdl' and _G.myself == true then
		print('----------print_to_be-----------')
		for i,v in pairs(_G.to_be_destory_list[hero:GetTeam()]) do
			if v == nil then
				print('['..i..']'..'nil')
			elseif v:IsNull() then
				print('['..i..']'..'Null')
			elseif v:IsAlive() == false then
				print('['..i..']'..'(DEAD)'..v:GetUnitName()..',team='..v:GetTeam())
			else
				print('['..i..']'..v:GetUnitName()..',team='..v:GetTeam())
			end
		end
	end

	if tokens[1] == '-print_to_be' and _G.myself == true then
		print('----------print_to_be-----------')
		for i,v in pairs(_G.to_be_destory_list[hero:GetTeam()]) do
			if v == nil then
				print('['..i..']'..'nil')
			elseif v:IsNull() then
				print('['..i..']'..'Null')
			elseif v:IsAlive() == false then
				print('['..i..']'..'(DEAD)'..v:GetUnitName()..',team='..v:GetTeam())
			else
				print('['..i..']'..v:GetUnitName()..',team='..v:GetTeam())
			end
		end
	end

	-- if tokens[1] == '-test_hp_bar_table' and _G.myself == true then
	-- 	local count,str = GetHPBarTableLength()
	-- 	prt('神秘代码('..count..')'..str)
	-- end

	if (tokens[1] == '-chesspool' or tokens[1] == '-pool') and _G.myself == true then
		local count = FindChessCountInChessPool('chess_'..tokens[2] or 'nil') or 0
		prt('棋库中|'..tokens[2]..'|的数量：'..count)
		return
	end

	if tokens[1] == '-removechess' and _G.myself == true then
		RemoveChessFromChessPool(tokens[2])
		prt('移除1个')
		return
	end

	--发弹幕
	if _G.p2_mode == true and keys.teamonly == 1 then
		--2P模式
		local ally_team = GetP2Ally(hero:GetTeam())
		if ally_team then
			local team_from = hero:GetTeam()
			local player_from = hero:GetPlayerID()
			local team_to = ally_team
			local player_to = TeamId2Hero(team_to):GetPlayerID()
			CustomGameEventManager:Send_ServerToTeam(team_to,"chat_bubble_player_board",{
				key = GetClientKey(team_to),
				player_from = player_from,
				player_to = player_to,
				text = keys.text,
				is_vip = hero.is_vip,
			})
			CustomGameEventManager:Send_ServerToTeam(team_from,"chat_bubble_player_board",{
				key = GetClientKey(team_from),
				player_from = player_from,
				player_to = player_to,
				text = keys.text,
				is_vip = hero.is_vip,
			})
		else
			--给自己发
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"chat_bubble_player_board",{
				key = GetClientKey(hero:GetTeam()),
				player_from = hero:GetPlayerID(),
				player_to = hero:GetPlayerID(),
				text = keys.text,
				is_vip = hero.is_vip,
			})
		end
		
	else
		-- CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"chat_bubble",{
		-- 	key = GetClientKey(hero:GetTeam()),
		-- 	player_from = hero:GetPlayerID(),
		-- 	player_to = hero:GetPlayerID(),
		-- 	text = keys.text,
		-- 	is_vip = hero.is_vip,
		-- })

		--发弹幕
		-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
		-- 	player_id = hero:GetPlayerID(),
		-- 	vip = false,--hero.is_vip,
		-- 	win_streak = hero.win_streak or 0,
		-- 	text = keys.text,
		-- })

		-- CustomGameEventManager:Send_ServerToAllClients("chat_bubble_player_board",{
		-- 	key = GetClientKey(hero:GetTeam()),
		-- 	player_from = hero:GetPlayerID(),
		-- 	player_to = hero:GetPlayerID(),
		-- 	text = keys.text,
		-- 	is_vip = hero.is_vip,
		-- })

		--发送聊天到UI
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = keys.text,
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_chat',
		})
		
	end
end
function DAC:OnRefreshChess(keys)
	local player_team = _G.playerid2team[keys.PlayerID]
	local hero = _G.teamid2hero[player_team]

	if player_team ~= keys.team or hero == nil or hero:IsNull() == true then
		-- hero.is_banned = true
		return
	end

	local cost_mana = 2
	if hero:GetMana() < 2 then
		CustomGameEventManager:Send_ServerToTeam(keys.team,"mima",{
			key = GetClientKey(keys.team),
			text = "text_mima_no_mana"
		})
		return
	else
		hero.chesslock = false
		CostMana(hero,2)
		Draw5ChessAndShow(keys.team, true)
	end
end
function DAC:OnCatchCrab(keys)
	local player_id = keys.PlayerID
	local urls = {
		ranking_top = 'http://autochess.ppbizon.com/ranking/top',
		refresh_shop = 'http://autochess.ppbizon.com/shop/v4/get',
		buy_courier = 'http://autochess.ppbizon.com/shop/v4/courier',
		buy_effect = 'http://autochess.ppbizon.com/shop/v4/effect',
		buy_projectile = 'http://autochess.ppbizon.com/shop/v4/projectile',
		buy_pet = 'http://autochess.ppbizon.com/shop/v4/pet',
		buy_animation = 'http://autochess.ppbizon.com/shop/v4/animation',
		buy_emotion = 'http://autochess.ppbizon.com/shop/v4/emotion',
		buy_chessboard = 'http://autochess.ppbizon.com/shop/v4/chessboard',
		choose_hero = 'http://autochess.ppbizon.com/courier/change',
		lottery_go = 'http://autochess.ppbizon.com/shop/lottery',
		
		activate_cdkey = 'http://autochess.ppbizon.com/cdkey/act',
		jihuan_hero = 'http://autochess.ppbizon.com/shop/v4/collect',
		request_vote_chess = 'http://autochess.ppbizon.com/vip/vote',
		get_season_award = 'http://autochess.ppbizon.com/award/get',
		bet_ti9 = 'http://autochess.ppbizon.com/bet/ti9',
		merge_hero = 'http://autochess.ppbizon.com/courier/merge',

		recycle_hero = 'http://autochess.ppbizon.com/courier/del',
		recycle_effect = 'http://autochess.ppbizon.com/effect/del',
		recycle_projectile = 'http://autochess.ppbizon.com/projectile/del',
		recycle_animation = 'http://autochess.ppbizon.com/animation/del',
		recycle_pet = 'http://autochess.ppbizon.com/pet/del',
	}
	if urls[keys.event] ~= nil then
		local send_url = urls[keys.event]
		--user_specific=1：要带上@id
		if keys.user_specific == 1 then
			send_url = send_url..'/@'..(_G.playerid2steamid[keys.PlayerID] or '')
		end
		--这些情况有第二个@
		if keys.event == 'buy_effect' or keys.event == 'choose_hero' or keys.event == 'recycle_hero' or keys.event == 'activate_cdkey' or keys.event == 'jihuan_hero' or keys.event == 'merge_hero' or keys.event == 'buy_projectile' or keys.event == 'buy_animation' or keys.event == 'buy_pet' or keys.event == 'buy_emotion' or keys.event == 'buy_chessboard' or keys.event == 'recycle_effect' or keys.event == 'recycle_projectile' or keys.event == 'recycle_pet' or keys.event == 'recycle_animation' or keys.event == 'buy_courier' then
			send_url = send_url..'@'..keys.params['hero']
		end
		send_url = send_url..'?hehe='..RandomInt(1,10000)
		for i,v in pairs(keys.params) do
			send_url = send_url..'&'..i..'='..v
		end

		send_url = send_url..GetSendKey()

		Timers:CreateTimer(RandomFloat(0,1),function()
			SendHTTP(send_url,function(t)
				if keys.event == 'bet_ti9' then
					_G.user_info[_G.playerid2steamid[keys.PlayerID]]['bet_info'] = t['team']
					CustomNetTables:SetTableValue( "dac_table", "player_info", { info = _G.user_info, hehe = RandomInt(1,1000)})
				end
				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player_id),'send_http_cb',{
					key = GetClientKey(_G.playerid2team[player_id]),
					event = keys.cb,
					data = json.encode(t),
				})
			end)
	    end)
	end
end
function DAC:OnUnlockChess(keys)
	local player_team = _G.playerid2team[keys.PlayerID]
	local hero = TeamId2Hero(player_team)
	if hero == nil then return end
	if player_team ~= keys.team then
		hero.is_banned = true
		return
	end

	hero.chesslock = false
end
function DAC:OnLockChess(keys)
	local player_team = _G.playerid2team[keys.PlayerID]
	local hero = TeamId2Hero(player_team)
	if IsUnitExist(hero) == false then return end

	hero.chesslock = true
end
function DAC:OnChangeOndutyHero(keys)
	local player_id = keys.PlayerID
	local onduty_hero_new = keys.onduty_hero_new

	local onduty_hero = string.split(onduty_hero_new,'_')[1]
	local onduty_hero_effect = string.split(onduty_hero_new,'_')[2] or ''
	local onduty_hero_projectile = string.split(onduty_hero_new,'_')[4] or ''
	local onduty_hero_pet = string.split(onduty_hero_new,'_')[5] or ''
	local onduty_hero_animation = string.split(onduty_hero_new,'_')[6] or ''

	local hero = PlayerId2Hero(player_id)
	if keys.player_id ~= keys.PlayerID then
		hero.is_banned = true
		return
	end

	hero.onduty_hero_long = onduty_hero_new

	--装饰信使
	SetCourier(hero, onduty_hero, onduty_hero_effect, onduty_hero_projectile, onduty_hero_pet, onduty_hero_animation,onduty_hero_new)
	hero.is_changed_hero = true
	
	local steam_id = hero.steam_id
	local onduty_hero_model = _G.sm_hero_list[onduty_hero]
	if _G.user_info == nil then return end
	SetStat(player_id,'zhugong',onduty_hero)
	SetStat(player_id,'zhugong_model',onduty_hero_model)
	SetStat(player_id,'zhugong_effect',onduty_hero_effect)
	_G.user_info[steam_id]['zhugong_model'] = onduty_hero_model
	_G.user_info[steam_id]['zhugong_effect'] = onduty_hero_effect
	_G.user_info[steam_id]['onduty_hero'] = onduty_hero
	_G.user_info[steam_id]['onduty_hero_effect'] = onduty_hero_effect

	CustomNetTables:SetTableValue( "dac_table", "player_info", { info = _G.user_info, hehe = RandomInt(1,1000)})

	RemoveAbilityAndModifier(hero,'courier_fly')
	if hero.flyup_effect ~= nil then
		ParticleManager:DestroyParticle(hero.flyup_effect,true)
	end
end
function DAC:OnPreviewEffect(keys)
	local h = PlayerId2Hero(keys.PlayerID) --   EntIndexToHScript(keys.hero_index)
	if h.is_preview_cd == true then
		return
	end
	h.is_preview_cd = true
	local e = keys.effect

	if _G.effect_list[e] ~= nil then
		if h.effect ~= nil then
			h:RemoveAbility(h.effect)
			h:RemoveModifierByName('modifier_texiao_star')
		end
		h:AddAbility(e)
		h:FindAbilityByName(e):SetLevel(1)

		Timers:CreateTimer(5,function()
			h:RemoveAbility(e)
			h:RemoveModifierByName('modifier_texiao_star')
			if h.effect ~= nil then
				h:AddAbility(h.effect)
				h:FindAbilityByName(h.effect):SetLevel(1)
			end
			Timers:CreateTimer(5,function()
				h.is_preview_cd = false
			end)
		end)
	else
		h.is_banned = true
	end
end
function DAC:OnPreviewProjectile(keys)
	local hero = PlayerId2Hero(keys.PlayerID) --   EntIndexToHScript(keys.hero_index)
	if hero.is_preview_cd == true then
		return
	end
	hero.is_preview_cd = true
	local e = keys.projectile
	local pj = _G.projectile_list[e]['effect']

	for i=1,3 do
		Timers:CreateTimer(RandomFloat(1,3),function()
			PreviewProjectile(hero,e,pj)
		end)
	end

	Timers:CreateTimer(10,function()
		hero.is_preview_cd = false
	end)
end
function DAC:OnReport(keys)
	local steam_id = _G.playerid2steamid[keys.PlayerID]

	local report_str = keys.cheatuser..'_'..steam_id
	if _G.reportinfo[report_str] == nil and string.find(_G.steamidlist,keys.cheatuser) then
		SendHTTP('https://autochess.ppbizon.com/cheat/report?hehe='..RandomInt(1,10000)..'&cheatuser='..keys.cheatuser..'&reporter='..keys.reporter,function()
			end
		)
	end
end
function DAC:OnSetAutoCombine(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)
	if hero ~= nil then
		hero.is_auto_combine = keys.is_auto_combine
	end
end
function DAC:OnSelectDifficulty(keys)
	_G.difficulty = keys.difficulty or 2
end
function DAC:OnRequestSelectChess(keys)
	local player_id = keys.PlayerID
	local hero = _G.playerid2hero[player_id]
	local unit_index = keys.unit_index
	local unit = EntIndexToHScript(unit_index)

	if IsUnitExist(unit) == false or (unit.hand_index == nil and IsBattleTime() == true) then
		return
	end

	if IsUnitExist(hero) == true and hero:FindAbilityByName('pick_chess') ~= nil then
		ExecuteOrderFromTable({
			UnitIndex = hero:entindex(), 
			OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
			TargetIndex = unit_index,
			AbilityIndex = hero:FindAbilityByName('pick_chess'):entindex(),
			Queue = 0
		})
	end
end
function DAC:OnPauseGame(keys)
	local player_id = keys.playerid
	local hero = _G.playerid2hero[player_id]

	if IsUnitExist(hero) == false then
		return
	end
	if GameRules:IsGamePaused() then
		PauseGame(false)
		-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
		-- 	player_id = player_id,
		-- 	vip = hero.is_vip,
		-- 	text = '#text_unpause_game'
		-- })
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_unpause",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})
		return
	end

	if _G.START_TIME == nil then
		return
	end

	local pause_time = math.floor(GameRules:GetGameTime() - _G.START_TIME)
	if hero.last_pause_time == nil or GetPlayingPlayerCount() == 1 then
		PauseGame(true)
		-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
		-- 	player_id = player_id,
		-- 	vip = hero.is_vip,
		-- 	text = '#text_pause_game'
		-- })
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_pause",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
		})
		hero.last_pause_time = pause_time
	else
		if pause_time - hero.last_pause_time > 300 then
			PauseGame(true)
			-- CustomGameEventManager:Send_ServerToAllClients("bullet",{
			-- 	player_id = player_id,
			-- 	vip = hero.is_vip,
			-- 	text = '#text_pause_game'
			-- })
			hero.last_pause_time = pause_time
		else
			return
		end
	end
end
function DAC:OnRequestChooseLoot(keys)
	local player_id = keys.PlayerID
	local loot_index = keys.loot_index
	local unit_index = keys.unit_index
	local target_item = keys.target_item
	local hero = PlayerId2Hero(player_id)
	if loot_index ~= nil and loot_index == -1 then
		--放弃选择
		if hero ~= nil and hero:IsNull() ~= true then
			hero.loot_table = nil
		end
		return
	end
	if hero == nil or hero:IsNull() == true or hero.loot_table == nil or hero.loot_table[loot_index] == nil then
		return
	end

	local loot = hero.loot_table[loot_index]
	hero.loot_table = nil
	if FindValueInTable(_G.DROP_RELIC_LIST,loot) == true then
		--获得圣物
		hero:RemoveItem(hero:GetItemInSlot(16))
		SetStat(player_id,'relic',loot,true)
		if IsUnitExist(hero.mango_tree) then
			EmitSoundOn("item.mangotree.break",hero.mango_tree)
			hero.mango_tree:ForceKill(false)
			hero.mango_tree:SetModelScale(0.001)
			play_particle("effect/animation/tree/2_oak_01_destruction.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero.mango_tree,3)
		end
		if IsUnitExist(hero.great_vault) then
			EmitSoundOn("item.mangotree.break",hero.great_vault)
			hero.great_vault:ForceKill(false)
			hero.great_vault:SetModelScale(0.001)
			play_particle("particles/creatures/aghanim/aghanim_shard_channel_swirl.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero.great_vault,3)
		end
	end
	if unit_index ~= nil then
		--TODO：考虑各种情况。棋子不一定实体化了
		local target = EntIndexToHScript(unit_index)
		if not target then
			target = hero
		end
		AddItemPlus(target,loot)
		if target_item then
			Timers:CreateTimer(0.1,function()
				CombineItem(target, target_item)
			end)
		end
	else
		AddItemPlus(hero,loot)
		if target_item then
			Timers:CreateTimer(0.1,function()
				CombineItem(hero, target_item)
			end)
		end
	end
	

	local quest_2_relic_list = {
		q033 = 'item_double_lootbox',
		q034 = 'item_upgrade_lootbox',
		q035 = 'item_more_interest',
		q036 = 'item_more_reward',
		q037 = 'item_upgrade_roll',
		q038 = 'item_destroy_piece',
		q039 = 'item_friends_discount',
		q040 = 'item_conceal_prepare',
		q041 = 'item_streak_plus',
		q042 = 'item_free_ban',
		q043 = 'item_double_io',
		q044 = 'item_shrink_meister',
		q045 = 'item_vampiric_embrace',
		q046 = 'item_second_chance',
		q047 = 'item_mangotree',
	}

	if quest_2_relic_list[_G.egg_quest] ~= nil and quest_2_relic_list[_G.egg_quest] == loot then
		--完成指定圣物任务
		SetQuest(hero.team_id,true)
	end

	if loot == 'item_conceal_prepare' then
		--帷幕
		if _G.game_status ~= 2 then
			HidePrepare(hero:GetTeam())
		end
		EmitSoundOn("item.hide",hero)
	end
	if loot == 'item_destroy_piece' then
		--垄断契约
		local star3_chess_list = FindStar3Chess(hero:GetTeam())
		if star3_chess_list and table.maxn(star3_chess_list) > 0 then
			for _,star3_chess in pairs(star3_chess_list) do
				local base_chess = GetChessBaseName(star3_chess)
				MonopolizeAChessPiece(hero:GetTeam(), base_chess)
			end
			EmitGlobalSound("item.destroy_piece")
		end
	end
	if loot == 'item_mangotree' then
		local pp = CenterVector(hero:GetTeam()) + Vector(128*5,-128*2.5,0)
		GridNav:DestroyTreesAroundPoint( pp, 100, false )
		local tt = CreateUnitByName("mango_tree",pp,false,nil,nil,hero:GetTeam())
		tt.team_id = hero:GetTeam()
		hero.mango_tree = tt
		play_particle("particles/econ/items/oracle/oracle_ti10_immortal/oracle_ti10_immortal_purifyingflames_dust_hit_ring.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero.mango_tree,3)
		EmitSoundOn("item.mangotree.spawn",hero.mango_tree)
	end
	if loot == 'item_more_interest' then
		local pp = CenterVector(hero:GetTeam()) + Vector(128*5,-128*2.5,0)
		GridNav:DestroyTreesAroundPoint( pp, 100, false )
		local gg = CreateUnitByName("great_vault",pp,false,nil,nil,hero:GetTeam())
		gg.team_id = hero:GetTeam()
		hero.great_vault = gg
		play_particle("particles/econ/items/oracle/oracle_ti10_immortal/oracle_ti10_immortal_purifyingflames_dust_hit_ring.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero.great_vault,3)
		EmitSoundOn("item.greatvault.spawn",hero.great_vault)
	end
	
	if loot == 'item_bench_contract' then
		for i=1,8 do
			local pp = HandIndex2Vector(hero:GetTeam(),i)
			local holder = CreateChessInHand(hero,"placeholder",nil,'nil')
			if IsUnitExist(holder) then
				BlinkChessX({caster=holder,blink_type="breaksoil"})
				-- holder:SetForwardVector(Vector(0,-1,0))
				holder.buy_price = 0
				local scale = AddTrackMoneyCount(holder,1)
				AddModelScalePlus(holder, 1.2+scale/10.0)
				AddTotalMoneyStat(player_id, 1)
				holder:SetBaseMaxHealth(scale)
				holder:SetMaxHealth(scale)
			end
		end
		EmitSoundOn('Hero_Treant.Overgrowth.Target',hero)
	end

	if loot == 'item_egg' then
		--如果已经有蛋了，不会产生额外的蛋巢
		if IsUnitExist(hero) == false then
			return
		end
		if hero.hand_entities == nil then
			hero.hand_entities = {}
		end
		
		local already_have_egg = false
		for _,ent in pairs(hero.hand_entities) do
			if IsUnitExist(ent) == true then
				local chess_name = ent:GetUnitName()
				if chess_name == 'egg' then
					already_have_egg = true
				end
			end
		end

		if already_have_egg == false then
			local holder = CreateChessInHand(hero,"egg",nil,'nil')
			if IsUnitExist(holder) then
				AddAbilityAndSetLevel(holder,'no_hp_add')
				BlinkChessX({caster=holder,blink_type="breaksoil"})
				-- holder:SetForwardVector(Vector(0,-1,0))
				holder.buy_price = 0
			end
		end
		EmitSoundOn('Hero_Treant.Overgrowth.Target',hero)
	end

	-- if loot == 'item_black_gear' then
	-- 	--将已拥有的机械之心都替换为暗黑机械之心
	-- 	for slot=0,9 do
	-- 		if hero:GetItemInSlot(slot)~= nil then
	-- 			local item = hero:GetItemInSlot(slot)
	-- 			local name = hero:GetItemInSlot(slot):GetAbilityName()
	-- 			if name == 'item_jixiezhixin' then
	-- 				local charges = hero:GetItemInSlot(slot):GetCurrentCharges()
	-- 				hero:RemoveItem(hero:GetItemInSlot(slot))
	-- 				for i=1,charges do
	-- 					AddItemPlus(hero,'item_jixiezhixin_black',0.1*i)
	-- 				end
	-- 				if charges >= 1 then
	-- 					EmitSoundOn("black_gear.transfer",hero)
	-- 				end
	-- 			end
	-- 		end
	-- 	end
	-- end
end
function DAC:OnChooseBadge(keys)
	local player_id = keys.PlayerID
	local badge = keys.badge

	CustomNetTables:SetTableValue( "player_id_table", 'badge_'..player_id, {badge=badge})
end
function DAC:OnChooseChessboard(keys)
	local player_id = keys.PlayerID
	local chessboard = keys.chessboard
	if player_id == nil then return end
	CustomNetTables:SetTableValue( "player_id_table", 'chessboard_'..player_id, {chessboard=chessboard})
end
function DAC:OnChooseCourier(keys)
	local player_id = keys.PlayerID
	local courier = keys.courier
	local courier_id = keys.courier_id

	local courier_info = CustomNetTables:GetTableValue( "player_id_table", "courier_"..player_id ) or {}
	courier_info['courier'] = courier --只取hxxx部分的id 
	courier_info['courier_id'] = courier_id --完整id

	CustomNetTables:SetTableValue( "player_id_table", 'courier_'..player_id, courier_info)

	CustomGameEventManager:Send_ServerToAllClients("update_portrait_courier_name",{})
end
function DAC:OnUpdateMMRLevel(keys)
	local player_id = keys.PlayerID
	local mmr_level = keys.mmr_level
	local queen_rank = keys.queen_rank

	CustomNetTables:SetTableValue( "player_id_table", 'mmr_level_'..player_id, {mmr_level=mmr_level,queen_rank=queen_rank})
end
function DAC:OnShowGameNotice(keys)
	local player_id = keys.PlayerID
	if player_id ~= 0 then
		return
	end
	local text = keys.text
end
function DAC:OnPlayerLanguage(keys)
	local player_id = keys.PlayerID
	local language = keys.language
	local hero = PlayerId2Hero(player_id)
	if hero ~= nil then
		hero.language = language
	end
end
function DAC:DamageFilter(keys)
	if keys.entindex_victim_const == nil then
		return false
	end
	local v = EntIndexToHScript(keys.entindex_victim_const)
	local a = EntIndexToHScript(keys.entindex_attacker_const or keys.entindex_victim_const)
	local t = keys.damagetype_const

	if a.damage_owner ~= nil and a.damage_owner:IsNull() == false then
		a = a.damage_owner
	end

	--仅限同棋盘伤害
	local attacker_at_team_id = a.at_team_id or a.team_id
	local victim_at_teamid = v.at_team_id or v.team_id
	if attacker_at_team_id ~= victim_at_teamid then
		keys.damage = 0
	    return false
	end

	--手牌的棋子，不能造成伤害（拿辉耀之类的情况）
	if a.hand_index ~= nil then
		keys.damage = 0
	    return false
	end

	--攻击伤害类型转换1：火枪狙击伤害锁定为物理
	if t == DAMAGE_TYPE_MAGICAL and a:HasAbility('sniper_assassinate') and keys.entindex_inflictor_const ~= nil and keys.entindex_inflictor_const > 0 and keys.damage > 10 then
		local ability = EntIndexToHScript(keys.entindex_inflictor_const)
		if ability ~= nil and ability:GetAbilityName() ~= nil and ability:GetAbilityName() == 'sniper_assassinate' then
			--新版狙击手-暗杀：根据等级造成物理伤害，并将原来的魔法伤害无效化
			if not v:HasModifier("modifier_is_naga_buff_plus") then
				local d = ability:GetAbilityDamage() or 400
				Timers:CreateTimer(0.1,function()
					ApplyDamage({
						victim=v,
						attacker=a,
						damage_type=DAMAGE_TYPE_PHYSICAL,
						damage= d,
						ability = a:FindAbilityByName('sniper_assassinate'),
					})
				end)
				keys.damage = 0
				return false
			end
		end
	end
	--攻击伤害类型转换2：巨魔战将飞斧技能的伤害锁定为物理伤害
	if keys.entindex_inflictor_const ~= nil and keys.entindex_inflictor_const > 0 and keys.damage > 10 then
		local ability = EntIndexToHScript(keys.entindex_inflictor_const)
		if ability ~= nil and ability:GetAbilityName() ~= nil and ability:GetAbilityName() == 'troll_warlord_whirling_axes_melee' then
			-- if not v:HasModifier("modifier_is_naga_buff_plus") then
				local axe_damage = keys.damage
				Timers:CreateTimer(0.1,function()
					ApplyDamage({
						victim=v,
						attacker=a,
						damage_type=DAMAGE_TYPE_PHYSICAL,
						damage= axe_damage,
						ability = a:FindAbilityByName('troll_axe'),
					})
				end)
				a:PerformAttack( v, true, true, true, false, false, false, true )
				play_particle("particles/econ/items/bloodseeker/bloodseeker_eztzhok_weapon/bloodseeker_bloodbath_eztzhok_ribbon.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
				EmitSoundOn("chess_troll.axe.hit",v)
				keys.damage = 0
				return false
			-- end
		end
		if ability ~= nil and ability:GetAbilityName() ~= nil and ability:GetAbilityName() == 'troll_warlord_whirling_axes_ranged' then
			-- if not v:HasModifier("modifier_is_naga_buff_plus") then
				local axe_damage = keys.damage
				Timers:CreateTimer(0.1,function()
					ApplyDamage({
						victim=v,
						attacker=a,
						damage_type=DAMAGE_TYPE_PHYSICAL,
						damage= axe_damage,
						ability = a:FindAbilityByName('troll_axe'),
					})
				end)
				a:PerformAttack( v, true, true, true, false, false, false, true )
				play_particle("particles/econ/items/bloodseeker/bloodseeker_eztzhok_weapon/bloodseeker_bloodbath_eztzhok_ribbon.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
				EmitSoundOn("chess_troll.axe.hit",v)
				keys.damage = 0
				return false
			-- end
		end
	end
	--攻击伤害类型转换3：战鹰、斗熊等锁定伤害类型的攻击
	if a:HasAbility('attack_magical') and t == DAMAGE_TYPE_PHYSICAL then
		--仅在这里将伤害无效化，实际伤害逻辑做在了技能里
	    keys.damage = 0
	    return false
	end
	if a:HasAbility('attack_pure') and t ~= DAMAGE_TYPE_PURE then
		--仅在这里将伤害无效化，实际伤害逻辑做在了技能里
	    keys.damage = 0
	    return false
	end
	--攻击伤害类型转换4：单恶魔的攻击伤害转为纯粹
	if a:HasModifier('modifier_is_demon_buff') and keys.entindex_inflictor_const == nil and t ~= DAMAGE_TYPE_PURE then
		--仅在这里将伤害无效化，实际伤害逻辑做在了技能里
	    keys.damage = 0
	    return false
	end
	--攻击伤害类型转换5：4恶魔猎手的技能伤害转为纯粹 4DH
	if keys.entindex_inflictor_const ~= nil and a:HasModifier('modifier_is_demon_buff_plus') and t ~= DAMAGE_TYPE_PURE then
		local damage_origin = keys.damage*1.15
		local m_r = v:GetMagicalArmorValue()
		if t == DAMAGE_TYPE_MAGICAL then
			damage_origin = damage_origin/(1-m_r)
		end
		local ability = EntIndexToHScript(keys.entindex_inflictor_const)
		if ability and ability:GetClassname() ~= 'npc_dota_creature' then
			Timers:CreateTimer(0.1,function()
				ApplyDamage({
					victim=v,
					attacker=a,
					damage_type=DAMAGE_TYPE_PURE,
					damage= damage_origin,
					ability = ability,
				})
			end)
			keys.damage = 0
			return false
		end
	end

	--新神谕：普攻伤害无效，技能伤害放大
	if keys.entindex_inflictor_const == nil and v:HasModifier('modifier_oracle_mingyunsheling') == true then
		keys.damage = 0
	end
	if keys.entindex_inflictor_const ~= nil and v:HasModifier('modifier_oracle_mingyunsheling') == true then
		local m = v:FindModifierByName('modifier_oracle_mingyunsheling')
		if m ~= nil then
			local a = m:GetAbility()
			if a ~= nil then
				local bonus = GetAbilityKV(a,'damage_bonus') or 0
				keys.damage = keys.damage * (100.0+bonus) /100.0
			end
		end
	end

	--受击伤害类型转换1：4娜迦受到物理伤害转为魔法伤害
	-- if t == DAMAGE_TYPE_PHYSICAL and v:HasModifier("modifier_is_naga_buff_plus") then
	-- 	if keys.entindex_inflictor_const ~= nil and keys.entindex_inflictor_const > 0 then
	-- 		local ability = EntIndexToHScript(keys.entindex_inflictor_const)
	-- 		local p_r = v:GetPhysicalArmorValue(false)
	-- 		local damage_base = keys.damage*(1-0.052*p_r/(0.9+0.048*p_r))
	-- 		Timers:CreateTimer(0.1,function()
	-- 			ApplyDamage({
	-- 				victim=v,
	-- 				attacker=a,
	-- 				damage_type=DAMAGE_TYPE_MAGICAL,
	-- 				damage= damage_base,
	-- 				ability = ability,
	-- 			})
	-- 		end)
	-- 	else
	-- 		local p_r = v:GetPhysicalArmorValue(false)
	-- 		local damage_base = keys.damage*(1-0.052*p_r/(0.9+0.048*p_r))
	-- 		Timers:CreateTimer(0.1,function()
	-- 			ApplyDamage({
	-- 				victim=v,
	-- 				attacker=a,
	-- 				damage_type=DAMAGE_TYPE_MAGICAL,
	-- 				damage= damage_base,
	-- 			})
	-- 		end)
	-- 	end
	-- 	keys.damage = 0
	--     return false
	-- end

	--图腾受到伤害，锁定伤害量为1或者2
	if v:HasAbility('is_ward') == true and keys.damage > 0 then
		if IsUnitExist(a) == true and (v:GetAbsOrigin() - a:GetAbsOrigin()):Length2D() > 200 then
			keys.damage = 2
		else
			keys.damage = 1
		end
	end

	--镜像棋子，只造成50%伤害
	if a:HasModifier("modifier_illusion") == true then
		keys.damage = keys.damage * 0.5
	end

	--幽鬼打荒芜
	if a:HasModifier('modifier_spe_desolate') and IsLonely(v) == true then
		-- play_particle('effect/dead/2.vpcf',PATTACH_ABSORIGIN_FOLLOW,v,3)
		keys.damage = keys.damage * 2
		-- local desolate_ability = a:FindAbilityByName('spe_desolate')
		-- if desolate_ability ~= nil then
		-- 	local chaos_per = GetAbilityKV(desolate_ability,'chaos_per')
		-- 	local chaos_duration = GetAbilityKV(desolate_ability,'chaos_duration')
		-- 	if RandomInt(1,100) <= chaos_per then
		-- 		desolate_ability:ApplyDataDrivenModifier(a, v, "modifier_queenofpain_sonic_wave_chaos_debuff", {
		-- 			duration = chaos_duration
		-- 		})
		-- 	end
		-- end
	end

	if t == DAMAGE_TYPE_PHYSICAL then
		if v:HasAbility("mars_bulwark_attack") == true then
			--玛尔斯，计算角度，决定是否抵挡部分伤害
			local ability = v:FindAbilityByName("mars_bulwark_attack")
			local level = ability:GetLevel()
			local v1 = v:GetForwardVector():Normalized()
			local v2 = (a:GetAbsOrigin() - v:GetAbsOrigin()):Normalized()
			-- local cross_product = v1.x * v2.x + v1.y * v2.y
			local angle1 = VectorToAngles(v1)
			local angle2 = VectorToAngles(v2)
			local p = "particles/units/heroes/hero_mars/mars_shield_of_mars_small.vpcf"
			if level >= 3 then
				p = "particles/units/heroes/hero_mars/mars_shield_of_mars.vpcf"
			end

			if math.abs(angle1.y - angle2.y) < 45 or (360-math.abs(angle1.y - angle2.y)) < 45 then
				--90度范围内
				local damage_reduce_per = ability:GetLevelSpecialValueFor( "physical_damage_reduction", level - 1 )
				keys.damage = keys.damage/100.0*(100-damage_reduce_per)
				play_particle(p,PATTACH_ABSORIGIN_FOLLOW,v,2)
			elseif math.abs(angle1.y - angle2.y) < 90 or (360-math.abs(angle1.y - angle2.y)) < 90 then
				--180度范围内
				local damage_reduce_per = ability:GetLevelSpecialValueFor( "physical_damage_reduction_side", level - 1 )
				keys.damage = keys.damage/100.0*(100-damage_reduce_per)
				play_particle(p,PATTACH_ABSORIGIN_FOLLOW,v,2)
			end
		end
		--矮人：所以类型伤害根据距离增加伤害
		if a:HasModifier('modifier_is_dwarf_buff_plus') then
			--2矮人
			local distance = (a:GetAbsOrigin() - v:GetAbsOrigin()):Length2D()
			local damage_bouns_per = distance/128.0*10
			keys.damage = keys.damage * (100 + damage_bouns_per) / 100
		end
		--6野兽
		if v:FindModifierByName('modifier_is_beast_debuff_plus_plus') ~= nil then
			local count = v:FindModifierByName('modifier_is_beast_debuff_plus_plus'):GetStackCount()
			keys.damage = keys.damage*(1+count*12/100)
		end
	end
	if t == DAMAGE_TYPE_MAGICAL then
		--魔法伤害，可被装备加成
		local damage_magical_x_list = {
			modifier_item_molifazhang = 20,
			modifier_item_shenmifazhang = 60,
			modifier_item_hongzhang_1 = 20,
			modifier_item_hongzhang_2 = 40,
			modifier_item_hongzhang_3 = 60,
			modifier_item_hongzhang_4 = 80,
			modifier_item_hongzhang_5 = 100,
			modifier_item_yangdao = 60,
			modifier_item_yuanlifazhang = 20,
			modifier_item_xiwa = 60,
			modifier_item_xueji = 20,
			modifier_item_sanchaji = 40,
		}

		local damage_magical_bonus = 0
		for m,b in pairs(damage_magical_x_list) do
			if a:FindModifierByName(m) ~= nil then
				damage_magical_bonus = damage_magical_bonus + b
			end
		end

		if a.xuejingshi_count ~= nil and a.xuejingshi_count > 0 then
			local xuejingshi_magic_bonus = tonumber(a.xuejingshi_count or 0) or 0
			damage_magical_bonus = damage_magical_bonus + xuejingshi_magic_bonus*10.0
		end

		keys.damage = math.floor(keys.damage * (100+damage_magical_bonus) / 100)
		-- 火女，技能造成魔法伤害：叠炽魂
		if keys.entindex_inflictor_const ~= nil then
			local ability = EntIndexToHScript(keys.entindex_inflictor_const)
			if ability ~= nil and ability:GetAbilityName() == 'lina_laguna_blade' and a:FindAbilityByName('lina_laguna_blade') ~= nil then
				local level = a:FindAbilityByName('lina_laguna_blade'):GetLevel()
				InvisibleUnitCast({
					caster = a,
					ability = 'give_fiery_soul',
					level = level,
					unluckydog = a,
					ignore_nether_ward = true,
				})
			end
		end
	end

	--格挡：物理伤害减免
	if t == DAMAGE_TYPE_PHYSICAL then
		local gedang_all = 0
		local gedang_list = {
			modifier_item_yuandun = 15,
			modifier_item_qiongguidun = 30,
			modifier_item_jurenzhijie = 30,
			modifier_item_yonghengzhipan = 30,
			modifier_item_shenjingdun = 30,
		}
		for m,gedang in pairs(gedang_list) do
			if v:HasModifier(m) then
				gedang_all = gedang_all + gedang
			end
		end
		--特殊的格挡，先锋盾/赤红甲
		if v:HasModifier('modifier_item_xianfengdun') then
			if RandomInt(1,100) < 50 then
				if v:IsRangedAttacker() == false then
					gedang_all = gedang_all + 100
				else
					gedang_all = gedang_all + 40
				end
			end
		end
		if v:HasModifier('modifier_item_chihongjia') then
			if RandomInt(1,100) < 50 then
				if v:IsRangedAttacker() == false then
					gedang_all = gedang_all + 100
				else
					gedang_all = gedang_all + 40
				end
			end
		end
		if v:HasModifier("modifier_chihongjia_buff") then
			if RandomInt(1,100) < 50 then
				if v:IsRangedAttacker() == false then
					gedang_all = gedang_all + 100
				else
					gedang_all = gedang_all + 40
				end
			end
		end

		if v:HasModifier('modifier_item_qiongguidun') then
			if RandomInt(1,100) < 30 then
				gedang_all = gedang_all + keys.damage*0.3
			end
		end
		if v:HasModifier('modifier_item_yonghengzhipan') then
			if RandomInt(1,100) < 30 then
				gedang_all = gedang_all + keys.damage*0.3
			end
		end
		if v:HasModifier('modifier_item_jurenzhijie') then
			if RandomInt(1,100) < 30 then
				gedang_all = gedang_all + keys.damage*0.3
			end
		end
		if v:HasModifier('modifier_item_shenjingdun') then
			if RandomInt(1,100) < 30 then
				gedang_all = gedang_all + keys.damage*0.3
			end
		end

		if v:HasModifier("modifier_yonghengzhipan_buff") then
			gedang_all = keys.damage
		end

		--巨人之戒buff
		if v:HasModifier("modifier_jurenzhijie_buff") then
			gedang_all = gedang_all * 3
		end

		

		if gedang_all > 0 then
			keys.damage = math.floor(keys.damage-gedang_all)
			if keys.damage < 0 then
				keys.damage = 0
			end
		end
	end

	--醉酒：物理伤害闪避
	if t == DAMAGE_TYPE_PHYSICAL then
		if keys.entindex_inflictor_const == nil and a:HasModifier('modifier_brewmaster_cinder_brew') and a:IsUnableToMiss() == false then
			local cinder_brew_miss_table = {
				[1] = 25,
				[2] = 50,
				[3] = 75,
			}
			local cinder_brew_ability = a:FindModifierByName('modifier_brewmaster_cinder_brew'):GetAbility()
			if cinder_brew_ability ~= nil then
				local cinder_brew_ability_level = cinder_brew_ability:GetLevel() or 1
				if RandomInt(1,100) <= cinder_brew_miss_table[cinder_brew_ability_level] then
					keys.damage = 0

					ShowMiss({caster = a})
					return false
				end
			end
		end

		--移除概率必中的buff
		local per_cannot_miss_buff_table = {
			"modifier_is_hunter_buff_jingzhun",
			"modifier_is_hunter_buff_jingzhun_plus",
			"modifier_is_hunter_buff_jingzhun_plus_plus",
			"modifier_bizhong",
		}
		for _,m in pairs(per_cannot_miss_buff_table) do
			if a:HasModifier(m) then
				a:RemoveModifierByName(m)
			end
		end
	end

	--百兽大游行：伤害降低25%
	if a:HasModifier('modifier_more_creep') then
		keys.damage = keys.damage * 0.75
	end

	--新版骑士盾：百分比的物理/魔法伤害减伤
	if t == DAMAGE_TYPE_PHYSICAL or t == DAMAGE_TYPE_MAGICAL then
		if v:HasModifier("modifier_is_knight_buff_2") then
			keys.damage = keys.damage * 0.5
		end
		if v:HasModifier("modifier_is_knight_buff_2_plus") then
			keys.damage = keys.damage * 0.5
		end
		if v:HasModifier("modifier_is_knight_buff_2_plus_plus") then
			keys.damage = keys.damage * 0.5
		end
	end

	--9战士：根据护甲值反伤
	if t ~= DAMAGE_TYPE_PURE and v:HasModifier("modifier_is_warrior_buff_plus_plus") then
		local amount = 1.5
		if v:GetHealth() < v:GetMaxHealth()/2 then
			amount = 3
		end
		Timers:CreateTimer(0.1,function()
			ApplyDamage({
		    	victim=a,
		    	attacker=v,
		    	damage_type=DAMAGE_TYPE_PURE,
		    	damage= v:GetPhysicalArmorValue(false)*amount,
		    })
		end)
	end
	--9法师：根据魔法伤害值冻结
	if t == DAMAGE_TYPE_MAGICAL and v:HasModifier("modifier_is_mage_buff_plus_plus") and a:entindex() ~= v:entindex() then
		local dd = keys.damage/400
		local aa = v:FindModifierByName("modifier_is_mage_buff_plus_plus"):GetAbility()
		aa:ApplyDataDrivenModifier(v,v,'modifier_is_mage_frozen_debuff',{duration = dd})
	end
	--德莱尼：概率反弹伤害
	-- if RandomInt(1,100) < 25 and v:HasModifier("modifier_is_draenei_buff") then 
	-- 	Timers:CreateTimer(0.1,function()
	-- 		local ud = FindUnluckyDogClosest(v)
	-- 		play_particle("particles/econ/events/battlecup/battle_cup_fall_destroy_trails.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
	-- 		ApplyDamage({
	-- 	    	victim=ud,
	-- 	    	attacker=v,
	-- 	    	damage_type=DAMAGE_TYPE_MAGICAL,
	-- 	    	damage= keys.damage,
	-- 	    })
	-- 	end)
	-- 	keys.damage = 0
	-- 	return false
	-- end
	--神镜盾，反弹
	if v:HasModifier('modifier_shenjingdun_buff') and a:entindex() ~= v:entindex() then
		local shenjing_damage = keys.damage*2
		Timers:CreateTimer(0.1,function()
			if shenjing_damage > 99999 then
				shenjing_damage = 99999
			end
			ApplyDamage({
		    	victim=a,
		    	attacker=v,
		    	damage_type=DAMAGE_TYPE_PURE,
		    	damage= shenjing_damage,
		    })
			projectile = ProjectileManager:CreateTrackingProjectile({
				Target = a,
				Source = v,
				Ability = nil,
				EffectName = 'effect/shenjing/tinker_laser.vpcf',
				bDodgeable = false,
				iMoveSpeed = 2000,
				bProvidesVision = false,
				iVisionRadius = 0,
				iVisionTeamNumber = v:GetTeam(),
				iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_HITLOCATION
			})
			EmitSoundOn("shenjingdun.damage",a)
		end)
	end

	--三叉戟
	if a:HasModifier('modifier_item_sanchaji') then
		local is_sanchaji_damage = false
		if keys.entindex_inflictor_const ~= nil and keys.entindex_inflictor_const > 0 then
			local ability = EntIndexToHScript(keys.entindex_inflictor_const)
			if ability ~= nil and ability:GetClassname() == 'item_datadriven' and ability:GetAbilityName() ~= nil and ability:GetAbilityName() == 'item_sanchaji' then
				is_sanchaji_damage = true
			end
		end

		if not is_sanchaji_damage then
			local unluckydogs = GetSameNameFriendChess(v,2)
			if unluckydogs and table.maxn(unluckydogs) > 0 then
				local dd = keys.damage
				for _,dog in pairs(unluckydogs) do
					Timers:CreateTimer(0.1,function()
						play_particle("particles/units/heroes/hero_siren/naga_siren_riptide_foam.vpcf",PATTACH_ABSORIGIN_FOLLOW,dog,2)
						ApplyDamage({
							victim=dog,
							attacker=a,
							damage_type=t,
							damage= dd,
							ability = FindItemInInventory(a,'item_sanchaji'),
						})
					end)
				end
			end
		end
	end
	if a:HasModifier('modifier_item_bingyan') then
		a:FindItemInInventory('item_bingyan'):ApplyDataDrivenModifier(a,v,'modifier_item_bingyan_2',{duration = 5})
	end
	if keys.damage > 0 and keys.entindex_inflictor_const == nil and v:HasModifier('modifier_siren_song_debuff') then
		v:RemoveModifierByName('modifier_siren_song_debuff')
	end

	--永恒之盘
	if t ~= DAMAGE_TYPE_PURE and keys.damage >= v:GetHealth() and v.is_yonghengzhipan_triggered == nil and v:HasModifier('modifier_yonghengzhipan_buff') == false then
		for slot=0,5 do
			if v:GetItemInSlot(slot)~= nil then
				local ability = v:GetItemInSlot(slot)
				local name = ability:GetAbilityName()
				if name == 'item_yonghengzhipan' then
					ability:ApplyDataDrivenModifier(v,v,'modifier_yonghengzhipan_buff',{ duration = 5, })
					EmitSoundOn('DOTA_Item.BlackKingBar.Activate',v)
					play_particle("effect/essence_ring/1.vpcf",PATTACH_ABSORIGIN_FOLLOW,v,2)
					
					InvisibleUnitCast({
						caster = v,
						ability = 'give_bkb_buff',
						level = 1,
						unluckydog = v,
						ignore_nether_ward = true,
					})
					v:Purge(false, true, false, false, false) --净化
	
					ability:StartCooldown(60)
					v.is_yonghengzhipan_triggered = true
					keys.damage = 0
				end
			end
		end
	end

	--6野兽
	if t == DAMAGE_TYPE_PHYSICAL and a:HasAbility('is_beast_buff_plus_plus') == true then
		Add6BeastDebuff({
			ability = a:FindAbilityByName('is_beast_buff_plus_plus'),
			caster = a,
			target = v,
		})
	end

	--伤害显示
	if (_G.show_damage == true or keys.damage > 1000) and a:GetTeam() ~= 4  then
		if t == DAMAGE_TYPE_MAGICAL then
			AMHC:CreateNumberEffect(v,keys.damage,3,AMHC.MSG_DAMAGE,{90,145,205},9)
		elseif t == DAMAGE_TYPE_PHYSICAL then
			AMHC:CreateNumberEffect(v,keys.damage,3,AMHC.MSG_DAMAGE,{160,45,39},9)
		elseif t == DAMAGE_TYPE_PURE then
			AMHC:CreateNumberEffect(v,keys.damage,3,AMHC.MSG_DAMAGE,{216,175,84},9)
		end
	end

	if v:GetUnitName() == 'dummy' then
		v:StartGestureWithPlaybackRate(ACT_DOTA_FLINCH,1)
	end

	--伤害统计（不统计过量伤害）
	local damage_stat = keys.damage
	if damage_stat > v:GetHealth() then
		damage_stat = v:GetHealth()
	end
	Add2DamageStat(a, v, damage_stat, t)

	return true
end
function DAC:HealingFilter(keys)
	local t = EntIndexToHScript(keys.entindex_target_const)

	local heal_bonus = 0

	if t:HasAbility('is_ward') then
		return false
	end

	if t:HasAbility('is_mech') then
		keys.heal = keys.heal * 1.5
	end

	if t:HasModifier('modifier_dazzle_shallow_grave') then
		keys.heal = keys.heal * 2
	end
	if t:HasModifier("modifier_item_bingyan_2") then
		keys.heal = keys.heal * 0.5
	end
	if t:HasModifier("modifier_shiva_debuff") then
		keys.heal = keys.heal * 0.75
	end

	if _G.show_damage == true and keys.heal >= 100 then
		if t ~= nil then
			local h = math.floor(keys.heal)
			AMHC:CreateNumberEffect(t,h,2,AMHC.MSG_MISS,{0,255,0},0)
		end
	end

	return true
end
function DAC:ExecuteOrderFilter(keys)

	if keys.order_type == 19 and (keys.entindex_target == 6 or keys.entindex_target == 7 or keys.entindex_target == 8) then
		--兼容不能吃树的bug，把吃树换成即食的item_chishu_new
		local a = EntIndexToHScript(keys.entindex_ability)
		if a ~= nil and a:IsNull() == false and a:GetClassname() =='item_datadriven' and a:GetAbilityName() ~= nil and a:GetAbilityName() == 'item_chishu' then
			Timers:CreateTimer(0.1,function()
				MakeTangoEatable(keys.issuer_player_id_const,keys.entindex_target)
			end)
		end
	end
	return true
end
function DAC:ItemAddedToInventoryFilter(keys)
	local item_entindex_const = keys.item_entindex_const
	local inventory_parent_entindex_const = keys.inventory_parent_entindex_const
	local item_parent_entindex_const = keys.item_parent_entindex_const

	local item = EntIndexToHScript(item_entindex_const)
	local inventory_parent = EntIndexToHScript(inventory_parent_entindex_const)
	local item_parent = EntIndexToHScript(item_parent_entindex_const)

	if item ~= nil and inventory_parent ~= nil and inventory_parent:HasItemInInventory('item_null') ~= true and inventory_parent.evolve_result == nil and inventory_parent.devolve_result == nil and inventory_parent.is_clearing == nil then
		item:SetPurchaser(inventory_parent)
	end

	return true
end
function DAC:ModifierGainedFilter(keys)
	local victim = EntIndexToHScript(keys.entindex_parent_const)
	local modifier = keys.name_const
	local duration = keys.duration

	
	RemindItem(victim, modifier)

	if modifier == 'modifier_winter_wyvern_cold_embrace' then
		for _,unit in pairs (GetValidChessOnBoard(victim.at_team_id or victim.team_id)) do
			if IsUnitExist(unit) and unit.team_id ~= victim.team_id and IsUnitExist(unit:GetAttackTarget()) and  unit:GetAttackTarget():entindex() == victim:entindex() then
				local ww = victim:FindModifierByName(modifier):GetAbility():GetOwner()
				if IsUnitExist(ww) then
					ww:FindAbilityByName('ww_frost'):ApplyDataDrivenModifier(ww,unit,'modifier_ww_frost',{
					duration = 5})
				end
			end
		end
	end
	if victim:HasModifier('modifier_is_nraqi_buff') and victim:FindModifierByName(modifier) ~= nil and (victim:FindModifierByName(modifier):IsDebuff() or modifier == "modifier_pangolier_luckyshot_disarm") and IsModifierInNraqiWhiteList(modifier) ~= true then
		--无面者，抵消debuff
		if victim.nraqi_animation ~= true then
			victim.nraqi_animation = true
			play_particle("particles/units/heroes/hero_faceless_void/faceless_void_backtrack.vpcf",PATTACH_ABSORIGIN_FOLLOW,victim,2)
			Timers:CreateTimer(2,function()
				victim.nraqi_animation = nil
			end)
		end
		return false
	end
	if victim:HasModifier('modifier_hoodwink_hunters_mark') and victim:FindModifierByName(modifier) ~= nil and victim:FindModifierByName(modifier):IsDebuff() then
		local addition = GetAbilityKV(victim:FindModifierByName('modifier_hoodwink_hunters_mark'):GetAbility(), 'debuff_amp') or 50
		keys.duration = duration*(1+addition/100)
	end

	if modifier == "modifier_medusa_stone_gaze_stone" then
		--石化，净化效果
		local caster = EntIndexToHScript(keys.entindex_caster_const)
		PurgeASummonedChess(caster,victim)
	end

	return true
end



--坟场管理
function ResetAllDeadChessList()
	_G.dead_chess_list = {
		[6] = {},
		[7] = {},
		[8] = {},
		[9] = {},
		[10] = {},
		[11] = {},
		[12] = {},
		[13] = {},
	}
end
function AddChess2DeadChessList(keys)
	local at_team_id = keys.at_team_id --必填
	local chess_base_name = keys.chess_base_name --必填
	if at_team_id == nil or chess_base_name == nil then
		return
	end

	local level = keys.level or 0
	if string.find(chess_base_name,'chess_') ~= nil then
		level = _G.chess_2_mana[chess_base_name]
	end
	local items = keys.items or {}
	if _G.dead_chess_list ~= nil then
		local index = table.maxn(_G.dead_chess_list[at_team_id]) + 1
		table.insert(_G.dead_chess_list[at_team_id],{
			index = index,
			chess_base_name = chess_base_name,
			items = items,
			level = level,
		})
	end
end
function GetMaxLevelChessFromDeadChessList(keys)
	local at_team_id = keys.at_team_id --必填
	if at_team_id == nil then
		return
	end
	local is_remove = keys.is_remove or false

	local max_level = 0
	local max_level_chess = nil
	local max_level_index = nil
	for i,v in pairs(_G.dead_chess_list[at_team_id]) do
		if v.level ~= nil and v.level > max_level then 
			max_level = v.level
			max_level_chess = v
			max_level_index = i
		end
	end
	if is_remove == true and max_level_index ~= nil then
		table.remove(_G.dead_chess_list[at_team_id],max_level_index)
	end
	return max_level_chess
end

--上帝之手：复活
function ChenFuhuo(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()

	local fuhuo_unit = GetMaxLevelChessFromDeadChessList({
		at_team_id = caster.at_team_id or caster.team_id,
		is_remove = true,
	})

	if fuhuo_unit ~= nil then
		--复活！
		local unit_name = fuhuo_unit.chess_base_name
		if string.find(unit_name,'chess_') ~= nil then
			if level == 2 then
				unit_name = unit_name..'1'
			elseif level >= 3 then
				unit_name = unit_name..'11'
			end
		end
		if unit_name == 'chess_io11' then 
			--io暂时没有3星的，容错为2星
			unit_name = 'chess_io1'
		end

		-- local p = FindRandomEmptyGridAtUnit(caster)
		local p = FindEmptyGridAtUnit(caster, true)
		local w = SummonAChess(caster.team_id,p,unit_name,caster.at_team_id or caster.team_id,100,100, nil, false)
		if w ~= nil then
			ExtendBeastBuff(w,caster)
			w.is_fuhuo = true
			play_particle("particles/units/heroes/hero_chen/chen_holy_persuasion.vpcf",PATTACH_ABSORIGIN_FOLLOW,w,3)
			SetWard(w)
		end
		EmitSoundOn("chess_chen.fuhuo",caster)
	end
end

--食人魔之帽
function AddOgre(keys)
	local caster = keys.caster
	if caster:IsHero() ~= true then
		AddAbilityAndSetLevel(caster,'is_ogre',1)
		caster:FindAbilityByName('is_ogre'):SetHidden(true)
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end
function RemoveOgre(keys)
	local caster = keys.caster
	if FindValueInTable(_G.chess_list_by_synergy['is_ogre'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman['is_ogre'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_ban_unavailable['is_ogre'],GetUnitBaseName(caster)) ~= true  then
 		RemoveAbilityAndModifier(caster,'is_ogre')
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
 	end
end
function AddShaman(keys)
	local caster = keys.caster
	if caster:IsHero() ~= true then
		AddAbilityAndSetLevel(caster,'is_shaman',1)
		caster:FindAbilityByName('is_shaman'):SetHidden(true)
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end
function RemoveShaman(keys)
	local caster = keys.caster
	if FindValueInTable(_G.chess_list_by_synergy['is_shaman'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman['is_shaman'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_ban_unavailable['is_shaman'],GetUnitBaseName(caster)) ~= true then
		RemoveAbilityAndModifier(caster,'is_shaman')
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end
function AddDwarf(keys)
	local caster = keys.caster
	if caster:IsHero() ~= true and caster:Script_GetAttackRange() > 205 then
		AddAbilityAndSetLevel(caster,'is_dwarf',1)
		caster:FindAbilityByName('is_dwarf'):SetHidden(true)
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end
function RemoveDwarf(keys)
	local caster = keys.caster
	if FindValueInTable(_G.chess_list_by_synergy['is_dwarf'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman['is_dwarf'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_ban_unavailable['is_dwarf'],GetUnitBaseName(caster)) ~= true  then
		RemoveAbilityAndModifier(caster,'is_dwarf')
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end
function AddAqir(keys)
	local caster = keys.caster
	if caster:IsHero() ~= true then
		AddAbilityAndSetLevel(caster,'is_aqir',1)
		caster:FindAbilityByName('is_aqir'):SetHidden(true)
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end
function RemoveAqir(keys)
	local caster = keys.caster
	if FindValueInTable(_G.chess_list_by_synergy['is_aqir'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_black_and_pandaman['is_aqir'],GetUnitBaseName(caster)) ~= true and FindValueInTable(_G.chess_list_by_synergy_ban_unavailable['is_aqir'],GetUnitBaseName(caster)) ~= true then
		RemoveAbilityAndModifier(caster,'is_aqir')
		if _G.game_status ~= 2 then
			StatClassCount(caster:GetTeam())
		end
	end
end

function ShowAbility(keys)
	local target = keys.target

	if target == nil then
		return
	end
	for i=0,23 do
		if target:GetAbilityByIndex(i) ~= nil then
			print(i..'-->'..target:GetAbilityByIndex(i):GetAbilityName()..'-->'..target:GetAbilityByIndex(i):GetLevel())
		end
	end

	local all_modifier = target:FindAllModifiers()
	for _,m in pairs(all_modifier) do
		print(m:GetName())
	end

	print('is_in_battle:'..tostring(target.is_in_battle or 'nil'))

	ChessAI(target,0.01)
end

function DisarmChess(keys)
	local target = keys.target
	local caster = keys.caster
	local team_id = target.team_id

	if string.find(target:GetUnitName(),'chess_') == nil then
		return
	end
	if team_id == nil or team_id == 4 or team_id ~= caster:GetTeam() then
		return
	end

	if target.is_removing == true then
		return
	end	

	if (GetTime().phase == GAME_PHASE_BATTLE and target.hand_index == nil) or (GetTime().phase == GAME_PHASE_PREPARE and GetTime().left < 2 and target.hand_index == nil) then
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_cannot_delete_battle_chess"
		})
		EmitSoundOn("General.CastFail_NoMana",caster)
		return
	end

	--清空物品table
	-- for _,c in pairs (_G.mychess[team_id]) do
	-- 	if c.index == target:entindex() then
	-- 		c.item = {}
	-- 	end
	-- end
	local item_count = DropChessItem({
		target = target
	})

	--恢复原始弹道
	local units_kv = LoadKeyValues("scripts/npc/npc_units_custom.txt")
	if units_kv[target:GetUnitName()] ~= nil then
		local ori_proj = units_kv[target:GetUnitName()]["ProjectileModel"]
		if ori_proj ~= nil then
			target:SetRangedProjectileName(ori_proj)
		end
	end

	InitChessMana(target)

	if item_count > 0 then
		target:StartGesture(ACT_DOTA_SPAWN)
		EmitSoundOn("dac.disarm_chess",target)
		caster:FindAbilityByName('disarm_chess'):SetActivated(false)
	else
		CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"mima",{
			key = GetClientKey(caster:GetTeam()),
			text = "text_mima_no_item_to_disarm"
		})
		EmitSoundOn("General.CastFail_NoMana",caster)
	end
end

function DropChessItem(keys)
	local target = keys.target
	local item_count = 0
	if target == nil or IsUnitExist(target) == false then
		return
	end
	for slot=0,8 do
		if target:GetItemInSlot(slot)~= nil then
			local item = target:GetItemInSlot(slot)
			local item_name = item:GetAbilityName()

			if item_name == 'item_silingshu_2' or item_name == 'item_silingshu_3' then
				item_name = 'item_silingshu'
			end

			if item:IsPermanent() == true then
				--永久物品，丢出来
				local newItem = CreateItem( item_name, target, target )
				local drop = CreateItemOnPositionForLaunch(target:GetAbsOrigin(), newItem )
				local dropRadius = RandomFloat( 50, 200 )
				newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, target:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
				target:RemoveItem(target:GetItemInSlot(slot))
				item_count = item_count + 1
			else
				--消耗品，按charges丢出来
				local charges = item:GetCurrentCharges()
				for i=1,charges do
					local newItem = CreateItem( item_name, target, target )
					local drop = CreateItemOnPositionForLaunch(target:GetAbsOrigin(), newItem )
					local dropRadius = RandomFloat( 50, 200 )
					newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, target:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
				end
				target:RemoveItem(target:GetItemInSlot(slot))
				item_count = item_count + 1
			end
		end
	end

	return item_count
end


function DAC:_GoldDropConsoleCommand( cmdName, goldToDrop )
	local newItem = CreateItem( "item_money", nil, nil )
	newItem:SetPurchaseTime( 0 )
	if goldToDrop == nil then goldToDrop = 100 end
	newItem:SetCurrentCharges( goldToDrop )
	local spawnPoint = Vector( 0, 0, 0 )
	local heroEnt = PlayerResource:GetSelectedHeroEntity( 0 )
	if heroEnt ~= nil then
		spawnPoint = heroEnt:GetAbsOrigin()
	end
	local drop = CreateItemOnPositionSync( spawnPoint, newItem )
	newItem:LaunchLoot( true, 300, 0.75, spawnPoint + RandomVector( RandomFloat( 50, 350 ) ) )
end




function EquipPingguo(keys)

	-- for i,_ in pairs(keys) do
	-- 	print(i)
	-- end
end

--在6格物品栏中找到指定的一个物品，返回item对象
function FindItemInInventory(unit, item_name)
	for i = 0,5 do
		local item = unit:GetItemInSlot(i)
		if item and item:GetAbilityName() == item_name then
			return item
		end
	end
end

function DisableItemBagCD(hero)
	if not hero.item_fixer_timer then
		hero.item_fixer_timer = Timers:CreateTimer(0,function()
			for i = 0,5 do
				local item = hero:GetItemInSlot(i)
				if item and item:GetItemState() ~= 1 then
					item:SetItemState(1)
				end
			end
			return 0.3
		end)
	end
end

-- 为AOE技能寻找最佳释放位置
function FindBestGridForCircleAOE(u,a)
	local team_id = u.at_team_id or u.team_id
	local range = 200
	local enemy_count = 0
	local enemy = nil
	local possible_postion = {}
	local target_position = nil

	if RandomInt(1,100)<30 then
		--30%概率随机找敌人
		local unluckydog = FindUnluckyDogRandom(u)
		if unluckydog then
			return unluckydog:GetAbsOrigin()
		else
			return nil
		end
	end

    -- 干扰者、谜团、飞机技能半径
 	if u:FindAbilityByName(a):GetSpecialValueFor('radius') > 0 then
 		range = u:FindAbilityByName(a):GetSpecialValueFor('radius')
	end

	for x=1,8 do
		for y=1,8 do
			local tt = TargetCountForCircleAOE(x,y,u,range)
			local count_temp = tt['count']
			if count_temp > enemy_count then
				enemy_count = count_temp
				possible_postion = {}
				table.insert(possible_postion, XY2Vector(x,y,team_id))
			elseif count_temp == enemy_count and count_temp > 1 then
				table.insert(possible_postion, XY2Vector(x,y,team_id))
			end
			if count_temp == 1 then
				enemy = tt['target']
			end
		end
	end
	
	if enemy_count == 1 and enemy ~= nil then
	-- 当仅能伤害一个敌人时，以该敌人位置为目标
		target_position = enemy:GetAbsOrigin()
	else
	-- 当有多个等效位置时，选择离萨尔最近的位置释放
		-- target_position = possible_postion[RandomInt(1,table.maxn(possible_postion))]
		local min_length2d = 9999
		for _,p in pairs(possible_postion) do
			if (p-u:GetAbsOrigin()):Length2D() < min_length2d then
				min_length2d = (p-u:GetAbsOrigin()):Length2D()
				target_position = p
			end
		end
	end

	return target_position
end

--获取所有能被武僧分担的友军棋子
function GetAllFriendlyChess(u)
	local unit_table = {}
	local team_id = u.at_team_id or u.team_id
	--遍历所有单位
	for _,v in pairs (GetValidChessOnBoard(team_id)) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and IsAttackLowPriority(v) == false and u:entindex() ~= v:entindex() and v.is_youhun ~= true and v:IsInvulnerable() == false and v:HasAbility('is_ward') == false then
			table.insert(unit_table,v)
		end
	end
	return unit_table
end
function GetAllEnemyChess(u)
	local unit_table = {}
	local team_id = u.at_team_id or u.team_id
	--遍历所有单位
	for _,v in pairs (GetValidChessOnBoard(team_id)) do
		if IsUnitExist(v) == true and v:GetTeam() ~= u:GetTeam() and v:HasAbility('is_ward') == false then
			table.insert(unit_table,v)
		end
	end
	return unit_table
end
function FindFriendlyChessesBySynergy(u,s)
	local unit_table = {}
	local team_id = u.at_team_id or u.team_id
	--遍历所有单位
	for _,v in pairs (GetValidChessOnBoard(team_id)) do
		if IsUnitExist(v) == true and v.team_id == u.team_id and IsAttackLowPriority(v) == false and u:entindex() ~= v:entindex() and v:HasAbility(s) == true then
			table.insert(unit_table,v)
		end
	end
	return unit_table
end
function FindRandomChessSpeak(t,fish_chess)
	local unluckydog = nil
	local same_unluckydog = nil
	local try_count = 0
	while same_unluckydog == nil and try_count < 100 do
		local uu = GetValidChessOnBoard(t)[RandomInt(1,table.maxn(GetValidChessOnBoard(t)))]
		if IsUnitExist(uu) == true and uu.team_id == t then
			if uu:HasAbility('is_pandaman') == true then
				unluckydog = uu
			end
			if GetUnitBaseName(uu) == fish_chess and uu:HasAbility('is_pandaman') == true then
				same_unluckydog = uu
			end
		end
		try_count = try_count + 1
	end
	if same_unluckydog == nil then
		same_unluckydog = unluckydog
	end
	return same_unluckydog
end

-- 计算在目标格释放AOE时，能伤害到的单位个数
function TargetCountForCircleAOE(x,y,u,range)
	local team_id = u.at_team_id or u.team_id
	local count = 0
	local target = nil
	--遍历所有单位
	for _,enemy in pairs (GetValidChessOnBoard(team_id)) do
		if IsUnitExist(enemy) and enemy.team_id ~= u.team_id and enemy:IsInvisible() == false and IsAttackLowPriority(enemy) == false then
			local enemy_to_centerpoint = (enemy:GetAbsOrigin() - XY2Vector(x,y,team_id)):Length2D()
			if enemy_to_centerpoint <= range then
				count = count + 1
				if count == 1 then
					target = enemy
				else
					target = nil
				end
			end
		end
	end
	return {
		count = count,
		target = target,
	}
end 

--初始化背刺跳跃：造成可能倍数的暴击伤害
function InitAssassinJump(u)
	local crit_table = {
		is_assassin_buff_plus = {
			[1] = 400,
		},
		is_assassin_buff = {
			[1] = 300,
		},
		phantom_assassin_coup_de_grace = {
			[1] = 300,
			[2] = 450,
			[3] = 600,
		},
		tusk_walrus_punch = {
			[1] = 300,
			[2] = 400,
			[3] = 600,
		},
		mk_ruyibangfa = {
			[1] = 150,
			[2] = 200,
			[3] = 300,
		},
		item_shuijingjian = {
			[1] = 200,
		},
		item_dapao = {
			[1] = 350,
		},
	}

	local max_crit = 0
	local crit_posbility_table = {};

	for a,t in pairs(crit_table) do
		if u:HasAbility(a) then
			local level = u:FindAbilityByName(a):GetLevel() or 1
			local crit = t[level] or 0
			if crit > max_crit then
				max_crit = crit
			end
			table.insert(crit_posbility_table,'modifier_assassin_crit_x'..crit)
		end
	end

	if u:HasAbility('is_assassin_buff_plus_plus') == true then
		--9刺客，取最高的暴击
		u:FindAbilityByName('dac_guai_base'):ApplyDataDrivenModifier(u,u,'modifier_assassin_crit_x'..max_crit,{})
	elseif u:HasAbility('is_assassin_buff_plus') == true or u:HasAbility('is_assassin_buff') == true then
		--3或6刺客，取随机的暴击
		if table.maxn(crit_posbility_table) > 0 then
			local random = crit_posbility_table[RandomInt(1,table.maxn(crit_posbility_table))]
			u:FindAbilityByName('dac_guai_base'):ApplyDataDrivenModifier(u,u,random,{})
		end
	end
end

function RequestBanChess(keys)
	local caster = keys.caster
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_ban_choose",{
		key = GetClientKey(caster:GetTeam()),
		player_id = caster:GetPlayerID(),
		chess_pool = _G.chess_list_by_synergy,
		curr_money = caster:GetMana(),
	})
end
function DAC:OnBanChess(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)
	if hero == nil or hero.synergy_banned ~= nil then
		return
	end
	local synergy = keys.synergy
	local price = (table.maxn(_G.chess_list_by_synergy[synergy])+table.maxn(_G.chess_list_by_synergy_black_and_pandaman[synergy]))*2

	if price <= 0 then
		return
	end

	if hero:HasModifier('modifier_item_free_ban') then
		price = 0
	end
	if hero:GetMana() < price then
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"mima",{
			key = GetClientKey(hero:GetTeam()),
			text = "text_mima_no_mana"
		})
		EmitSoundOn("General.CastFail_NoMana",hero)
		return
	else
		-- EmitSoundOn("dac.popup",hero)
		EmitSoundOn("ui.npe_objective_given",hero)
		CostMana(hero,price)
		hero.synergy_banned = synergy
		hero:RemoveAbility('ban_chess')
		SetStat(hero:GetPlayerID(),'ban_synergy',synergy)
		AddAbilityAndSetLevel(hero,synergy..'_banned')
		hero:FindAbilityByName(synergy..'_banned'):SetActivated(false)
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"ban_chess",{
			key = GetClientKey(hero:GetTeam()),
			synergy = synergy,
		})
		CustomNetTables:SetTableValue( "chess_pool_table", "ban_info_"..hero:GetPlayerID(), { banned_synergy = synergy } )
		--弹幕：ban chess
		CustomGameEventManager:Send_ServerToAllClients("bullet",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			ban = synergy,
		})
		_G.bans = _G.bans..synergy..','
		if _G.egg_quest == 'q028' and price >= 15 then
			SetQuest(hero:GetTeam(),true)
		end
	end
end

function UnbanSynergy(keys)
	local caster = keys.caster
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"show_confirm_unban_synergy",{
		key = GetClientKey(caster:GetTeam()),
		player_id = caster:GetPlayerID(),
	})
	
end

function DAC:OnUnBanSynergy(keys)
	local player_id = keys.PlayerID
	local caster = PlayerId2Hero(player_id)
	local synergy = caster.synergy_banned
	caster.synergy_banned = nil

	if synergy == nil then
		return
	end
	caster:RemoveAbility(synergy..'_banned')
	EmitSoundOn("card.flip",caster)
	AddAbilityAndSetLevel(caster,'ban_chess')
	SetStat(caster:GetPlayerID(),'ban_synergy',nil)	
	CustomGameEventManager:Send_ServerToTeam(caster:GetTeam(),"unban_chess",{
		key = GetClientKey(caster:GetTeam()),
	})
	CustomNetTables:SetTableValue( "chess_pool_table", "ban_info_"..caster:GetPlayerID(), { banned_synergy = nil } )
end

function AddTotalMoneyStat(player_id, money)
	if IsUnitExist(PlayerId2Hero(player_id)) == false then
		return
	end
	local total_money1 = GetStat(player_id,'total_money')
	AddStat(player_id,'total_money',money)
	local total_money2 = GetStat(player_id,'total_money')
	if _G.egg_quest == 'q023' and total_money2 >= 400 then
		SetQuest(PlayerId2Hero(player_id):GetTeam(),true)
	end
end

function UpdateStatUI()
	CustomNetTables:SetTableValue( "player_info_table", "player_info", { data = _G.stat_info, hehe = RandomInt(1,100000)})
end

function GetChessCostByName(c)
	for cost,chess_list in pairs(_G.chess_list_by_mana) do
		for _,chess_name in pairs(chess_list) do
			if chess_name == c then
				return cost
			end
		end
	end
	for cost,chess_list in pairs(_G.chess_list_by_mana_black) do
		for _,chess_name in pairs(chess_list) do
			if chess_name == c then
				return cost
			end
		end
	end
	return nil
end

function IsCombinedItem(item_name)
	if item_name == nil then
		return nil
	end
	for cost,item_cost_table in pairs(_G.COMBINED_ITEM_LIST) do
		for _,item in pairs(item_cost_table) do
			if item == item_name then
				return cost
			end
		end
	end
end

function KillSelfTeam(team,is_false_kill)
	local hero = TeamId2Hero(team)
	if is_false_kill == nil then
		is_false_kill = false
	end
	if is_false_kill ~= true and (IsUnitExist(hero) == false or hero.is_banned == true) then
		return
	end
	if is_false_kill ~= true then
		CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
			player_id = hero:GetPlayerID(),
			win_streak = hero.win_streak or 0,
			vip = hero.is_vip,
			onduty_hero = hero.onduty_hero,
			text = "notice_player_killself",
			time_stamp = math.floor(GameRules:GetGameTime()),
			type = 'player_event',
			emoji = 175,
		})
		if _G.game_status == 2 then
			--战斗回合，延时死亡（避免因为自杀而改变战斗奖励）
			hero.is_banned = true;
			return
		end
	end

	if _G.battle_round < 3 then
		DAC:OnSuggestLiuju({player_id = hero:GetPlayerID()})
	end
	local dur = GameRules:GetGameTime() - _G.START_TIME
	SetStat(hero:GetPlayerID(), 'duration', dur)
	SetStat(hero:GetPlayerID(), 'round', _G.battle_round)
	hero.last_damaged_by_team = nil
	Timers:CreateTimer(0.5,function()
		-- _G.battle_count = _G.battle_count - 1
		SetBattleTable(team,false)
		DamageTeam(team, 999, 'p002')
		--雷击特效和音效
		EmitSoundOn('Hero_Zuus.GodsWrath.Target',hero)
		PlayParticleOnUnitUntilDeath({
			caster = hero,
			p = "particles/econ/items/zeus/arcana_chariot/zeus_arcana_thundergods_wrath_start_bolt_parent.vpcf",
		})
		if _G.p2_mode == true and GetP2Ally(team) ~= nil then
			--2P模式，队友分担伤害
			SetStat(TeamId2Hero(GetP2Ally(team)):GetPlayerID(), 'duration', dur)
			SetStat(TeamId2Hero(GetP2Ally(team)):GetPlayerID(), 'round', _G.battle_round)
			-- _G.battle_count = _G.battle_count - 1
			SetBattleTable(GetP2Ally(team),false)
			DamageTeam(GetP2Ally(team), 999, 'p002')
		end
	end)
end

function MkAttack(keys)
	local caster = keys.caster
	-- StartAnimation(caster, {duration=1, activity=ACT_DOTA_ATTACK, rate=1, translate="attack_normal_range"})
	caster:AddActivityModifier('attack_normal_range')
	caster:StartGestureWithPlaybackRate(ACT_DOTA_ATTACK,caster:GetAttacksPerSecond()*1.2)
end

function MarsAttack(keys)
	local caster = keys.caster
	if caster:HasAbility("mars_bulwark_attack") and caster:FindAbilityByName("mars_bulwark_attack"):GetCooldownTimeRemaining() == 0 and caster:IsSilenced() == false and caster:IsStunned() == false and caster:IsFrozen() == false and caster:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and caster:HasModifier('modifier_vs_swap_debuff') == false and caster:IsHexed() == false and caster:IsCommandRestricted() == false and caster:HasModifier("modifier_axe_berserkers_call") == false and caster.is_moving ~= true then
		caster:Stop()
		StartMarsShieldCD(caster)
		caster:StartGesture(ACT_DOTA_CAST_ABILITY_4)
		
		MarsShieldDamage({
			caster = caster,
			ability = caster:FindAbilityByName("mars_bulwark_attack"),
		})
		local p = "particles/units/heroes/hero_mars/mars_shield_bash.vpcf"
		if caster:FindAbilityByName("mars_bulwark_attack"):GetLevel() >= 3 then
			p = "particles/econ/items/mars/mars_fall20_immortal_shield/mars_fall20_immortal_shield_bash.vpcf"
		end
		
		Timers:CreateTimer(0.4,function()
			play_particle(p,PATTACH_ABSORIGIN_FOLLOW,caster,3)
			EmitSoundOn("Hero_Mars.Shield.Cast",caster)
		end)
	else
		--普通攻击
		caster:AddActivityModifier('attack_close_range')
		caster:AddActivityModifier('faster')
		caster:StartGestureWithPlaybackRate(ACT_DOTA_ATTACK,caster:GetAttacksPerSecond()*3)
	end
end

function QopAttack(keys)
	local caster = keys.caster
	-- StartAnimation(caster, {duration=1, activity=ACT_DOTA_ATTACK, rate=1, translate="attack_normal_range"})
	caster:AddActivityModifier('close')
	caster:StartGestureWithPlaybackRate(ACT_DOTA_ATTACK,caster:GetAttacksPerSecond()*1.2)
end

function Bangjidadi(keys)
	local caster = keys.caster
	local target = keys.target
	if caster:FindModifierByName('modifier_mk_ruyibangfa_stack') ~= nil then
		local count = caster:FindModifierByName('modifier_mk_ruyibangfa_stack'):GetStackCount()
		caster:FindModifierByName('modifier_mk_ruyibangfa_stack'):SetStackCount(count+1)
	else
		caster:FindAbilityByName('mk_ruyibangfa'):ApplyDataDrivenModifier(caster,caster,'modifier_mk_ruyibangfa_stack',{})
		if caster:FindModifierByName('modifier_mk_ruyibangfa_stack') then caster:FindModifierByName('modifier_mk_ruyibangfa_stack'):SetStackCount(1) end
	end
end

function Add6BeastDebuff(keys)
	local ability = keys.ability
	local caster = keys.caster
	local target = keys.target
	if IsUnitExist(target) and IsUnitExist(caster) then
		if target:FindModifierByName('modifier_is_beast_debuff_plus_plus') ~= nil then
			local count = target:FindModifierByName('modifier_is_beast_debuff_plus_plus'):GetStackCount()
			if target:FindModifierByName('modifier_is_beast_debuff_plus_plus') ~= nil then
				target:FindModifierByName('modifier_is_beast_debuff_plus_plus'):SetStackCount(count+1)
			end
		else
			ability:ApplyDataDrivenModifier(caster,target,'modifier_is_beast_debuff_plus_plus',{})
			if target:FindModifierByName('modifier_is_beast_debuff_plus_plus') ~= nil then
				target:FindModifierByName('modifier_is_beast_debuff_plus_plus'):SetStackCount(1)
			end
		end
	end
end
--土猫：巨石翻滚
function EarthStartRockRoll(keys)
	local caster = keys.caster
	if IsUnitExist(caster) == false then
		return
	end
	local team_id = caster:GetTeam()
	local at_team_id = caster.at_team_id or team_id
	local ability = keys.ability
	if ability == nil then
		return
	end
	local level = ability:GetLevel() or 1
	local roll_count = ability:GetLevelSpecialValueFor( "roll_count", level - 1 )

	Timers:CreateTimer(0.5,function()
		if roll_count > 0 and caster:HasModifier('modifier_earth_rock_roll') then
			local x = 0
			local y = 0
			if RandomInt(1,100) < 50 then
				x = GetRandomXHasEnemy(team_id, at_team_id)
			else
				y = GetRandomYHasEnemy(team_id, at_team_id)
			end
			if RandomInt(1,100) < 50 then
				x = -x
				y = -y
			end
			RollAStone(caster,at_team_id,x,y,level)
			roll_count = roll_count - 1
			return 1
		else
			return
		end
	end)
end

function GetRandomXHasEnemy(team_id, at_team_id)
	local lucky_x = 0
	local try_count = 0
	while try_count < 100 and lucky_x == 0 do
		local random_x = RandomInt(1,8)
		for _,enemy in pairs (GetValidChessOnBoard(at_team_id)) do
			if IsUnitExist(enemy) == true and enemy.team_id ~= team_id and enemy.x == random_x then
				lucky_x = random_x
			end
		end
		try_count = try_count + 1
	end
	return lucky_x
end
function GetRandomYHasEnemy(team_id, at_team_id)
	local lucky_y = 0
	local try_count = 0
	while try_count < 100 and lucky_y == 0 do
		local random_y = RandomInt(1,8)
		for _,enemy in pairs (GetValidChessOnBoard(at_team_id)) do
			if IsUnitExist(enemy) == true and enemy.team_id ~= team_id and enemy.y == random_y then
				lucky_y = random_y
			end
		end
		try_count = try_count + 1
	end
	return lucky_y
end

--土猫：滚一个石头
function RollAStone(owner,at_team_id,x,y,level)
	if owner == nil then
		return 
	end
	local team_id = owner:GetTeam()
	if x == nil then
		x = 0 
	end
	if y == nil then
		y = 0 
	end
	if x ~= 0 then
		y = 0
	end
	if y ~= 0 then
		x = 0
	end
	if x == 0 and y == 0 then
		x = RandomInt(1,8)
	end

	if at_team_id == nil then
		at_team_id = team_id
	end
	if level == nil then
		level = 1
	end
	if level > 3 then
		level = 3
	end

	local stone_particle = 'effect/earth/roll/1.vpcf'
	if level == 3 then
		stone_particle = 'particles/econ/items/earth_spirit/earth_spirit_ti6_boulder/espirit_ti6_rollingboulder.vpcf'
	end

	local start_position = nil
	local end_position = nil
	if y == 0 and x > 0 then
		start_position = XY2Vector(x,0,at_team_id)
		end_position = XY2Vector(x,9,at_team_id)
	end
	if y == 0 and x < 0 then
		start_position = XY2Vector(-x,9,at_team_id)
		end_position = XY2Vector(-x,0,at_team_id)
	end
	if x == 0 and y > 0 then
		start_position = XY2Vector(0,y,at_team_id)
		end_position = XY2Vector(9,y,at_team_id)
	end
	if x == 0 and y < 0 then
		start_position = XY2Vector(9,-y,at_team_id)
		end_position = XY2Vector(0,-y,at_team_id)
	end

	if start_position ~= nil and end_position ~= nil then
		local invisible_unit = CreateUnitByName("invisible_unit", start_position ,false,nil,nil, team_id) 
		invisible_unit:SetForwardVector(end_position - start_position)
		invisible_unit:SetOwner(owner)
		invisible_unit.damage_owner = owner
		local pp = ParticleManager:CreateParticle(stone_particle, PATTACH_ABSORIGIN_FOLLOW, invisible_unit)
		ParticleManager:SetParticleControlEnt( pp, 10, invisible_unit, PATTACH_ABSORIGIN_FOLLOW, nil, Vector(0,1,0), true )
		invisible_unit.roll_particle = pp
		EmitSoundOn('Hero_EarthSpirit.RollingBoulder.Loop',invisible_unit)
		Timers:CreateTimer(0.5,function()
			--开始滚
			invisible_unit:AddNewModifier(invisible_unit,nil,"modifier_run",
			{
				vx = end_position.x,
				vy = end_position.y,
				speed = 800,
			})

			Timers:CreateTimer(0.2,function()
				if IsUnitExist(invisible_unit) == false then
					StopSoundEvent( 'Hero_EarthSpirit.RollingBoulder.Loop', invisible_unit )
					return
				end

				--判断砸中敌人
				if _G.to_be_destory_list[at_team_id] ~= nil and table.maxn(GetValidChessOnBoard(at_team_id)) > 0 then
					for _,enemy in pairs (GetValidChessOnBoard(at_team_id)) do
						if IsUnitExist(enemy) == true and enemy.team_id ~= team_id and (invisible_unit:GetAbsOrigin() - enemy:GetAbsOrigin()):Length2D() < 100 then
							--砸中enemy
							if enemy:HasModifier('modifier_earth_rock_one_debuff') and (enemy.earth_rock_one_debuff_index == nil or enemy.earth_rock_one_debuff_index == invisible_unit:entindex()) then
								--重复砸中的，啥也不做
							elseif enemy:IsMagicImmune() == true then
								--魔法免疫的，啥也不做
							else
								--击晕+物理伤害
								local earth = invisible_unit.damage_owner
								enemy.earth_rock_one_debuff_index = invisible_unit:entindex()
								local ability = earth:FindAbilityByName('earth_rock_roll')
								local level = ability:GetLevel()
								local stun_duration = ability:GetLevelSpecialValueFor( "stun_duration", level - 1 )
								local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
								ability:ApplyDataDrivenModifier(invisible_unit,enemy,'modifier_earth_rock_one_debuff',{duration = stun_duration})
								ApplyDamage({
							    	victim = enemy,
							    	attacker = earth,
							    	damage_type = DAMAGE_TYPE_PHYSICAL,
							    	damage = damage,
							    	ability = ability,
							    })
							    EmitSoundOn('Hero_EarthSpirit.RollingBoulder.Target', enemy)
							end
						end
					end
				end

				--判断到达
				if (invisible_unit:GetAbsOrigin() - end_position):Length2D() < 50 then
					if pp ~= nil and IsUnitExist(invisible_unit) == true then
						ParticleManager:DestroyParticle(pp,false)
					end
					Timers:CreateTimer(3,function()
						if IsUnitExist(invisible_unit) == true then
							invisible_unit:ForceKill(false)
							invisible_unit:Destroy()
						end
					end)
					if IsUnitExist(invisible_unit) == true then
						EmitSoundOn('Hero_EarthSpirit.RollingBoulder.Destroy', invisible_unit)
						StopSoundEvent( 'Hero_EarthSpirit.RollingBoulder.Loop', invisible_unit)
					end
					return
				end
				return 0.2
			end)
		end)
	end

	
end

function AddDrShooterAura(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	for _,unit in pairs(GetValidChessOnBoard(at_team_id)) do
		local enemy_team_id = 4
		if unit:GetTeam() == 4 then
			enemy_team_id = unit.at_team_id
		end
		if IsUnitExist(unit) and unit.team_id == team_id and unit:Script_GetAttackRange() > 205 and IsLonely4Team(unit,enemy_team_id) == true then --and unit:entindex() ~= caster:entindex()
			if unit:HasModifier('modifier_shooter_buff') == false then
				--没有射手光环，直接添加
				keys.ability:ApplyDataDrivenModifier(caster,unit,'modifier_shooter_buff',{ })
			else
				--已有射手光环
				local m = unit:FindModifierByName('modifier_shooter_buff')
				if m ~= nil then
					if m:GetAbility():GetLevel() < ability_level then
						unit:RemoveModifierByName('modifier_shooter_buff')
						keys.ability:ApplyDataDrivenModifier(caster,unit,'modifier_shooter_buff',{ })
					end
				end
			end
		end
	end
end

function RemoveDrShooterAura(keys)
	local caster = keys.caster
	local ability_level = keys.ability:GetLevel()
	local at_team_id = caster.at_team_id or caster.team_id
	local team_id = caster.team_id

	for _,unit in pairs(GetValidChessOnBoard(at_team_id)) do
		
		if unit.team_id == team_id and unit:FindModifierByNameAndCaster('modifier_shooter_buff',caster) ~= nil then
			unit:RemoveModifierByNameAndCaster('modifier_shooter_buff',caster)
		end
	end
end

function ThinkDrShooterAura(keys)
	local caster = keys.caster
	local target = keys.target

	local enemy_team_id = 4
	if target:GetTeam() == 4 then
		enemy_team_id = target.at_team_id
	end
	if IsLonely4Team(target,enemy_team_id) == false then
		--有敌人近身了
		target:RemoveModifierByNameAndCaster('modifier_shooter_buff',caster)
	end
end

function BrewSSR3Pandas(keys)
	local caster = keys.caster
	local items = GetAllItemsInUnits({[1] = caster})

	if IsUnitExist(caster) == true and caster.tuihua ~= true then
		caster.tuihua = true
		--生成三只熊猫
		Timers:CreateTimer(0,function()
			local x = SummonOneMinion(caster,'chess_earth1')
			x:SetMana(0)
			FillEmptySlot(x)
			ExtendBeastBuff(x,caster)
			AddChessAbility(x,2)
			AddAbilityAndSetLevel(x,'jiaoxie_wudi')
			Timers:CreateTimer(0.1,function()
				local x = SummonOneMinion(caster,'chess_ember1')
				x:SetMana(0)
				FillEmptySlot(x)
				ExtendBeastBuff(x,caster)
				AddChessAbility(x,2)
				AddAbilityAndSetLevel(x,'jiaoxie_wudi')
				Timers:CreateTimer(0.2,function()
					local x = SummonOneMinion(caster,'chess_storm1')
					x:SetMana(0)
					FillEmptySlot(x)
					ExtendBeastBuff(x,caster)
					AddChessAbility(x,2)
					AddAbilityAndSetLevel(x,'jiaoxie_wudi')
					Timers:CreateTimer(0.2,function()
						local x = SummonOneMinion(caster,'chess_void1')
						x:SetMana(0)
						FillEmptySlot(x)
						ExtendBeastBuff(x,caster)
						AddChessAbility(x,2)
						AddAbilityAndSetLevel(x,'jiaoxie_wudi')
					end)
				end)
			end)
		end)

		--销毁酒仙
		RemoveFromToBeDestroyList(caster)
		AddAbilityAndSetLevel(caster,'no_selectable')

		Timers:CreateTimer(1,function()
			if IsUnitExist(caster) == true then
				if caster.team_id ~= 4 then
					SaveItem(caster.team_id,caster:entindex(),function()
						caster:Destroy()
					end)
				else
					caster:Destroy()
				end
			end
		end)
	end
end

function QOPSonicWave(keys)
	local caster = keys.caster
	local p = keys.target_points[1]
	local ability = keys.ability
	local level = ability:GetLevel()
	local speed = ability:GetLevelSpecialValueFor( "speed", level - 1 )
	local forwardVec = p - caster:GetAbsOrigin()


	local speed = ability:GetLevelSpecialValueFor( "speed", level - 1 )
	local starting_aoe = ability:GetLevelSpecialValueFor( "starting_aoe", level - 1 )
	local final_aoe = ability:GetLevelSpecialValueFor( "final_aoe", level - 1 )

	local effect_name = 'particles/units/heroes/hero_queenofpain/queen_sonic_wave.vpcf'
	if level >= 3 then
		effect_name = 'particles/econ/items/queen_of_pain/qop_arcana/qop_arcana_sonic_wave.vpcf'
	end

	local projectileTable =
	{
		Source = caster,
		Ability = ability,
		EffectName = effect_name,
		vSpawnOrigin = caster:GetOrigin(),
		fDistance = 900,
		vVelocity = (p-caster:GetAbsOrigin()):Normalized() * 1100,
		fStartRadius = starting_aoe,
		fEndRadius = final_aoe,
		iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
		iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_SPELL_IMMUNE_ENEMIES,
		iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
		bReplaceExisting = false,
		bProvidesVision = false,
	}
	local projectileID = ProjectileManager:CreateLinearProjectile( projectileTable )
end

function KunkkaShip(keys)
	local caster = keys.caster
	local p = keys.target_points[1]
	local damage = keys.damage
	local ghostship_speed = keys.ghostship_speed
	local stun_duration = keys.stun_duration
	local ghostship_width = keys.ghostship_width
	local ghostship_distance = keys.ghostship_distance or 2000
	local ability = keys.ability
	local level = ability:GetLevel()

	local ship_particle = "particles/units/heroes/hero_kunkka/kunkka_ghost_ship.vpcf"
	local marker_particle = "particles/units/heroes/hero_kunkka/kunkka_ghostship_marker.vpcf"
	if level >= 3 then
		ship_particle = "particles/econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship.vpcf"
		marker_particle = "particles/econ/items/kunkka/kunkka_immortal/kunkka_immortal_ghost_ship_marker.vpcf"
	end
	if caster:GetUnitName() == 'chess_rubick' or caster:GetUnitName() == 'chess_rubick1' or caster:GetUnitName() == 'chess_rubick11' then
		ship_particle = "particles/econ/items/rubick/rubick_arcana/rbck_arc_kunkka_ghost_ship.vpcf"
	end

	if level >= 3 then
		EmitSoundOn("chess_kunkka.ship_bell_shark",caster)
		EmitSoundOn("chess_kunkka.ship_run",caster)
	else
		EmitSoundOn("chess_kunkka.ship_bell",caster)
		EmitSoundOn("chess_kunkka.ship_run",caster)
	end

	local start_point = p + ((caster:GetOrigin()-p):Normalized() * ghostship_distance)
	ProjectileManager:CreateLinearProjectile( {
		Source = caster,
		Ability = nil,
		EffectName = ship_particle,
		vSpawnOrigin = start_point,
		fDistance = ghostship_distance,
		vVelocity = (p-caster:GetOrigin()):Normalized() * ghostship_speed,
		fStartRadius = ghostship_width,
		fEndRadius = ghostship_width,
		iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
		iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_SPELL_IMMUNE_ENEMIES,
		iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
		bReplaceExisting = false,
		bProvidesVision = false,
	} )

	local ppp = ParticleManager:CreateParticle(marker_particle, PATTACH_WORLDORIGIN ,nil)
    ParticleManager:SetParticleControl(ppp, 0, p)


	local duration = 1.0*ghostship_distance/ghostship_speed
	Timers:CreateTimer(duration, function()
		if level >= 3 then
			EmitSoundOn("chess_kunkka.ship_crash_shark",caster)
		else
			EmitSoundOn("chess_kunkka.ship_crash",caster)
		end
		if ppp ~= nil then
            ParticleManager:DestroyParticle(ppp,true)
        end
	end)
	
	ApplyDamageInRadius({
		delay = duration,
		caster = caster,
		team = caster.team_id,
		radius = ghostship_width,
		role = 2,
		position = p,
		damage = damage,
		damage_type = DAMAGE_TYPE_MAGICAL,
		stun_duration = stun_duration,
		ability = "kunkka_ship",
		ability_entity = ability,
	})
end

function AddLinKen(keys)
	local caster = keys.caster
	if IsUnitExist(caster) == true and caster:IsHero() == false and caster:HasModifier("modifier_item_sphere_target") == false then
		caster:AddNewModifier(caster,FindItemAbility(caster,'item_linkenfaqiu'),"modifier_item_sphere_target",{})
	end
end
function RemoveLinKen(keys)
	local caster = keys.caster
	if caster:HasModifier("modifier_item_sphere_target") == true then
		caster:RemoveModifierByName("modifier_item_sphere_target")
	end
end
function ThinkLinKen(keys)
	local caster = keys.caster
	local ability = keys.ability
	if IsUnitExist(caster) == true and caster:IsHero() == false and caster:HasModifier("modifier_item_sphere_target") == false then
		if ability.cd == nil then
			ability.cd = true
			ability:StartCooldown(3)
		else
			if ability:IsCooldownReady() == true then
				--冷却好了，加上buff
				ability.cd = nil
				caster:AddNewModifier(caster,nil,"modifier_item_sphere_target",{})
			else
				return
			end
		end
	end
end


function FindChessInGrid(teamid,x,y)
	local chess = nil
	for i,v in pairs(GetValidChessOnBoard(teamid)) do
		if v.x == x and v.y == y then
			chess = v
		end
	end
	return chess
end
function FindEnemyInGrid(teamid,x,y,at_team_id)
	local chess = nil
	for i,v in pairs(GetValidChessOnBoard(at_team_id)) do
		if IsUnitExist(v) == true and v.x == x and v.y == y and v:GetTeam() ~= teamid then
			chess = v
		end
	end
	return chess
end
function FindGouheDirection(es)
	local at_team_id = es.at_team_id or es.team_id
	local position = es:GetAbsOrigin()
	local directions = {
		[1] = {x=1,y=0},
		[2] = {x=1,y=1},
		[3] = {x=1,y=-1},
		[4] = {x=-1,y=0},
		[5] = {x=-1,y=1},
		[6] = {x=-1,y=-1},
		[7] = {x=0,y=-1},
		[8] = {x=0,y=1},
	}
	local x = Vector2X(position,at_team_id)
	local y = Vector2Y(position,at_team_id)
	local return_direction = nil
	local max_enemy = 0
	for i,v in pairs(directions) do
		local direction_length = 1
		local x0 = x + v.x
		local y0 = y + v.y
		local count_enemy = 0
		while IsIn8x8(x0,y0) == true do
			if FindEnemyInGrid(es:GetTeam(),x0,y0,at_team_id) ~= nil then
				count_enemy = count_enemy + 1
			end
			x0 = x0 + v.x
			y0 = y0 + v.y
			direction_length = direction_length + 1
		end
		if count_enemy > 0 and max_enemy < count_enemy + (direction_length*0.1) then
			max_enemy = count_enemy + (direction_length*0.1)
			return_direction = v
		end
	end
	return return_direction
end
function TpSeedThink(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	if ability == nil then
		return
	end
	local level = ability:GetLevel()
	local radius = ability:GetLevelSpecialValueFor( "radius", level - 1 )
	local damage = ability:GetLevelSpecialValueFor( "damage_heal", level - 1 )

	if IsUnitExist(target) == false or ability == nil then
		return
	end
	ApplyDamage({
    	victim = target,
    	attacker = caster,
    	damage_type = DAMAGE_TYPE_MAGICAL,
    	damage = damage,
    	ability = ability,
    })

	for _,unit in pairs (GetValidChessOnBoard(target.at_team_id or target.team_id)) do
		local dd = (target:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D()
		if dd < radius and unit.team_id ~= target.team_id then
			TpSeedHeal(target,unit,ability)
		end
	end
end

function TpSeedCast(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()

	if BlockByLinken(target) == false then
		local pp = ParticleManager:CreateParticle('particles/units/heroes/hero_treant/treant_leech_seed.vpcf', PATTACH_ABSORIGIN_FOLLOW, caster)
		ParticleManager:SetParticleControlEnt( pp, 0, caster, PATTACH_ABSORIGIN_FOLLOW, nil, caster:GetOrigin(), true )
		ParticleManager:SetParticleControlEnt( pp, 1, target, PATTACH_ABSORIGIN_FOLLOW, nil, target:GetOrigin(), true )
		Timers:CreateTimer(2,function()
			if pp ~= nil then
		        ParticleManager:DestroyParticle(pp,true)
		    end
	    end)
	else
		--被林肯挡了
		if target:HasModifier('modifier_tp_seed_debuff') then
			target:RemoveModifierByName('modifier_tp_seed_debuff')
		end
	end
end

function TpSeedHeal(from,to,ability)
	ProjectileManager:CreateTrackingProjectile({
        Target = to,
        Source = from,
        Ability = ability,
        EffectName = 'particles/units/heroes/hero_treant/treant_leech_seed_projectile.vpcf',
        bDodgeable = false,
        iMoveSpeed = 450,
        bProvidesVision = false,
        iVisionRadius = 0,
        iVisionTeamNumber = to:GetTeamNumber(),
        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
    })
    local level = ability:GetLevel()
    local heal = ability:GetLevelSpecialValueFor( "damage_heal", level - 1 )
    local duration = (from:GetAbsOrigin() - to:GetAbsOrigin()):Length2D() / 450.0
    Timers:CreateTimer(duration, function()
    	to:Heal(heal, to)
    	-- AMHC:CreateNumberEffect(to,heal,2,AMHC.MSG_MISS,{0,255,0},0)
    end)
end

function BlockByLinken(target)
	for slot=0,5 do
		if target:GetItemInSlot(slot)~= nil then
			local ability = target:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == 'item_linkenfaqiu' and ability:IsCooldownReady() == true then
				target:RemoveModifierByName("modifier_item_sphere_target")
				ability.cd = true
				ability:StartCooldown(5)
				
				play_particle("particles/items_fx/immunity_sphere_2.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
				EmitSoundOn("item.linken",target)
				return true
			end
		end
	end

	return false
end

function RefreshAssassinJump(keys)
	local caster = keys.caster

	--9刺客，重置背刺跳跃
	if IsUnitExist(caster) and  caster:HasModifier('modifier_is_assassin_buff_plus_plus') == true then
		caster.has_assassin_blink = true
		AddAbilityAndSetLevel(caster,'jiaoxie')
	end
end

function SbBash(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local stun = ability:GetLevelSpecialValueFor( "stun", level - 1 )

	local vec = (target:GetAbsOrigin()-caster:GetAbsOrigin()):Normalized()
	local deltax = math.floor(vec.x+0.5)
	local deltay = math.floor(vec.y+0.5)

	local team_id = target.at_team_id or target.team_id
	if target == nil or target:IsNull() == true or target.x == nil or target.y == nil then return end
	local y = target.y
	local x = target.x

	if IsIn8x8(x+deltax,y+deltay) == true and IsEmptyGrid(team_id,x+deltax,y+deltay) == true and not target:HasModifier('modifier_tuitui') and target:HasMovementCapability() == true then
		local target_pos = XY2Vector(x+deltax,y+deltay,team_id)
		local stun_duration = ((target_pos-target:GetAbsOrigin()):Length2D()/1000)
		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration+stun})

		_G.unit[team_id][(y+deltay)..'_'..(x+deltax)] = 1
		target.is_moving = true
		BlinkChessX({p=target_pos,caster=target,blink_type='tuitui'})
		target.y_x = (y+deltay)..'_'..(x+deltax)
		target.y = y+deltay
		target.x = x+deltax
		_G.unit[team_id][y..'_'..x] = nil
	else
		target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun})
	end

	Timers:CreateTimer(0.1,function()
		ApplyDamage({
	    	victim = target,
	    	attacker = caster,
	    	damage_type = DAMAGE_TYPE_PHYSICAL,
	    	damage = damage,
			ability = ability,
	    })
	end)
end

function GetAnimation(n)
	local animation_list = _G.animation_list
	if animation_list == nil then
		return 'n000'
	end
	if animation_list ~= nil and animation_list[n] ~= nil then
		return animation_list[n]
	else
		return animation_list[animation_list['default_animation']]
	end
end

function FindFriendlyChessesByName(caster,chessname)
	local t = {}
	local teamid = caster.team_id
	local atteamid = caster.at_team_id or caster.team_id
	for i,v in pairs(GetValidChessOnBoard(atteamid)) do
		if string.find(v:GetUnitName(),chessname) ~= nil and teamid == v.team_id then
			table.insert(t,v)
		end
	end
	return t
end

function FindEnemyChessesByName(caster,chessname)
	local t = {}
	local teamid = caster.team_id
	local atteamid = caster.at_team_id or caster.team_id
	if _G.to_be_destory_list[atteamid] ~= nil then 
		for i,v in pairs(GetValidChessOnBoard(atteamid)) do
			if IsUnitExist(v) == true and string.find(v:GetUnitName(),chessname) ~= nil and teamid ~= v.team_id then
				table.insert(t,v)
			end
		end
	end
	return t
end

function MeepoPoofOuter(keys)
	local c = keys.caster
	local a = keys.ability
	local t = keys.target
	local level = a:GetLevel()
	local meepos = FindFriendlyChessesByName(c,'chess_meepo')
	if table.maxn(meepos) > 0 then
		for _,m in pairs(meepos) do
			if m:HasModifier('modifier_axe_berserkers_call') == false and m:FindModifierByName('modifier_doom_bringer_doom') == nil and IsHexxed(m) == false and m:FindModifierByName('modifier_medusa_stone_gaze_stone') == nil and m:IsSilenced() == false and m:IsStunned() == false and IsChessCanMove(m) then
				m.stop_moving = true
				MeepoPoofOne(c,m,t,a)
			end
		end
	end
end

function MeepoPoofOne(c,m,t,a)
	Timers:CreateTimer(RandomFloat(0.1,0.8),function()
		local p = FindClosestEmptyGrid(t)
		ChangeUnitPosition(m, p, true)
		m.stop_moving = nil

		-- local x = Vector2X(p,m.at_team_id or m.team_id)
		-- local y = Vector2Y(p,m.at_team_id or m.team_id)
		-- local xx = m.x
		-- local yy = m.y
		-- _G.unit[m.at_team_id or m.team_id][y..'_'..x] = 1
		-- m:SetAbsOrigin(p)
		-- m.y_x = y..'_'..x
		-- m.y = y
		-- m.x = x
		-- _G.unit[m.at_team_id or m.team_id][yy..'_'..xx] = nil
 
		local level = a:GetLevel()
		local damage = a:GetLevelSpecialValueFor( "pure_damage", level - 1 )

		ApplyDamageInRadius({
			caster = m,
			team = m.team_id,
			radius = 205,
			role = 2,
			position = p,
			damage = damage,
			damage_type = DAMAGE_TYPE_PURE,
			ability = "poof",
		})
		play_particle("particles/units/heroes/hero_meepo/meepo_poof_end.vpcf",PATTACH_ABSORIGIN_FOLLOW,m,3)
		
	end)
end

function AttackAbilityMagical(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local damage = caster:GetAttackDamage()
	local damage_bonus = caster:GetAverageTrueAttackDamage(target) - ( caster:GetBaseDamageMax() + caster:GetBaseDamageMin() ) / 2

	local team_id = target.at_team_id or target.team_id
	ApplyDamage({
		victim = target, 
		attacker = caster, 
		damage = damage + damage_bonus, 
		damage_type = DAMAGE_TYPE_MAGICAL, 
		damage_flags = DOTA_DAMAGE_FLAG_NONE, 
	})
end

function AttackAbilityPure(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local damage = caster:GetAttackDamage()
	local damage_bonus = caster:GetAverageTrueAttackDamage(target) - ( caster:GetBaseDamageMax() + caster:GetBaseDamageMin() ) / 2

	local team_id = target.at_team_id or target.team_id
	ApplyDamage({
		victim = target, 
		attacker = caster, 
		damage = damage + damage_bonus, 
		damage_type = DAMAGE_TYPE_PURE, 
		damage_flags = DOTA_DAMAGE_FLAG_NONE, 
	})
end

function DemonAttackPure(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local damage = keys.Damage 

	local team_id = target.at_team_id or target.team_id
	ApplyDamage({
		victim = target, 
		attacker = caster, 
		damage = damage*1.15, 
		damage_type = DAMAGE_TYPE_PURE, 
		damage_flags = DOTA_DAMAGE_FLAG_NONE, 
	})
end	
function IsKobold(unit_name)
	local base_name = GetChessBaseName(unit_name)
	return FindValueInTable(_G.chess_list_by_synergy['is_kobold'],base_name)
end
function GetChessBaseName(name)
	if string.find(name,'11') ~= nil then
		name = string.sub(name,1,-2)
	end
	if string.find(name,'1') ~= nil then
		name = string.sub(name,1,-2)
	end
	return name
end
function WardDisarm(keys)
	local c = keys.caster
	local w = FindEnemyChessesByName(c,'disarm_ward')
	if table.maxn(w) > 0 and IsUnitExist(w[1]) == true and RandomInt(1,100) > 90 then
		if w[1]:FindAbilityByName('ward_disarm') ~= nil and w[1]:FindAbilityByName('ward_disarm'):IsCooldownReady() == true then
			if c:IsMagicImmune() == false then
				w[1]:FindAbilityByName('ward_disarm'):StartCooldown(0.5)
				c:AddNewModifier(c,nil,"modifier_pangolier_luckyshot_disarm",{duration = 2})
			    ApplyDamage({
			    	victim = c,
			    	attacker = w[1],
			    	damage_type = DAMAGE_TYPE_PHYSICAL,
			    	damage = 100
			    })
			    --特效、音效
				local effect_name = "particles/econ/items/tinker/tinker_ti10_immortal_laser/tinker_ti10_immortal_laser.vpcf"-- "particles/units/heroes/hero_tinker/tinker_laser.vpcf"
				ProjectileManager:CreateTrackingProjectile({
			        Target = c,
			        Source = w[1],
			        Ability = nil,
			        EffectName = effect_name,
			        bDodgeable = false,
			        iMoveSpeed = 1200,
			        bProvidesVision = false,
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    })
			    EmitSoundOn("tauren.ward.laser",w[1])
			    w[1]:SetForwardVector(c:GetAbsOrigin()-w[1]:GetAbsOrigin())
			end
		end
	end
end
function WardNether(keys)
	local c = keys.caster
	if c:GetUnitName() == 'invisible_unit' then
		--隐藏施法单位，寻找它的真正施法者
		if c.damage_owner ~= nil and IsUnitExist(c.damage_owner) == true and c.ignore_nether_ward ~= true then -- 增加对 ignore_nether_ward  的判断
			c = c.damage_owner
		else
			--找不到的话，就算了！
			return
		end
	end
	local w = FindEnemyChessesByName(c,'nether_ward')

	if table.maxn(w) > 0 and IsUnitExist(w[1]) == true and RandomInt(1,100) <= 20 then
		if w[1]:FindAbilityByName('ward_nether') ~= nil and w[1]:FindAbilityByName('ward_nether'):IsCooldownReady() == true then
			if c:IsMagicImmune() == false then
				w[1]:FindAbilityByName('ward_nether'):StartCooldown(0.5)
				ApplyDamage({
			    	victim = c,
			    	attacker = w[1],
			    	damage_type = DAMAGE_TYPE_MAGICAL,
			    	damage = 300
			    })
				c:AddNewModifier(c,nil,"modifier_silencer_global_silence",{duration = 5})
				--特效、音效
				local effect_name = "particles/econ/items/pugna/pugna_ward_ti5/pugna_ward_attack_heavy_ti_5.vpcf"
				ProjectileManager:CreateTrackingProjectile({
			        Target = c,
			        Source = w[1],
			        Ability = nil,
			        EffectName = effect_name,
			        bDodgeable = false,
			        iMoveSpeed = 1200,
			        bProvidesVision = false,
			        iSourceAttachment = DOTA_PROJECTILE_ATTACHMENT_ATTACK_1
			    })
			    EmitSoundOn("tauren.ward.nether",w[1])
			    w[1]:SetForwardVector(c:GetAbsOrigin()-w[1]:GetAbsOrigin())
				return true
			end
		end
	end
end

function ESGouhe(keys)
	local es = keys.caster
	local team = es.at_team_id or es.team_id
	local point = keys.target_points[1]
	local ability = keys.ability
	local level = ability:GetLevel()
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local duration = ability:GetLevelSpecialValueFor( "duration", level - 1 )
	local stun = ability:GetLevelSpecialValueFor( "stun", level - 1 )

	EmitSoundOn('Hero_EarthShaker.Fissure',es)
	local pp = "particles/units/heroes/hero_earthshaker/earthshaker_fissure.vpcf"
	if level == 3 then
		pp = "particles/econ/items/earthshaker/earthshaker_ti9/earthshaker_fissure_ti9.vpcf"
	end
	local direction = point - es:GetAbsOrigin()
	local gouhe_table = {}
	local endpoint = point
	while IsIn8x8(Vector2X(endpoint,team),Vector2Y(endpoint,team)) == true do
		table.insert(gouhe_table,{x=Vector2X(endpoint,team),y=Vector2Y(endpoint,team)})
		endpoint = endpoint + direction
	end
	local particle = ParticleManager:CreateParticle(pp, PATTACH_ABSORIGIN, es)
	ParticleManager:SetParticleControl(particle, 0, point)
	ParticleManager:SetParticleControl(particle, 1, endpoint-direction)
	ParticleManager:SetParticleControl(particle, 2, Vector(duration,0,0))
	for i,v in pairs(gouhe_table) do
		if v.x ~= nil and v.y ~= nil then
			local c = FindChessInGrid(team,v.x,v.y)
			if c ~= nil and c:IsNull() ~= true and c:GetAbsOrigin() ~= nil and c:HasMovementCapability() == true then
				local pp = FindClosestEmptyGrid(c)
				local stun_duration = (((pp or c:GetAbsOrigin())-c:GetAbsOrigin()):Length2D()/1000)
				if IsUnitExist(c) and (c:GetTeam() == es:GetTeam() or c:IsMagicImmune() == true) then
					c:AddNewModifier(c,nil,"modifier_stunned",{ duration = stun_duration})
				else
					c:AddNewModifier(c,nil,"modifier_stunned",{ duration = stun_duration+stun})
					-- ApplyDamage({
				 --    	victim = c,
				 --    	attacker = es,
				 --    	damage_type = DAMAGE_TYPE_PHYSICAL,
				 --    	damage = damage,
				 --    	ability = es:FindAbilityByName('gouhe'),
				 --    })
				    ApplyDamageInRadius({
						caster = es,
						team = es:GetTeam(),
						radius = 250,
						role = 2,
						position = c:GetAbsOrigin(),
						damage = damage,
						damage_type = DAMAGE_TYPE_PHYSICAL,
						ability = 'gouhe',
						ability_entity = ability,
					})
				end
				if IsUnitExist(c) then
					c.is_moving = true
					BlinkChessX({p=pp,caster=c,blink_type='tuitui'})
					local xx = Vector2X(pp,team)
					local yy = Vector2Y(pp,team)
					if xx ~= nil and yy ~= nil then
						c.x = xx
						c.y = yy
						c.y_x = yy..'_'..xx
						_G.unit[team][v.y..'_'..v.x] = nil
						_G.unit[team][yy..'_'..xx] = 1
					end
				end
			end
			if _G.unit[team][v.y..'_'..v.x] == nil then
				_G.unit[team][v.y..'_'..v.x] = 1
			else
				_G.unit[team][v.y..'_'..v.x] = _G.unit[team][v.y..'_'..v.x] + 1
			end
			Timers:CreateTimer(duration,function()
				if _G.unit[team][v.y..'_'..v.x] ~= nil and FindChessInGrid(team,v.x,v.y) == nil then
					if _G.unit[team][v.y..'_'..v.x] <= 1 then
						_G.unit[team][v.y..'_'..v.x] = nil
					else
						_G.unit[team][v.y..'_'..v.x] = _G.unit[team][v.y..'_'..v.x] - 1
					end
				end
			end)
		end
	end
end

--上古巨神-裂地沟壑
function EarthSplitter(keys)
	local et = keys.caster
	local team = et.at_team_id or et.team_id or et:GetTeam()
	local point = keys.target_points[1]
	local ability = keys.ability
	local level = ability:GetLevel()
	local duration = ability:GetLevelSpecialValueFor( "duration", level - 1 )
	local damage_base = ability:GetLevelSpecialValueFor( "damage_base", level - 1 )
	local damage_per = ability:GetLevelSpecialValueFor( "damage_per", level - 1 )
	local radius = ability:GetLevelSpecialValueFor( "radius", level - 1 )

	EmitSoundOn('Hero_ElderTitan.EarthSplitter.Projectile',et)
	local pp = "particles/units/heroes/hero_elder_titan/elder_titan_earth_splitter.vpcf"

	local direction = point - et:GetAbsOrigin()
	local gouhe_table = {}
	local endpoint = point
	while IsIn8x8(Vector2X(endpoint,team),Vector2Y(endpoint,team)) == true do
		table.insert(gouhe_table, Vector2X(endpoint,team)..'_'..Vector2Y(endpoint,team))
		endpoint = endpoint + direction
	end
	local particle = ParticleManager:CreateParticle(pp, PATTACH_ABSORIGIN, et)
	ParticleManager:SetParticleControl(particle, 0, point)
	ParticleManager:SetParticleControl(particle, 1, endpoint+direction)
	ParticleManager:SetParticleControl(particle, 3, Vector(0,3.5,0))

	local gouhe_table_expand = {}
	for i,v in pairs(gouhe_table) do
		table.insert(gouhe_table_expand,v)
	end

	--扩大一圈范围
	for i,v in pairs(gouhe_table) do
		local x = tonumber(string.split(v,'_')[1])
		local y = tonumber(string.split(v,'_')[2])

		local delta = {
			[1] = {x=1,y=0},
			[2] = {x=-1,y=0},
			[3] = {x=0,y=1},
			[4] = {x=0,y=-1},
		}
		for _,d in pairs(delta) do
			if IsIn8x8(x+d.x,y+d.y) == true and FindValueInTable(gouhe_table_expand,''..(x+d.x)..'_'..(y+d.y)) == false then
				table.insert(gouhe_table_expand,''..(x+d.x)..'_'..(y+d.y))
			end
		end
	end

	Timers:CreateTimer(3,function()
		EmitSoundOn("et.earth_splitter.end",et)
		--遍历每一个格子，拉最近的棋子
		for i,v in pairs(gouhe_table_expand) do
			local x = tonumber(string.split(v,'_')[1])
			local y = tonumber(string.split(v,'_')[2])
			local p = XY2Vector(x,y,team)

			if IsEmptyGrid(team,x,y) == true then
				local enemy_chess = FindClosestEarthSplitterEnemyByGrid(team, x, y, radius, et, gouhe_table, gouhe_table_expand)
				if IsUnitExist(enemy_chess) == true then
					_G.unit[team][enemy_chess.y..'_'..enemy_chess.x] = nil
					enemy_chess.is_moving = true
					BlinkChessX({p=p,caster=enemy_chess,blink_type='tuitui'})
					enemy_chess.x = x
					enemy_chess.y = y
					enemy_chess.y_x = y..'_'..x
					_G.unit[team][y..'_'..x] = 1
					SplitterDamageAndStun(et, ability, enemy_chess, damage_base, damage_per, duration)
				end
			else
				local enemy_chess = FindChessInGrid(team,x,y)
				if IsUnitExist(enemy_chess) == true and et:GetTeam() ~= enemy_chess:GetTeam() then
					SplitterDamageAndStun(et, ability, enemy_chess, damage_base, damage_per, duration)
				end
			end
		end
	end)
end

function SplitterDamageAndStun(et, ability, enemy_chess, damage_base, damage_per, duration)
	ability:ApplyDataDrivenModifier(et,enemy_chess,'modifier_et_earth_splitter_stunned_debuff',{duration = duration})
	local damage = (damage_base + enemy_chess:GetMaxHealth() / 100.0 * damage_per) * 0.5
	ApplyDamageDelay({
		caster = et,
		victim = enemy_chess,
		damage = damage,
		damage_type = DAMAGE_TYPE_MAGICAL,
		delay = 0.5,
		ability = ability,
	})
	ApplyDamageDelay({
		caster = et,
		victim = enemy_chess,
		damage = damage,
		damage_type = DAMAGE_TYPE_PHYSICAL,
		delay = 0.5,
		ability = ability,
	})
end

function FindClosestEarthSplitterEnemyByGrid(at_team_id, x, y, radius, caster, g_table, g_table_expand)
	local enemy = nil
	local min_distance = 9999
	for _,chess in pairs(GetValidChessOnBoard(at_team_id)) do
		if IsUnitExist(chess) == true and caster:GetTeam() ~= chess:GetTeam() and chess:HasMovementCapability() == true then
			local la = true
			if FindValueInTable(g_table, chess.x..'_'..chess.y) == true then
				la = false
			else
				if FindValueInTable(g_table, x..'_'..y) == false and FindValueInTable(g_table_expand, chess.x..'_'..chess.y) == true then
					la = false
				end
			end
			if la then 
				local d = (chess:GetAbsOrigin() - XY2Vector(x,y,at_team_id)):Length2D()
				if d< radius and d < min_distance then
					enemy = chess
					min_distance = d
				end
			end
		end
	end
	return enemy
end

function DAC:ResetFOW(keys)
	local local_player_team = keys.local_player_team
	local target_player_team = keys.target_player_team
	local hero = TeamId2Hero(local_player_team)
	if hero == nil or Entities:FindByName(nil,"center"..(target_player_team-6)) == nil then
		return
	end
	--先删除之前的视野
	if hero.ob_viewer_id ~= nil then
		RemoveFOWViewer(local_player_team, hero.ob_viewer_id)
	end
	--添加新的玩家对应棋盘视野
	hero.ob_viewer_id = AddFOWViewer(local_player_team, Entities:FindByName(nil,"center"..(target_player_team-6)):GetOrigin(), 1000, 9999, false)

	-- prt('ResetFOW:'..target_player_team)
end

function BhShuriken(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability
	local level = ability:GetLevel()
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local ministun = ability:GetLevelSpecialValueFor( "ministun", level - 1 )
	local skip_count = ability:GetLevelSpecialValueFor( "skip_count", level - 1 )

	--伤害和眩晕
	target:AddNewModifier(target,nil,"modifier_stunned",{ duration = ministun})
	ApplyDamage({
    	victim = target,
    	attacker = caster.damage_owner or caster,
    	damage_type = DAMAGE_TYPE_MAGICAL,
    	damage = damage,
    	ability = ability
    })

    if level >= 2 then
    	--弹跳下一个飞镖
    	if caster.damage_owner ~= nil then
    		caster = caster.damage_owner
    	end
    	local next_enemy = FindMinHPEnemy(caster,target)
    	InvisibleUnitCast({
			caster = caster,
			ability = "bh_shuriken",
			level = level - 1,
			unluckydog = next_enemy,
			force_unluckydog = next_enemy,
			caster_position = target:GetAbsOrigin(),
			ignore_nether_ward = true,
		})
    end
end

function FindMinHPEnemy(u,last_target)
	local unluckydog = nil
	local min_hp = 999999
	local last_index = -1
	if last_target ~= nil then
		last_index = last_target:entindex()
	end
	local team = u.at_team_id or u.team_id
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if unit.team_id ~= u.team_id and IsUnitExist(unit) and unit:entindex() ~= last_index and unit:GetHealth() < min_hp then
			unluckydog = unit
			min_hp = unit:GetHealth()
		end
	end
	return unluckydog
end

function FvZhao(keys)
	local caster = keys.caster
	local ability = keys.ability
	local point = keys.target_points[1]
	local duration = ability:GetLevelSpecialValueFor( "duration", ability:GetLevel() - 1 )
	local radius = ability:GetLevelSpecialValueFor( "radius", ability:GetLevel() - 1 )
	caster.is_fv_zhao = true

	--播放特效和音效
	local particle = ParticleManager:CreateParticle('particles/units/heroes/hero_faceless_void/faceless_void_chronosphere.vpcf', PATTACH_ABSORIGIN, caster)
	ParticleManager:SetParticleControl(particle, 0, point)
	ParticleManager:SetParticleControl(particle, 1, Vector(radius-50,radius-50,radius-50))
	Timers:CreateTimer(duration,function()
		caster.is_fv_zhao = nil
		if particle ~= nil then
	        ParticleManager:DestroyParticle(particle,true)
	    end
    end)
    EmitSoundOn("Hero_FacelessVoid.Chronosphere",caster)

    --计时器，每interval秒判断罩子内部的敌人，给interval秒的冻结debuff
    local interval = 0.1
    local count_down = duration or 5
    Timers:CreateTimer(interval,function()
    	count_down = count_down - interval
    	if count_down <= 0 then
    		return
    	end
    	GiveFvDebuffAndBuff(caster,point,radius,ability,"modifier_faceless_void_chronosphere_freeze",nil,interval)

    	return interval
    end)
end

function GiveFvDebuffAndBuff(caster,point,radius,ability,debuff,buff,duration)
	if caster == nil or caster:IsNull() == true then
		return
	end
	if debuff ~= nil then
		--给罩子内全部棋子debuff
		local unlucky_dogs = FindUnitsInRadiusByTeam({
			team = caster:GetTeam(),
			role = 3,
			position = point,
			radius = radius,
		})
		for i,v in pairs(unlucky_dogs) do
			if IsUnitExist(v) == true and v:HasAbility('fv_zhao') == false and v.is_moving ~= true then
				v:AddNewModifier(v,nil,debuff,{duration = duration})
			end
		end
	end
	if buff ~= nil then
		--未来可能添加的buff
	end
end





function PlaySpawnAnimation(x)
	x:StartGesture(ACT_DOTA_SPAWN)
	if string.find(x:GetUnitName(),'sniper') ~= nil then
		x:StartGesture(ACT_DOTA_IDLE)
	end
end

function ClearEmotionCooldown(h)
	h.is_emotion_cooldown = true
end
function SetEmotionCooldown(h)
	h.is_emotion_cooldown = nil
end
function IsEmotionCooldown(h)
	if h.is_emotion_cooldown == true then
		return true
	else
		return false
	end
end
function DAC:RequestShowEmotionBubble(keys)
	local player_id = keys.playerID or keys.player_id
	local h = PlayerId2Hero(player_id)
	local emotion_index = keys.emotion_index

	if IsUnitExist(h) == false then
		CustomGameEventManager:Send_ServerToTeam(PlayerId2Hero(player_id):GetTeam(),"mima",{
			key = GetClientKey(PlayerId2Hero(player_id):GetTeam()),
			text = "txt_you_dead"
		})
		return
	end

	if IsEmotionCooldown(h) == true then
		return
	end

	local mirror_chesser_entindex
	if h.my_away_mirror_chesser ~= nil and IsUnitExist(h.my_away_mirror_chesser) == true then
		mirror_chesser_entindex = h.my_away_mirror_chesser:entindex()
	end

	CustomGameEventManager:Send_ServerToAllClients("drodo_emotion",{
		id = keys.PlayerID,
		player_from = player_id,
		player_to = player_id,
		mirror_chesser_entindex = mirror_chesser_entindex,
		emotion_index = emotion_index,
		hehe = RandomFloat(1,10000),
	})
	SetEmotionCooldown(h)

	--发送聊天到UI
	CustomGameEventManager:Send_ServerToAllClients("drodo_chat",{
		player_id = h:GetPlayerID(),
		win_streak = h.win_streak or 0,
		vip = h.is_vip,
		onduty_hero = h.onduty_hero,
		emotion_index = emotion_index,
		time_stamp = math.floor(GameRules:GetGameTime()),
		type = 'player_emotion',
	})

	-- if RandomInt(1,100) <= 50 then
    -- 	SayCheerBubble(h:GetTeam(), nil, 'emotion', 0, emotion_index)
    -- end
end

function IsUnitAbleToCast(u)
	if u:IsSilenced() == false and u:IsStunned() == false and u:IsFrozen() == false and u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == false and u:HasModifier('modifier_vs_swap_debuff') == false and u:IsHexed() == false and u:IsCommandRestricted() == false and u:HasModifier("modifier_axe_berserkers_call") == false then
		return true
	else
		return false
	end
end

function PangolierSwashbuckleStart(keys)
	--滚滚
	local p = keys.target_points[1]
	local caster = keys.caster
	local chessboard_id = caster.at_team_id or caster.team_id
	local ability = keys.ability
	local level = ability:GetLevel() or 1
	local damage = ability:GetLevelSpecialValueFor( "damage", level - 1 )
	local attack_interval = ability:GetLevelSpecialValueFor( "attack_interval", level - 1 )
	local end_radius = ability:GetLevelSpecialValueFor( "end_radius", level - 1 )
	local strikes = ability:GetLevelSpecialValueFor( "strikes", level - 1 )

	if caster.stop_moving == true or caster:HasModifier('modifier_gungun') == true then
		return
	end

	-- 跳跃
	local target_x = Vector2X(p,chessboard_id)
	local target_y = Vector2Y(p,chessboard_id)
	local xx = caster.x
	local yy = caster.y
	caster.y_x = target_y..'_'..target_x
	caster.y = target_y
	caster.x = target_x
	_G.unit[chessboard_id][yy..'_'..xx] = nil
	_G.unit[chessboard_id][target_y..'_'..target_x] = 1
	caster.is_moving = true

	--冲刺到目标地点
	local blink_duration = BlinkChessX({
		caster = caster,
		p = p,
		blink_type = 'gungun',
	})
	if blink_duration > 0 then
		Timers:CreateTimer(blink_duration+0.1,function()
			--选一个方向，刺刺刺刺
			local di = FindGouheDirection(caster)
			if di == nil then
				local directions = {
					[1] = {x=1,y=0},
					[2] = {x=1,y=1},
					[3] = {x=1,y=-1},
					[4] = {x=-1,y=0},
					[5] = {x=-1,y=1},
					[6] = {x=-1,y=-1},
					[7] = {x=0,y=-1},
					[8] = {x=0,y=1},
				}
				local trytime = 0
				local di_random = nil
				while trytime < 100 and di == nil do
					di_random = directions[RandomInt(1,8)]
					local target_point_x = Vector2X(caster:GetAbsOrigin(),chessboard_id)
					local target_point_y = Vector2Y(caster:GetAbsOrigin(),chessboard_id)
					while IsIn8x8(target_point_x + di_random.x, target_point_y + di_random.y) == true do
						target_point_x = target_point_x + di_random.x
						target_point_y = target_point_y + di_random.y
					end
					local find_enemy = TargetCountForMorph(
						target_point_x,
						target_point_y,
						caster,
						end_radius)
					if find_enemy.count > 0 then
						di = di_random
					end
					trytime = trytime + 1
				end
			end
			if di ~= nil then
				local direction = Vector(di.x*128,di.y*128,0)
				-- 	caster:SetForwardVector(direction)
				ability.direction = direction
				ability.attack_count = 0
				ability:ApplyDataDrivenModifier(caster,caster,'modifier_pangolier_swashbuckle_attack',{ duration = 5 })
			end
		end)
	end
end

function PangolierSwashbuckleAttack(keys)
	local caster = keys.caster
	local chessboard_id = caster.at_team_id or caster.team_id
	local ability = keys.ability
	local direction = ability.direction
	local level = ability:GetLevel() or 1
	local attack_interval = ability:GetLevelSpecialValueFor( "attack_interval", level - 1 )
	local end_radius = ability:GetLevelSpecialValueFor( "end_radius", level - 1 ) or 125
	local strikes = ability:GetLevelSpecialValueFor( "strikes", level - 1 ) or 4
	local max_distance = ability:GetLevelSpecialValueFor( "max_distance", level - 1 ) or 640
	local particle_cast = "particles/units/heroes/hero_pangolier/pangolier_swashbuckler.vpcf"
	local sound_cast = "Hero_Pangolier.Swashbuckle.Attack"

	local effect_cast = ParticleManager:CreateParticle( particle_cast, PATTACH_ABSORIGIN_FOLLOW, caster )
	ParticleManager:SetParticleControl( effect_cast, 1, direction*7 )
	EmitSoundOn( sound_cast, caster )
	local duration = 0.5
	-- if level >= 3 then
	-- 	duration = 3
	-- end

	Timers:CreateTimer(duration,function()
		if effect_cast ~= nil then
			ParticleManager:DestroyParticle(effect_cast,true)
		end
	end)

	local target_point = caster:GetAbsOrigin()
	while IsIn8x8(Vector2X(target_point+ direction,chessboard_id),Vector2Y(target_point+ direction,chessboard_id)) == true do
		target_point = target_point + direction
	end
	local find_enemy = TargetCountForMorph(
		Vector2X(target_point,chessboard_id),
		Vector2Y(target_point,chessboard_id),
		caster,
		end_radius)
	if find_enemy ~= nil then
		local enemies = find_enemy.all_enemy
		for _,enemy in pairs(enemies) do
			local distance = (enemy:GetAbsOrigin() - caster:GetAbsOrigin()):Length2D()
			if distance < max_distance then
				-- Attack
				caster:PerformAttack( enemy, true, true, true, false, false, false, true )

				-- play sound
				local sound_target = "Hero_Pangolier.Swashbuckle.Damage"
				EmitSoundOn( sound_target, enemy )
			end
		end
	end

	--攻击计数，到达次数就终止
	ability.attack_count = (ability.attack_count or 0) + 1
	if ability.attack_count >= strikes then
		caster:RemoveModifierByName('modifier_pangolier_swashbuckle_attack')
	end
end



--非当前信使观战
function RandomSummonCheerCourier(team_id)
	SpawnCheerCourier(
		team_id, 
		FindAvailableCheerIndex(team_id), 
		RandomACourierFromCourierTable(team_id)
	)
end
function SummonCheerCourier(team_id, count)
	Timers:CreateTimer(0.5,function()
		if count == nil or count == 0 then
			return
		end
		RandomSummonCheerCourier(team_id)
		count = count - 1
		return 0.5
	end)
end
			


function RemoveAllCheerCourier(team_id)
	RemoveCheerCourier(team_id, nil)
end
function RemoveOndutyCourierFromCheerCourier(team_id)
	if team_id == nil or courier_name == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end

end
function SayCheerBubble(team_id, unit_index, text, delay, emotion_index)
	if team_id == nil then
		return false
	end
	if GetCheerCourierCount(team_id) < 3 and RandomInt(1,100) < 50 then
		--人数较少的观战，说话概率降为一半
		return false
	end
	Timers:CreateTimer((delay or 0), function()
		local unit = nil
		if unit_index == nil then
			unit = GetCheerCourier(team_id)
			if unit ~= nil then
				unit_index = unit:entindex()
			end
		end
		if unit_index ~= nil then
			CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
				unit_index = unit_index,
				text = '#text_cheer_'..text..'_'..RandomInt(1,10),
				player_name = TeamId2Hero(team_id).player_name,
				emotion_index = emotion_index,
			})
		end
	end)
end

function GetCheerPosition(team_id, cheer_index)
	if not cheer_index then
		cheer_index = 0
	end
	if cheer_index < 1 then
		cheer_index = 1
	end
	if cheer_index > 8 then
		cheer_index = 8
	end
	local center_vector = CenterVector(team_id)
	if cheer_index < 5 then
		--棋盘左边
		local left_line_vector = center_vector + Vector(128*(-4.5),0,0) 
		local left_index = cheer_index
		return left_line_vector + Vector(0, -128*3+left_index*128,200)
	else
		--棋盘右边
		local right_line_vector = center_vector + Vector(128*(4.5),0,0) 
		local right_index = cheer_index - 4
		return right_line_vector + Vector(0, -128*3+right_index*128,200)
	end
end

function GetCheerPetPosition(team_id, cheer_index)
	local cheer_position = GetCheerPosition(team_id, cheer_index)
	if cheer_index < 5 then
		return cheer_position + Vector(64,64,0)
	else
		return cheer_position + Vector(-64,-64,0)
	end
end

function SpawnCheerCourier(team_id, cheer_index, courier_name)
	if team_id == nil or courier_name == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end
	if cheer_index == nil or cheer_index <= 0 then
		cheer_index = FindAvailableCheerIndex(team_id)
		if cheer_index == nil or cheer_index <= 0 then
			return false
		end
	end
	local cheer_courier = CreateUnitByName("cheer_courier",GetCheerPosition(team_id, cheer_index),true,nil,nil,DOTA_TEAM_NEUTRALS)
	--设置朝向
	if cheer_index < 5 then
		cheer_courier:SetForwardVector(Vector(1,0,0))
	else
		cheer_courier:SetForwardVector(Vector(-1,0,0))
	end
	--设置模型
	local courier_id = string.split(courier_name,'_')[1]
	local courier_effect = string.split(courier_name,'_')[2] or ''
	local courier_projectile = string.split(courier_name,'_')[4] or ''
	local courier_pet = string.split(courier_name,'_')[5]
	local courier_animation = string.split(courier_name,'_')[6] or ''

	local courier_model = _G.sm_hero_list[courier_id] or 'models/props_gameplay/donkey_wings.vmdl'
	courier_model = ChangeFlyingCourierModel(courier_model)
	local courier_skin = _G.sm_hero_list_skin[courier_id] or 0
	local courier_scale = _G.sm_hero_size[courier_id] or 1
	cheer_courier:SetOriginalModel(courier_model)
	cheer_courier:SetModel(courier_model)
	cheer_courier:SetSkin(courier_skin)
	cheer_courier:SetModelScale(courier_scale*0.8)
	cheer_courier.courier_name = courier_id
	MakeGreevil(cheer_courier,true)
	
	if cheer_courier.effect ~= nil then
		cheer_courier:RemoveAbility(cheer_courier.effect)
		cheer_courier:RemoveModifierByName('modifier_texiao_star')
	end
	if courier_effect ~= nil and courier_effect ~= '' and courier_effect ~= 'e000' then
    	if _G.effect_list[courier_effect] ~= nil then
			AddAbilityAndSetLevel(cheer_courier,courier_effect)
			cheer_courier.effect = courier_effect
		end
	else
		cheer_courier.courier_effect = nil
    end
    -- cheer_courier.courier_name = courier_id
    -- cheer_courier.onduty_hero = courier_id
    -- ShowCourierEffect(cheer_courier,2)

    SetCheerCourier(team_id, cheer_index, cheer_courier)
    FindClearSpaceForUnit(cheer_courier, cheer_courier:GetAbsOrigin(), true)
    -- BlinkChessX({caster=cheer_courier,blink_type="fall"})
    cheer_courier:AddNewModifier(cheer_courier,nil,"modifier_fall",{})
    if courier_pet ~= nil and courier_pet ~= '' and courier_pet ~= 'p000' then
    	Timers:CreateTimer(0.5,function()
    		SpawnCheerCourierPet(team_id, cheer_index, courier_pet, cheer_courier)
    	end)
    end

    if RandomInt(1,100) < 50 then
    	SayCheerBubble(team_id, cheer_courier:entindex(), 'hello', 1)
    end
    return cheer_index
end

function SpawnCheerCourierPet(team_id, cheer_index, pet_id, cheer_courier)
	if team_id == nil or cheer_courier == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end
	if cheer_index == nil or cheer_index <= 0 then
		return false
	end

	if pet_id ~= nil and _G.pet_list[pet_id] ~= nil then
		local my_pet = CreateUnitByName("gemtd_pet", GetCheerPetPosition(team_id, cheer_index),true,nil,nil, DOTA_TEAM_GOODGUYS)
		cheer_courier.pet_entity = my_pet
		my_pet.pet_name = pet
		AddAbilityAndSetLevel(my_pet,'no_collision')
		AddAbilityAndSetLevel(my_pet,'cheer_pet_fly')

		if pet_id == 't305' then
			PlayParticleOnUnitUntilDeath({
				caster = my_pet,
				p = "effect/bose_hand/bose.vpcf",
			})
		end

		--设置朝向
		if cheer_index < 5 then
			my_pet:SetForwardVector(Vector(1,0,0))
		else
			my_pet:SetForwardVector(Vector(-1,0,0))
		end

		--设置模型
		local onduty_pet_model = _G.pet_list[pet_id]
		local onduty_pet_skin = 0
		my_pet:SetOriginalModel(onduty_pet_model)
		my_pet:SetModel(onduty_pet_model)
		my_pet:SetSkin(onduty_pet_skin)
		my_pet:SetModelScale((_G.pet_size_list[pet_id] or 1)*0.8)
		my_pet.owner = cheer_courier
		my_pet:AddNewModifier(my_pet,nil,"modifier_fall",{})
	end
end

function InitCheerCourier(team_id)
	if team_id == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return false
	end
	hero.cheer_courier_list = {
		[1] = nil,[2] = nil,[3] = nil,[4] = nil,[5] = nil,
		[6] = nil,[7] = nil,[8] = nil,
	}
end
function SetCheerCourier(team_id, index, courier)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return
	end
	if hero.cheer_courier_list == nil then
		InitCheerCourier(team_id)
	end

	if index ~= nil and index >= 1 and index <= 8 then
		hero.cheer_courier_list[index] = courier
	else
		local available_index = FindAvailableCheerIndex(team_id)
		if available_index ~= nil and available_index > 0 then
			hero.cheer_courier_list[available_index] = courier
		else
			print('[SetCheerCourier] No available_index! team_id='..team_id)
		end
	end
end
function FindAvailableCheerIndex(team_id)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return
	end

	if hero.cheer_courier_list == nil then
		InitCheerCourier(team_id)
	end

	local try_count = 0
	local available_index = 0
	while try_count < 100 and available_index == 0 do
		local random_index = RandomInt(1,8)
		if GetCheerCourier(team_id, random_index) == nil then
			available_index = random_index
		end
		try_count = try_count + 1
	end
	return available_index
end
function GetCheerCourier(team_id, index)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.cheer_courier_list == nil then
		return
	end
	if index ~= nil and index >= 1 and index <= 8 then
		return hero.cheer_courier_list[index]
	else
		--随机一个
		local try_count = 0
		local available_index = 0
		while try_count < 100 and available_index == 0 do
			local random_index = RandomInt(1,8)
			if GetCheerCourier(team_id, random_index) ~= nil then
				available_index = random_index
			end
			try_count = try_count + 1
		end
		if available_index > 0 then
			return hero.cheer_courier_list[available_index]
		else
			return nil
		end
	end
end
function GetCheerCourierCount(team_id)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.cheer_courier_list == nil then
		return 0
	end

	local count = 0
	for i=1,8 do
		if hero.cheer_courier_list[index] ~= nil then
			count = count + 1
		end
	end
	return count
end
function RemoveCheerCourier(team_id, index)
	if team_id == nil then
		return
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil then
		return
	end
	if index ~= nil and index > 0 then
		--移除指定index的
		local courier = GetCheerCourier(team_id, index)
		if courier ~= nil then
			if courier.pet_entity ~= nil then
				courier.pet_entity:Destroy()
				courier.pet_entity = nil
			end
			courier:ForceKill(false)
			hero.cheer_courier_list[index] = nil
		end
	else
		--全部移除
		for i=1,10 do
			local courier = GetCheerCourier(team_id, i)
			if courier ~= nil then
				if courier.pet_entity ~= nil then
					courier.pet_entity:Destroy()
					courier.pet_entity = nil
				end
				courier:ForceKill(false)
				hero.cheer_courier_list[i] = nil
			end
		end
	end
end

function DAC:SetCourierTable(keys)
	local player_id = keys.PlayerID
	local hero = PlayerId2Hero(player_id)

	if hero == nil then
		return
	end

	if hero.courier_table == nil then
		--设置信使池，不覆盖
		hero.courier_table = string.split(keys.courier_list or '',',')
	end
	local team_id = hero:GetTeam()

	--移除当前信使
	local cheer_courier_list = hero.cheer_courier_list or {}
	for index,v in pairs(cheer_courier_list) do
		if v.courier_name == keys.onduty_courier then
			RemoveCheerCourier(team_id, index)
		end
	end
	if hero.courier_table ~= nil then
		for index,v in pairs(hero.courier_table) do
			if v == keys.onduty_courier then
				RemoveOneKeyInTable(hero.courier_table, keys.onduty_courier)
			end
		end
	end
end

function RandomACourierFromCourierTable(team_id)
	if team_id == nil then
		return nil
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.courier_table == nil or table.maxn(hero.courier_table) <= 0 then
		return nil
	end
	local index = RandomInt(1,table.maxn(hero.courier_table))
	local courier_name = nil
	if hero.last_cheer_courier ~= nil then
		courier_name = FindMyCPCourier(hero)
	end
	if courier_name == nil then
		courier_name = hero.courier_table[index]
	end
	hero.last_cheer_courier = string.sub(courier_name,1,4)
	RemoveOneKeyInTable(hero.courier_table,courier_name)
	return courier_name
end
function FindMyCPCourier(hero)
	local result = nil
	local color_index = _G.COLOR_GROUP[hero.last_cheer_courier]
	if color_index ~= nil then
		local ct1 = {}
		for i,v in pairs(hero.courier_table) do
			local check_name = string.sub(v,1,4)
			if _G.COLOR_GROUP[check_name] == _G.COLOR_GROUP[hero.last_cheer_courier] then
				table.insert(ct1,v)
			end
		end
		if table.maxn(ct1) > 0 then
			result = ct1[RandomInt(1,table.maxn(ct1))]
		end
	end
	local cp_index = _G.CP_GROUP[hero.last_cheer_courier]
	if cp_index ~= nil and result == nil then
		local ct2 = {}
		for i,v in pairs(hero.courier_table) do
			local check_name = string.sub(v,1,4)
			if _G.CP_GROUP[check_name] == _G.CP_GROUP[hero.last_cheer_courier] then
				table.insert(ct2,v)
			end
		end
		if table.maxn(ct2) > 0 then
			result = ct2[RandomInt(1,table.maxn(ct2))]
		end
	end
	return result
end
function RemoveACourierFromCourierTable(team_id, courier_id)
	if team_id == nil then
		return false
	end
	local hero = TeamId2Hero(team_id)
	if hero == nil or hero.courier_table == nil or table.maxn(hero.courier_table) <= 0 then
		return false
	end

	RemoveOneKeyInTable(hero.courier_table, courier_id)
	return true
end

function DAC:SetPlayerShowBuffList(keys)
	local player_id = keys.PlayerID
	SetStat(player_id,'show_buff',keys.show_buff_list,false)
end

function VSSwap(keys)
	local caster = keys.caster
	local target = keys.target
	local duration = keys.ability:GetLevelSpecialValueFor( "stun_duration", keys.ability:GetLevel() - 1)

	if HasMovingModifier(target) == true then
		--万一目标在位移，就临时换一个目标，以免bug
		target = FindUnluckyDogEnemySameStar(caster)
		if target == nil then
			--找不到的话，就算了！
			return
		end
	end

	if IsUnitExist(target) and BlockByLinken(target) == false then
		--播放音效
		caster:EmitSound("Hero_VengefulSpirit.NetherSwap")
	    target:EmitSound("Hero_VengefulSpirit.NetherSwap")
	    --播放特效
	    local caster_pfx = ParticleManager:CreateParticle("particles/units/heroes/hero_vengeful/vengeful_nether_swap.vpcf", PATTACH_ABSORIGIN, caster)
	    ParticleManager:SetParticleControlEnt(caster_pfx, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)
	    ParticleManager:SetParticleControlEnt(caster_pfx, 1, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	    local target_pfx = ParticleManager:CreateParticle("particles/units/heroes/hero_vengeful/vengeful_nether_swap_target.vpcf", PATTACH_ABSORIGIN, target)
	    ParticleManager:SetParticleControlEnt(target_pfx, 0, target, PATTACH_POINT_FOLLOW, "attach_hitloc", target:GetAbsOrigin(), true)
	    ParticleManager:SetParticleControlEnt(target_pfx, 1, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetAbsOrigin(), true)

	    --打断target动作
	    target:Stop()
	    RemoveRoot(caster)
	    RemoveRoot(target)

	    SwapUnitPosition(caster, target)
		TauntEnemy({caster = target})

		--debuff
		-- target:AddNewModifier(target,nil,"modifier_stunned",{ duration = duration})
		caster:FindAbilityByName("vs_swap"):ApplyDataDrivenModifier(caster,target,'modifier_vs_swap_debuff',{ duration = duration})
	end
end

function WarlockInferno(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()

	local inferno_count = level
	if caster:HasModifier('modifier_item_minglingshu') and RandomInt(1,100) < 75 then
		inferno_count = inferno_count + 1
	end

	for i=1,inferno_count do
		Timers:CreateTimer(i*1,function()
			SummonAnInferno(caster)
		end)
	end

	-- SummonAnInferno(cc)
	-- if level >= 2 then
	-- 	Timers:CreateTimer(1,function()
	-- 		SummonAnInferno(cc)
	-- 	end)
	-- end
	-- if level >= 3 then
	-- 	Timers:CreateTimer(2,function()
	-- 		SummonAnInferno(cc)
	-- 	end)
	-- end
end

function SummonAnInferno(warlock)
	local pos = FindRandomEnemyEmptyGrid(warlock)
	if pos ~= nil then
		local model_list = {
			'models/items/warlock/golem/ahmhedoq/ahmhedoq.vmdl',
			'models/items/warlock/golem/doom_of_ithogoaki/doom_of_ithogoaki.vmdl',
			'models/items/warlock/golem/grimoires_pitlord_ultimate/grimoires_pitlord_ultimate.vmdl',
			'models/items/warlock/golem/hellsworn_golem/hellsworn_golem.vmdl',
			'models/items/warlock/golem/mdl_warlock_golem/mdl_warlock_golem.vmdl',
			'models/items/warlock/golem/mystery_of_the_lost_ores_golem/mystery_of_the_lost_ores_golem.vmdl',
			'models/items/warlock/golem/obsidian_golem/obsidian_golem.vmdl',
			'models/items/warlock/golem/puppet_summoner_golem/puppet_summoner_golem.vmdl',
			'models/items/warlock/golem/the_torchbearer/the_torchbearer.vmdl',
			'models/items/warlock/golem/ti_8_warlock_darkness_apostate_golem/ti_8_warlock_darkness_apostate_golem.vmdl',
		}
		local uu = SummonOneMinion(warlock,'wl_golem',pos)
		local mm = model_list[RandomInt(1,table.maxn(model_list))]
		if uu == nil or uu:IsNull() == true then return end
		uu:SetOriginalModel(mm)
		uu:SetModel(mm)
		ExtendBeastBuff(uu,warlock)
		-- uu:AddNewModifier(uu,nil,"modifier_kill",{duration = RandomInt(5,10)})
		uu:SetMaxMana(0)
		FillEmptySlot(uu)
		BlinkChessX({caster=uu,blink_type="fall"})

		Timers:CreateTimer(0.5,function()
			EmitSoundOn("Hero_Warlock.RainOfChaos", uu)
			local pp = ParticleManager:CreateParticle("particles/units/heroes/hero_warlock/warlock_rain_of_chaos.vpcf", PATTACH_POINT, warlock)
			ParticleManager:SetParticleControl(pp, 0, pos)
			ParticleManager:SetParticleControl(pp, 1, Vector(1,1,1))
			ParticleManager:SetParticleControl(pp, 2, pos)
			ParticleManager:SetParticleControl(pp, 5, pos)
			ParticleManager:ReleaseParticleIndex(pp)

			local team_id = warlock.at_team_id or warlock.team_id
			for p,vp in pairs(GetValidChessOnBoard(team_id)) do
				if (vp:GetAbsOrigin()-pos):Length2D() < 250 and vp:GetTeam() ~= warlock:GetTeam() then
					vp:AddNewModifier(vp,nil,"modifier_stunned",{ duration = RandomFloat(0.5,1.5)})
					ApplyDamage({
				    	victim = vp,
				    	attacker = warlock,
				    	damage_type = DAMAGE_TYPE_PURE,
				    	damage = RandomInt(50,200)
				    })
				end
			end
		end)
	end
end

function DAC:RequestFindCombinableItem(keys)
	local player_id = keys.PlayerID
	local unit_index = keys.unit_index
	local hero = PlayerId2Hero(player_id)
	if unit_index then
		hero = EntIndexToHScript(unit_index)
	end
	if hero == nil then
		return
	end
	if hero:IsHero() == false then
		if (GetTime().phase == GAME_PHASE_BATTLE and hero.hand_index == nil) or (GetTime().phase == GAME_PHASE_PREPARE and GetTime().left < 2 and hero.hand_index == nil ) then
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"mima",{
				key = GetClientKey(hero:GetTeam()),
				text = "text_mima_cannot_delete_battle_chess"
			})
			EmitSoundOn("General.CastFail_NoMana",PlayerId2Hero(player_id))
			return
		end
	end
	local items = FindCombinableItemByCourier(hero)

	--展示给UI，可供选择、点击
	if hero:IsHero() == false then
		--棋子
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_combinable_item",{
			key = GetClientKey(hero:GetTeam()),
			items = items,
			unit_index = unit_index,
			unit_name = hero:GetUnitName(),
			base_unit_name = GetUnitBaseName(hero),
		})
	else
		--信使
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"show_combinable_item",{
			key = GetClientKey(hero:GetTeam()),
			items = items,
			unit_index = unit_index,
			onduty_hero = hero.onduty_hero,
		})
	end
end

--如果给unit添加more_item_table这些装备，unit能多合成什么物品？
function FindMoreItemsByUnitAndTable(unit, more_item_table)
	local item_table_now = GetAllItemsInUnits({[1] = unit})
	return FindMoreItemsByTableAndTable(item_table_now, more_item_table)
end

function FindMoreItemsByTableAndTable(item_table, more_item_table)
	local result_table = {}
	local item_table_now = CopyTable(item_table)
	local item_table_a = FindCombinableItem(item_table_now)
	if more_item_table ~= nil and table.maxn(more_item_table)> 0 then
		for i=1,table.maxn(more_item_table) do
			table.insert(item_table_now,more_item_table[i])
		end
	end
	local item_table_b = FindCombinableItem(item_table_now)

	if item_table_b ~= nil and table.maxn(item_table_b)> 0 then
		for i=1,table.maxn(item_table_b) do
			local item = item_table_b[i]
			if item ~= '' and FindValueInTable(item_table_a, item) == false then
				local is_dup = false
				if more_item_table ~= nil and table.maxn(more_item_table)> 0 then
					for j=1,table.maxn(more_item_table) do
						local item_add = more_item_table[j]
						if IsAPartOfB(item,item_add) == true then
							--如果item是more_item_table其中一个的一部分，则不提示
							is_dup = true
						end
					end
				end
				if is_dup == false then
					table.insert(result_table,item)
				end
			end
		end
	end
	return result_table
end

function FindCombinableItemByCourier(courier)
	local item_table_now = GetAllItemsInUnits({[1] = courier})
	return FindCombinableItem(item_table_now)
end

--寻找快捷合成物品
function FindCombinableItem(item_table_now)
	local item_table_source = {}
	local item_table_combined = {}
	local item_table_temp = {}

	-- 获取所有原材料
	for i=1,table.maxn(item_table_now) do
		local item_name = item_table_now[i]
		if _G.basic_recipe[item_name] and item_name ~= 'item_shengjian' then
			--可以拆分的，拆分后放进item_table_source
			for _,v in pairs(string.split(_G.basic_recipe[item_name],';')) do
				table.insert(item_table_source, v)
			end
		-- 不能拆分的，直接放进item_table_source
		else
			table.insert(item_table_source, item_name)
		end
	end

	-- 遍历 basic_recipe，寻找可以合成的高级装备
	for item_name,v in pairs (_G.basic_recipe) do
		-- 确保不再显示身上已有的高级装备
		if FindValueInTable(item_table_now, item_name) == false then
			item_table_temp = CopyTable(item_table_source)
			local can_combined = true
			-- 查询该高级装备的材料是否齐全
			for _,item_we_need in pairs(string.split(_G.basic_recipe[item_name],';')) do
				-- 若不齐全，则标记该装备无法合成
				if FindValueInTable(item_table_temp, item_we_need) == false then
					can_combined = false
					break
				else
					RemoveOneKeyInTable(item_table_temp, item_we_need)
				end
			end
			-- 若齐全，则将该装备加进 item_table_combined
			if can_combined == true then 
				for k,v in pairs (_G.basic_recipe) do
					if item_name == k and item_name ~= 'item_silingshu_2' and item_name ~= 'item_silingshu_3' then
						table.insert( item_table_combined, item_name)
					end
				end
			end
		end
	end

	-- 在结果中去除已有装备的配件。例如：大电锤可合成的物品不包含小电锤
	for i = table.maxn(item_table_combined),1,-1 do
		local item_a = item_table_combined[i]
		for j=1,table.maxn(item_table_now) do
			local item_b = item_table_now[j]
			--判断a是不是b的配件，如果是，就把a移除
			if IsRecipe(item_a,item_b) == true then
				-- table.remove(item_table_combined,i)
				item_table_combined[i] = ''
			end
		end
	end

	return item_table_combined
end

function DAC:RequestCombineItem(keys)
	local player_id = keys.PlayerID
	local unit_index = keys.unit_index
	local hero = PlayerId2Hero(player_id)
	if unit_index and unit_index > 0 then
		hero = EntIndexToHScript(unit_index)
	end
	if hero == nil then
		return
	end
	local item = keys.item

	CombineItem(hero, item)
end
function CombineItem(hero, item)
	local target_item = item
	local item_table_now = {}
	local item_table_needed = {}
	local item_table_unused = {}
	local item_table_will_be_removed = {}
	local can_be_combined = false
	if IsUnitExist(hero) == false then return end
	if hero:IsHero() == false then
		if (GetTime().phase == GAME_PHASE_BATTLE and hero.hand_index == nil) or (GetTime().phase == GAME_PHASE_PREPARE and GetTime().left < 2 and hero.hand_index == nil) then
			CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"mima",{
				key = GetClientKey(hero:GetTeam()),
				text = "text_mima_cannot_delete_battle_chess"
			})
			EmitSoundOn("General.CastFail_NoMana",hero)
			return
		end
	end

	-- 获取所有原材料
	for slot=0,8 do
		if hero:GetItemInSlot(slot)~= nil then
			local item = hero:GetItemInSlot(slot)
			local item_name = item:GetAbilityName()
			table.insert( item_table_now, item_name)
		end
	end

	-- 列出合成新装备所需的材料
	for _,item_needed in pairs(string.split(_G.basic_recipe[target_item],';')) do
		table.insert(item_table_needed, item_needed)
	end

	-- 遍历现有装备
	for slot=0,8 do
		if hero:GetItemInSlot(slot)~= nil then
			local item = hero:GetItemInSlot(slot)
			local item_name = item:GetAbilityName()
			local item_table_temp = {}
			local new_item = true
			if item:IsPermanent() == true and item_name ~= 'item_shengjian' then
				-- 格子中若为高级装备
				if _G.basic_recipe[item_name] then
					for _,v in pairs(string.split(_G.basic_recipe[item_name],';')) do
						-- 若有所需材料，则拆分。消耗所需材料，保留未使用的材料
						if FindValueInTable(item_table_needed, v) then
							RemoveOneKeyInTable(item_table_needed, v)
							if new_item == true then
								table.insert(item_table_will_be_removed, slot)
								new_item = false
							end
						else
							table.insert(item_table_temp, v)
						end
					end
					if new_item == false then
						for k,v in pairs(item_table_temp) do
							table.insert(item_table_unused,v)
						end
					end
				-- 格子中若为基础装备
				else
					-- 若为所需材料就消耗，否则保留
					if FindValueInTable(item_table_needed, item_name) then
						RemoveOneKeyInTable(item_table_needed, item_name)
						table.insert(item_table_will_be_removed, slot)
					end
				end
			end
			-- 若材料足够了，就终止遍历过程
			if table.maxn(item_table_needed) == 0 then
				can_be_combined = true
				break
			end
		end
	end

	-- 判断目标装备最终是否可以被合成，可以则继续
	if can_be_combined == true then
		-- 移除所有需拆分的装备
		for _,slot in pairs(item_table_will_be_removed) do
			hero:RemoveItem(hero:GetItemInSlot(slot))
		end
		-- 添加目标装备
		hero:AddItemByName(target_item)
		-- 将未消耗的材料添加回来
		for _,v in pairs(item_table_unused) do
			-- Timers:CreateTimer(_/20,function()
				-- 装备栏有空格就直接添加
				if HasEmptyInventorySpace(hero) then
					hero:AddItemByName(v)
				-- 装备栏满了就掉出来
				else
					local newItem = CreateItem( v, hero, hero )
					local drop = CreateItemOnPositionForLaunch(hero:GetAbsOrigin(), newItem )
					newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, hero:GetAbsOrigin() + Vector(RandomFloat( -100, 100 ),RandomFloat( -100, 100 ),0))
				end
			-- end)
		end

		EmitSoundOn("General.Combine", hero)
		play_particle("effect/combine_item/1.vpcf",PATTACH_ABSORIGIN_FOLLOW,hero,3)

		return target_item
	end

	return nil
end

function HasEmptyInventorySpace(u)
	if IsUnitExist(u) == false or u:HasInventory() == false then
		return false
	end
	for slot=0,8 do
		if u:GetItemInSlot(slot) == nil then
			return true
		end
	end
	return false
end

function PlayItemMultiCastParticle(unit)
	EmitSoundOn("item.multicast",unit)

	if unit.item_multicast_particle ~= nil then
		ParticleManager:DestroyParticle(unit.item_multicast_particle,true)
		unit.item_multicast_particle = nil
	end

	local pp = ParticleManager:CreateParticle("particles/econ/items/ogre_magi/ogre_magi_jackpot/ogre_magi_jackpot_multicast.vpcf", PATTACH_OVERHEAD_FOLLOW, unit)
	-- ParticleManager:SetParticleControlEnt( pp, 1, unit, PATTACH_OVERHEAD_FOLLOW, nil, Vector(2,1,1), true );
	unit.item_multicast_particle = pp

	Timers:CreateTimer(5,function()
		if IsUnitExist(unit) == false then
			if unit.item_multicast_particle ~= nil then
				ParticleManager:DestroyParticle(unit.item_multicast_particle,true)
			end
			return
		end
	end)
end

function GetAbilityKV(ability, key)
	if ability == nil then
		return
	end
	local level = ability:GetLevel() or 1
	return ability:GetLevelSpecialValueFor( key, level - 1 )
end

function TrollAxeAttack(keys)
	local caster = keys.caster
	local attack_target_curr = caster.attack_target_curr
	if IsUnitExist(caster) == false then
		return
	end
	local ability = keys.ability
	local level = ability:GetLevel() or 1
	local axe_per = GetAbilityKV(keys.ability, "axe_per") or 25

	local curr_target = caster:GetAttackTarget()
	if curr_target == nil or curr_target:entindex() == nil then
		return
	end
	local curr_attack_target_index = curr_target:entindex() or 0
	local last_attack_target_index = caster.last_attack_target_index or 0
	if last_attack_target_index == 0 then
		caster.last_attack_target_index = curr_attack_target_index
		return
	end
	if curr_attack_target_index ~= last_attack_target_index or RandomInt(1,100) < axe_per then
		--概率触发
		caster.last_attack_target_index = curr_attack_target_index
		if (caster:GetAbsOrigin() - curr_target:GetAbsOrigin()):Length2D() <= 250 and caster:FindAbilityByName('troll_warlord_whirling_axes_melee') ~= nil then
			ExecuteOrderFromTable({
		 		UnitIndex = caster:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
		 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = caster:FindAbilityByName('troll_warlord_whirling_axes_melee'):entindex(), --Optional.  Only used when casting abilities
		 		Position = nil, --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	})
		elseif caster:FindAbilityByName('troll_warlord_whirling_axes_ranged') ~= nil then
			ExecuteOrderFromTable({
		 		UnitIndex = caster:entindex(), 
		 		OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
		 		TargetIndex = nil,--unluckydog:entindex(), --Optional.  Only used when targeting units
		 		AbilityIndex = caster:FindAbilityByName('troll_warlord_whirling_axes_ranged'):entindex(), --Optional.  Only used when casting abilities
		 		Position = curr_target:GetAbsOrigin(), --Optional.  Only used when targeting the ground
		 		Queue = 0 --Optional.  Used for queueing up abilities
		 	})
		end
	end
end

function RemoveRoot(u)
	if u:HasModifier('modifier_item_atuosi_debuff') then
	    u:RemoveModifierByName('modifier_item_atuosi_debuff')
	end
	if u:HasModifier('modifier_item_xueji_debuff') then
	    u:RemoveModifierByName('modifier_item_xueji_debuff')
	end
	if u:HasModifier('modifier_item_fulingsuo_debuff') then
	    u:RemoveModifierByName('modifier_item_fulingsuo_debuff')
	end
	if u:HasModifier('modifier_br_web_debuff') then
	    u:RemoveModifierByName('modifier_br_web_debuff')
	end
end


function Celebrate(u)
	--庆祝动作
	if IsUnitExist(u) then
		u:StartGesture(ACT_DOTA_VICTORY)
	end
	-- AddAbilityAndSetLevel(u,'act_victory')
	-- Timers:CreateTimer(10,function()
	-- 	if IsUnitExist(u) == true then
	-- 		RemoveAbilityAndModifier(u,'act_victory')
	-- 	end
	-- end)
end

function FindItemAbility(u,item_name)
	for slot=0,5 do
		if u:GetItemInSlot(slot)~= nil then
			local ability = u:GetItemInSlot(slot)
			local name = ability:GetAbilityName()
			if name == item_name then
				return ability
			end
		end
	end
end

--获得某棋子某技能的实际魔法消耗（用自动自带的GetManaCost不会计算modifier减免，很蠢）
function GetManaCostX(u,a)
	local mana_cost_list = {
			modifier_is_shaman_50mana = 75,
		}
	local mana_cost = u:FindAbilityByName(a):GetManaCost(u:FindAbilityByName(a):GetLevel()) or 100
	for m,p in pairs(mana_cost_list) do
		if a == 'leshrac_pulse_nova' then
			mana_cost = 100
		end
		if u:HasModifier(m) then
			mana_cost = mana_cost/100.0 * p
		end
	end
	return mana_cost
end

-- function AddHuiguang(keys)
-- 	local caster = keys.caster
-- 	if IsUnitExist(caster) == true and caster:IsHero() == false and caster:HasModifier("modifier_item_huiguang") == false then
-- 		caster:AddNewModifier(caster,FindItemAbility(caster,'item_huiguang'),"modifier_item_huiguang",{})
-- 	end
-- end
-- function RemoveHuiguang(keys)
-- 	local caster = keys.caster
-- 	if IsUnitExist(caster) == true and caster:HasModifier("modifier_item_huiguang") == true then
-- 		caster:RemoveModifierByName("modifier_item_huiguang")
-- 	end
-- end

function SummonMinion(caster,minion_name,minion_count,particle,cb,force_position)
	if minion_name == nil then
		return
	end
	if minion_count == nil or minion_count <= 0 then
		minion_count = 1
	end
	if caster:HasModifier('modifier_item_minglingshu') and RandomInt(1,100) < 75 then
		minion_count = minion_count + 1
	end

	if GetBattleTable(caster.at_team_id or caster.team_id) == false then
		return
	end

	for i=1,minion_count do
		Timers:CreateTimer(i*0.1,function()
			if GetBattleTable(caster.at_team_id or caster.team_id) == false then
				return
			end
			local w = SummonOneMinion(caster,minion_name,force_position)
			ExtendBeastBuff(w,caster)
			if particle then
				play_particle(particle,PATTACH_ABSORIGIN_FOLLOW,w,3)
			end
			if cb then
				cb(w)
			end
		end)
	end
end

function GetCourierInfo(player_id)
	local info = CustomNetTables:GetTableValue( "player_id_table", "courier_"..player_id ) or {}
	if info and info.courier then
		return info.courier
	else
		return nil
	end
end

function GetChessboardInfo(player_id)
	if _G.chessboard_list == nil then
		return nil
	end
	local chessboard_id = _G.chessboard_list['default_chessboard']
	local info = CustomNetTables:GetTableValue( "player_id_table", "chessboard_"..player_id ) or {}
	if info and info.chessboard then
		chessboard_id = info.chessboard
	end
	return _G.chessboard_list[chessboard_id]
end
function InitChessboards()
	--动态生成地图
	local h = DOTA_SpawnMapAtPosition(
		'logo', 
		Entities:FindByName(nil,"center8"):GetOrigin()+Vector(0,0,256), 
		true,
		function(tAllMaps)
			ManuallyTriggerSpawnGroupCompletion(tAllMaps)
		end,
		nil,
		self
	)

	for team_id=6,13 do
		local player_id = _G.teamid2playerid[team_id]
		if player_id then
			local chessboard_info = GetChessboardInfo(player_id)
			if chessboard_info ~= nil then
				local h = DOTA_SpawnMapAtPosition(
					chessboard_info.vmap, 
					Entities:FindByName(nil,"center"..(team_id-6)):GetOrigin()+Vector(0,128,256), 
					true,
					function(tAllMaps)
						ManuallyTriggerSpawnGroupCompletion(tAllMaps)
					end,
					nil, 
					self
				)
				print( "load chessboard "..(team_id-6)..' -->'..chessboard_info.vmap)
			end
		end
	end
	print( "load chessboard OK")
end


function DropMangoAndUpdateLastBattle(team_id, result)
	local hero = TeamId2Hero(team_id)
	if IsUnitExist(hero) == false then
		return
	end
	if hero.last_battle_victory and hero.last_battle_victory ~= result and hero:HasModifier('modifier_item_mangotree') then
		if hero.mango_tree ~= nil then
			local newItem = CreateItem( 'item_mangguo', hero, hero )
			local drop = CreateItemOnPositionForLaunch(hero.mango_tree:GetAbsOrigin(), newItem )
			newItem:LaunchLootInitialHeight( false, 0, 50, 0.75, hero.mango_tree:GetAbsOrigin() + Vector(RandomFloat( -100, -50 ),RandomFloat( -50, 50 ),0))
		end
	end
	hero.last_battle_victory = result
end

function FindRangedChessAtRow34(at_team_id)
	for _,u in pairs(GetValidChessOnBoard(at_team_id)) do
		if IsUnitExist(u) and (u.y == 3 or u.y == 4) and u:Script_GetAttackRange() > 205 then
			return u
		end
	end
	return nil
end
function FindMeleeChessAtRow12(at_team_id)
	for _,u in pairs(GetValidChessOnBoard(at_team_id)) do
		if IsUnitExist(u) and (u.y == 1 or u.y == 2) and u:Script_GetAttackRange() <= 205 then
			return u
		end
	end
	return nil
end

function FindEmptyPosAtRow(at_team_id, min_row, max_row)
	local try_count = 0
	while try_count < 100 do
		local y = RandomInt(min_row,max_row)
		local x = RandomInt(1,8)
		if IsEmptyGrid(at_team_id,x,y) == true then
			return XY2Vector(x,y,at_team_id)
		end

		try_count = try_count + 1
	end
end

function PetMakeSynergy(hero)
	
	local pet = hero.pet_entity
	if pet == nil then
		return
	end

	hero.ai_synergy = {}

	--决定抽牌策略
	local synergy_table = {}
	--招募面板
	if hero.curr_chess_table then
		for _,c in pairs(hero.curr_chess_table) do
			local chess_name = c.chess
			local level = _G.chess_2_mana[chess_name] or 1
			local price = c.price

			local classes = GetChessClassAndRaceTable(chess_name)
			for _,s in pairs(classes) do
				if synergy_table[s] == nil then
					synergy_table[s] = 0
				end
				synergy_table[s] = synergy_table[s] + level
			end
		end
	end
	--手牌
	if hero.hand_entities then
		for _,ent in pairs(hero.hand_entities) do
			local chess_name = ent:GetUnitName()
			local chess_base_name = GetChessBaseName(chess_name)
			local star = GetChessNameStar(chess_name)
			local level = _G.chess_2_mana[chess_base_name] or 1

			local classes = GetChessClassAndRaceTable(chess_base_name)
			for _,s in pairs(classes) do
				if synergy_table[s] == nil then
					synergy_table[s] = 0
				end
				synergy_table[s] = synergy_table[s] + star*level
			end
		end
	end
	--场上棋子
	for _,v in pairs(_G.mychess[hero:GetTeam()]) do
		if v ~= nil and v.chess ~= nil then 
			local chess_name = v.chess
			local chess_base_name = GetChessBaseName(chess_name)
			local star = GetChessNameStar(chess_name)
			local level = _G.chess_2_mana[chess_base_name] or 1

			local classes = GetChessClassAndRaceTable(chess_base_name)
			for _,s in pairs(classes) do
				if synergy_table[s] == nil then
					synergy_table[s] = 0
				end
				synergy_table[s] = synergy_table[s] + star*level
			end
		end
	end

	local synergy_table_sort = {}
	for class,score in pairs(synergy_table) do
		table.insert(synergy_table_sort,{
			class = class,
			score = score or 0,
		})
	end
	table.sort(synergy_table_sort,function(a,b)
		return a.score > b.score
	end)

	if table.maxn(synergy_table_sort) >= 1 then
		table.insert(hero.ai_synergy,synergy_table_sort[1].class)
	end
	if table.maxn(synergy_table_sort) >= 2 then
		table.insert(hero.ai_synergy,synergy_table_sort[2].class)
	end

	Timers:CreateTimer(1,function()
		local ai_synergy_str = 'text_start_ai'
		for _,s in pairs(hero.ai_synergy) do
			ai_synergy_str = ai_synergy_str..'|DOTA_Tooltip_ability_'..s
		end

		CustomGameEventManager:Send_ServerToAllClients("drodo_bubble",{
			unit_index = pet:entindex(),
			text = ai_synergy_str,
			player_name = hero.player_name,
		})
	end)
end

function CourierAI(hero)
	local pet = hero.pet_entity
	if pet == nil then
		return
	end
	local pet_name = hero.pet_name
	hero.ai_synergy = {}
	hero.ai_pet = hero.pet_entity
	hero.stop_ai = false

	local pet = hero.pet_entity
	pet.idle = true
	if pet.aitimer == nil or Timers.timers[pet.aitimer] == nil then
		pet.aitimer = Timers:CreateTimer(1, function()
			--关闭AI、信使死亡或者游戏结束，就终止AI
			if hero == nil or hero:IsNull() == true or hero:IsAlive() == false or _G.is_game_ended == true or hero.stop_ai == true or hero.pet_entity == nil then
				return
			end

			if pet.idle ~= true then
				return 0.5
			end

			if hero.ai_synergy == nil or hero.last_ai_synergy_round == nil or table.maxn(hero.ai_synergy) <= 0 then
				hero.last_ai_synergy_round = _G.battle_round
				PetMakeSynergy(hero)
			else
				if hero.last_ai_synergy_round ~= _G.battle_round then
					hero.last_ai_synergy_round = _G.battle_round
					PetMakeSynergy(hero)
				end
			end

			--考虑购买棋子
			if hero.curr_chess_table ~= nil and table.maxn(hero.curr_chess_table) > 0 and hero:GetMana() > 0 and FindEmptyHandSlot(hero:GetTeam()) then
				for i,c in pairs(hero.curr_chess_table) do
					if IsPreferChess(hero,c.chess) == true and c.price <= hero:GetMana() then
						DAC:OnRequestBuyChess({
							buy_index = i,
							PlayerID = hero:GetPlayerID(),
						})
						return 0.5
					end
				end
			end

			--考虑上棋子
			local population = _G.population[hero:GetTeam()]
			local population_max = _G.population_max[hero:GetTeam()]
			if population < population_max then
				if hero.hand_entities ~= nil and hero:FindAbilityByName('recall_chess') ~= nil and hero:FindAbilityByName('recall_chess'):IsActivated() == true then
					for _,ent in pairs(hero.hand_entities) do
						if IsUnitExist(ent) then
							PetMove(
								pet,
								ent:GetAbsOrigin()-(ent:GetAbsOrigin()-pet:GetAbsOrigin()):Normalized()*50,
								1200
							)
							ExecuteOrderFromTable({
						 		UnitIndex = hero:entindex(), 
						 		OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
						 		TargetIndex = ent:entindex(), 
						 		AbilityIndex = hero:FindAbilityByName('recall_chess'):entindex(),
						 		Queue = 0,
						 	})
						 	return 1
						end
					end
				end
			end

			--考虑F还是D
			if hero:GetMana() >= 44 or (hero:GetLevel() < 4 and hero:GetMana() >= 6) or (not FindEmptyHandSlot(hero:GetTeam()) and hero:GetMana() >= 4) then
				-- PetMove(pet,hero:GetAbsOrigin())
				ExecuteOrderFromTable({
			 		UnitIndex = hero:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
			 		AbilityIndex = hero:FindAbilityByName('exp_book'):entindex(),
			 		Queue = 0,
			 	})
			 	return 0.5
			end
			if hero:GetMana() >= 45 then
				-- PetMove(pet,hero:GetAbsOrigin())
				ExecuteOrderFromTable({
			 		UnitIndex = hero:entindex(), 
			 		OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
			 		AbilityIndex = hero:FindAbilityByName('summon_hero'):entindex(),
			 		Queue = 0,
			 	})
			 	return 1
			end

			--调整站位
			if hero:FindAbilityByName("pick_chess") ~= nil and hero:FindAbilityByName("pick_chess"):IsActivated() == true then
				--考虑远程的放后排
				local ranged_chess = FindRangedChessAtRow34(hero:GetTeam())
				local target_pos = FindEmptyPosAtRow(hero:GetTeam(),1,2)
				if ranged_chess ~= nil and target_pos ~= nil then
					hero.picked_chess = ranged_chess
					PetMove(
						pet,
						ranged_chess:GetAbsOrigin()-(ranged_chess:GetAbsOrigin()-pet:GetAbsOrigin()):Normalized()*50,
						1500
					)
					DAC:OnPickChessPosition({
						caster = hero,
						x = target_pos.x,
						y = target_pos.y,
						z = target_pos.z,
						player_id = hero:GetOwner():GetPlayerID(),
						PlayerID = hero:GetOwner():GetPlayerID(),
					})
					return 0.5
				end

				--考虑近战的放前排
				local melee_chess = FindMeleeChessAtRow12(hero:GetTeam())
				local target_pos = FindEmptyPosAtRow(hero:GetTeam(),3,4)
				if melee_chess ~= nil and target_pos ~= nil then
					hero.picked_chess = melee_chess
					PetMove(
						pet,
						melee_chess:GetAbsOrigin()-(melee_chess:GetAbsOrigin()-pet:GetAbsOrigin()):Normalized()*50,
						1500
					)
					DAC:OnPickChessPosition({
						caster = hero,
						x = target_pos.x,
						y = target_pos.y,
						z = target_pos.z,
						player_id = hero:GetOwner():GetPlayerID(),
						PlayerID = hero:GetOwner():GetPlayerID(),
					})
					return 0.5
				end
			end

			--考虑把能升星的替补上场

			--考虑把高等级的替补上场

			--其他高级思想以后慢慢添加

			--什么也不做，走到场边休息
			local p = Entities:FindByName(nil,'center'..(hero:GetTeam()-6)):GetOrigin()+Vector(0,-340,512)
			if pet.idle == true then
				if not pet.rest then
					PetMove(pet,p,500,Vector(0,1,0))
					pet.rest = true
				end
			end
			-- hero.pet_entity:MoveToPosition(p)

			return 1
		end)
	end
end
function PetMove(pet,p,speed,forward)
	if pet == nil then
		return
	end
	if pet.idle ~= true then
		Timers:CreateTimer(1,function()
			PetMove(pet,p,cb)
		end)
		return
	end
	pet.rest = nil
	if speed ~= nil and speed > 500 then
		BlinkChessX({
			p = p,
			caster = pet,
			blink_type = 'elfrun',
			ignore_grid = true,
			speed = speed,
		})
	else
		pet:MoveToPosition(p)
	end
	pet.idle = false
	Timers:CreateTimer(1,function()
		if (pet:GetAbsOrigin() - p):Length2D() < 50 then
			pet:Stop()
			pet.idle = true
			if forward ~= nil then
				Timers:CreateTimer(0.5,function()
					pet:SetForwardVector(forward)
					pet:MoveToPosition(pet:GetAbsOrigin()+forward*30)
				end)
			end
			return
		end
		return 1
	end)
end

function IsPreferChess(hero,chess)
	if hero.level_one_chess ~= nil and string.find(hero.level_one_chess,chess) then
		return true
	end

	for _,v in pairs(hero.ai_synergy) do
		if _G.chess_list_by_synergy[v] then
			for _,c in pairs(_G.chess_list_by_synergy[v]) do
				if c == chess then
					return true
				end
			end
		end
	end
	return false
end

--进化
function EvolveThink(u)
	if IsUnitExist(u) == true and IsUnitAbleToCast(u) == true and u:IsChanneling() == false then
		if u:HasAbility('evolve_immediate') then
			ExecuteOrderFromTable({
	            UnitIndex = u:entindex(),
	            OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	            AbilityIndex = u:FindAbilityByName('evolve_immediate'):entindex(),
	        })
	        return 0.5
		elseif u:HasAbility('evolve') then
			u.channeling_evolve = true
	        ExecuteOrderFromTable({
	            UnitIndex = u:entindex(),
	            OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
	            AbilityIndex = u:FindAbilityByName('evolve'):entindex(),
	        })
	        return 3
	    end
	end
end

function EvolveSuccess(keys)
	local caster = keys.caster
	EvolveAChess(caster)
end

function EvolveFailed(keys)
	local caster = keys.caster
	caster:Stop()
end

function RandomSunStrike(keys)
	local caster = keys.caster
	Timers:CreateTimer(RandomFloat(0,0.5),function()
		local unluckydog = FindUnluckyDog(caster)
		if unluckydog ~= nil then
			InvisibleUnitCast({
				caster = caster,
				ability = 'invoker_sun_strike',
				level = 3,
				position = unluckydog:GetAbsOrigin(),
				ignore_nether_ward = true,
			})
		end
	end)
	Timers:CreateTimer(RandomFloat(0,0.5),function()
		local unluckydog = FindUnluckyDog(caster)
		if unluckydog ~= nil then
			InvisibleUnitCast({
				caster = caster,
				ability = 'invoker_sun_strike',
				level = 3,
				position = unluckydog:GetAbsOrigin(),
				ignore_nether_ward = true,
			})
		end
	end)
	Timers:CreateTimer(RandomFloat(0,0.5),function()
		local unluckydog = FindUnluckyDog(caster)
		if unluckydog ~= nil then
			InvisibleUnitCast({
				caster = caster,
				ability = 'invoker_sun_strike',
				level = 3,
				position = unluckydog:GetAbsOrigin(),
				ignore_nether_ward = true,
			})
		end
	end)
end

function MakeSharkEffect()
	if Entities:FindByName(nil,"shayu01") == nil then
		Timers:CreateTimer(1,function()
			MakeSharkEffect()
		end)
		return
	end
	for i=1,3 do
		local shayu = Entities:FindByName(nil,"shayu0"..i)
		local pos = PATTACH_ABSORIGIN_FOLLOW

		local pp = ParticleManager:CreateParticle('effect/shayu/bose.vpcf', pos, shayu)
		ParticleManager:SetParticleControlEnt( pp, 0, shayu, pos, nil, shayu:GetOrigin(), true );
	end
end

function ItemSpendCharge(keys)
	local ability = keys.ability
	local caster = keys.caster

	local charges = ability:GetCurrentCharges()
	charges = charges - 1
	ability:SetCurrentCharges(charges)
	if ability:IsPermanent() == false and charges <= 0 then
		caster:RemoveItem(ability)
	end
end

function DKAttack(keys)
	local caster = keys.caster
    local target = keys.target
    local ability = keys.ability
    local level = ability:GetLevel()

    local target_units = FindUnitsInRadiusByTeam({
		team = caster:GetTeam(),
		role = 2,
		position = target:GetAbsOrigin(),
		radius = 300,
	})
	for _,unit in pairs(target_units) do
		--获取攻击伤害
		if IsUnitExist(unit) then
			if unit:entindex() ~= target:entindex() then
				--主目标不会再造成额外伤害
			    local attack_damage = keys.Damage
			    local per = GetAbilityKV(ability,'splash_percent')
			    local damage = attack_damage*per/100
			    local damageTable = {
			    	victim=unit,
			    	attacker=caster,
			    	damage_type=DAMAGE_TYPE_PURE,
			    	damage=damage
			    }
			    ApplyDamage(damageTable)
			end

			--但包括主目标的所有目标都有减速/毒的效果
		    if level >= 2 then
		    	local per_slow = GetAbilityKV(ability,'slow_percent')
		    	ability:ApplyDataDrivenModifier(caster,unit,'modifier_dk_slow',{})
			end
			if level >= 3 then
				local per_slow = GetAbilityKV(ability,'poison_percent')
		    	ability:ApplyDataDrivenModifier(caster,unit,'modifier_dk_poison',{})
			end
		end
	end
end

function DragonForm(keys)
	local ability = keys.ability
	local caster = keys.caster
	local level = ability:GetLevel() or 1
	local particle_list = {
		[1] = 'particles/units/heroes/hero_dragon_knight/dragon_knight_transform_red.vpcf',
		[2] = 'particles/units/heroes/hero_dragon_knight/dragon_knight_transform_red.vpcf',
		[3] = 'particles/units/heroes/hero_dragon_knight/dragon_knight_transform_red.vpcf',
	}
	local name_list = {
		[1] = 'chess_dk_dragon',
		[2] = 'chess_dk1_dragon',
		[3] = 'chess_dk11_dragon',
	}

	local team_id = caster:GetTeam()
	local at_team_id = caster.at_team_id or caster.team_id
	play_particle(particle_list[level],PATTACH_ABSORIGIN_FOLLOW,caster,3)

	TransformAChess(caster,name_list[level],true,function(x)
		if IsUnitExist(x) then
			AddAbilityAndSetLevel(x,"dk_dragon_attack",level)
			EmitSoundOn("Hero_DragonKnight.ElderDragonForm",x)
		end
	end)
end

function DkPoisonDamage(keys)
	local caster = keys.caster
	local target = keys.target
	local max_hp = target:GetMaxHealth()
	local ability = keys.ability
	local damage_per = GetAbilityKV(ability, "poison_percent") or 5
	local damage = max_hp/100.0*damage_per

	if keys.target:IsMagicImmune() == false then
	    ApplyDamage({
	    	victim = target,
	    	attacker = caster,
	    	damage_type = DAMAGE_TYPE_MAGICAL,
	    	damage = damage,
			ability = ability,
	    })
	end
end

function GetAllComboModifierAbilityByChess(u)
	local ability_table = {}
	local all_modifier = u:FindAllModifiers()
	for _,m in pairs(all_modifier) do
		local a = FindAbilityInComboModifier(m:GetName())
		if a ~= nil then
			table.insert(ability_table,a)
		end
	end
	return ability_table
end

function FindAbilityInComboModifier(m)
	for _,c in pairs(_G.combo_ability_type) do
		if c and c.ability ~= nil and m == 'modifier_'..c.ability then
			return c.ability
		end
		if c and c.ability_special ~= nil and m == 'modifier_'..c.ability_special then
			return c.ability_special
		end
	end
	return nil
end

function GetCurrMapInfo()
	local map_info = {
		map_name = 'casual_1x8',
		min_mmr_level = 0,
		is_2p = false,
		has_ob = false,
	}
	local map_name = GetMapName()
	if map_name == 'ranked_1x8' then
		map_info.map_name = 'ranked_1x8'
	elseif map_name == 'ranked_1x8_bishop+' then
		map_info.map_name = 'ranked_1x8'
		map_info.map_name_real = map_name
		map_info.min_mmr_level = 19
	elseif map_name == 'ranked_1x8_rook+' then
		map_info.map_name = 'ranked_1x8'
		map_info.map_name_real = map_name
		map_info.min_mmr_level = 28
	elseif map_name == 'ranked_1x8_king+' then
		map_info.map_name = 'ranked_1x8'
		map_info.map_name_real = map_name
		map_info.min_mmr_level = 37
	elseif map_name == 'casual_1x8' then
		map_info.map_name = 'casual_1x8'
		map_info.min_mmr_level = 0
	elseif map_name == 'casual_1x8_ob' then
		map_info.map_name = 'casual_1x8'
		map_info.map_name_real = map_name
		map_info.min_mmr_level = 0
		map_info.has_ob = true
	elseif map_name == 'ranked_2x4' then
		map_info.map_name = 'ranked_2x4'
		map_info.min_mmr_level = 0
		map_info.is_2p = true
	elseif map_name == 'casual_2x4' then
		map_info.map_name = 'casual_2x4'
		map_info.min_mmr_level = 0
		map_info.is_2p = true
	elseif map_name == 'casual_2x4_ob' then
		map_info.map_name = 'casual_2x4'
		map_info.min_mmr_level = 0
		map_info.is_2p = true
		map_info.has_ob = true
	end

	return map_info
end

function CheckQiangxiOwner(keys)
	local caster = keys.caster
	if IsUnitExist(caster) == false or caster:IsHero() == true then
		caster:RemoveModifierByName("modifier_item_qiangxi")
		caster:RemoveModifierByName("modifier_item_qiangxi2")
	end
end

function JinghunAttack(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability

	if target:HasModifier("modifier_kill") then
		--净化限时的召唤物棋子
		PurgeASummonedChess(caster,target)
	end
end

function PurgeASummonedChess(caster,target)
	if IsUnitExist(target) == false then
		return
	end
	if target:HasModifier("modifier_kill") then
		local hp = target:GetHealth()
		local damage = hp/4
		Timers:CreateTimer(0.1,function()
			ApplyDamage({
				victim=target,
				attacker=caster,
				damage_type=DAMAGE_TYPE_PURE,
				damage=damage,
			})
		end)

		play_particle("particles/generic_gameplay/generic_purge.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
		EmitSoundOn("item.diffusalblade",target)
	end
end

function FindFriendlyChessInRadius(unit, ability_filter, radius)
	for _,u in pairs(GetValidChessOnBoard(unit.at_team_id or unit.team_id)) do
		if IsUnitExist(u) == true and unit:entindex() ~= u:entindex() and(unit:GetAbsOrigin() - u:GetAbsOrigin()):Length2D() <= radius and unit:GetTeam() == u:GetTeam() and u:HasAbility(ability_filter) then
			return true
		end
	end
	return false
end

function DAC:OnTesterBoxStartBattle(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	local team_id = hero:GetTeam()
	if _G.game_status ~= 2 then
		EmitGlobalSound("ui.abilitydraft_yourpick")
		combat('TESTER: GO!')
		_G.prepare_timer_ingame = 7
	else
		CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
			key = GetClientKey(team_id),
			text = "text_mima_cannot_do_in_battle",
		})
	end
end

function DAC:OnTesterBoxChooseRound(keys)
	if _G.game_status ~= 2 then
		local round = tonumber(keys.round)
		EmitGlobalSound("ui.abilitydraft_yourpick")
		combat('TESTER: ROUND = '..round )
		_G.battle_round = round
		CustomNetTables:SetTableValue( "game_info", "round_info", { round = _G.battle_round } )
	else
		if keys.PlayerID ~= nil then
			local hero = PlayerId2Hero(keys.PlayerID)
			local team_id = hero:GetTeam()
			CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
				key = GetClientKey(team_id),
				text = "text_mima_cannot_do_in_battle",
			})
		end
	end
end

function DAC:OnTesterBoxGiveMoney(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	if IsUnitExist(hero) then
		EmitGlobalSound("ui.abilitydraft_yourpick")
		local money = tonumber(keys.money or 100)
		combat('TESTER: +'..money..' GOLD')
		AddMana(hero, money)
		AddTotalMoneyStat(hero:GetPlayerID(), money)
	end
end

function DAC:OnTesterBoxGiveExp(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	if IsUnitExist(hero) then
		EmitGlobalSound("ui.abilitydraft_yourpick")
		local exp = tonumber(keys.exp or 9999) 
		combat('TESTER: +'..exp..' EXP')
		ExpBook({
			caster = hero,
			xpadd = exp,
			cost = 0,
		})
	end
end

function DAC:OnTesterBoxShowDamage(keys)
	local is_show_damage = keys.is_show_damage
	if is_show_damage == 1 then
		EmitGlobalSound("ui.abilitydraft_yourpick")
		combat('TESTER: SHOW DAMAGE')
		_G.show_damage = true
	else
		EmitGlobalSound("ui.abilitydraft_yourpick")
		combat('TESTER: HIDE DAMAGE')
		_G.show_damage = false
	end
end

function DAC:OnTesterBoxShowGrid(keys)
	local team_id = _G.playerid2team[keys.PlayerID]
	local is_show_damage = keys.is_show_grid
	if is_show_damage == 1 then
		EmitGlobalSound("ui.abilitydraft_yourpick")
		combat('TESTER: SHOW GRID')
		StartShowGrid(team_id)
	else
		EmitGlobalSound("ui.abilitydraft_yourpick")
		combat('TESTER: HIDE GRID')
		StopShowGrid(team_id)
	end
end

function DAC:OnTesterBoxGiveChess(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	if IsUnitExist(hero) then
		CreateChessInHand(hero,keys.chess)
	end
end

function DAC:OnTesterBoxGiveItem(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	if IsUnitExist(hero) then
		local i = keys.item
		local newItem = CreateItem( i, hero, hero )
		local drop = CreateItemOnPositionForLaunch(hero:GetAbsOrigin(), newItem )
		local dropRadius = RandomFloat( 50, 200 )
		newItem:LaunchLootInitialHeight( false, 0, 200, 0.75, hero:GetAbsOrigin()+RandomVector(dropRadius))
	end
end

function Add2DamageStat(attacker, victim, damage, damage_type)
	--伤害统计
	attacker = attacker.damage_owner or attacker
	if IsUnitExist(attacker) == true then
		local attacker_id = attacker:GetEntityIndex()
		local team_id = attacker.team_id
		if team_id == nil or _G.damage_stat[team_id] == nil then
			return
		end

		if _G.damage_stat[team_id][attacker:entindex()] == nil then
			_G.damage_stat[team_id][attacker:entindex()] = {
				unit_name = attacker:GetUnitName(),
				total = 0,
				physical = 0,
				magical = 0,
				pure = 0,
			}
		end

		if damage_type == DAMAGE_TYPE_PHYSICAL then
			_G.damage_stat[team_id][attacker:entindex()]['physical'] = _G.damage_stat[team_id][attacker:entindex()]['physical'] + damage
		end
		if damage_type == DAMAGE_TYPE_MAGICAL then
			_G.damage_stat[team_id][attacker:entindex()]['magical'] = _G.damage_stat[team_id][attacker:entindex()]['magical'] + damage
		end
		if damage_type == DAMAGE_TYPE_PURE then
			_G.damage_stat[team_id][attacker:entindex()]['pure'] = _G.damage_stat[team_id][attacker:entindex()]['pure'] + damage
		end
		_G.damage_stat[team_id][attacker:entindex()]['total'] = _G.damage_stat[team_id][attacker:entindex()]['physical']+_G.damage_stat[team_id][attacker:entindex()]['magical']+_G.damage_stat[team_id][attacker:entindex()]['pure']

		-- local curr_damage = _G.damage_stat[team_id][attacker:GetUnitName()]
		-- if curr_damage == nil then
		-- 	curr_damage = 0
		-- end
		-- curr_damage = curr_damage + damage
		-- _G.damage_stat[team_id][attacker:GetUnitName()] = curr_damage


		--计算时间，看看要不要刷新UI展示
		local g_time = GameRules:GetGameTime()
		if GameRules:GetGameModeEntity()['last_g_time'..team_id] == nil then
			GameRules:GetGameModeEntity()['last_g_time'..team_id] = 0
		end
		local time_this_level = 51 - _G.battle_timer
		if g_time - GameRules:GetGameModeEntity()['last_g_time'..team_id] > 0.25 then
			GameRules:GetGameModeEntity()['last_g_time'..team_id] = g_time
			ShowDamageStatOfTeam(team_id)
		end
	end
end


function SpectreHaunt(keys)
	local spe = keys.caster
	local ability = keys.ability
	local duration = GetAbilityKV(ability, "duration") or 6
	local board_team = spe.at_team_id or spe.team_id
	if ability:GetLevel() < 3 then
		EmitSoundOn('Hero_Spectre.Haunt',spe)
	else
		EmitSoundOn('chess_spe.dota1',spe)
	end
	play_particle('particles/econ/items/spectre/spectre_arcana/spectre_arcana_haunt_caster.vpcf',PATTACH_ABSORIGIN_FOLLOW,spe,3)
	local curr_hp = spe:GetHealth()

	local spe_dogs = GetAllEnemyChess(spe)
	for i,v in pairs(spe_dogs) do
		local backward_v  = v:GetAbsOrigin() - v:GetForwardVector():Normalized()*128
		local backward_x = Vector2X(backward_v,board_team)
		local backward_y = Vector2Y(backward_v,board_team)
		if IsIn8x8(backward_x,backward_y) == true and IsEmptyGrid(board_team,backward_x,backward_y) == true then
			local items = GetAllItemsInUnits({[1] = spe})
			local spe_haunt = SummonOneMinion(spe,spe:GetUnitName(),XY2Vector(backward_x,backward_y,board_team))
			if IsUnitExist(spe_haunt) then
				if items ~= nil then
					GiveItems2Unit(items,spe_haunt)
				end
				FillEmptySlot(spe_haunt)
				ExtendBeastBuff(spe_haunt,spe)
				spe_haunt.is_summoned = false
				spe_haunt:AddNewModifier(spe_haunt,nil,"modifier_illusion",{duration = duration})
				AddAbilityAndSetLevel(spe_haunt,'spe_desolate',1)
				spe_haunt:SetForwardVector(v:GetAbsOrigin()-spe_haunt:GetAbsOrigin())
				play_particle('particles/econ/items/spectre/spectre_arcana/spectre_arcana_haunt_caster.vpcf',PATTACH_ABSORIGIN_FOLLOW,spe_haunt,3)

				spe_haunt:SetHealth(curr_hp) --幻象与幽鬼同样血量
			end
		end
	end
end
function IsLonely(u)
	if IsUnitExist(u) == false then
		return false
	end
	for i,v in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) and u:entindex() ~= v:entindex() and u:GetTeam() == v:GetTeam() and (u:GetAbsOrigin()-v:GetAbsOrigin()):Length2D() < 209 then
			return false
		end
	end
	return true
end
function IsLonely4Team(u, team_id)
	if IsUnitExist(u) == false then
		return false
	end
	for i,v in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(v) and u:entindex() ~= v:entindex() and v:GetTeam() == team_id and (u:GetAbsOrigin()-v:GetAbsOrigin()):Length2D() < 205 then
			return false
		end
	end
	return true
end
function IsGridLonely4Team(at_team_id, x, y, team_id)
	local p = XY2Vector(x,y,at_team_id)
	for i,v in pairs (GetValidChessOnBoard(at_team_id)) do
		if IsUnitExist(v) and (v:GetTeam() == team_id or team_id == nil) and (p-v:GetAbsOrigin()):Length2D() < 205 then
			return false
		end
	end
	return true
end

function AddDemonBuff(keys)
	local c = keys.caster
	local aa = AddAbilityAndSetLevel(c,'is_demon_buff')
	aa:ApplyDataDrivenModifier(c,c,'modifier_is_demon_buff',{})
end

function Jurenzhijie(keys)
	local caster = keys.caster

	--变大，嘲讽
	TauntEnemy(keys)

	local curr_model_scale = caster:GetModelScale()
	caster.curr_model_scale = curr_model_scale
	local scale = curr_model_scale*1.5
	AddModelScalePlus(caster, scale)

	play_particle("particles/units/heroes/hero_axe/axe_beserkers_call_owner.vpcf",PATTACH_ABSORIGIN_FOLLOW,caster,5)

	--播放声音
	EmitSoundOn("bkb.dota1",caster)
end

function JurenzhijieEnd(keys)

	local caster = keys.caster
	if caster.curr_model_scale then
		AddModelScalePlus(caster, caster.curr_model_scale)
	end
	caster.curr_model_scale = nil
end

function Jingmixie(keys)
	local caster = keys.caster
	if caster:IsHero() or caster:HasModifier('modifier_illusion') then
		return
	end

	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 1,
		position = caster:GetAbsOrigin(),
		radius = 300,
	})
	
	for _,luckydog in pairs(units) do
		luckydog:Heal(20, caster)
	end
end

function Kongaozhixin(keys)
	local caster = keys.caster
	if caster:IsHero() or caster:HasModifier('modifier_illusion') then
		return
	end

	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 1,
		position = caster:GetAbsOrigin(),
		radius = 300,
	})
	
	for _,luckydog in pairs(units) do
		local heal = caster:GetMaxHealth()*0.015
		luckydog:Heal(heal, caster)
	end
end

function DAC:RequestShowConfig(keys)
	local player_id = keys.PlayerID
	local team_id = _G.playerid2team[player_id]
	if team_id then
		CustomGameEventManager:Send_ServerToTeam(team_id,"show_config",{
			key = GetClientKey(team_id),
			hehe = RandomInt(1,100000),
		});
	end
end

function DAC:OnUpdateUserSettings(keys)
	local player_id = keys.PlayerID
	local hero = _G.playerid2hero[player_id]

	if hero == nil then
		return
	end
	local steam_id = hero.steam_id

	if steam_id ~= nil and _G.user_setting[steam_id] ~= nil then
		_G.user_setting[steam_id][keys.key] = keys.value
		CustomNetTables:SetTableValue( "setting_table", "show_settings", _G.user_setting)
	end

	if keys.key == 'is_auto_combine' then
		hero.is_auto_combine = keys.value
	end
	if keys.key == 'is_click_select' then
		CustomGameEventManager:Send_ServerToTeam(hero:GetTeam(),"toggle_is_click_select",{
			key = GetClientKey(hero:GetTeam()),
			is_click_select = keys.value,
			hehe = RandomInt(1,100000),
		});
	end
end

function DAC:GGSimida(keys)
	local player_id = keys.PlayerID
	local hero = _G.playerid2hero[player_id]
	if IsUnitExist(hero) == true then
		KillSelfTeam(hero:GetTeam())
	end
end

function DAC:OnCourierTP(keys)
	local player_id = keys.PlayerID
	local hero = _G.playerid2hero[player_id]
	if IsUnitExist(hero) == true then
		AddAbilityAndSetLevel(hero,'tp')
		if hero:FindAbilityByName('tp'):IsCooldownReady() then
			ExecuteOrderFromTable({
				UnitIndex = hero:entindex(),
				OrderType = DOTA_UNIT_ORDER_CAST_NO_TARGET,
				AbilityIndex = hero:FindAbilityByName('tp'):entindex(), 
				Queue = 0,
			})
		else
			RemoveAbilityAndModifier(hero,'tp')
		end
	end
end

function TPEffect(keys)
	local caster = keys.caster

	if caster.tp_effect_start then
		ParticleManager:DestroyParticle(caster.tp_effect_start,true)
	end
	if caster.tp_target_start then
		ParticleManager:DestroyParticle(caster.tp_target_start,true)
	end
	StopSoundOn('Portal.Loop_Appear', caster)

	local p = Entities:FindByName(nil,'center'..(caster:GetTeam()-6)):GetOrigin()+Vector(0,-320,512)

	caster.tp_effect_start = play_particle('particles/items2_fx/teleport_start.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster)
	EmitSoundOn('Portal.Loop_Appear', caster)

	local animation_info = GetAnimation(caster.animation or 'n000')
	--播放起始动画
	caster.tp_target_start = ShowTPEffectAtPosition(p,animation_info.tp_effect)

	keys.ability:ApplyDataDrivenModifier(caster,caster,'modifier_tp',{ duration = 2})
end

function TPSuccess(keys)
	local caster = keys.caster
	RemoveAbilityAndModifier(caster,'tp')
	local p = Entities:FindByName(nil,'center'..(caster:GetTeam()-6)):GetOrigin()+Vector(0,-320,512)
	FindClearSpaceForUnit(caster,p,true)

	if caster.tp_effect_start ~= nil then
		ParticleManager:DestroyParticle(caster.tp_effect_start,true)
	end
	if caster.tp_target_start ~= nil then
		ParticleManager:DestroyParticle(caster.tp_target_start,true)
	end
	StopSoundOn('Portal.Loop_Appear', caster)

	local animation_info = GetAnimation(caster.animation or 'n000')

	--播放后续动画
	if animation_info.tp_sound ~= nil then
		EmitSoundOn(animation_info.tp_sound,caster)
	end
	if animation_info.animation_modifier ~= nil then
		BlinkChessX({caster=caster,blink_type=animation_info.animation_modifier})
	end
	if animation_info.end_effect ~= nil then
		play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,caster,3)
	end
end

function TPFailed(keys)
	local caster = keys.caster

	RemoveAbilityAndModifier(caster,'tp')

	if caster.tp_effect_start then
		ParticleManager:DestroyParticle(caster.tp_effect_start,true)
	end
	if caster.tp_target_start then
		ParticleManager:DestroyParticle(caster.tp_target_start,true)
	end
	StopSoundOn('Portal.Loop_Appear', caster)
end

function DAC:GetAllPlayerInfoFromServer(keys)
	if _G.request_all_user_info_from_server ~= true then
		--只请求一次
		_G.request_all_user_info_from_server = true
		local url = "http://autochess.ppbizon.com/courier/get/@"..JoinTableString(_G.playerid2steamid).."?hehe="..RandomInt(1,9999)
		url = url..GetSendKey()

		local req = CreateHTTPRequestScriptVM('GET', url)
		req:SetHTTPRequestAbsoluteTimeoutMS(20000)

		req:Send(function(res)
			if res.StatusCode ~= 200 or not res.Body then
				if fail_callback ~= nil then
					combat('LOAD PLAYER INFO FAILED!')
				end
				return
			end

			local t = json.decode(res.Body)
			combat('LOAD PLAYER INFO OK!')
			if t ~= nil and t.err == 0 then
				local user_info_by_playerid = {}
				for steam_id, user_info in pairs(t.user_info) do
					local player_id = _G.steamid2playerid[steam_id]
					user_info_by_playerid[player_id] = {}
					local info = user_info_by_playerid[player_id]
					info['player_id'] = player_id
					info['steam_id'] = steam_id
					info['mmr_level'] = user_info["mmr_level"]
					info['queen_rank'] = user_info["queen_rank"]
					info['player_name'] = _G.steamid2name[steam_id]
					info['zhugong'] = JoinTableString(user_info["zhugong"])
					info['onduty_hero'] = user_info["onduty_hero"]
					info['onduty_chessboard'] = user_info["onduty_chessboard"]
					info['chessboard_list'] = json.encode(user_info['chessboard_list'])
					info['badgeall'] = user_info['badgeall']

					DAC:OnUpdateMMRLevel({
						PlayerID = player_id,
						mmr_level = user_info["mmr_level"] or 0,
						queen_rank = user_info["queen_rank"]
					})
				end

				CustomGameEventManager:Send_ServerToAllClients("update_user_info",{
					hehe = RandomFloat(1,10000),
					user_info = user_info_by_playerid,
					notice = t.notice,
				});
			end
		end)

	end
end

--卡尔-超震声波（去掉了击退效果）
function deafening_blast_start( keys )
    local caster = keys.caster
    local caster_location = caster:GetAbsOrigin()
    local target_point = keys.target_points[1]
    local ability = keys.ability
    local ability_level = ability:GetLevel() - 1
    local quas_level = 1
    if caster:FindAbilityByName("invoker_quas") ~= nil then
        quas_level = caster:FindAbilityByName("invoker_quas"):GetLevel() - 1
    end

    -- Ability and projectile variables
    local knockback_duration = ability:GetLevelSpecialValueFor("knockback_duration", quas_level) + 0.1
    local travel_distance = ability:GetLevelSpecialValueFor("travel_distance", ability_level) 
    local travel_speed = ability:GetLevelSpecialValueFor("travel_speed", ability_level) 
    local radius_start = ability:GetLevelSpecialValueFor("radius_start", ability_level) 
    local radius_end = ability:GetLevelSpecialValueFor("radius_end", ability_level) 
    local dummy_ability_name = keys.dummy_ability_name
    local projectile_name = keys.projectile_name
    local direction = (target_point - caster_location):Normalized()

    -- Create projectile
    local projectile_table =
    {
        EffectName = projectile_name,
        Ability = ability,
        vSpawnOrigin = caster_location,
        vVelocity = direction * travel_speed,
        fDistance = travel_distance,
        fStartRadius = radius_start,
        fEndRadius = radius_end,
        Source = caster,
        bHasFrontalCone = true,
        iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
		iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
		iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
		bReplaceExisting = false,
		bProvidesVision = false,
    }
    ProjectileManager:CreateLinearProjectile( projectile_table )
end

function deafening_blast_hit( keys )
    local caster = keys.caster -- Hero
    local target = keys.target
    local ability = keys.ability
    local owner_ability_level = ability:GetLevel()

    -- Ability variables
    local damage = ability:GetLevelSpecialValueFor("damage", owner_ability_level-1) 
    local disarm_duration = ability:GetLevelSpecialValueFor("disarm_duration", owner_ability_level-1) 

    -- Initialize the damage table and deal the damage
    local damage_table = {}
    damage_table.attacker = caster
    damage_table.victim = target
    damage_table.ability = ability
    damage_table.damage_type = ability:GetAbilityDamageType() 
    damage_table.damage = damage

    ApplyDamage(damage_table)

    ability:ApplyDataDrivenModifier(caster, target, "modifier_deafening_blast_disarm_datadriven", {duration = disarm_duration})

    HunterKnockBack({
        caster = caster,
        target = target,
    })
end

--祈求者：强袭飓风（重制版）
function invoker_tornado_datadriven_on_spell_start(keys)
	local caster_origin = keys.caster:GetAbsOrigin()
	keys.caster:EmitSound("Hero_Invoker.Tornado")

	local effect = "particles/units/heroes/hero_invoker/invoker_tornado.vpcf"
	if keys.ability:GetLevel() >= 2 then
		effect = "particles/econ/items/invoker/invoker_ti6/invoker_tornado_ti6.vpcf"
	end

	local projectile_information =
	{
		EffectName = effect,
		Ability = keys.ability,
		vSpawnOrigin = keys.caster:GetAbsOrigin(),
		fDistance = GetAbilityKV(keys.ability, "travel_distance") or 800,
		fStartRadius = GetAbilityKV(keys.ability, "area_of_effect") or 200,
		fEndRadius = GetAbilityKV(keys.ability, "area_of_effect") or 200,
		Source = keys.caster,
		bHasFrontalCone = false,
		iMoveSpeed = GetAbilityKV(keys.ability, "travel_speed") or 1000,
		bReplaceExisting = false,
		bProvidesVision = true,
		iVisionTeamNumber = keys.caster:GetTeam(),
		iVisionRadius = GetAbilityKV(keys.ability, "vision_distance") or 500,
		bDrawsOnMinimap = false,
		bVisibleToEnemies = true,
		iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_ENEMY,
		iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,
		iUnitTargetType = DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,
		fExpireTime = GameRules:GetGameTime() + 20.0,
	}

	local target_point = keys.target_points[1]
	target_point.z = 0
	local caster_point = keys.caster:GetAbsOrigin()
	caster_point.z = 0
	local point_difference_normalized = (target_point - caster_point):Normalized()
	projectile_information.vVelocity = point_difference_normalized * keys.TravelSpeed

	local tornado_projectile = ProjectileManager:CreateLinearProjectile(projectile_information)
end
function invoker_tornado_datadriven_on_projectile_hit_unit(keys)
	if IsUnitExist(keys.target) and HasMovingModifier(keys.target) == false then
		--Store the target's forward vector so they can be left facing in the same direction when they land.
		keys.target.invoker_tornado_forward_vector = keys.target:GetForwardVector()

		local lift_duration = GetAbilityKV(keys.ability, "lift_duration") or 2
		keys.caster.invoker_tornado_lift_duration = lift_duration
		keys.ability:ApplyDataDrivenModifier(keys.caster, keys.target, "modifier_invoker_tornado_datadriven_cyclone", {
			duration = lift_duration,
		})
		keys.target:EmitSound("Hero_Invoker.Tornado.Target")
		--Stop the sound when the cycloning ends.
		Timers:CreateTimer(lift_duration,function()
			if IsUnitExist(keys.target) == false then return end
			keys.target:StopSound("Hero_Invoker.Tornado.Target")
		end)
	end
end

function modifier_invoker_tornado_datadriven_cyclone_on_destroy(keys)
	keys.target:EmitSound("Hero_Invoker.Tornado.LandDamage")

	--Set it so the target is facing the same direction as they were when they were hit by the tornado.
	if keys.target.invoker_tornado_forward_vector ~= nil then
		keys.target:SetForwardVector(keys.target.invoker_tornado_forward_vector)
	end

	ApplyDamage({
		victim = keys.target, 
		attacker = keys.caster, 
		damage = GetAbilityKV(keys.ability, "base_damage") or 400, 
		damage_type = DAMAGE_TYPE_MAGICAL,
	})

	keys.target.invoker_tornado_degrees_to_spin = nil
end

function modifier_invoker_tornado_datadriven_cyclone_on_interval_think(keys)
	local total_degrees = 20

	--Rotate as close to 20 degrees per .03 seconds (666.666 degrees per second) as possible, but such that the target lands facing their initial direction.
	if keys.target.invoker_tornado_degrees_to_spin == nil and keys.caster.invoker_tornado_lift_duration ~= nil then
		local ideal_degrees_per_second = 666.666
		local ideal_full_spins = (ideal_degrees_per_second / 360) * keys.caster.invoker_tornado_lift_duration
		ideal_full_spins = math.floor(ideal_full_spins + .5) --Round the number of spins to aim for to the closest integer.
		local degrees_per_second_ending_in_same_forward_vector = (360 * ideal_full_spins) / keys.caster.invoker_tornado_lift_duration

		keys.target.invoker_tornado_degrees_to_spin = degrees_per_second_ending_in_same_forward_vector * .03
	end

	keys.target:SetForwardVector(RotatePosition(Vector(0,0,0), QAngle(0, keys.target.invoker_tornado_degrees_to_spin, 0), keys.target:GetForwardVector()))
end

function modifier_invoker_tornado_datadriven_cyclone_on_created(keys)
	local caster = keys.caster
	local target = keys.target
	local ability = keys.ability

	-- Position variables
	local target_origin = target:GetAbsOrigin()
	local target_initial_x = target_origin.x
	local target_initial_y = target_origin.y
	local target_initial_z = target_origin.z
	local position = Vector(target_initial_x, target_initial_y, target_initial_z) --This is updated whenever the target has their position changed.

	local duration = GetAbilityKV(keys.ability, "lift_duration") or 2

	local ground_position = GetGroundPosition(position, target)
	local cyclone_initial_height = keys.CycloneInitialHeight + ground_position.z
	local cyclone_min_height = keys.CycloneMinHeight + ground_position.z
	local cyclone_max_height = keys.CycloneMaxHeight + ground_position.z
	local tornado_start = GameRules:GetGameTime()

	-- Height per time calculation
	local time_to_reach_initial_height = duration / 10 --1/10th of the total cyclone duration will be spent ascending and descending to and from the initial height.
	local initial_ascent_height_per_frame = ((cyclone_initial_height - position.z) / time_to_reach_initial_height) * .03 --This is the height to add every frame when the unit is first cycloned, and applies until the caster reaches their max height.

	local up_down_cycle_height_per_frame = initial_ascent_height_per_frame / 3 --This is the height to add or remove every frame while the caster is in up/down cycle mode.
	if up_down_cycle_height_per_frame > 7.5 then --Cap this value so the unit doesn't jerk up and down for short-duration cyclones.
		up_down_cycle_height_per_frame = 7.5
	end

	local final_descent_height_per_frame = nil --This is calculated when the unit begins descending.

	-- Time to go down
	local time_to_stop_fly = duration - time_to_reach_initial_height

	-- Loop up and down
	local going_up = true

	-- Loop every frame for the duration
	Timers:CreateTimer(function()
		local time_in_air = GameRules:GetGameTime() - tornado_start
		if IsUnitExist(target) == false then return end
		-- First send the target to the cyclone's initial height.
		if position.z < cyclone_initial_height and time_in_air <= time_to_reach_initial_height then
			position.z = position.z + initial_ascent_height_per_frame
			target:SetAbsOrigin(position)
			return 0.03
		-- Go down until the target reaches the ground.
		elseif time_in_air > time_to_stop_fly and time_in_air <= duration then
			--Since the unit may be anywhere between the cyclone's min and max height values when they start descending to the ground,
			--the descending height per frame must be calculated when that begins, so the unit will end up right on the ground when the duration is supposed to end.
			if final_descent_height_per_frame == nil then
				local descent_initial_height_above_ground = position.z - ground_position.z
				final_descent_height_per_frame = (descent_initial_height_above_ground / time_to_reach_initial_height) * .03
			end

			position.z = position.z - final_descent_height_per_frame
			target:SetAbsOrigin(position)
			return 0.03
		-- Do Up and down cycles
		elseif time_in_air <= duration then
			-- Up
			if position.z < cyclone_max_height and going_up then
				position.z = position.z + up_down_cycle_height_per_frame
				target:SetAbsOrigin(position)
				return 0.03
			-- Down
			elseif position.z >= cyclone_min_height then
				going_up = false
				position.z = position.z - up_down_cycle_height_per_frame
				target:SetAbsOrigin(position)
				return 0.03


			-- Go up again
			else
				going_up = true
				return 0.03
			end
		else
		end
	end)
end

--棋子是否在技能施法期间需要走动？
function IsChannelingWalk(u)
	if IsUnitExist(u) == false then
		return false
	end
	if u:HasModifier('modifier_juggernaut_blade_fury') == true then
		return true
	end
	if u:HasModifier('modifier_leshrac_pulse_nova') == true then
		return true
	end
	return false
end

function IsEscapeMonk(u)
	if IsUnitExist(u) == false then
		return false
	end
	if u:HasAbility('is_monk') == false then
		return false
	end
	if u.is_monk_escaped == true then
		return false
	end
	if IsLonely(u) == true then
		return false
	end
	if u.is_monk_escaping == true then
		return true
	end
	
	-- if HasShoes(u) == false then
	-- 	return false
	-- end
	if HasAbilityBuff(u) == true then
		return false
	end
	local hp = u:GetHealth()
	local max_hp = u:GetMaxHealth()
	if 1.0*hp/max_hp < 0.3 then
		if FindNextMonkEscapePosition(u) ~= nil then
			return true
		else
			return false
		end
	else
		return false
	end
end

function IsEscapePriest(u)
	if IsUnitExist(u) == false then
		return false
	end
	if u:HasAbility('is_priest') == false then
		return false
	end
	if u:IsChanneling() == true then
		return false
	end
	if u.is_priest_escaping == true then
		return true
	end
	local enemy_team_id = 4
	if u:GetTeam() == 4 then
		enemy_team_id = u.at_team_id
	end
	if IsLonely4Team(u,enemy_team_id) == false then
		if FindNextPriestEscapePosition(u) ~= nil then
			return true
		else
			return false
		end
	else
		return false
	end
end

--如果attacker移动到x,y是否可以攻击target，不传x，y就是attaacker当前位置
function IsCanAttackTarget(attacker,target,x,y)
	if IsUnitExist(attacker) == false then
		return false
	end
	if target == nil then
		target = attacker:GetAttackTarget()
		if IsUnitExist(target) == false then
			return false
		end
	end
	if attacker:GetTeam() == target:GetTeam() then
		return false
	end
	if target:IsInvulnerable() == true then
		return false
	end 
	local team_id = attacker.at_team_id or attacker.team_id
	if x == nil then
		x = attacker.x
	end
	if y == nil then
		y = attacker.y
	end
	if x and y and target.x and target.y then
		local p = XY2Vector(x,y,team_id)
		local p2 = target:GetAbsOrigin() --XY2Vector(target.x,target.y,team_id) 
		if target:IsInvisible() == false and target:HasModifier('modifier_skeleton_king_reincarnation_scepter_active') == false and (p - p2):Length2D() < attacker:Script_GetAttackRange() + target:GetHullRadius() + attacker:GetHullRadius() then
			return true
		else
			return false
		end
	else
		return false
	end
end

function DAC:RequestExportLineup(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	local team_id = hero:GetTeam()
	local data = {
		mychess = CopyTable(_G.mychess[team_id]),
		yourchess = CopyTable(_G.yourchess[team_id]),
	}

	for _,d in pairs(data.mychess) do
		if d.index ~= nil then
			local unit = EntIndexToHScript(d.index)
			d.item = GetAllItemsInUnits({[1] = unit})
		end
	end
	for _,d in pairs(data.yourchess) do
		if d.index ~= nil then
			local unit = EntIndexToHScript(d.index)
			d.item = GetAllItemsInUnits({[1] = unit})
		end
	end

	local data_str = json.encode(data)
	-- local data_base64 = base64.encode(data_str)

	local url = "http://autochess.ppbizon.com/lineup/str/add?str="..data_str
	url = url..GetSendKey()

	local req = CreateHTTPRequestScriptVM('GET', url)
	req:SetHTTPRequestAbsoluteTimeoutMS(20000)

	req:Send(function(res)
		if res.StatusCode ~= 200 or not res.Body then
			if fail_callback ~= nil then
				combat('EXPORT LINEUP FAILED!')
			end
			return
		end

		local t = json.decode(res.Body)
		
		if t ~= nil and t.err == 0 then
			combat('EXPORT LINEUP OK!')
			local key = t.key
			CustomGameEventManager:Send_ServerToTeam(team_id,"export_lineup",{
				key = GetClientKey(team_i),
				hehe = RandomInt(1,100000),
				data = key,
			})
		else
			CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
				key = GetClientKey(team_id),
				text = "text_mima_export_error"
			})
			combat('EXPORT LINEUP ERROR:'..t.err)
		end
	end)
end

function DAC:RequestImportLineup(keys)
	local hero = PlayerId2Hero(keys.PlayerID)
	local team_id = hero:GetTeam()
	local data = keys.data

	local url = "http://autochess.ppbizon.com/lineup/str/get?key="..data

	local req = CreateHTTPRequestScriptVM('GET', url)
	req:SetHTTPRequestAbsoluteTimeoutMS(20000)

	req:Send(function(res)
		if res.StatusCode ~= 200 or not res.Body then
			if fail_callback ~= nil then
				combat('IMPORT LINEUP FAILED!')
			end
			return
		end

		local t = json.decode(res.Body)
		
		if t ~= nil and t.err == 0 and t.data then
			combat('IMPORT LINEUP OK!')
			local data = t.data
			local data_obj = json.decode(data)

			for _,v in pairs(GetValidChessOnBoard(team_id)) do
				if v ~= nil and v:IsNull() == false then
					v:Destroy()
				end
			end
			ClearAllYourChess(team_id)

			_G.mychess[team_id] = {}
			for _,d in pairs(data_obj.mychess) do
				_G.mychess[team_id][''..d.y..'_'..d.x] = d
			end
			_G.yourchess[team_id] = {}
			for _,d in pairs(data_obj.yourchess) do
				_G.yourchess[team_id][''..d.y..'_'..d.x] = d
			end

			_G.to_be_destory_list[team_id] = {}
			_G.unit[team_id] = {}

			for _,v in pairs(_G.mychess[team_id]) do
				RestoreOneChess(v,team_id)
			end
			for _,v in pairs(_G.yourchess[team_id]) do
				RestoreOneChess(v,team_id)
			end
		else
			CustomGameEventManager:Send_ServerToTeam(team_id,"mima",{
				key = GetClientKey(team_id),
				text = "text_mima_import_error"
			})
			combat('IMPORT LINEUP ERROR:'..t.err)
		end
	end)
end

--棋子穿鞋还是光脚
function HasShoes(u)
	if u:FindModifierByName('modifier_item_suduzhixue') ~= nil or u:FindModifierByName('modifier_item_aoshuxie') ~= nil or u:FindModifierByName('modifier_item_jingmixie') ~= nil or u:FindModifierByName('modifier_item_weishijingjia') ~= nil or u:FindModifierByName('modifier_item_wangchongtui') ~= nil or u:FindModifierByName('modifier_item_longxin') ~= nil then
		return true
	else
		return false
	end
end

--棋子是否有持续性技能buff（影响ai的判断）
function HasAbilityBuff(u)
	local buff_table = {
		'modifier_axe_berserkers_call_armor',
		'modifier_marci_unleash',
		'modifier_rattletrap_battery_assault',
		'modifier_alchemist_chemical_rage',
		'modifier_snapfire_lil_shredder_buff',
		'modifier_templar_assassin_refraction_absorb',
		'modifier_spiked_carapace_buff_datadriven',
	}
	for _,m in pairs(buff_table) do
		if u:HasModifier(m) then
			return true
		end
	end
	if u.is_comboing == true then
		return true
	end
	if u.is_fv_zhao == true then
		return true
	end
	return false
end
function MPRechargeBase(keys)
	if _G.game_status == 2 and keys.caster.ai_started == true then
		local mana_amp = AmplifyMPRecharge(keys.caster)
		local mana_get = math.floor(keys.caster:GetLevel()*(100+mana_amp)/100)
		ChessAddMana(keys.caster,mana_get)
	end
end
function AmplifyMPRecharge(u)
	local mana_x_list = {
		modifier_item_wangguan = 100,
		modifier_item_hongzhang_1 = 100,
		modifier_item_hongzhang_2 = 100,
		modifier_item_hongzhang_3 = 100,
		modifier_item_hongzhang_4 = 100,
		modifier_item_hongzhang_5 = 100,
		modifier_item_jixianfaqiu = 100,
		modifier_item_huanyingfu = 100,

		modifier_item_linkenfaqiu = 150,
		modifier_item_bingyan = 200,

		modifier_item_xuwubaoshi = 50,
		modifier_item_jianrenqiu = 50,
		modifier_item_kuangzhanfu = 50,
		modifier_item_shuaxinqiu = 100,
		modifier_item_qinglianbaozhu = 50,

		modifier_item_yangdao = 150,
		modifier_item_atuosi = 100,
		modifier_item_wangchongtui = 100,
		modifier_item_fulingsuo = 100,
		modifier_item_xueji = 100,
	}

	local mana_bonus = 0
	for m,b in pairs(mana_x_list) do
		if u:FindModifierByName(m) ~= nil then
			mana_bonus = mana_bonus + b
		end
	end

	if u:HasAbility('is_mage') and IsLonely(u) == false then
		local friendly_mage_count = GetFriendlyMageCount(u) or 0
		if friendly_mage_count >= 5 then
			friendly_mage_count = 5
		end
		mana_bonus = mana_bonus + (friendly_mage_count*10)
	end

	return mana_bonus
end

function GetFriendlyMageCount(u)
	local count = 0
	if IsUnitExist(u) == false then
		return 0
	end
	for _,unit in pairs (GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(unit) == true and u:GetTeam() == unit:GetTeam() then
			count = count + 1
		end
	end
	return count
end

function WarriorThink(keys)
	local caster = keys.caster
	local ability = keys.ability
	local modifier_name = keys.modifier_name
	if IsUnitExist(caster) == false or caster:HasAbility('is_warrior') == false then
		return
	end
	if caster:GetHealth() < caster:GetMaxHealth()/2 then
		if caster:HasModifier(modifier_name) == false then
			ability:ApplyDataDrivenModifier(caster, caster, modifier_name, {})
		end
	else
		if caster:HasModifier(modifier_name) == true then
			caster:RemoveModifierByName(modifier_name)
		end
	end
end

--hp bar table
function InitHPBarTable()
	if _G.hp_bar == nil then
		_G.hp_bar = {}
	end
	CustomNetTables:SetTableValue( "hp_bar_table", "hp_bar", _G.hp_bar)
	Timers:CreateTimer(1,function()
		RefreshHPBarTable()
		return 5
	end)
end

function AddHPBar2HPBarTable(keys)
	local unit_index = keys.unit_index
	local unit = EntIndexToHScript(unit_index)
	if _G.hp_bar[unit_index] == nil and IsUnitExist(unit) == true then
		hp_bar[unit_index] = {
			unit_index = unit_index,
			unit_name = unit:GetUnitName(),
			is_hero = unit:IsHero(),
		}
	end
	CustomNetTables:SetTableValue( "hp_bar_table", "hp_bar", _G.hp_bar)
end

function RefreshHPBarTable()
	for unit_index,info in pairs(_G.hp_bar) do
		local unit = EntIndexToHScript(unit_index)
		if IsUnitExist(unit) == false then
			_G.hp_bar[unit_index] = nil
		end
	end
	CustomNetTables:SetTableValue( "hp_bar_table", "hp_bar", _G.hp_bar)
end

function GetHPBarTableLength()
	local count = 0
	local str = ''
	for index,_ in pairs(_G.hp_bar) do
		count = count + 1
		str = str..index..','
	end
	return count,str
end

function SirenSong(keys)
	local siren = keys.caster
	local ability = keys.ability
	local units = FindUnitsInRadiusOnTeamGround({
		team = siren:GetTeam(),
		at_team = siren.at_team_id or siren.team_id,
		role = 2,
		position = siren:GetAbsOrigin(),
		radius = keys.radius,
	})

	local sleep_duration = GetAbilityKV(ability, "sleep_duration") or 9
	for _,u in pairs(units) do
		if RandomInt(1,100) < 50 and u:HasModifier('modifier_siren_song_debuff') == false and u.is_moving ~= true and u:IsMagicImmune() == false then
			ability:ApplyDataDrivenModifier(siren, u, 'modifier_siren_song_debuff', {
				duration = sleep_duration,
			})
		end
	end
end

function SirenSongStart(keys)
	local caster = keys.caster
	local ability = keys.ability
	local level = ability:GetLevel()
	local duration = GetAbilityKV(ability, "duration") or 7

	EmitSoundOn('Hero_NagaSiren.SongOfTheSiren',caster)
	keys.ability:ApplyDataDrivenModifier(caster, caster, 'modifier_siren_song_'..level, {
		duration = duration
	})
	-- caster.siren_song_effect = play_particle('particles/units/heroes/hero_siren/naga_siren_siren_song_cast.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster)
end

function SirenSongEnd(keys)
	local caster = keys.caster
	StopSoundOn('Hero_NagaSiren.SongOfTheSiren',caster)
	if caster.siren_song_effect ~= nil then
		ParticleManager:DestroyParticle(caster.siren_song_effect,true)
	end
	play_particle('particles/units/heroes/hero_siren/naga_siren_siren_song_end.vpcf',PATTACH_ABSORIGIN_FOLLOW,caster)
end

function FindAstralStepPosition(caster)
	local units = FindUnitsInRadiusOnTeamGround({
		team = caster:GetTeam(),
		at_team = caster.at_team_id or caster.team_id,
		role = 2,
		position = caster:GetAbsOrigin(),
		radius = 370,
	})
	local jump_position = nil
	local try_count = 0
	while try_count < 30 and jump_position == nil do
		try_count = try_count + 1
		local uu = units[RandomInt(1,table.maxn(units))]
		if IsUnitExist(uu) and not uu:HasModifier('modifier_void_spirit_astral_step_debuff') then --
			jump_position = FindAJumpPosition(caster,uu)
		end
		if jump_position and (caster:GetAbsOrigin() - jump_position):Length2D() < 250 then
			jump_position = nil
		end
	end
	if jump_position then
		return jump_position
	end
	while try_count < 30 and jump_position == nil do
		try_count = try_count + 1
		local uu = units[RandomInt(1,table.maxn(units))]
		if IsUnitExist(uu) then --and not uu:HasModifier('modifier_void_spirit_astral_step_debuff')
			jump_position = FindAJumpPosition(caster,uu)
		end
		if jump_position and (caster:GetAbsOrigin() - jump_position):Length2D() < 250 then
			jump_position = nil
		end
	end
	if jump_position then
		return jump_position
	end
	local jump_position = nil
	local try_count = 0
	while try_count < 30 and jump_position == nil do
		try_count = try_count + 1
		local uu = units[RandomInt(1,table.maxn(units))]
		if IsUnitExist(uu) and uu:IsInvulnerable() == false and not uu:HasModifier('modifier_void_spirit_astral_step_debuff') then
			jump_position = FindFarthestEmptyGridAtUnit(uu,caster)
		end
	end
	return jump_position
end


function HitPOMStart(keys)
	local a = keys.ability
	local caster = keys.caster
	a.start = caster:GetAbsOrigin()
end
function HitPOMTarget(keys)
	local caster = keys.caster
	local target = keys.target
	local a = keys.ability
	local start = a.start or caster:GetAbsOrigin() or Vector(0,0,0)
	local distance = (target:GetAbsOrigin() - start):Length2D()
	local min_damage = keys.min_damage
	local min_stun = keys.min_stun
	local max_damage = keys.max_damage
	local max_stun = keys.max_stun
	local max_distance = keys.max_distance

	if target == nil or target:IsNull() == true or target:IsAlive() == false then
		return
	end

	if BlockByLinken(target) == false then
		local stun_duration = min_stun + ((max_stun - min_stun)*(distance / max_distance)) or min_stun
		local damage = min_damage + ((max_damage - min_damage)*(distance / max_distance)) or min_damage

		play_particle("particles/econ/items/mirana/mirana_starstorm_bow/mirana_starstorm_starfall_attack.vpcf",PATTACH_ABSORIGIN_FOLLOW,target,3)
		EmitSoundOn('Ability.Starfall',target)
		if target:IsMagicImmune() == false then
			target:AddNewModifier(target,nil,"modifier_stunned",{ duration = stun_duration })
		end

		Timers:CreateTimer(0.5,function()
			if target == nil or target:IsNull() == true or target:IsAlive() == false then
				return
			end
			EmitSoundOn('Ability.StarfallImpact',target)
			if target:IsMagicImmune() == false then
				local damageTable = {
			    	victim=target,
			    	attacker=caster,
			    	damage_type=DAMAGE_TYPE_MAGICAL,
			    	damage=damage,
			    	ability=a,
			    }
			    ApplyDamage(damageTable)
			end
		end)
	end
end

function DAC:RequestGetAllCourierList(keys)
	local url = "http://autochess.ppbizon.com/shop/v4/courier/getall/@76561198090931971"
	url = url..GetSendKey()

	local req = CreateHTTPRequestScriptVM('GET', url)
	req:SetHTTPRequestAbsoluteTimeoutMS(20000)

	req:Send(function(res)
		if res.StatusCode ~= 200 or not res.Body then
			if fail_callback ~= nil then
				combat('GET ALL COURIER LIST FAILED!')
			end
			return
		end

		local t = json.decode(res.Body)
		
		if t ~= nil and t.err == 0 then
			combat('GET ALL COURIER LIST OK!')
			CustomGameEventManager:Send_ServerToAllClients("set_all_courier_list",{
				key = GetClientKey(team_i),
				hehe = RandomInt(1,100000),
				all_courier_list = t.all_courier_list,
			})
		else
			combat('GET ALL COURIER LIST ERROR:'..t.err)
		end
	end)
end

--获取棋子的种族/职业
function GetChessClassAndRaceTable(chess_name)
	local class_table = {}
	for c,list in pairs(_G.chess_list_by_synergy) do
		for _,ch in pairs(list) do
			if ch == chess_name then
				table.insert(class_table,c)
			end
		end
	end
	return class_table
end

--判断棋子是不是不在棋库中的特殊棋子，包括：
--（1）备用棋子库的棋子（黑核）
--（2）SSR棋子
--（3）非酒仙的熊猫人棋子
--（4）精灵守卫
--（5）本局没有随机到的传说棋子
function IsSpecialChess(chess_name)
	--（1）备用棋子库的棋子（黑核）
	for _,list in pairs(_G.chess_list_by_mana_black) do
		for _,chess in pairs(list) do
			if chess == chess_name then
				return true
			end
		end
	end
	--（2）SSR棋子
	for _,chess in pairs(_G.chess_list_ssr) do
		if chess == chess_name then
			return true
		end
	end
	--（3）非酒仙的熊猫人棋子
	if chess_name == 'chess_brew' then
		return false
	end
	for _,chess in pairs(_G.pandaman_list) do
		if chess == chess_name then
			return true
		end
	end
	--（4）精灵守卫
	if chess_name == 'chess_io' then
		return true
	end
	--（5）本局没有随机到的传说棋子
	if FindValueInTable(_G.chess_list_by_mana_gold,chess_name) == true and FindValueInTable(_G.chess_list_by_mana[5],chess_name) == false then
		return true
	end
	return false
end

function UpdatePlayerCurrRank()
	local arr = {}
	for steam_id,info in pairs(_G.stat_info) do
		table.insert(arr, info)
	end

	table.sort(arr,function(a,b)
		local aa = 0
		local bb = 0
		aa = aa + (a.hp or 0) * 1000000
		bb = bb + (b.hp or 0) * 1000000

		aa = aa + (10 - a.rank or 0) * 1000
		bb = bb + (10 - b.rank or 0) * 1000

		aa = aa + a.player_id
		bb = bb + b.player_id

		return aa > bb
	end)

	for curr_rank,info in pairs(arr) do
		local steam_id = info.steam_id
		_G.stat_info[steam_id]['curr_rank'] = curr_rank

		-- print(steam_id..' --> #'..curr_rank)
	end
end

function ShowLuaPing()
	Timers:CreateTimer(1,function()
		local f1 = GetFrameCount()
		Timers:CreateTimer(1,function()
			local f2 = GetFrameCount()
			local fps = f2-f1
			local memory = math.floor(collectgarbage("count")/1000)
			local entities = table.maxn(Entities:FindAllInSphere(Vector(0,0,0), 99999.9))
			CustomGameEventManager:Send_ServerToAllClients("show_lua_ping",{
				fps = fps,
				memory = memory,
				entities = entities,
			})
		end)
		return 2
	end)
	
end

function DAC:OnRequestSelectHandChess(keys)
	local player_id = keys.PlayerID
	local hero = _G.playerid2hero[player_id]
	local hand_index = keys.hand_index or 1
	if hero == nil or hero.hand_entities == nil or hero.hand_entities[hand_index] == nil then 
		return
	end
	local target = hero.hand_entities[hand_index]

	if IsUnitExist(hero) == true and hero:FindAbilityByName('pick_chess') ~= nil and IsUnitExist(target) == true then
		ExecuteOrderFromTable({
			UnitIndex = hero:entindex(), 
			OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
			TargetIndex = target:entindex(),
			AbilityIndex = hero:FindAbilityByName('pick_chess'):entindex(),
			Queue = 0,
		})
	end
end

function StartPrimalBeastThink(unluckydog)
	Timers:CreateTimer(0.1,function()
		if IsUnitExist(unluckydog) == false then
			return
		end
		--如果unluckydog有modifier_primal_beast_pulverize了，说明被獸抓起来了
		if unluckydog:HasModifier('modifier_primal_beast_pulverize') then
			Timers:CreateTimer(0.1,function()
				if IsUnitExist(unluckydog) == false then
					return
				end
				unluckydog:AddNewModifier(unluckydog,nil,"modifier_stunned",{duration = 0.5})
				if unluckydog:HasModifier('modifier_primal_beast_pulverize') == false then
					--抓完了，重设位置
					ChangeUnitPosition(unluckydog, XY2Vector(unluckydog.x,unluckydog.y,unluckydog.at_team_id or unluckydog.team_id), true)
					unluckydog:RemoveModifierByName('modifier_stunned')
					return
				end
				return 0.1
			end)
			return
		end
		return 0.1
	end)
end

function DestroyChessDelay(target,delay)
	local children = target:GetChildren()
    for k,child in pairs(children) do
       if child:IsNull() == false and child:GetClassname() == "dota_item_wearable" then
           child:RemoveSelf()
       end
    end
	target.is_removing = true    
    AddAbilityAndSetLevel(target,'no_minimap_icon')
	target:SetModelScale(0.0001)
	AddAbilityAndSetLevel(target,'no_hp_bar')
	Timers:CreateTimer(delay or 3,function()
		if target ~= nil and target:IsNull() == false then target:Destroy() end
	end)
end

function RemindChess(keys)
    local caster = keys.caster
    if caster == nil or caster:IsNull() == true or caster:GetClassname() ~= 'npc_dota_creature' then
        return
    end
    if caster.is_reminding ~= nil and caster.is_reminding == true then
        return
    end
    caster.is_reminding = true

    local model_scale = caster:GetModelScale()
    local big_duration = keys.big_duration or 0
    
    for i=1,10 do
        SetUnitModel({
            unit = caster,
            delay = i*0.03,
            scale = model_scale + (i*0.03),
        })
    end
    for i=1,10 do
        SetUnitModel({
            unit = caster,
            delay = 0.3 + big_duration + i*0.03,
            scale = model_scale + ((10-i)*0.03),
        })
    end
    Timers:CreateTimer(big_duration+1, function()
		if caster == nil or caster:IsNull() == true then
            return
        end
        SetUnitModel({
            unit = caster,
            scale = model_scale,
        })
        caster.is_reminding = nil
    end)
end

function SetUnitModel(keys)
    local unit = keys.unit
    local delay = keys.delay or 0
    if unit == nil or unit:IsNull() == true then
        return
    end
    Timers:CreateTimer(delay,function()
		if unit == nil or unit:IsNull() == true then
			return
		end
        if keys.model ~= nil then
            unit:SetOriginalModel(keys.model)
            unit:SetModel(keys.model)
        end
        if keys.skin ~= nil then
            unit:SetSkin(keys.skin)
        end
        if keys.scale ~= nil then
            unit:SetModelScale(keys.scale)
        end
    end)
end

function UpdateBHGold(keys)
	local caster = keys.caster
	Timers:CreateTimer(0.5,function()
		if IsUnitExist(caster) == false then
			return
		end
		if caster.bh_gold == nil and caster:HasAbility('bh_shuriken') == true then
			local level = caster:GetLevel()
			caster:FindAbilityByName("dac_guai_base"):ApplyDataDrivenModifier(caster,caster,'modifier_bh_gold',{})
			caster:FindModifierByName("modifier_bh_gold"):SetStackCount(level)
		end
	end)
end

-- function VoidAstralStep(keys)
-- 	local caster = keys.caster
-- 	local ability = keys.ability
-- 	local steps = keys.steps or 3
-- 	if IsUnitExist(caster) == false then
-- 		return
-- 	end
-- 	caster.astral_step_count = steps

-- 	local jump_position = FindAstralStepPosition(caster) 
	
-- 	if jump_position ~= nil and IsUnitExist(caster) then
		
		
-- 		caster.astral_step_count = caster.astral_step_count + 1
		
-- 		Timers:CreateTimer(0.3,function()
			
-- 			VoidAstralStep({
-- 				damage = damage,
-- 				caster = caster,
-- 				ability = ability,
-- 				steps = steps,
-- 			})
-- 		end)
-- 	else
-- 		caster.astral_step_count = nil
-- 		Timers:CreateTimer(0.2,function()
-- 			-- ChangeUnitPosition(caster,XY2Vector(caster.x,caster.y,caster.at_team_id or caster.team_id),true)
			
-- 		end)
-- 	end
-- end

function AstralStepInit(keys)
	local caster = keys.caster
	local ability = keys.ability
	local steps = keys.steps or 3
	if IsUnitExist(caster) == false then
		return
	end
	caster.astral_step_count = steps

	Timers:CreateTimer(0.3,function()
		if IsUnitExist(caster) == true and caster:HasModifier('modifier_void_astralstep') then
			AstralStepCut({
				caster = caster,
				ability = ability,
			})
			if caster.astral_step_count == nil then
				caster.astral_step_count = 0
			end
			caster.astral_step_count = caster.astral_step_count - 1
			if caster.astral_step_count <= 0 then
				caster:RemoveModifierByName('modifier_void_astralstep')
			end
			return 0.3
		else
			return
		end
	end)
end

function AstralStepCut(keys)
	local caster = keys.caster
	local ability = keys.ability
	if IsUnitExist(caster) == false then
		return
	end
	local team_id = caster.at_team_id or caster.team_id
	local jump_position = FindAstralStepPosition(caster)
	if jump_position ~= nil then
		InvisibleUnitCast({
			caster = caster,
			ability = 'void_spirit_astral_step',
			level = ability:GetLevel(),
			position = jump_position,
			ignore_nether_ward = true,
		})
		ChangeUnitPosition(caster,jump_position,true)
	else
		caster:RemoveModifierByName('modifier_void_astralstep')
	end
end

function AstralStepStop(keys)
	local caster = keys.caster
	local ability = keys.ability
	if IsUnitExist(caster) == false then
		return
	end
	caster.astral_step_count = nil
	BlinkChessX({p=XY2Vector(caster.x,caster.y,caster.at_team_id or caster.team_id),caster=caster,blink_type='tuitui'})
end

--获取游戏时间
-- {
-- 	total_elapsed     	 = 296 (number) 	--本局游戏总共过了多少时间
-- 	phase              	 = 1 (number)		--现在是什么阶段，0=初始化，1=准备，2=战斗，3=结束
-- 	left        		 = 703 (number)		--当前阶段剩余多少时间
-- 	elapsed     		 = 296 (number)		--当前阶段过了多少时间
-- }
GAME_PHASE_INIT = 0
GAME_PHASE_PREPARE = 1
GAME_PHASE_BATTLE = 2
GAME_PHASE_END = 3
function GetTime()
	local time_obj = {
		phase = _G.game_status,
		left = -1,
		elapsed = -1,
		total_elapsed = math.floor(GameRules:GetGameTime() - (_G.START_TIME or 0)),
	}
	if _G.game_status == 1 then
		--准备回合
		time_obj['left'] = _G.prepare_timer_ingame or 0
		time_obj['elapsed'] = (_G.prepare_timer or 0) - (_G.prepare_timer_ingame or 0)
	end
	if _G.game_status == 2 then
		--战斗回合
		time_obj['left'] = _G.battle_timer or 0
		time_obj['elapsed'] = 50 - (_G.battle_timer or 0)
	end
	return time_obj
end
function UpdateTimer()
	--发给6-13队伍的玩家
	for team_i=6,13 do
		CustomGameEventManager:Send_ServerToTeam(team_i,"show_time",{
			key = GetClientKey(team_i),
			phase = GetTime().phase,
			total_elapsed = GetTime().total_elapsed,
			left = GetTime().left,
			elapsed = GetTime().elapsed,
		})
	end
	--发给观战者
	CustomGameEventManager:Send_ServerToTeam(1,"show_time",{
		key = GetClientKey(1),
		phase = GetTime().phase,
		total_elapsed = GetTime().total_elapsed,
		left = GetTime().left,
		elapsed = GetTime().elapsed,
	})
end
--初始化准备回合时间
function InitPrepareTime()
	if _G.custom_round_time then
		_G.prepare_timer_ingame = _G.custom_round_time
		_G.prepare_timer = _G.custom_round_time
	else
		if _G.battle_round <= 10 then
			--前10回合时间较少
			_G.prepare_timer_ingame = 25
			_G.prepare_timer = 25
		else
			_G.prepare_timer_ingame = 40
			_G.prepare_timer = 40
		end
	end
end

--德莱尼：流亡
function DraeneiAssist(unit)
	if IsUnitExist(unit) == false then 
		return false
	end
	if _G.battle_round_type == 'pve' then
		--PVE回合，不流亡
		-- prt('PVE回合，不流亡')
		return false
	end
	local at_team_id = unit.at_team_id
	local team_id = unit:GetTeam()

	if team_id == 4 then
		-- prt('客场棋子')
		--客场棋子，team_id=4，at_team_id=谁在打客场的我
		--GetMyHostEnemyTeam(at_team_id)=我是谁
		local target_team = GetMyHostEnemyTeam(at_team_id)
		if target_team ~= at_team_id then
			-- prt(target_team)
			return MirrorADraenei(target_team, unit, 'host')
		else
			-- prt('无需支援自己'..target_team)
		end
	else
		-- prt('主场棋子')
		--主场棋子，team_id=自己，GetMyGuestEnemyTeam(team_id)=谁在打我
		local target_team = GetMyGuestEnemyTeam(team_id)
		if target_team ~= team_id then
			return MirrorADraenei(target_team, unit, 'guest')
		else
			-- prt('无需支援自己'..target_team)
		end
	end
end
--unit传送到chessboard_id棋盘助战，帮助type=host/guest
function MirrorADraenei(chessboard_id, unit, type)
	if chessboard_id == nil then
		-- prt('chessboard_id是nil，无需支援')
		return false
	end
	if IsUnitExist(unit) == false then
		-- prt('IsUnitExist(unit) == false')
		return false
	end
	if unit:HasAbility('is_ward') == true then
		-- prt('守卫，不传')
		return false
	end
	if GetBattleTable(chessboard_id) == false then
		-- prt('场地'..chessboard_id..' 已经不在战斗了，无需支援')
		return false
	end
	
	local team_id = chessboard_id
	local animation_info = GetAnimation('n000')

	if type == 'host' then
		--主场助战
		local hero = TeamId2Hero(team_id)
		if IsUnitExist(hero) == false then
			-- prt('主场助战IsUnitExist(hero) == false')
			return false
		end
		animation_info = GetAnimation(hero.animation or 'n000')
	end
	if type == 'guest' then
		--客场助战
		team_id = 4
		local hero = TeamId2Hero(GetMyHostEnemyTeam(chessboard_id))
		if IsUnitExist(hero) == false then
			-- prt('客场助战IsUnitExist(hero) == false')
			return false
		end
		animation_info = GetAnimation(hero.animation or 'n000')
	end

	local v = FindUnluckyPoint(nil, chessboard_id)
	if v == nil then
		-- prt('v是nil')
		return false
	end
	if team_id == nil or chessboard_id == nil then
		-- prt('team_id == nil or chessboard_id == nil')
		return false
	end

	if _G.battle_timer <= 1 then
		-- prt('场地'..chessboard_id..'已经结算了，无需支援')
		return false
	end
	
	-- prt(unit:GetUnitName()..'支援场地'..chessboard_id..'！')
	--确定需要支援！！

	--驱散一下debuff
	for _,m in pairs(unit:FindAllModifiers()) do
		if m:IsDebuff() and IsModifierInNraqiWhiteList(m:GetName()) ~= true then
			unit:RemoveModifierByName(m:GetName())
		end
	end

	--播放起始动画
	local ppp = ShowTPEffectAtPosition(v,animation_info.tp_effect)
	_G.unit[chessboard_id][Vector2Y(v,chessboard_id)..'_'..Vector2X(v,chessboard_id)] = 1

	unit:StartGesture(ACT_DOTA_TELEPORT)
	local qqq = ShowTPEffectAtPosition(unit:GetAbsOrigin(),animation_info.tp_effect)

	if unit.team_id ~= 4 then
		FillEmptySlot(unit)
		SaveItem(unit.team_id,unit:entindex())
	end

	Timers:CreateTimer(2, function()
		if ppp ~= nil then
			ParticleManager:DestroyParticle(ppp,true)
		end
		if qqq ~= nil then
			ParticleManager:DestroyParticle(qqq,true)
		end

		table.insert(_G.to_be_destory_list[chessboard_id],unit)
		RemoveFromToBeDestroyList(unit)

		unit.x = Vector2X(v,chessboard_id)
		unit.y = Vector2Y(v,chessboard_id)
		unit.y_x = ''..unit.y..'_'..unit.x
		unit.at_team_id = chessboard_id
		unit.team_id = team_id
		
		unit:SetAbsOrigin(v)
		unit:SetTeam(team_id)
		unit:RemoveGesture(ACT_DOTA_TELEPORT)
		unit:Stop()

		-- unit:SetHealth(unit:GetMaxHealth())
		-- unit:SetMana(100)
		-- if unit:HasAbility(GetChessAbility(unit)) then
		-- 	unit:FindAbilityName(GetChessAbility(unit)):EndCooldown()
		-- 	for s=0,5 do
		-- 		if unit:GetItemInSlot(s)~= nil then
		-- 			local aa = unit:GetItemInSlot(s)
		-- 			if aa:IsCooldownReady() == false then
		-- 				aa:EndCooldown()
		-- 			end
		-- 		end
		-- 	end
		-- end

		AddAbilityAndSetLevel(unit,'root_self')
		unit.alreadywon = false
		ChessAI(unit)

		--播放后续动画
		if animation_info.tp_sound ~= nil then
			EmitSoundOn(animation_info.tp_sound,x)
		end
		if animation_info.animation_modifier ~= nil then
			BlinkChessX({caster=x,blink_type=animation_info.animation_modifier})
		end
		if animation_info.end_effect ~= nil then
			play_particle(animation_info.end_effect,PATTACH_ABSORIGIN_FOLLOW,x,3)
		end
		-- local x = CreateUnitByName(unit:GetUnitName(),v,true,nil,nil,team_id)
	end)
	return true
end

function HasEnemy(u)
	if IsUnitExist(u) == false then
		return false
	end
	for p,q in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsUnitExist(q) == true and q:GetUnitName() ~= 'fissure' and q:IsInvisible() == false then
			if q:GetTeam() ~= u:GetTeam() then
				return true
			end
		end
	end
	return false
end

--棋子能否攻击
function IsChessCanAttack(u)
	if IsUnitExist(u) == false then
		return false
	end
	-- if u:IsDisarmed() then
	-- 	print('111')
	-- 	return false
	-- end
	if u.has_assassin_blink == true or u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') or u:HasModifier('modifier_vs_swap_debuff') then
		return false
	end
	for _,q in pairs(GetValidChessOnBoard(u.at_team_id or u.team_id)) do
		if IsCanAttackTarget(u,q) then
			return true
		end
	end
	return false
end

--棋子是否可以移动
function IsChessCanMove(u)
	-- if u:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == true then
	-- 	return false
	-- end
	-- if u:HasModifier('modifier_vs_swap_debuff') == true then
	-- 	return false
	-- end
	-- if u:HasModifier('modifier_riki_smoke_screen') then
	-- 	return false
	-- end
	if u.stop_moving == true then
		return false
	end
	if u.cannot_move == true then
		return false
	end
	if u:HasMovementCapability() == false then
		return false
	end
	if u:HasModifier('modifier_oracle_mingyunsheling') == true then
		return false
	end
	if u:HasModifier('modifier_br_web_debuff') == true then
		return false
	end
	if u:HasModifier('modifier_item_atuosi_debuff') == true then
		return false
	end
	if u:HasModifier('modifier_item_xueji_debuff') == true then
		return false
	end
	if u:HasModifier('modifier_item_fulingsuo_debuff') == true then
		return false
	end
	if u:HasAbility('is_ward') == true then
		return false
	end
	if u:IsStunned() == true then
		return false
	end
	if u:IsFrozen() == true then  
		return false
	end
	if u:GetUnitName() == 'dummy' then
		return false
	end

	local xx = u.x
	local yy = u.y
	local is_blocked = true
	if IsIn8x8(xx+1,yy) == true and IsEmptyGrid(u.at_team_id or u.team_id,xx+1,yy) == true then
		is_blocked = false
	end
	if IsIn8x8(xx-1,yy) == true and IsEmptyGrid(u.at_team_id or u.team_id,xx-1,yy) == true then
		is_blocked = false
	end
	if IsIn8x8(xx,yy+1) == true and IsEmptyGrid(u.at_team_id or u.team_id,xx,yy+1) == true then
		is_blocked = false
	end
	if IsIn8x8(xx,yy-1) == true and IsEmptyGrid(u.at_team_id or u.team_id,xx,yy-1) == true then
		is_blocked = false
	end

	return not is_blocked
end

--棋子是否可以使用物品
function IsChessCanUseItem(chess)
	if IsUnitExist(chess) == false then
		return false
	end
	if chess:HasModifier('modifier_queenofpain_sonic_wave_chaos_debuff') == true then
		return false
	end
	if chess:HasModifier('modifier_vs_swap_debuff') == true then
		return false
	end
	if chess:HasModifier('modifier_axe_berserkers_call') == true then
		return false
	end
	if chess:HasModifier('modifier_doom_bringer_doom') == true then
		return false
	end
	-- if chess.taunt_target ~= nil then
	-- 	return false
	-- end
	if chess:HasModifier('modifier_skeleton_king_reincarnation_scepter_active') == true then
		return false
	end
	if chess:IsStunned() == true then
		return false
	end
	if chess:IsFrozen() == true then
		return false
	end
	if IsHexxed(chess) == true then
		return false
	end
	if chess:HasModifier('modifier_illusion') == true then
		return false
	end
	-- if string.find(chess:GetUnitName(),'chess_tb_mohua') ~= nil then
	-- 	return false
	-- end

	--有没有物品
	for slot=0,5 do
		if chess:GetItemInSlot(slot) ~= nil then
			return true
		end
	end

	return false
end

function play_ground_particle(e,p,d)
	local ppp = ParticleManager:CreateParticle(e, PATTACH_WORLDORIGIN ,nil)
	ParticleManager:SetParticleControl(ppp, 0, p)
	ParticleManager:SetParticleControl(ppp, 1, p)
	Timers:CreateTimer(d or 1,function()
		if ppp ~= nil then
			ParticleManager:DestroyParticle(ppp,true)
		end
	end)
end

function StartShowGrid(team_id)
	_G.is_show_grid[team_id] = 1
	Timers:CreateTimer(function()
		if _G.is_show_grid[team_id] ~= 1 then
			return
		end
		local grid = _G.unit[team_id]
		for i,iv in pairs(grid) do
			if iv ~= nil then
				local x = string.split(i,'_')[2]
				local y = string.split(i,'_')[1]
				play_ground_particle("effect/grid/blobk0.vpcf",XY2Vector(x,y,team_id),0.49)
			end
		end
		return 0.5
	end)
end
function StopShowGrid(team_id)
	_G.is_show_grid[team_id] = -1
end